DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 1
DAKABT	MAC	19-JAN-77 13:38		DIAGNOSTIC PARAMETERS                                                              SEQ 0007

     1					;DAKAB
     2
     3
     4
     5			000002			DECVER==2
     6			000000			MCNVER==0
     7
     8						XLIST
     9						LIST
    10						LALL
    11						NAME	\MCNVER,\DECVER^
    12
    13					TITLE	DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2
    14					^
    15
    16					;TEST DESIGNED FOR INITIAL DEBUGGING OF PROCESSOR HARDWARE
    17					;AND TO DETECT (SOLID) FAILURES IN THE FIELD.
    18
    19					;COPYRIGHT 1972,1977
    20					;DIGITAL EQUIPMENT CORPORATION
    21					;MARLBORO, MASS. 01752
    22
    23					;JOHN R. KIRCHOFF
    24					;DICK MALISKA
    25
    26	000137					LOC	137
    27	000137	000000	000002			MCNVER,,DECVER
    28
    29						NOSYM
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 2
DAKABT	MAC	19-JAN-77 13:38		DIAGNOSTIC PARAMETERS                                                              SEQ 0008

    30					SUBTTL	DIAGNOSTIC PARAMETERS
    31					;PARAMETER DEFINITIONS
    32			000001		EXCASB==1
    33			000001		USRASB==1
    34
    35					;FLAG DEFINITIONS
    36			010000		USERF=10000		;USER MODE FLAG
    37
    38
    39					;MACROS
    40
    41					; STOP - USED FOR SCOPE LOOP, IF INSTRUCTION FAILS, CHANGE (JUMPA .+1)
    42					;	 TO A (JUMPA .-X) TO CYCLE ON FAILING INSTRUCTION
    43
    44					DEFINE	STOP	(A)<
    45						HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
    46						JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
    47									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
    48									;IN THE SUBTEST) TO LOOP ON ERROR>
    49
    50					;SPECIAL FEATURE PARAMETERS
    51
    52			030742		SADR1=B00
    53			030742		SADR2=B00
    54			030742		SADR3=B00
    55			030742		SADR4=B00
    56		254000	030742		SADR5=JRST B00
    57		254000	030742		SADR6=JRST B00
    58		254000	030742		SADR7=JRST B00
    59		254000	030742		SADR8=JRST B00
    60		254000	030742		SADR9=JRST B00
    61		254000	030742		SADR10=JRST B00
    62		254000	030742		SADR11=JRST B00
    63
    64			000000		PAREA0=0
    65			000000		PAREA1=0
    66			000000		PAREA2=0
    67		444153	414200		PAREA3=SIXBIT/DAKAB/
    68		645560	000000		PAREA4=SIXBIT/TMP/
    69			000000		PAREA5=0
    70			000000		PAREA6=0
    71			001000		ITERAT==1000
    72			000001		PGMEND==1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 1
PARAM	KLM	18-JAN-77 11:38		*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, JAN 18,1977                               SEQ 0009

    73					SUBTTL	*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, JAN 18,1977
    74
    75					DEFINE	S,<;*********************************************************************>
    76
    77					S^;*********************************************************************^
    78					;*DATA SWITCHES (READ FROM CONSOLE IN EXEC MODE OR TYPED IN IN USER MODE)
    79					;*LEFT HALF SWITCHES ARE PRE-ASSIGNED FOR SUBROUTINE PACKAGE USE
    80					;*AND CONTROL LOOPING, PRINTING (TTY OR OTHER DEVICE) AND MISC. FUNCTIONS
    81					S^;*********************************************************************^
    82
    83			400000		ABORT==	400000			;ABORT PROGRAM ON PASS COMPLETION
    84			200000		RSTART==200000			;RESTART TEST, PRINT TOTALS
    85			100000		TOTALS==100000			;PRINT TOTALS, CONTINUE
    86
    87			040000		NOPNT==	040000			;INHIBIT ALL PRINT/TYPE OUT (EXCEPT FORCED)
    88			020000		PNTLPT==020000			;PRINT ALL DATA ON LPT (LOGICAL DEVICE, USER MODE)
    89			010000		DING==	010000			;RING BELL ON ERROR
    90
    91			004000		LOOPER==004000			;ENTER EXERCISE/CHECK LOOP ON ERROR
    92			002000		ERSTOP==002000			;HALT ON TEST ERROR
    93			001000		PALERS==001000			;PRINT ALL ERRORS
    94
    95			000400		RELIAB==000400			;RELIABILITY MODE
    96			000200		TXTINH==000200			;INHIBIT ERROR TEXT
    97			000100		INHPAG==000100			;INHIBIT PAGING
    98
    99			000040		MODDVC==000040			;MODIFY DEVICE CODE
   100			000020		INHCSH==000020			;INHIBIT CACHE
   101			000010		OPRSEL==000010			;OPERATOR SELECTION
   102
   103			000004		CHAIN==	000004			;CHAIN CONTROL SWITCH
   104
   105			000002		KAHZ50==000002			;KA10 50 HERTZ POWER
   106
   107									;SWITCH 17 RESERVED !!!
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 2
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0010

   108					SUBTTL	*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977
   109
   110					S^;*********************************************************************^
   111					;*SPECIAL SUBPROGRAM LINKAGES
   112					S^;*********************************************************************^
   113
   114			027772		FSELNK=	27772	;FILE SELECT LINK
   115			027773		FRDLNK=	27773	;FILE READ LINK
   116			027774		LDLNK=	27774	;LOAD LINKAGE ADDRESS
   117			027775		DDTLNK=	27775	;DDT LINKAGE ADDRESS
   118			027776		MODLNK=	27776	;OPERATIONAL MODE CHECK LINKAGE ADDRESS
   119			027777		SUBLNK=	27777	;SUBROUTINE LINKAGE ADDRESS
   120
   121					S^;*********************************************************************^
   122					;*SPECIAL SUBROUTINE FATAL HALTS
   123					;*USED TO REPORT ERRORS THAT CAUSE THE SUBROUTINES TO BE UNUSABLE
   124					S^;*********************************************************************^
   125
   126					;ADDRESS   TAG	REASON
   127					;---------------------
   128
   129					; 1010 	NOEXEC	;PROGRAM NOT CODED FOR EXEC MODE OPERATION
   130					; 1011  PLERR	;FATAL PUSH LIST POINTER ERROR
   131					; 1012  PLERR1	;INITIAL PUSH LIST POINTER ERROR
   132					; 1013  MUOERR	;MUUO WITH LUUO HANDLER WIPED OUT
   133					; 1014  DTEBER	;DTE20 INTERRUPT WITHOUT DOORBELL
   134					; 1015  DTECER	;DTE20 CLOCK INTERRUPT WITHOUT FLAG SET
   135					; 1016  CPIERR	;CPU INITIALIZATION ERROR
   136					; 1017  EOPERR	;END OF PROGRAM ERROR
   137					; 1020  LUOERR	;INTERRUPT WITH LUUO HANDLER WIPED OUT
   138
   139					S^;*********************************************************************^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 3
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0011

   140					S^;*********************************************************************^
   141					;OPERATOR DEFINITIONS (NON-UUO'S)
   142					S^;*********************************************************************^
   143
   144		260740	000000		OPDEF	GO	[PUSHJ	P,]	;SUBROUTINE CALL
   145		263740	000000		OPDEF	RTN	[POPJ	P,]	;SUBROUTINE RETURN
   146		261740	000000		OPDEF	PUT	[PUSH	P,]	;PUT DATA ON PUSH LIST
   147		262740	000000		OPDEF	GET	[POP	P,]	;GET DATA FROM PUSH LIST
   148		254000	000000		OPDEF	PJRST	[JRST	]	;JRST TO ROUTINE THAT RTN'S
   149		254200	000000		OPDEF	HALT	[JRST	4,]	;DEFINITION FOR DDT
   150		254100	000000		OPDEF	JRSTF	[JRST	2,]	;DEFINITION FOR DDT
   151		254500	000000		OPDEF	JEN	[JRST	12,]	;DEFINITION FOR DDT
   152
   153					S^;*********************************************************************^
   154					;*SUBROUTINE INITIALIZATION CALL
   155					S^;*********************************************************************^
   156
   157		265000	030011		OPDEF	PGMINT	[JSP	0,SBINIT]	;SUBROUTINE INITIALIZATION
   158
   159					S^;*********************************************************************^
   160					;*HALTING UUO'S (A MORE GRACEFUL HALT THAN SIMPLY USING THE HALT INSTRUCTION).
   161					S^;*********************************************************************^
   162
   163		037640	000004		OPDEF	FATAL	[37B8!15B12!4]	;FATAL PROGRAMMING HALT
   164		037600	000004		OPDEF	ERRHLT	[37B8!14B12!4]	;PROGRAM ERROR HALT
   165
   166					S^;*********************************************************************^
   167					;*TERMINAL INPUT UUO'S
   168					;*ALWAYS COME FROM THE CONSOLE TERMINAL IN EXEC MODE OR THE
   169					;*CONTROLLING TERMINAL (REAL TERMINAL OR PTY) IN USER MODE.
   170					S^;*********************************************************************^
   171
   172		037000	000003		OPDEF	TTICHR 	[37B8!0B12!3]	;TTY, INPUT ANY CHARACTER
   173		037040	000003		OPDEF	TTIYES	[37B8!1B12!3]	;TTY, NORMAL RETURN Y
   174		037100	000003		OPDEF	TTINO	[37B8!2B12!3]	;TTY, NORMAL RETURN N
   175		037140	000003		OPDEF	TTIOCT	[37B8!3B12!3]	;TTY, INPUT OCTAL WORD
   176		037200	000003		OPDEF	TTIDEC	[37B8!4B12!3]	;TTY, INPUT DECIMAL WORD
   177		037240	000003		OPDEF	TTICNV	[37B8!5B12!3]	;TTY, INPUT CONVERTABLE WORD
   178		037300	000003		OPDEF	TTLOOK	[37B8!6B12!3]	;TTY, KEYBOARD CHECK
   179		037340	000003		OPDEF	TTALTM	[37B8!7B12!3]	;TTY, ALT-MODE CHECK
   180		037400	000003		OPDEF	TTSIXB	[37B8!10B12!3]	;TTY, INPUT SIXBIT WORD
   181		037440	000003		OPDEF	TTYINP	[37B8!11B12!3]	;TTY, IMAGE MODE INPUT
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 4
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0012

   182					;*TERMINAL OUTPUT UUO'S.
   183
   184		037000	000000		OPDEF	PNTA	[37B8!0B12!0]	;PRINT ASCII WORD
   185		037000	000001		OPDEF	PNTAF	[37B8!0B12!1]	;PRINT ASCII WORD FORCED
   186		037740	000000		OPDEF	PNTAL	[37B8!17B12!0]	;PRINT ASCIZ LINE
   187		037740	000001		OPDEF	PNTALF	[37B8!17B12!1]	;PRINT ASCIZ LINE FORCED
   188		037600	000003		OPDEF	PSIXL	[37B8!14B12!3]	;PRINT SIXBIT'Z LINE
   189		037640	000003		OPDEF	PSIXLF	[37B8!15B12!3]	;PRINT SIXBIT'Z LINE FORCED
   190		037000	000000		OPDEF	PNTMSG	[37B8!0B12!0]	;PRINT MESSAGE IMMEDIATE
   191		037040	000000		OPDEF	PNTMSF	[37B8!1B12!0]	;PRINT MESSAGE IMMEDIATE FORCED
   192		037100	000000		OPDEF	PSIXM	[37B8!2B12!0]	;PRINT SIXBIT'Z MSG IMMEDIATE
   193		037200	000000		OPDEF	PSIXMF	[37B8!4B12!0]	;PRINT SIXBIT'Z MSG IMM FORCED
   194		037000	000000		OPDEF	PNTCI	[37B8!0B12!0]	;PRINT CHARACTER IMMEDIATE
   195		037040	000000		OPDEF	PNTCIF	[37B8!1B12!0]	;PRINT CHARACTER IMMEDIATE FORCED
   196		037500	000000		OPDEF	PNTCHR	[37B8!12B12!0]	;PRINT CHARACTER
   197		037500	000001		OPDEF	PNTCHF	[37B8!12B12!1]	;PRINT CHARACTER FORCED
   198		037040	000000		OPDEF	PNT1	[37B8!1B12!0]	;PRINT ONE OCTAL DIGIT
   199		037040	000001		OPDEF	PNT1F	[37B8!1B12!1]	;PRINT 1 OCTAL DIGIT FORCED
   200		037100	000000		OPDEF	PNT2	[37B8!2B12!0]	;PRINT TWO OCTAL DIGITS
   201		037100	000001		OPDEF	PNT2F	[37B8!2B12!1]	;PRINT 2 OCTAL DIGITS FORCED
   202		037140	000000		OPDEF	PNT3	[37B8!3B12!0]	;PRINT THREE OCTAL DIGITS
   203		037140	000001		OPDEF	PNT3F	[37B8!3B12!1]	;PRINT THREE OCTAL DIGITS FORCED
   204		037200	000000		OPDEF	PNT4	[37B8!4B12!0]	;PRINT FOUR OCTAL DIGITS
   205		037200	000001		OPDEF	PNT4F	[37B8!4B12!1]	;PRINT FOUR OCTAL DIGITS FORCED
   206		037240	000000		OPDEF	PNT5	[37B8!5B12!0]	;PRINT FIVE OCTAL DIGITS
   207		037240	000001		OPDEF	PNT5F	[37B8!5B12!1]	;PRINT FIVE OCTAL DIGITS FORCED
   208		037300	000000		OPDEF	PNT6	[37B8!6B12!0]	;PRINT SIX OCTAL DIGITS
   209		037300	000001		OPDEF	PNT6F	[37B8!6B12!1]	;PRINT SIX OCTAL DIGITS FORCED
   210		037340	000000		OPDEF	PNT7	[37B8!7B12!0]	;PRINT 7 OCTAL DIGITS
   211		037340	000001		OPDEF	PNT7F	[37B8!7B12!1]	;PRINT 7 OCTAL DIGITS FORCED
   212		037440	000000		OPDEF	PNT11	[37B8!11B12!0]	;PRINT 11 OCTAL DIGITS
   213		037440	000001		OPDEF	PNT11F	[37B8!11B12!1]	;PRINT 11 OCTAL DIGITS FORCED.
   214		037400	000000		OPDEF	PNTADR	[37B8!10B12!0]	;PRINT PHYSICAL ADDRESS
   215		037400	000001		OPDEF	PNTADF	[37B8!10B12!1]	;PRINT PHYSICAL ADDRESS FORCED
   216		037600	000000		OPDEF	PNTOCT  [37B8!14B12!0]	;PRINT FULL WORD OCTAL
   217		037600	000001		OPDEF	PNTOTF	[37B8!14B12!1]	;PRINT FULL WORD OCTAL FORCED
   218		037540	000000		OPDEF	PNTHW	[37B8!13B12!0]	;PRINT OCTAL HALF WORDS, 6 SP 6
   219		037540	000001		OPDEF	PNTHWF	[37B8!13B12!1]	;PRINT OCTAL HALF WORDS, 6 SP 6 FORCED
   220		037700	000003		OPDEF	PNTOCS	[37B8!16B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S
   221		037740	000003		OPDEF	PNTOCF	[37B8!17B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S FORCED
   222		037640	000000		OPDEF	PNTDEC	[37B8!15B12!0]	;PRINT DECIMAL, SUPRESS LEADING 0'S
   223		037640	000001		OPDEF	PNTDCF	[37B8!15B12!1]	;PRINT DECIMAL, SUPRESS LEADING 0'S FORCED
   224		037700	000000		OPDEF	PNTDS	[37B8!16B12!0]	;PRINT DECIMAL, SPACES FOR LD 0'S
   225		037700	000001		OPDEF	PNTDSF	[37B8!16B12!1]	;PRINT DECIMAL, SPACES FOR LD 0'S FORCED
   226		037200	000002		OPDEF	PNTNM	[37B8!4B12!2]	;PRINT PROGRAM NAME
   227		037000	000002		OPDEF	PNTSIX	[37B8!0B12!2]	;PRINT SIXBIT WORD
   228		037040	000002		OPDEF	PNTSXF	[37B8!1B12!2]	;PRINT SIXBIT WORD FORCED
   229		037240	000002		OPDEF	DROPDV	[37B8!5B12!2]	;CLOSE LOGICAL FILE, USER MODE
   230		037100	000002		OPDEF	PNTCW	[37B8!2B12!2]	;PRINT DF10 CONTROL WORD
   231		037140	000002		OPDEF	PNTCWF	[37B8!3B12!2]	;PRINT DF10 CONTROL WORD FORCED
   232		037000	030242		OPDEF	PCRL	[37B8!0B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED
   233		037040	030242		OPDEF	PCRLF	[37B8!1B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED FORCED
   234		037000	000040		OPDEF	PSP	[37B8!0B12!40]	;PRINT SPACE
   235		037040	000040		OPDEF	PSPF	[37B8!1B12!40]	;PRINT SPACE FORCED
   236		037000	030243		OPDEF	PCRL2	[37B8!0B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 4-1
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0013

   237		037040	030243		OPDEF	PCRL2F	[37B8!1B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE) FORCED
   238		037040	000007		OPDEF	PBELL	[37B8!1B12!7]	;PRINT TTY BELL
   239
   240		037040	000026		OPDEF	PFORCE	[37B8!1B12!26]	;PRINT FORCE, CONTROL O OVERRIDE
   241
   242					DEFINE	PMSG	(ARG),<
   243						PSIXM	[SIXBIT\ARG'_\]>
   244
   245					DEFINE	PMSGF	(ARG),<
   246						PSIXMF	[SIXBIT\ARG'_\]>
   247
   248					;*SIXBTZ -- MACRO TO GENERATE SIXBIT DATA FOR PRINTING
   249					;*	CONSERVES CORE OVER ASCIZ
   250
   251					DEFINE	SIXBTZ	(ARG),<	[SIXBIT\ARG'_\]>
   252
   253					;*CONSOLE SWITCH INPUT UUO.
   254					;*READS CONSOLE SWITCHES IF IN EXEC MODE OR ASKS FOR THEM IF
   255					;* USER MODE.
   256
   257		037400	000002		OPDEF	SWITCH	[37B8!10B12!2]	;INPUT CONSOLE SWITCHES
   258
   259					;*CLOCK INITIALIZATION UUO - TO SET DESIRED CLOCK OPERATION
   260					;*EITHER IGNORE CLOCK, ONLY LET IT TICK OR CAUSE INTERRUPT TO OCCUR.
   261
   262		037540	000004		OPDEF	CLOKOP	[37B8!13B12!4]	;CLOCK OPERATION UUO - PDP-11 CLOCK
   263		037200	000004		OPDEF	MTROP	[37B8!4B12!4]	;CLOCK OPERATION UUO - DK20 METER
   264
   265					;*KL10 ONLY CACHE OPERATION UUO'S
   266
   267		037040	000004		OPDEF	CINVAL	[37B8!1B12!4]	;CACHE INVALIDATE
   268		037100	000004		OPDEF	CFLUSH	[37B8!2B12!4]	;CACHE FLUSH
   269		037140	000004		OPDEF	CWRTBI	[37B8!3B12!4]	;CACHE WRITE-BACK & INVALIDATE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0014

   270					;*END OF PASS/PROGRAM UUOS
   271
   272					;PERFORMS THE END OF PASS FUNCTIONS. INCREMENT PASS COUNT,
   273					;*DECREMENT ITERATION COUNT, CHECK IF FINISHED WITH THIS PROGRAM ETC.
   274
   275		037500	000004		OPDEF	ENDUUO	[37B8!12B12!4]	;UUO TO DISPLAY LIGHTS
   276		037700	000004		OPDEF	EOPUUO	[37B8!16B12!4]	;END OF PROGRAM UUO
   277
   278					;*MEMORY MANAGEMENT UUO'S
   279					;*UUO'S TO PERFORM VARIOUS MEMORY FUNCTIONS. MAPPING, ZEROING, PAGING,
   280					;*ADDRESS CONVERSION, ETC...
   281
   282		037000	000004		OPDEF	MAPMEM	[37B8!0B12!4]	;MAP MEMORY
   283		037500	000002		OPDEF	MEMZRO	[37B8!12B12!2]	;ZERO MEMORY
   284		037440	000002		OPDEF	MEMSEG	[37B8!11B12!2]	;SETUP MEMORY SEGMENT
   285		037540	000002		OPDEF	MAPADR	[37B8!13B12!2]	;VIRTUAL TO PHYSICAL ADR CONVERT
   286		037640	000002		OPDEF	MAPCNK	[37B8!15B12!2]	;MAP MEMORY CHUNK
   287		037600	000002		OPDEF	MAPSET	[37B8!14B12!2]	;SET KI10 EXEC PAGE MAP
   288		037740	000002		OPDEF	MAPPNT	[37B8!17B12!2]	;PRINT MEMORY MAP
   289
   290					;*DEVICE CODE MODIFICATION UUO
   291					;*ALLOWS THE MODIFICATION OF IOT'S TO ONE DEVICE TO BE CHANGED TO
   292					;*IOT'S TO A DIFFERENT DEVICE CODE.
   293
   294		037340	000002		OPDEF	MODPCU	[37B8!7B12!2]	;MODIFY PERHIPERAL CODE, USER
   295		037300	000002		OPDEF	MODPCP	[37B8!6B12!2]	;MODIFY PERHIPERAL CODE, PROGRAM
   296
   297			030000			IFNDEF	MODDVL,<MODDVL==BEGIN>
   298			030000			IFNDEF	MODDVU,<MODDVU==BEGIN>
   299
   300					;*"DIAMON" FILE SELECTION AND READ UUOS
   301
   302		037240	000004		OPDEF	FSELECT	[37B8!5B12!4]	;FILE SELECTION
   303		037300	000004		OPDEF	FREAD	[37B8!6B12!4]	;FILE READ - ASCII DATA
   304		037340	000004		OPDEF	FRD36	[37B8!7B12!4]	;FILE READ - 36 BIT DATA
   305		037400	000004		OPDEF	FRD8	[37B8!10B12!4]	;FILE READ - 8 BIT DATA
   306
   307					;*KI10 ONLY UUO FOR PRINTING MARGIN VALUES
   308
   309		037700	000002		OPDEF	PNTMGN	[37B8!16B12!2]	;PRINT MARGIN VALUE
   310
   311						XLIST
   312					IFNDEF	KLOLD,<LIST
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 6
PARAM	KLM	18-JAN-77 11:38		ERROR HANDLING UUO DEFINITIONS, JAN 18,1977                                        SEQ 0015

   313					SUBTTL	ERROR HANDLING UUO DEFINITIONS, JAN 18,1977
   314
   315					S^;*********************************************************************^
   316					;*ERROR HANDLER PARAMETERS
   317					S^;*********************************************************************^
   318
   319		036000	000000		OPDEF	ERUUO	[36B8]		;ERROR CALL UUO
   320		035000	000000		OPDEF	ERLOOP	[35B8]		;ERROR LOOP, CHECKS PC,REPT,REPT1,ERROR
   321		035040	000000		OPDEF	ERLP1	[35B8!1B12]	;ERROR LOOP IF PC'S MATCH
   322		035100	000000		OPDEF	ERLP2	[35B8!2B12]	;ERROR LOOP IF ANY ERROR
   323		034000	000000		OPDEF	REPTUO	[34B8]		;REPEAT LOOP UUO
   324
   325					;*THE ERROR HANDLER MACROS
   326
   327					;*A MACRO TO REPORT AN ERROR AND LOOP
   328
   329						DEFINE	ERROR	(ADR,FORMAT,CORECT,ACTUAL,F,D,ERR)<
   330						SALL
   331						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   332							   CORECT,,ACTUAL
   333							   [SIXBIT\D'_\],,ERR]
   334						XALL
   335
   336						ERLOOP	ADR		;IF ERROR, LOOP TO ADR
   337					>
   338
   339					;*A MACRO TO REPORT AN ERROR AND NOT LOOP
   340
   341						DEFINE	ERROR1	(FORMAT,CORECT,ACTUAL,F,D,ERR)<
   342						SALL
   343						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   344							   CORECT,,ACTUAL
   345							   [SIXBIT\D'_\],,ERR]
   346						XALL	>
   347
   348					>;END OF KLOLD CONDITIONAL
   349
   350						XLIST
   351						LIST
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 1
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0016

   352					SUBTTL	*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977
   353
   354	030000					LOC	30000
   355
   356					S^;*********************************************************************^
   357					;*PROGRAM STARTING ADDRESSES
   358					;*THESE ADDRESSES CALL VARIOUS SPECIAL START ROUTINES AND OR OPTIONS
   359					;*NORMAL START ADDRESS IS 30000 ALL OTHERS ARE SPECIAL. INVOKED BECAUSE
   360					;*OF END OF PASS, POWER FAILURE, DDT START, RE-ENTERING(TYPICALLY USER
   361					;*MODE), OR ANY NUMBER OF SPECIAL FEATURE TESTS.
   362					S^;*********************************************************************^
   363
   364	030000	254 00 1 00 027776 	BEGIN:	JRST	@MODLNK		;STAND-ALONE START
   365	030001	254 00 0 00 030712 	$START:	JRST	START		;MODE CHECK STARTING ADDRESS
   366
   367	030002	254 00 1 00 027774 	DIAGMN:	JRST	@LDLNK		;DIAGNOSTIC MONITOR START
   368
   369	030003	254 00 1 00 027774 	SYSEXR:	JRST	@LDLNK		;SYSTEM EXERCISER START
   370
   371	030004	254 00 0 00 030742 	SFSTRT:	JRST	SADR1		;SPECIAL FEATURE START
   372
   373	030005	254 00 0 00 030742 	PFSTRT:	JRST	SADR2		;POWER FAIL RESTART
   374
   375	030006	254 00 0 00 030742 	REENTR:	JRST	SADR3		;REENTER START(USUALLY USER MODE ONLY)
   376
   377	030007				SRTDDT:				;COMMONLY MISTAKEN NAME FOR "DDTSRT"
   378	030007	254 00 1 00 027775 	DDTSRT:	JRST	@DDTLNK		;DDT START
   379
   380	030010	254 00 0 00 030741 	BEGIN1:	JRST	STARTA		;LOOP START(END OF PASS COMES HERE)
   381	030011	254 00 1 00 027777 	SBINIT:	JRST	@SUBLNK		;PMGINT LINKAGE
   382	030012	000000	000000		RETURN:	0			;RETURN ADDRESS STORAGE
   383
   384	030013	254000	030742		START1:	SADR7			;OPTIONAL STARTING ADR/INSTRUCTIONS
   385	030014	254000	030742		START2:	SADR8			; "
   386	030015	254000	030742		START3:	SADR9			; "
   387	030016	254000	030742		START4:	SADR10			; "
   388	030017	254000	030742		START5:	SADR11			; "
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 2
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0017

   389					S^;*********************************************************************^
   390					;*PROGRAM FIXED PARAMETER AREA
   391					S^;*********************************************************************^
   392
   393	030020	444153	414200		PNTNAM:	PAREA3		;SIXBIT PROGRAM NAME
   394	030021	645560	000000		PNTEXT:	PAREA4		;SIXBIT PROGRAM EXTENSION
   395	030022	000000	000000		RANDBS:	PAREA1		;RANDOM BASE NUMBER
   396	030023	000000	000000		SWTEXR:	PAREA2		;SYSTEM EXERCISER SWITCHES
   397	030024	000000	001000		ITRCNT:	ITERAT		;PROGRAM ITERATIONS
   398	030025	000000	030725		$PNAME:	PGMNAM		;POINTER TO PROGRAMS NAME
   399	030026	000000	000002		$PVER:	MCNVER,,DECVER	;MCN & DEC VERSION LEVEL
   400	030027	000000	030000		$MODVL:	MODDVL		;DEVICE CODE CHANGE LOWER LIMIT
   401	030030	000000	030000		$MODVU:	MODDVU		;DEVICE CODE CHANGE UPPER LIMIT
   402	030031	777777	777777		$EMODE:	IFNDEF EXCASB,<0> IFDEF EXCASB,<-1>	;EXEC ALLOWED
   403	030032	777777	777777		$UMODE:	IFNDEF USRASB,<0> IFDEF USRASB,<-1>	;USER ALLOWED
   404	030033	000000	000000		$DSKUP:	IFNDEF DSKUPD,<0> IFDEF DSKUPD,<-1>	;DISK UPDATE MODE
   405	030034	000000	000000		$MMAP:	IFNDEF MEMMAP,<0> IFDEF MEMMAP,<-1>	;ALLOW MEMORY RTNS
   406	030035	000000	000000		PAREA7:	PAREA5		;OPTIONAL PARAMETER
   407	030036	000000	000000		PAREA8:	PAREA6		;OPTIONAL PARAMETER
   408
   409					S^;*********************************************************************^
   410					;*PROGRAM VARIABLE PARAMETER AREA
   411					S^;*********************************************************************^
   412
   413	030037	000000	000000		USER:	0		; 0 = EXEC, -1 = USER MODE FLAG
   414	030040	000000	000000		KAIFLG:	0		;PROCESSOR TYPE, 0 = KA10, -1 = KI10
   415	030041	000000	000000		KLFLG:	0		;PROCESSOR TYPE, 0 = KA/KI, -1 = KL10
   416	030042	777777	777777		MONFLG:	-1		;DIAG MONITOR SPECIAL USER FLAG
   417	030043	000000	000000		MONCTL:	0		;DIAG MON/SYS EXR FLAG
   418	030044	000000	000000		MONTEN:	0		;-1= LOADED BY 10
   419	030045	000000	000000		CLOCKF:	0		;CLOCK TICKED FLAG
   420	030046	000000	000000		CONSW:	0		;CONSOLE SWITCH SETTINGS
   421	030047	000000	000000		PASCNT:	0		;PROGRAM PASS COUNT
   422	030050	000000	000000		RUNFLG:	0		;PROGRAM RUN FLAG
   423	030051	000000	000000		TESTPC:	0		;SUBTEST PC
   424	030052	000000	000000		ERRPC:	0		;ERROR PC
   425	030053	000000	000000		ERRTLS:	0		;ERROR TOTALS
   426	030054	000000	000000		TICKS:	0		;PROGRAM RUNNING TIME
   427	030055	000000	000000		MARGIN:	0		;KI10 MARGIN WORD VALUE
   428	030056	000000	000000		$ONETM:	0		;SUBROUTINE INITIALIZATION FLAG
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 3
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0018

   429					S^;*********************************************************************^
   430					;*SPECIAL PROGRAM DISPATCH ADDRESSES
   431					S^;*********************************************************************^
   432
   433	030057	037 12 0 00 000004 	BEGEND:	ENDUUO		;END OF PASS
   434	030060	254 00 0 00 030010 	$BEND1:	JRST	BEGIN1	;KEEP RUNNING PROGRAM
   435	030061	037 16 0 00 000004 	$BEND2:	EOPUUO		;END OF PROGRAM - NO RETURN
   436	030062	254000	030742		CNTLC:	SADR5		;CONTROL C XFER ADDRESS
   437	030063	254000	030742		ALTMGO:	SADR6		;ALTMODE XFER ADDRESS
   438	030064				CPOPJ1:			;SKIP RETURN
   439	030064	350 00 0 17 000000 	UUOSKP:	AOS	(P)	;SKIP RETURN FROM UUO
   440	030065				CPOPJ:			;NON-SKIP REGULAR RETURN
   441	030065	263 17 0 00 000000 	UUOEXT:	RTN		;UUO RETURN
   442	030066	255 00 0 00 000000 	UUORTN:	JFCL		;ADDITIONAL USERS UUO ROUTINE
   443	030067	255 00 0 00 000000 	$UORTX:	JFCL		;ADDITIONAL UUO LINKAGE
   444	030070	255 00 0 00 000000 	$UUOER:	JFCL		;INITED AS (JRST $UOERX)
   445	030071	255 00 0 00 000000 	$ITRHL:	JFCL		;ADDITIONAL INTERRUPT LINKAGE
   446	030072	255 00 0 00 000000 	$ITRX1:	JFCL		; "
   447	030073	255 00 0 00 000000 	$USRHL:	JFCL		; "
   448	030074	255 00 0 00 000000 	$RSRTX:	JFCL		;ADDITIONAL POWER FAIL LINKAGE
   449	030075	255 00 0 00 000000 	$RSRTY:	JFCL		; "
   450	030076	255 00 0 00 000000 	RESRT1:	JFCL		; INITED AS (JRST RESRTX)
   451	030077	255 00 0 00 000000 	RESRT2:	JFCL		; "
   452	030100	255 00 0 00 000000 	$PARER:	JFCL		;ADDITIONAL PARITY ERROR LINKAGE
   453	030101	255 00 0 00 000000 	ERMORE:	JFCL		;ADDITIONAL ERROR HANDLER LINKAGE
   454	030102	254 04 0 00 030102 		HALT	.	;IMPROPER TRANSFER HALT
   455
   456	030103	000000	000000		$PSHER:	0		;INITED AS (JRST PSHERR)
   457	030104	000000	000000		ITRCH1:	0		;PC & FLAGS OF CURRENT INTERRUPT
   458	030105	000000	000000			0		;INITED AS (JRST $ITRC1)
   459
   460					S^;*********************************************************************^
   461					;*PROCESSOR CONTROL STORAGE
   462					S^;*********************************************************************^
   463
   464	030106	000000	000000		$ACC0:	0		;INTERRUPT SAVED AC0
   465	030107	000000	000000		$SVPI:	0		;INTERRUPT SAVED PI
   466	030110	000000	000000		$SVAPR:	0		;INTERRUPT SAVED APR
   467	030111	000000	000000		$SVPAG:	0		;INTERRUPT SAVED PAG (DATAI)
   468	030112	000000	000000		$SPAG1:	0		;INTERRUPT SAVED PAG (CONI)
   469
   470	030113	000000	000000		$SVUUO:	0		;CURRENT USERS UUO
   471	030114	000000	000000		$SVUPC:	0		;PC OF CURRENT USERS UUO
   472
   473	030115	000000	000000		REPTU:	0		;REPEAT UUO ITERATIONS
   474	030116	000000	000000		SCOPE:	0		;ERROR HANDLER SCOPE LOOP FLAG
   475	030117	000000	000000		%CORFLG:0		; " CORRECT FLAG
   476	030120	000000	000000		%COREC:	0		; " CORRECT DATA
   477	030121	000000	000000		%ACTFL:	0		; " ACTUAL FLAG
   478	030122	000000	000000		%ACTUL:	0		; " ACTUAL DATA
   479	030123	000000	000000		%DISCR:	0		; " DISCREPENCY DATA
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 4
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0019

   480					S^;*********************************************************************^
   481					;*UUO DISPATCH TABLE
   482					S^;*********************************************************************^
   483						XLIST
   484						LIST
   485	030124	030070	030070		UUODIS:	LUUO1,,$UUOER
   486	030125	030070	030070			LUUO3,,LUUO2
   487	030126	030070	030070			LUUO5,,LUUO4
   488	030127	030070	030070			LUUO7,,LUUO6
   489	030130	030070	030070			LUUO11,,LUUO10
   490	030131	030070	030070			LUUO13,,LUUO12
   491	030132	030070	030070			LUUO15,,LUUO14
   492	030133	030070	030070			LUUO17,,LUUO16
   493	030134	030070	030070			LUUO21,,LUUO20
   494	030135	030070	030070			LUUO23,,LUUO22
   495	030136	030070	030070			LUUO25,,LUUO24
   496	030137	030070	030070			LUUO27,,LUUO26
   497	030140	030070	030070			LUUO31,,LUUO30
   498	030141	030070	030070			LUUO33,,LUUO32
   499
   500					S^;*********************************************************************^
   501					;*MEMORY MANAGMENT STORAGE
   502					S^;*********************************************************************^
   503
   504	030142	000000	000000		DF22F:	0		;DF10 CONTROL FLAG, 0 = 18, -1 = 22 BIT
   505	030143	000000	000000		MAPNEW:	0		;MEMORY MAPPING CONTROL FLAG, -1 = 4096K MAPPING
   506	030144	000000	000000		MEMTOT:	0		;TOTAL MEMORY SIZE IN K (1024.)
   507	030145	000000	000000		MEMLOW:	0		;LOWEST USABLE MEMORY
   508	030146				MEMSIZ:	BLOCK ^D41	;MEMORY SEGMENT POINTER TABLE
   509
   510					S^;*********************************************************************^
   511					;*PRINT CONTROL STORAGE
   512					S^;*********************************************************************^
   513
   514	030217	000000	000000		PNTFLG:	0		;PRINT FLAG, -1 WHILE IN PRINT ROUTINE
   515	030220	000000	000000		PNTENB:	0		;PRINT ENABLE
   516	030221	000000	000000		PDISF:	0		;PRINT DISABLED FLAG
   517	030222	000000	000000		PNTINH:	0		;INHIBIT PRINT INPUT CHECKS
   518	030223	000000	000000		PNTSPC:	0		;PRINT SPACE CONTROL
   519	030224	000000	000000		OPTIME:	0		;TYPE-IN WAIT TIME
   520	030225	000000	000000		$TWCNT:	0		;TIME WAITED
   521	030226	000000	000000		$DVOFF:	0		;LOGICAL DEVICE INITED FLAG
   522	030227	000000	000000		TTYFIL:	0		;TTY EXEC FILLERS FLAG
   523	030230	000000	000000		TTYSPD:	0		;TTY EXEC BAUD RATE
   524	030231	000000	000000		$TTCHR:	0		;ACTUAL TYPED IN CHAR
   525	030232	000000	000000		$CHRIN:	0		;UPPER CASED & PARITY STRIPPED CHAR
   526	030233	000000	000000		$TYPNB:	0		;TYPED IN NUMBER
   527	030234	000000	000000		$CRLF:	0		;FREE CR/LF FLAG
   528	030235	000000	000000		$TABF:	0		;TAB CONVERSION FLAG
   529	030236	000000	000000		$FFF:	0		;FORM FEED CONVERSION FLAG
   530	030237	000000	000000		$VTF:	0		;VERTICAL TAB CONVERSION FLAG
   531	030240	000000	000000		USRLFF:	0		;USER LF FILLERS
   532	030241	000000	000000		USRCRF:	0		;USER CR FILLERS
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0020

   533					S^;*********************************************************************^
   534					;*THE FOLLOWING MISCELLANEOUS PRINT CHARACTERS ARE INCLUDED
   535					;*TO FACILITATE PRINTING AND ARE CALLED AS FOLLOWS:
   536					;*	MOVEI	NAME
   537					;*	PNTA		;OR PNTAF
   538					S^;*********************************************************************^
   539
   540	030242				CRLF:	ASCII/
   541	030242	015 012 000 000 000 	/
   542	030243				CRLF2:	ASCII/
   543
   544	030243	015 012 015 012 000 	/
   545	030244	054 000 000 000 000 	COMMA:	ASCII/,/
   546	030245	056 000 000 000 000 	PERIOD:	ASCII/./
   547	030246	040 000 000 000 000 	SPACE:	ASCII/ /
   548	030247	011 000 000 000 000 	TAB:	ASCII/	/
   549	030250				MINUS:
   550	030250	055 000 000 000 000 	HYPEN:	ASCII/-/
   551	030251	053 000 000 000 000 	PLUS:	ASCII/+/
   552	030252	052 000 000 000 000 	AST:	ASCII/*/
   553	030253	100 000 000 000 000 	ATSIN:	ASCII/@/
   554	030254	050 000 000 000 000 	LFP:	ASCII/(/
   555	030255	051 000 000 000 000 	RTP:	ASCII/)/
   556	030256	007 0000000000 		BELL:	BYTE (7) 007
   557	030257	077 000 000 000 000 	QUEST:	ASCII/?/
   558	030260	057 000 000 000 000 	SLASH:	ASCII!/!
   559	030261	044 000 000 000 000 	DOLLAR:	ASCII/$/
   560	030262	000000	000012		RADIX:	^D10			;DECIMAL PRINT RADIX
   561	030263	000000	000040		RADLSP:	40			;DECIMAL PRINT LEADING CHAR
   562	030264	000000	000012		RADLSC:	^D10			;DECIMAL PRINT LEADING CHAR COUNT
   563
   564					S^;*********************************************************************^
   565					;*USER MODE OUTPUT FILE INFORMATION
   566					S^;*********************************************************************^
   567
   568	030265				$OBUF:	BLOCK	3		;LOGICAL FILE OUTPUT BUFFER HEADER
   569	030270	60 62 51 56 64 00 	$OUTNM:	SIXBIT	/PRINT/		;FILE NAME
   570	030271	60 56 64 00 00 00 	$OUTEX:	SIXBIT	/PNT/		;FILE NAME EXTENSION
   571	030272					BLOCK	2
   572
   573					S^;*********************************************************************^
   574					;*DISK UPDATE MODE FILE INFORMATION
   575					S^;*********************************************************************^
   576
   577	030274				$IBUF:	BLOCK	3
   578	030277	60 62 51 56 64 00 	$INNM:	SIXBIT	/PRINT/
   579	030300	60 56 64 00 00 00 	$INEXT:	SIXBIT	/PNT/
   580	030301					BLOCK	2
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 6
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0021

   581					S^;*********************************************************************^
   582					;*PUSHDOWN LIST CONTROL INFORMATION
   583					S^;*********************************************************************^
   584
   585	030303	777577	030303		PLIST:	PLIST-PLISTE,,PLIST
   586	030304				PLISTS:	BLOCK	200
   587	030504	000000	000000		PLISTE:	0		;END OF PUSHDOWN LIST
   588
   589					S^;*********************************************************************^
   590					;*POWER LINE CLOCK FREQUENCY FLAG
   591					S^;*********************************************************************^
   592
   593	030505	000000	000000		CYCL60:	0	;0 = 60, -1 = 50 CYCLE
   594
   595					S^;*********************************************************************^
   596					;*KL10 CACHE CONTROL FLAGS
   597					S^;*********************************************************************^
   598
   599	030506	000000	000000		CSHFLG:	0	;ALLOW CACHE IF 0
   600	030507	000000	000000		CSHMEM:	0	;CACHE MEMORY SEGMENTS IF 0
   601
   602					S^;*********************************************************************^
   603					;*NUMBER INPUT DIGIT FLAG
   604					S^;*********************************************************************^
   605
   606	030510	000000	000000		TTNBRF:	0	;-1 IF ANY DIGIT TYPED
   607
   608					S^;*********************************************************************^
   609					;*KL10 & KI10 "INHPAG" SWITCH PAGING PREVENTION
   610					S^;*********************************************************************^
   611
   612	030511	000000	000000		PVPAGI:	0	;IF NON-ZERO, OVERRIDE "INHPAG" SWITCH ACTION
   613
   614					S^;*********************************************************************^
   615					;*ERROR REPORTING ROUTINE ADDITIONAL USERS CONTROL INSTRUCTIONS
   616					S^;*********************************************************************^
   617
   618	030512	000000	000000		%ERHI1:	0	;IF NON-ZERO, XCT'D AT START OF %ERUUO
   619	030513	000000	000000		%ERHI2:	0	;IF NON-ZERO, XCT'D AT END OF %ERUUO
   620	030514	000000	000000		%ERHI3:	0	;IF NON-ZERO, XCT'D AFTER "PC" OF %ERUUO
   621
   622					S^;*********************************************************************^
   623					;*SPECIAL USERS UUO INTERCEPT INSTRUCTION
   624					S^;*********************************************************************^
   625
   626	030515	000000	000000		$$UUO:	0	;IF NON-ZERO, XCT'D AT START OF $UORTN
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0022

   627					S^;*********************************************************************^
   628					;*KL10 PROCESSOR TYPE FLAG, 0=P0, 1=BBD NEW, 2=BBD OLD
   629					S^;*********************************************************************^
   630
   631	030516	000000	000000		KLTYP:	0
   632
   633					S^;*********************************************************************^
   634					;*SPECIAL USERS MUUO INTERCEPT INSTRUCTION
   635					S^;*********************************************************************^
   636
   637	030517	000000	000000		$$MUUO:	0	;IF NON-ZERO, XCT'D AT START OF MUUOER
   638
   639					S^;*********************************************************************^
   640					;*SPECIAL USERS USER MODE OUTPUT ERROR INTERCEPT INSTUCTION
   641					S^;*********************************************************************^
   642
   643	030520	000000	000000		$$OUTER:0	;IF NON-ZERO, XCT'D AT END OF USER MODE ERROR
   644
   645					S^;*********************************************************************^
   646					;*"SWITCH" CALL USAGE CONTROL
   647					S^;*********************************************************************^
   648
   649	030521	000000	000000		$$TOGGLE:0	;IF NON-ZERO, USE C(CONSW) FOR SWITCHES
   650
   651					S^;*********************************************************************^
   652					;*SPECIAL USERS ALTMODE SWITCH CALL INTERCEPT INSTRUCTIONS
   653					S^;*********************************************************************^
   654
   655	030522	000000	000000		$$TAX1:	0	;IF NON-ZERO, XCT'D AT START OF ALTMODE SWITCH CALL
   656	030523	000000	000000		$$TAX2:	0	;IF NON-ZERO, XCT'D AT END OF ALTMODE SWITCH CALL
   657
   658					S^;*********************************************************************^
   659					;*SPECIAL FUTURE EXPANSION ROOM
   660					;*IF ANY FIXED AREA TAGS ARE ADDED, REDUCE THE SIZE OF
   661					;*THIS BLOCK STATEMENT ACCORDINGLY.  THIS MUST BE DONE
   662					;*SO THAT PREVIOUS FIXED ASSIGNMENTS DO NOT CHANGE.
   663					S^;*********************************************************************^
   664
   665	030524					BLOCK	53	;HOPEFULLY THIS IS ENOUGH FOREVER
   666
   667					S^;*********************************************************************^
   668					;*END OF FIXED STORAGE
   669					S^;*********************************************************************^
   670
   671			030577			$ENDFX=<PLISTE+100>&<777700>-1
   672	030577					LOC	$ENDFX
   673	030577	000000	000000		ENDFIX:	0		;END OF FIXED STORAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 1
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0023

   674					SUBTTL	*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76
   675
   676					;NEW DEFINITIONS USED BY THE KL10 SUBROUTINE PACKAGE
   677
   678			000000		AC0=	0
   679			030000		DIAGNOS=30000		;PDP-10 DIAGNOSTIC START ADDRESS
   680			010000		DDT=	10000		;PDP-10 DDT START ADDRESS
   681			020000		DIAMON=	20000		;PDP-10 DIAMON LOADER START ADDRESS
   682			020000		DONG11=	1B22		;11 DOORBELL (FROM THE 10)
   683
   684					;DTE20 DEVICE CODES
   685
   686			000200		DTE==	200		;DTE0
   687			000204		DTE0==	204
   688			000204		DTE1==	204
   689			000210		DTE2==	210
   690			000214		DTE3==	214
   691
   692					;KL10 EPT COMMUNICATION AREA
   693
   694			000440		$STD=	440		;PDP-10 DIAGNOSTIC START ADDRESS
   695			000441		$DDT=	441		;PDP-10 DDT START ADDRESS
   696			000442		$STL=	442		;PDP-10 LOADER START ADDRESS
   697			000443		$STM=	443		;PDP-10 MONITOR START ADDRESS
   698
   699			000444		$DTFLG=	444		;DTE20 OPERATION COMPLETE FLAG
   700			000445		$DTCLK=	445		;DTE20 CLOCK INTERRUPT FLAG
   701			000446		$DTCI=	446		;DTE20 CLOCK INTERRUPT INSTRUCTION
   702			000447		$DTT11=	447		;DTE20 10 TO 11 ARGUMENT
   703			000450		$DTF11=	450		;DTE20 11 TO 10 ARGUMENT
   704			000451		$DTCMD=	451		;DTE20 TO 11 COMMAND WORD
   705			000452		$DTSEQ=	452		;DTE20 OPERATION SEQUENCE NUMBER
   706			000453		$DTOPR=	453		;DTE20 OPERATIONAL DTE #
   707			000454		$DTCHR=	454		;DTE20 LAST TYPED CHARACTER
   708			000455		$DTMTD=	455		;DTE20 MONITOR TTY OUTPUT COMPLETE FLAG
   709			000456		$DTMTI=	456		;DTE20 MONITOR TTY INPUT FLAG
   710
   711			000457		$DTSWR=	457		;DTE20 CONSOLE SWITCH REGISTER
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 2
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0024

   712					;SPECIAL "FIXED" REASSIGNMENTS
   713
   714			030600			$$LOC=.			;SAVE CURRENT LOCATION
   715
   716	030000					LOC	30000
   717	030000	254 00 0 00 030600 	$$BEGIN:JRST	$$START		;SETUP SPECIAL START
   718	030001	254 00 0 00 030600 		JRST	$$START		;"DIAMON" CHAIN START ADDRESS
   719
   720	000440					LOC	440
   721	000440	254 00 0 00 030000 	$STD:	JRST	BEGIN		;SETUP FOR "STD"
   722	000443					LOC	443
   723	000443	254 00 0 00 030636 	$STM:	JRST	$SPEC		;SIMPLE RUN CONTROL
   724
   725	030057					LOC	30057
   726	030057	254 00 0 00 030641 	$BEGEND:JRST	$SPBEND		;SETUP SPECIAL "BEGEND"
   727
   728					;SPECIAL MUUO, TRAP & PAGE FAIL SETUP
   729
   730	000420					LOC	420
   731	000420	254 04 0 00 000420 	$$420:	HALT	.		;KI10 PAGE FAIL
   732	000421	255 00 0 00 000000 	$$421:	JFCL			;OVERFLOW
   733	000422	254 04 0 00 000422 	$$422:	HALT	.		;PUSHDOWN OVERFLOW
   734	000423	254 04 0 00 000423 	$$423:	HALT	.		;TRAP 3
   735	000424	000000	000000		$$424:	0			;MMUO
   736	000425	000000	000000		$$425:	0			;MMUO PC
   737	000426	000000	000000		$$426:	0			;KI10-PAGE FAIL, KL10-PROCESS CONTEXT
   738	000427	254 04 0 00 000427 	$$427:	HALT	.
   739	000430	000000	000427		$$430:	427			;MMUO NEW PC'S
   740	000431	000000	000427		$$431:	427
   741	000432	000000	000427		$$432:	427
   742	000433	000000	000427		$$433:	427
   743	000434	000000	000427		$$434:	427
   744	000435	000000	000427		$$435:	427
   745	000436	000000	000427		$$436:	427
   746	000437	000000	000427		$$437:	427
   747
   748	000500					LOC	500
   749	000500	000000	000000		$$500:	0			;KL10 PAGE FAIL WORD
   750	000501	000000	000000		$$501:	0			;KL10 PAGE FAIL PC
   751	000502	000000	000503		$$502:	503			;KL10 PAGE FAIL NEW PC
   752	000503	254 04 0 00 000503 	$$503:	HALT	.
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 3
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0025

   753	030600					LOC	$$LOC		;RESET CURRENT LOCATION
   754
   755					;SPECIAL STARTUP SEQUENCE
   756
   757	030600	402 00 0 00 030037 	$$START:SETZM	USER
   758	030601	265 00 0 00 030602 		JSP	0,.+1		;IN USER MODE ?
   759	030602	603 00 0 00 010000 		TLNE	0,USERF
   760	030603	476 00 0 00 030037 		SETOM	USER		;YES, SET CONTROL WORD
   761	030604	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE ?
   762	030605	402 00 0 00 030037 		SETZM	USER		;YES, RUN AS EXEC
   763	030606	332 00 0 00 030037 		SKIPE	USER
   764	030607	254 00 0 00 030712 		JRST	START		;USER MODE, DON'T NEED CPU TYPE
   765
   766	030610	336 00 0 00 030044 	$STKIL:	SKIPN	MONTEN		;LOADED BY "DIAMON" ?
   767	030611	476 00 0 00 030024 		SETOM	ITRCNT		;NO, RUN FOREVER
   768	030612	402 00 0 00 030516 		SETZM	KLTYP
   769	030613	402 00 0 00 030041 		SETZM	KLFLG		;ASSUME KI10
   770	030614	200 01 0 00 035410 		MOVE	1,[1,,1]
   771	030615	251 01 0 00 000001 		BLT	1,1		;HOPE THIS WORKS
   772	030616	316 01 0 00 035410 		CAMN	1,[1,,1]	;IF AC NE 1,,1 AFTER BLT, KL10
   773	030617	254 00 0 00 030712 		JRST	START		;KI10, NO ADDITIONAL SETUP
   774
   775	030620	7 000 20 0 00 010040 	$STKL:	CONO	APR,10040	;SET BBD NOT BIT
   776	030621	7 000 24 0 00 000000 		CONI	APR,0
   777	030622	7 000 20 0 00 020040 		CONO	APR,20040	;CLEAR BBD NOT BIT
   778	030623	606 00 0 00 000040 		TRNN	0,40		;IF SET, KL10
   779	030624	350 00 0 00 030516 		AOS	KLTYP		;IF NOT, BBD
   780	030625	402 00 0 00 000444 		SETZM	$DTFLG
   781	030626	402 00 0 00 000445 		SETZM	$DTCLK
   782	030627	200 00 0 00 000453 		MOVE	$DTOPR		;GET DTE #
   783	030630	436 00 0 00 030670 		ORM	$$DTE0		;INSERT IN DTE I/O INSTS
   784	030631	436 00 0 00 030672 		ORM	$$DTE1
   785	030632	436 00 0 00 030704 		ORM	$$DTE2
   786	030633	436 00 0 00 030706 		ORM	$$DTE3
   787	030634	476 00 0 00 030041 		SETOM	KLFLG		;SET KL10 CONTROL FLAG
   788	030635	254 00 0 00 030712 		JRST	START
   789
   790	030636	200 00 0 00 035411 	$SPEC:	MOVE	[JRST STARTA]	;SIMPLE RUN CONTROL
   791	030637	202 00 0 00 030643 		MOVEM	$SPB1
   792	030640	254 00 0 00 030712 		JRST	START
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 4
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0026

   793					;SPECIAL "BEGEND" ROUTINE
   794
   795	030641	350 00 0 00 030047 	$SPBEND:AOS	PASCNT		;INCREMENT PASS COUNT
   796	030642	370 00 0 00 030024 		SOS	ITRCNT		;DECREMENT ITERATION COUNT
   797	030643	336 00 0 00 030037 	$SPB1:	SKIPN	USER
   798	030644	254 00 0 00 030652 		JRST	$SPBEX		;EXEC MODE
   799
   800	030645	332 00 0 00 030024 	$SPBUS:	SKIPE	ITRCNT		;USER MODE, COMPLETED ?
   801	030646	254 00 0 00 030741 		JRST	STARTA		;NO, KEEP RUNNING
   802	030647	336 00 0 00 030044 		SKIPN	MONTEN		;DONE, LOADED BY "DIAMON" ?
   803	030650	047 00 0 00 000012 		EXIT			;NO, RETURN TO MONITOR
   804	030651	254 00 1 00 030012 		JRST	@RETURN		;YES, RETURN TO "DIAMON"
   805
   806	030652	332 00 0 00 030041 	$SPBEX:	SKIPE	KLFLG
   807	030653	254 00 0 00 030660 		JRST	$SPBKL		;KL10 & EXEC
   808	030654	7 004 14 0 00 030024 		DATAO	PI,ITRCNT	;KI10 & EXEC, DISPLAY ITER COUNT
   809	030655	332 00 0 00 030024 		SKIPE	ITRCNT
   810	030656	254 00 0 00 030741 		JRST	STARTA		;NOT COMPLETED YET
   811	030657	254 00 1 00 030012 		JRST	@RETURN		;DONE
   812
   813	030660	336 00 0 00 030024 	$SPBKL:	SKIPN	ITRCNT
   814	030661	254 00 0 00 030676 		JRST	$SPKLD		;KL10, EXEC & COMPLETED
   815
   816	030662	335 00 0 00 030043 		SKIPGE	MONCTL
   817	030663	254 00 0 00 030741 		JRST	STARTA		;"DIAMON" CONTROL
   818	030664	201 00 0 00 000404 		MOVEI	0,404		;NOTIFY PDP-11 OF END OF PASS
   819	030665	202 00 0 00 000451 		MOVEM	0,$DTCMD
   820	030666	402 00 0 00 000444 		SETZM	$DTFLG
   821	030667	336 00 0 00 030516 		SKIPN	KLTYP
   822	030670	7 200 20 0 00 020000 	$$DTE0:	CONO	DTE,DONG11
   823	030671	332 00 0 00 030516 		SKIPE	KLTYP
   824	030672	7 200 20 0 00 010000 	$$DTE1:	CONO	DTE,10000
   825	030673	336 00 0 00 000444 		SKIPN	$DTFLG		;WAIT TILL 11 RESPONDS
   826	030674	254 00 0 00 030673 		JRST	.-1
   827	030675	254 00 0 00 030741 		JRST	STARTA		;KEEP RUNNING
   828
   829					;SPECIAL KL10 COMPLETED ROUTINE
   830
   831	030676	332 00 0 00 030044 	$SPKLD:	SKIPE	MONTEN
   832	030677	254 00 1 00 030012 		JRST	@RETURN		;LOADED BY "DIAMON"
   833
   834	030700	201 00 0 00 000403 		MOVEI	0,403		;NOTIFY PDP-11 OF COMPLETION
   835	030701	202 00 0 00 000451 		MOVEM	0,$DTCMD
   836	030702	402 00 0 00 000444 		SETZM	$DTFLG
   837	030703	336 00 0 00 030516 		SKIPN	KLTYP
   838	030704	7 200 20 0 00 020000 	$$DTE2:	CONO	DTE,DONG11
   839	030705	332 00 0 00 030516 		SKIPE	KLTYP
   840	030706	7 200 20 0 00 010000 	$$DTE3:	CONO	DTE,10000
   841	030707	336 00 0 00 000444 		SKIPN	$DTFLG		;SHOULD NEVER HAPPEN
   842	030710	254 00 0 00 030707 		JRST	.-1		;11 NEVER RETURNS ON END OF PROGRAM
   843	030711	254 04 0 00 030000 		HALT	BEGIN		;IF IT DOES, HALT.
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 1
DAKABM	MAC	19-JAN-77 13:39		DIAGNOSTIC SECTION                                                                 SEQ 0027

   844					SUBTTL	DIAGNOSTIC SECTION
   845						LALL
   846
   847	030712	402 00 0 00 030037 	START:	SETZM	USER#		;CLEAR USER CONTROL WORD
   848	030713	265 00 0 00 030714 		JSP	0,.+1		;GET FLAGS
   849	030714	603 00 0 00 010000 		TLNE	USERF		;IN USER MODE?
   850	030715	476 00 0 00 030037 		SETOM	USER		;YES, SET USER CONTROL WORD
   851	030716	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE?
   852	030717	402 00 0 00 030037 		SETZM	USER		;YES, CLEAR USER CONTROL WORD
   853	030720	336 00 0 00 030037 		SKIPN	USER
   854	030721	254 00 0 00 030742 		JRST	B00
   855	030722	331 00 0 00 030043 		SKIPL	MONCTL
   856	030723	051 03 0 00 030725 		TTCALL	3,PGMNAM		;MENTION OUR NAME
   857	030724	254 00 0 00 030741 		JRST	STARTA		; GO START
   858
   859	030725				PGMNAM:	ASCIZ/
   860	030725	015 012 120 104 120 	PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) [DAKAB]
   861	030726	055 061 060 040 113
   862	030727	101 061 060 040 102
   863	030730	101 123 111 103 040
   864	030731	111 116 123 124 122
   865	030732	125 103 124 111 117
   866	030733	116 040 104 111 101
   867	030734	107 116 117 123 124
   868	030735	111 103 040 050 062
   869	030736	051 040 133 104 101
   870	030737	113 101 102 135 015
   871	030740	012 000 000 000 000 	/
   872
   873					;BASIC INSTRUCTION TEST (2)
   874					;THE TEST IS DESIGNED FOR INITIAL DEBUGGING OF
   875					;PROCESSOR HARDWARE AND TO DETECT (SOLID) FAILURES
   876					;IN THE FIELD
   877
   878
   879	030741	254 00 0 00 030742 	STARTA:	JRST	.+1
   880
   881	030742				B00:
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 2
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0028

   882					SUBTTL	TEST OF THE ADD INSTRUCTION
   883
   884					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED
   885					;TO ADD A NON-ZERO NUMBER CONTAINED IN E TO AN AC CONTAINING ALL ZEROS,
   886					;THE RESULT IS A NON-ZERO NUMBER IN THE AC.  FIRST, THE AC IS CLEARED;
   887					;THEN, ANON-ZERO POSITIVE NUMBER IS ADDED TO THE AC USING THE ADD
   888					;INSTRUCTION.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
   889
   890	030742	200 00 0 00 035412 		A10400:	MOVE	[0]		;PRESET AC TO ALL ZEROS
   891	030743	270 00 0 00 035413 		ADD	[123456765432]	;*ADD OF A NON-ZERO NUMBER TO AN AC OF ALL
   892									;ZEROS SHOULD RESULT
   893									;IN AN AC CONTAINING A NON-ZERO NUMBER
   894	030744	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
   895						STOP^
   896	030745	254 04 0 00 030746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   897	030746	324 00 0 00 030747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   898									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   899									;IN THE SUBTEST) TO LOOP ON ERROR^
   900
   901					;AD ADD [ADC1], AD ADD EN [ADC1],
   902					;F CYC ACT EN A [F1], AD FM + FETCH EN A [ADFP],
   903					;F CYC ACT EN C[F1], IR ADSUB [IR1], IRXX [IR1]
   904
   905					;**********
   906
   907					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
   908					;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
   909					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
   910					;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
   911					; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
   912
   913	030747	200 00 0 00 035413 	A10500:	MOVE	[123456765432]	;PRESET AC WITH A NON-ZERO NUMBER
   914	030750	270 00 0 00 035412 		ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC
   915									;CONTAINING A NON-ZERO NUMBER
   916									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
   917	030751	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
   918						STOP^
   919	030752	254 04 0 00 030753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   920	030753	324 00 0 00 030754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   921									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   922									;IN THE SUBTEST) TO LOOP ON ERROR^
   923
   924					;AR AD EN [ARMA], AR AD EN A [ARMA], ET2C F/F [E],
   925					;AR AD ET2 EN [ARMA], IR ADSUB [IR1]
   926
   927					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 3
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0029

   928					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
   929					;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
   930					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
   931					;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
   932					; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
   933
   934	030754	200 00 0 00 035414 	A10600:	MOVE	[XWD 123456,0]	;PRESET AC WITH A NON-ZERO NUMBER
   935	030755	270 00 0 00 035412 		ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC CONTAINING
   936									;A NON-ZERO NUMBER SHOULD RESULT IN AN AC
   937									;CONTAINING A NON-ZERO NUMBER
   938	030756	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
   939						STOP^
   940	030757	254 04 0 00 030760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   941	030760	324 00 0 00 030761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   942									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   943									;IN THE SUBTEST) TO LOOP ON ERROR^
   944
   945					;AR AD EN [ARMA], AR AD EN A [ARMA], ET2C F/F[E],
   946					;AR AD ET2 EN [ARMA], IR AD SUB [IR1]
   947
   948					;*********
   949
   950					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
   951					;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
   952					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
   953					;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
   954					; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
   955
   956	030761	200 00 0 00 035415 	A10700:	MOVE	[123456]	;PRESET AC WITH A NON-ZERO NUMBER
   957	030762	270 00 0 00 035412 		ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC CONTAINING
   958									;A NON-ZERO NUMBER
   959									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
   960	030763	336 00 0 00 000000 		SKIPN			;PASS TEST IS C(AC) IS NON-ZERO
   961						STOP^
   962	030764	254 04 0 00 030765 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   963	030765	324 00 0 00 030766 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   964									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   965									;IN THE SUBTEST) TO LOOP ON ERROR^
   966
   967					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 4
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0030

   968					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
   969					;A WORD CONTAINING A NON-ZERO POSITIVE NUMBER TO AN AC OF ALL ZEROS, THE
   970					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
   971					;INITIALIZED WITH A WORD OF ALL ZEROS ;THEN, A NON-ZERO POSITIVE NUMBER
   972					;IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
   973
   974	030766	200 00 0 00 035412 	A13300:	MOVE	[0]		;PRESET AC WITH ALL ZEROS
   975	030767	270 00 0 00 035414 		ADD	[123456,,0]	;*ADD OF A NON-ZERO NUMBER TO AN AC CONTAINING ALL ZEROS
   976									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
   977	030770	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
   978						STOP^
   979	030771	254 04 0 00 030772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   980	030772	324 00 0 00 030773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   981									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   982									;IN THE SUBTEST) TO LOOP ON ERROR^
   983
   984					;**********
   985
   986					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
   987					;A WORD CONTAINING A NON-ZERO POSITIVE NUMBER TO AN AC OF ALL ZEROS, THE
   988					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
   989					;INITIALIZED WITH A WORD OF ALL ZEROS ;THEN, A NON-ZERO POSITIVE NUMBER
   990					;IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
   991
   992	030773	200 00 0 00 035412 	A13400:	MOVE	[0]		;PRESET AC WITH ALL ZEROS
   993	030774	270 00 0 00 035415 		ADD	[123456]	;*ADD OF A NON-ZERO NUMBER TO AN AC CONTAINING ALL ZEROS
   994									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
   995	030775	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
   996						STOP^
   997	030776	254 04 0 00 030777 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   998	030777	324 00 0 00 031000 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   999									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1000									;IN THE SUBTEST) TO LOOP ON ERROR^
  1001
  1002					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0031

  1003					;ADD ZERO TO A RIPPLED ONE
  1004
  1005			011000		SN=11000
  1006			000000			ZZ=0
  1007
  1008					A11000:	REPEAT	^D36,
  1009					<;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1010					;A WORD OF ALL ZEROS IS ADDED TO AN
  1011					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1012					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1013					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1014					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1015					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1016					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1017					;EVERY BIT OF THE AC.
  1018					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1019					SN=SN+1
  1020						ZZ=ZZ+ZZ
  1021						IFE	ZZ,<ZZ=1>
  1022						MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1023						ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1024						EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1025						EQV	[0]		;RESULTS IN C(AC)=0
  1026						SKIPE			;PASS TEST IF C(AC)=0
  1027						STOP
  1028
  1029					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1030					;IR ADDX [IR1], IR ADSUB [IR1]
  1031
  1032					;**********
  1033					PAGE
  1034					>
  1035					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1036					;A WORD OF ALL ZEROS IS ADDED TO AN
  1037					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1038					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1039					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1040					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1041					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1042					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1043					;EVERY BIT OF THE AC.
  1044					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1045			011001		SN=SN+1
  1046			000000			ZZ=ZZ+ZZ
  1047			000001			IFE	ZZ,<ZZ=1>
  1048	031000	200 00 0 00 035416 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1049	031001	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1050	031002	444 00 0 00 035416 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1051	031003	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1052	031004	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1053						STOP^
  1054	031005	254 04 0 00 031006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1055	031006	324 00 0 00 031007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1056									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1057									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0032

  1058
  1059					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1060					;IR ADDX [IR1], IR ADSUB [IR1]
  1061
  1062					;**********
  1063					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0033

  1064
  1065					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1066					;A WORD OF ALL ZEROS IS ADDED TO AN
  1067					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1068					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1069					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1070					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1071					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1072					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1073					;EVERY BIT OF THE AC.
  1074					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1075			011002		SN=SN+1
  1076			000002			ZZ=ZZ+ZZ
  1077						IFE	ZZ,<ZZ=1>
  1078	031007	200 00 0 00 035417 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1079	031010	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1080	031011	444 00 0 00 035417 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1081	031012	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1082	031013	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1083						STOP^
  1084	031014	254 04 0 00 031015 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1085	031015	324 00 0 00 031016 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1086									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1087									;IN THE SUBTEST) TO LOOP ON ERROR^
  1088
  1089					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1090					;IR ADDX [IR1], IR ADSUB [IR1]
  1091
  1092					;**********
  1093					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0034

  1094
  1095					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1096					;A WORD OF ALL ZEROS IS ADDED TO AN
  1097					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1098					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1099					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1100					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1101					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1102					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1103					;EVERY BIT OF THE AC.
  1104					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1105			011003		SN=SN+1
  1106			000004			ZZ=ZZ+ZZ
  1107						IFE	ZZ,<ZZ=1>
  1108	031016	200 00 0 00 035420 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1109	031017	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1110	031020	444 00 0 00 035420 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1111	031021	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1112	031022	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1113						STOP^
  1114	031023	254 04 0 00 031024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1115	031024	324 00 0 00 031025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1116									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1117									;IN THE SUBTEST) TO LOOP ON ERROR^
  1118
  1119					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1120					;IR ADDX [IR1], IR ADSUB [IR1]
  1121
  1122					;**********
  1123					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0035

  1124
  1125					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1126					;A WORD OF ALL ZEROS IS ADDED TO AN
  1127					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1128					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1129					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1130					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1131					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1132					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1133					;EVERY BIT OF THE AC.
  1134					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1135			011004		SN=SN+1
  1136			000010			ZZ=ZZ+ZZ
  1137						IFE	ZZ,<ZZ=1>
  1138	031025	200 00 0 00 035421 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1139	031026	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1140	031027	444 00 0 00 035421 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1141	031030	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1142	031031	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1143						STOP^
  1144	031032	254 04 0 00 031033 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1145	031033	324 00 0 00 031034 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1146									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1147									;IN THE SUBTEST) TO LOOP ON ERROR^
  1148
  1149					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1150					;IR ADDX [IR1], IR ADSUB [IR1]
  1151
  1152					;**********
  1153					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0036

  1154
  1155					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1156					;A WORD OF ALL ZEROS IS ADDED TO AN
  1157					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1158					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1159					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1160					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1161					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1162					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1163					;EVERY BIT OF THE AC.
  1164					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1165			011005		SN=SN+1
  1166			000020			ZZ=ZZ+ZZ
  1167						IFE	ZZ,<ZZ=1>
  1168	031034	200 00 0 00 035422 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1169	031035	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1170	031036	444 00 0 00 035422 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1171	031037	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1172	031040	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1173						STOP^
  1174	031041	254 04 0 00 031042 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1175	031042	324 00 0 00 031043 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1176									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1177									;IN THE SUBTEST) TO LOOP ON ERROR^
  1178
  1179					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1180					;IR ADDX [IR1], IR ADSUB [IR1]
  1181
  1182					;**********
  1183					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0037

  1184
  1185					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1186					;A WORD OF ALL ZEROS IS ADDED TO AN
  1187					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1188					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1189					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1190					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1191					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1192					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1193					;EVERY BIT OF THE AC.
  1194					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1195			011006		SN=SN+1
  1196			000040			ZZ=ZZ+ZZ
  1197						IFE	ZZ,<ZZ=1>
  1198	031043	200 00 0 00 035423 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1199	031044	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1200	031045	444 00 0 00 035423 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1201	031046	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1202	031047	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1203						STOP^
  1204	031050	254 04 0 00 031051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1205	031051	324 00 0 00 031052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1206									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1207									;IN THE SUBTEST) TO LOOP ON ERROR^
  1208
  1209					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1210					;IR ADDX [IR1], IR ADSUB [IR1]
  1211
  1212					;**********
  1213					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-7
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0038

  1214
  1215					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1216					;A WORD OF ALL ZEROS IS ADDED TO AN
  1217					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1218					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1219					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1220					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1221					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1222					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1223					;EVERY BIT OF THE AC.
  1224					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1225			011007		SN=SN+1
  1226			000100			ZZ=ZZ+ZZ
  1227						IFE	ZZ,<ZZ=1>
  1228	031052	200 00 0 00 035424 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1229	031053	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1230	031054	444 00 0 00 035424 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1231	031055	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1232	031056	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1233						STOP^
  1234	031057	254 04 0 00 031060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1235	031060	324 00 0 00 031061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1236									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1237									;IN THE SUBTEST) TO LOOP ON ERROR^
  1238
  1239					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1240					;IR ADDX [IR1], IR ADSUB [IR1]
  1241
  1242					;**********
  1243					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-8
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0039

  1244
  1245					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1246					;A WORD OF ALL ZEROS IS ADDED TO AN
  1247					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1248					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1249					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1250					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1251					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1252					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1253					;EVERY BIT OF THE AC.
  1254					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1255			011010		SN=SN+1
  1256			000200			ZZ=ZZ+ZZ
  1257						IFE	ZZ,<ZZ=1>
  1258	031061	200 00 0 00 035425 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1259	031062	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1260	031063	444 00 0 00 035425 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1261	031064	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1262	031065	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1263						STOP^
  1264	031066	254 04 0 00 031067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1265	031067	324 00 0 00 031070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1266									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1267									;IN THE SUBTEST) TO LOOP ON ERROR^
  1268
  1269					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1270					;IR ADDX [IR1], IR ADSUB [IR1]
  1271
  1272					;**********
  1273					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-9
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0040

  1274
  1275					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1276					;A WORD OF ALL ZEROS IS ADDED TO AN
  1277					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1278					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1279					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1280					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1281					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1282					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1283					;EVERY BIT OF THE AC.
  1284					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1285			011011		SN=SN+1
  1286			000400			ZZ=ZZ+ZZ
  1287						IFE	ZZ,<ZZ=1>
  1288	031070	200 00 0 00 035426 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1289	031071	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1290	031072	444 00 0 00 035426 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1291	031073	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1292	031074	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1293						STOP^
  1294	031075	254 04 0 00 031076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1295	031076	324 00 0 00 031077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1296									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1297									;IN THE SUBTEST) TO LOOP ON ERROR^
  1298
  1299					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1300					;IR ADDX [IR1], IR ADSUB [IR1]
  1301
  1302					;**********
  1303					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-10
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0041

  1304
  1305					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1306					;A WORD OF ALL ZEROS IS ADDED TO AN
  1307					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1308					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1309					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1310					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1311					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1312					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1313					;EVERY BIT OF THE AC.
  1314					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1315			011012		SN=SN+1
  1316			001000			ZZ=ZZ+ZZ
  1317						IFE	ZZ,<ZZ=1>
  1318	031077	200 00 0 00 035427 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1319	031100	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1320	031101	444 00 0 00 035427 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1321	031102	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1322	031103	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1323						STOP^
  1324	031104	254 04 0 00 031105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1325	031105	324 00 0 00 031106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1326									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1327									;IN THE SUBTEST) TO LOOP ON ERROR^
  1328
  1329					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1330					;IR ADDX [IR1], IR ADSUB [IR1]
  1331
  1332					;**********
  1333					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-11
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0042

  1334
  1335					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1336					;A WORD OF ALL ZEROS IS ADDED TO AN
  1337					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1338					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1339					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1340					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1341					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1342					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1343					;EVERY BIT OF THE AC.
  1344					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1345			011013		SN=SN+1
  1346			002000			ZZ=ZZ+ZZ
  1347						IFE	ZZ,<ZZ=1>
  1348	031106	200 00 0 00 035430 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1349	031107	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1350	031110	444 00 0 00 035430 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1351	031111	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1352	031112	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1353						STOP^
  1354	031113	254 04 0 00 031114 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1355	031114	324 00 0 00 031115 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1356									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1357									;IN THE SUBTEST) TO LOOP ON ERROR^
  1358
  1359					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1360					;IR ADDX [IR1], IR ADSUB [IR1]
  1361
  1362					;**********
  1363					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-12
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0043

  1364
  1365					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1366					;A WORD OF ALL ZEROS IS ADDED TO AN
  1367					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1368					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1369					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1370					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1371					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1372					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1373					;EVERY BIT OF THE AC.
  1374					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1375			011014		SN=SN+1
  1376			004000			ZZ=ZZ+ZZ
  1377						IFE	ZZ,<ZZ=1>
  1378	031115	200 00 0 00 035431 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1379	031116	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1380	031117	444 00 0 00 035431 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1381	031120	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1382	031121	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1383						STOP^
  1384	031122	254 04 0 00 031123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1385	031123	324 00 0 00 031124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1386									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1387									;IN THE SUBTEST) TO LOOP ON ERROR^
  1388
  1389					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1390					;IR ADDX [IR1], IR ADSUB [IR1]
  1391
  1392					;**********
  1393					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-13
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0044

  1394
  1395					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1396					;A WORD OF ALL ZEROS IS ADDED TO AN
  1397					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1398					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1399					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1400					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1401					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1402					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1403					;EVERY BIT OF THE AC.
  1404					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1405			011015		SN=SN+1
  1406			010000			ZZ=ZZ+ZZ
  1407						IFE	ZZ,<ZZ=1>
  1408	031124	200 00 0 00 035432 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1409	031125	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1410	031126	444 00 0 00 035432 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1411	031127	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1412	031130	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1413						STOP^
  1414	031131	254 04 0 00 031132 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1415	031132	324 00 0 00 031133 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1416									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1417									;IN THE SUBTEST) TO LOOP ON ERROR^
  1418
  1419					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1420					;IR ADDX [IR1], IR ADSUB [IR1]
  1421
  1422					;**********
  1423					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-14
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0045

  1424
  1425					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1426					;A WORD OF ALL ZEROS IS ADDED TO AN
  1427					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1428					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1429					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1430					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1431					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1432					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1433					;EVERY BIT OF THE AC.
  1434					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1435			011016		SN=SN+1
  1436			020000			ZZ=ZZ+ZZ
  1437						IFE	ZZ,<ZZ=1>
  1438	031133	200 00 0 00 035433 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1439	031134	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1440	031135	444 00 0 00 035433 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1441	031136	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1442	031137	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1443						STOP^
  1444	031140	254 04 0 00 031141 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1445	031141	324 00 0 00 031142 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1446									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1447									;IN THE SUBTEST) TO LOOP ON ERROR^
  1448
  1449					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1450					;IR ADDX [IR1], IR ADSUB [IR1]
  1451
  1452					;**********
  1453					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-15
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0046

  1454
  1455					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1456					;A WORD OF ALL ZEROS IS ADDED TO AN
  1457					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1458					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1459					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1460					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1461					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1462					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1463					;EVERY BIT OF THE AC.
  1464					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1465			011017		SN=SN+1
  1466			040000			ZZ=ZZ+ZZ
  1467						IFE	ZZ,<ZZ=1>
  1468	031142	200 00 0 00 035434 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1469	031143	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1470	031144	444 00 0 00 035434 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1471	031145	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1472	031146	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1473						STOP^
  1474	031147	254 04 0 00 031150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1475	031150	324 00 0 00 031151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1476									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1477									;IN THE SUBTEST) TO LOOP ON ERROR^
  1478
  1479					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1480					;IR ADDX [IR1], IR ADSUB [IR1]
  1481
  1482					;**********
  1483					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-16
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0047

  1484
  1485					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1486					;A WORD OF ALL ZEROS IS ADDED TO AN
  1487					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1488					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1489					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1490					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1491					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1492					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1493					;EVERY BIT OF THE AC.
  1494					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1495			011020		SN=SN+1
  1496			100000			ZZ=ZZ+ZZ
  1497						IFE	ZZ,<ZZ=1>
  1498	031151	200 00 0 00 035435 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1499	031152	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1500	031153	444 00 0 00 035435 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1501	031154	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1502	031155	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1503						STOP^
  1504	031156	254 04 0 00 031157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1505	031157	324 00 0 00 031160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1506									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1507									;IN THE SUBTEST) TO LOOP ON ERROR^
  1508
  1509					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1510					;IR ADDX [IR1], IR ADSUB [IR1]
  1511
  1512					;**********
  1513					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-17
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0048

  1514
  1515					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1516					;A WORD OF ALL ZEROS IS ADDED TO AN
  1517					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1518					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1519					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1520					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1521					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1522					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1523					;EVERY BIT OF THE AC.
  1524					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1525			011021		SN=SN+1
  1526			200000			ZZ=ZZ+ZZ
  1527						IFE	ZZ,<ZZ=1>
  1528	031160	200 00 0 00 035436 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1529	031161	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1530	031162	444 00 0 00 035436 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1531	031163	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1532	031164	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1533						STOP^
  1534	031165	254 04 0 00 031166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1535	031166	324 00 0 00 031167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1536									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1537									;IN THE SUBTEST) TO LOOP ON ERROR^
  1538
  1539					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1540					;IR ADDX [IR1], IR ADSUB [IR1]
  1541
  1542					;**********
  1543					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-18
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0049

  1544
  1545					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1546					;A WORD OF ALL ZEROS IS ADDED TO AN
  1547					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1548					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1549					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1550					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1551					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1552					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1553					;EVERY BIT OF THE AC.
  1554					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1555			011022		SN=SN+1
  1556			400000			ZZ=ZZ+ZZ
  1557						IFE	ZZ,<ZZ=1>
  1558	031167	200 00 0 00 035437 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1559	031170	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1560	031171	444 00 0 00 035437 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1561	031172	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1562	031173	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1563						STOP^
  1564	031174	254 04 0 00 031175 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1565	031175	324 00 0 00 031176 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1566									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1567									;IN THE SUBTEST) TO LOOP ON ERROR^
  1568
  1569					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1570					;IR ADDX [IR1], IR ADSUB [IR1]
  1571
  1572					;**********
  1573					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-19
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0050

  1574
  1575					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1576					;A WORD OF ALL ZEROS IS ADDED TO AN
  1577					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1578					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1579					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1580					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1581					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1582					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1583					;EVERY BIT OF THE AC.
  1584					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1585			011023		SN=SN+1
  1586		000001	000000			ZZ=ZZ+ZZ
  1587						IFE	ZZ,<ZZ=1>
  1588	031176	200 00 0 00 035440 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1589	031177	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1590	031200	444 00 0 00 035440 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1591	031201	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1592	031202	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1593						STOP^
  1594	031203	254 04 0 00 031204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1595	031204	324 00 0 00 031205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1596									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1597									;IN THE SUBTEST) TO LOOP ON ERROR^
  1598
  1599					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1600					;IR ADDX [IR1], IR ADSUB [IR1]
  1601
  1602					;**********
  1603					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-20
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0051

  1604
  1605					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1606					;A WORD OF ALL ZEROS IS ADDED TO AN
  1607					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1608					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1609					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1610					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1611					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1612					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1613					;EVERY BIT OF THE AC.
  1614					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1615			011024		SN=SN+1
  1616		000002	000000			ZZ=ZZ+ZZ
  1617						IFE	ZZ,<ZZ=1>
  1618	031205	200 00 0 00 035441 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1619	031206	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1620	031207	444 00 0 00 035441 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1621	031210	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1622	031211	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1623						STOP^
  1624	031212	254 04 0 00 031213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1625	031213	324 00 0 00 031214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1626									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1627									;IN THE SUBTEST) TO LOOP ON ERROR^
  1628
  1629					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1630					;IR ADDX [IR1], IR ADSUB [IR1]
  1631
  1632					;**********
  1633					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-21
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0052

  1634
  1635					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1636					;A WORD OF ALL ZEROS IS ADDED TO AN
  1637					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1638					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1639					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1640					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1641					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1642					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1643					;EVERY BIT OF THE AC.
  1644					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1645			011025		SN=SN+1
  1646		000004	000000			ZZ=ZZ+ZZ
  1647						IFE	ZZ,<ZZ=1>
  1648	031214	200 00 0 00 035442 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1649	031215	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1650	031216	444 00 0 00 035442 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1651	031217	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1652	031220	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1653						STOP^
  1654	031221	254 04 0 00 031222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1655	031222	324 00 0 00 031223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1656									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1657									;IN THE SUBTEST) TO LOOP ON ERROR^
  1658
  1659					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1660					;IR ADDX [IR1], IR ADSUB [IR1]
  1661
  1662					;**********
  1663					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-22
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0053

  1664
  1665					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1666					;A WORD OF ALL ZEROS IS ADDED TO AN
  1667					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1668					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1669					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1670					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1671					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1672					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1673					;EVERY BIT OF THE AC.
  1674					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1675			011026		SN=SN+1
  1676		000010	000000			ZZ=ZZ+ZZ
  1677						IFE	ZZ,<ZZ=1>
  1678	031223	200 00 0 00 035443 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1679	031224	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1680	031225	444 00 0 00 035443 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1681	031226	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1682	031227	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1683						STOP^
  1684	031230	254 04 0 00 031231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1685	031231	324 00 0 00 031232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1687									;IN THE SUBTEST) TO LOOP ON ERROR^
  1688
  1689					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1690					;IR ADDX [IR1], IR ADSUB [IR1]
  1691
  1692					;**********
  1693					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-23
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0054

  1694
  1695					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1696					;A WORD OF ALL ZEROS IS ADDED TO AN
  1697					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1698					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1699					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1700					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1701					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1702					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1703					;EVERY BIT OF THE AC.
  1704					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1705			011027		SN=SN+1
  1706		000020	000000			ZZ=ZZ+ZZ
  1707						IFE	ZZ,<ZZ=1>
  1708	031232	200 00 0 00 035444 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1709	031233	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1710	031234	444 00 0 00 035444 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1711	031235	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1712	031236	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1713						STOP^
  1714	031237	254 04 0 00 031240 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1715	031240	324 00 0 00 031241 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1716									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1717									;IN THE SUBTEST) TO LOOP ON ERROR^
  1718
  1719					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1720					;IR ADDX [IR1], IR ADSUB [IR1]
  1721
  1722					;**********
  1723					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-24
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0055

  1724
  1725					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1726					;A WORD OF ALL ZEROS IS ADDED TO AN
  1727					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1728					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1729					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1730					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1731					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1732					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1733					;EVERY BIT OF THE AC.
  1734					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1735			011030		SN=SN+1
  1736		000040	000000			ZZ=ZZ+ZZ
  1737						IFE	ZZ,<ZZ=1>
  1738	031241	200 00 0 00 035445 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1739	031242	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1740	031243	444 00 0 00 035445 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1741	031244	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1742	031245	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1743						STOP^
  1744	031246	254 04 0 00 031247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1745	031247	324 00 0 00 031250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1746									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1747									;IN THE SUBTEST) TO LOOP ON ERROR^
  1748
  1749					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1750					;IR ADDX [IR1], IR ADSUB [IR1]
  1751
  1752					;**********
  1753					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-25
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0056

  1754
  1755					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1756					;A WORD OF ALL ZEROS IS ADDED TO AN
  1757					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1758					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1759					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1760					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1761					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1762					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1763					;EVERY BIT OF THE AC.
  1764					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1765			011031		SN=SN+1
  1766		000100	000000			ZZ=ZZ+ZZ
  1767						IFE	ZZ,<ZZ=1>
  1768	031250	200 00 0 00 035446 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1769	031251	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1770	031252	444 00 0 00 035446 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1771	031253	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1772	031254	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1773						STOP^
  1774	031255	254 04 0 00 031256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1775	031256	324 00 0 00 031257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1776									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1777									;IN THE SUBTEST) TO LOOP ON ERROR^
  1778
  1779					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1780					;IR ADDX [IR1], IR ADSUB [IR1]
  1781
  1782					;**********
  1783					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-26
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0057

  1784
  1785					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1786					;A WORD OF ALL ZEROS IS ADDED TO AN
  1787					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1788					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1789					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1790					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1791					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1792					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1793					;EVERY BIT OF THE AC.
  1794					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1795			011032		SN=SN+1
  1796		000200	000000			ZZ=ZZ+ZZ
  1797						IFE	ZZ,<ZZ=1>
  1798	031257	200 00 0 00 035447 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1799	031260	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1800	031261	444 00 0 00 035447 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1801	031262	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1802	031263	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1803						STOP^
  1804	031264	254 04 0 00 031265 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1805	031265	324 00 0 00 031266 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1807									;IN THE SUBTEST) TO LOOP ON ERROR^
  1808
  1809					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1810					;IR ADDX [IR1], IR ADSUB [IR1]
  1811
  1812					;**********
  1813					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-27
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0058

  1814
  1815					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1816					;A WORD OF ALL ZEROS IS ADDED TO AN
  1817					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1818					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1819					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1820					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1821					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1822					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1823					;EVERY BIT OF THE AC.
  1824					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1825			011033		SN=SN+1
  1826		000400	000000			ZZ=ZZ+ZZ
  1827						IFE	ZZ,<ZZ=1>
  1828	031266	200 00 0 00 035450 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1829	031267	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1830	031270	444 00 0 00 035450 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1831	031271	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1832	031272	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1833						STOP^
  1834	031273	254 04 0 00 031274 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1835	031274	324 00 0 00 031275 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1836									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1837									;IN THE SUBTEST) TO LOOP ON ERROR^
  1838
  1839					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1840					;IR ADDX [IR1], IR ADSUB [IR1]
  1841
  1842					;**********
  1843					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-28
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0059

  1844
  1845					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1846					;A WORD OF ALL ZEROS IS ADDED TO AN
  1847					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1848					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1849					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1850					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1851					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1852					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1853					;EVERY BIT OF THE AC.
  1854					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1855			011034		SN=SN+1
  1856		001000	000000			ZZ=ZZ+ZZ
  1857						IFE	ZZ,<ZZ=1>
  1858	031275	200 00 0 00 035451 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1859	031276	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1860	031277	444 00 0 00 035451 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1861	031300	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1862	031301	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1863						STOP^
  1864	031302	254 04 0 00 031303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1865	031303	324 00 0 00 031304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1866									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1867									;IN THE SUBTEST) TO LOOP ON ERROR^
  1868
  1869					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1870					;IR ADDX [IR1], IR ADSUB [IR1]
  1871
  1872					;**********
  1873					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-29
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0060

  1874
  1875					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1876					;A WORD OF ALL ZEROS IS ADDED TO AN
  1877					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1878					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1879					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1880					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1881					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1882					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1883					;EVERY BIT OF THE AC.
  1884					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1885			011035		SN=SN+1
  1886		002000	000000			ZZ=ZZ+ZZ
  1887						IFE	ZZ,<ZZ=1>
  1888	031304	200 00 0 00 035452 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1889	031305	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1890	031306	444 00 0 00 035452 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1891	031307	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1892	031310	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1893						STOP^
  1894	031311	254 04 0 00 031312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1895	031312	324 00 0 00 031313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1896									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1897									;IN THE SUBTEST) TO LOOP ON ERROR^
  1898
  1899					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1900					;IR ADDX [IR1], IR ADSUB [IR1]
  1901
  1902					;**********
  1903					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-30
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0061

  1904
  1905					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1906					;A WORD OF ALL ZEROS IS ADDED TO AN
  1907					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1908					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1909					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1910					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1911					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1912					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1913					;EVERY BIT OF THE AC.
  1914					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1915			011036		SN=SN+1
  1916		004000	000000			ZZ=ZZ+ZZ
  1917						IFE	ZZ,<ZZ=1>
  1918	031313	200 00 0 00 035453 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1919	031314	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1920	031315	444 00 0 00 035453 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1921	031316	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1922	031317	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1923						STOP^
  1924	031320	254 04 0 00 031321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1925	031321	324 00 0 00 031322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1926									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1927									;IN THE SUBTEST) TO LOOP ON ERROR^
  1928
  1929					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1930					;IR ADDX [IR1], IR ADSUB [IR1]
  1931
  1932					;**********
  1933					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-31
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0062

  1934
  1935					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1936					;A WORD OF ALL ZEROS IS ADDED TO AN
  1937					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1938					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1939					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1940					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1941					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1942					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1943					;EVERY BIT OF THE AC.
  1944					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1945			011037		SN=SN+1
  1946		010000	000000			ZZ=ZZ+ZZ
  1947						IFE	ZZ,<ZZ=1>
  1948	031322	200 00 0 00 035454 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1949	031323	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1950	031324	444 00 0 00 035454 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1951	031325	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1952	031326	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1953						STOP^
  1954	031327	254 04 0 00 031330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1955	031330	324 00 0 00 031331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1956									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1957									;IN THE SUBTEST) TO LOOP ON ERROR^
  1958
  1959					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1960					;IR ADDX [IR1], IR ADSUB [IR1]
  1961
  1962					;**********
  1963					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-32
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0063

  1964
  1965					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1966					;A WORD OF ALL ZEROS IS ADDED TO AN
  1967					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1968					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1969					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  1970					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  1971					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  1972					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  1973					;EVERY BIT OF THE AC.
  1974					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  1975			011040		SN=SN+1
  1976		020000	000000			ZZ=ZZ+ZZ
  1977						IFE	ZZ,<ZZ=1>
  1978	031331	200 00 0 00 035455 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  1979	031332	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  1980	031333	444 00 0 00 035455 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  1981	031334	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  1982	031335	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  1983						STOP^
  1984	031336	254 04 0 00 031337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1985	031337	324 00 0 00 031340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1986									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1987									;IN THE SUBTEST) TO LOOP ON ERROR^
  1988
  1989					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  1990					;IR ADDX [IR1], IR ADSUB [IR1]
  1991
  1992					;**********
  1993					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-33
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0064

  1994
  1995					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  1996					;A WORD OF ALL ZEROS IS ADDED TO AN
  1997					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  1998					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  1999					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2000					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2001					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2002					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2003					;EVERY BIT OF THE AC.
  2004					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2005			011041		SN=SN+1
  2006		040000	000000			ZZ=ZZ+ZZ
  2007						IFE	ZZ,<ZZ=1>
  2008	031340	200 00 0 00 035456 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  2009	031341	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  2010	031342	444 00 0 00 035456 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2011	031343	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2012	031344	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2013						STOP^
  2014	031345	254 04 0 00 031346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2015	031346	324 00 0 00 031347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2016									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2017									;IN THE SUBTEST) TO LOOP ON ERROR^
  2018
  2019					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  2020					;IR ADDX [IR1], IR ADSUB [IR1]
  2021
  2022					;**********
  2023					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-34
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0065

  2024
  2025					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2026					;A WORD OF ALL ZEROS IS ADDED TO AN
  2027					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2028					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  2029					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2030					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2031					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2032					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2033					;EVERY BIT OF THE AC.
  2034					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2035			011042		SN=SN+1
  2036		100000	000000			ZZ=ZZ+ZZ
  2037						IFE	ZZ,<ZZ=1>
  2038	031347	200 00 0 00 035457 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  2039	031350	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  2040	031351	444 00 0 00 035457 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2041	031352	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2042	031353	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2043						STOP^
  2044	031354	254 04 0 00 031355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2045	031355	324 00 0 00 031356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2046									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2047									;IN THE SUBTEST) TO LOOP ON ERROR^
  2048
  2049					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  2050					;IR ADDX [IR1], IR ADSUB [IR1]
  2051
  2052					;**********
  2053					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-35
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0066

  2054
  2055					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2056					;A WORD OF ALL ZEROS IS ADDED TO AN
  2057					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2058					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  2059					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2060					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2061					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2062					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2063					;EVERY BIT OF THE AC.
  2064					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2065			011043		SN=SN+1
  2066		200000	000000			ZZ=ZZ+ZZ
  2067						IFE	ZZ,<ZZ=1>
  2068	031356	200 00 0 00 035460 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  2069	031357	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  2070	031360	444 00 0 00 035460 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2071	031361	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2072	031362	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2073						STOP^
  2074	031363	254 04 0 00 031364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2075	031364	324 00 0 00 031365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2076									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2077									;IN THE SUBTEST) TO LOOP ON ERROR^
  2078
  2079					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  2080					;IR ADDX [IR1], IR ADSUB [IR1]
  2081
  2082					;**********
  2083					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-36
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0067

  2084
  2085					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2086					;A WORD OF ALL ZEROS IS ADDED TO AN
  2087					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2088					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  2089					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2090					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2091					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2092					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2093					;EVERY BIT OF THE AC.
  2094					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2095			011044		SN=SN+1
  2096		400000	000000			ZZ=ZZ+ZZ
  2097						IFE	ZZ,<ZZ=1>
  2098	031365	200 00 0 00 035461 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  2099	031366	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  2100	031367	444 00 0 00 035461 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2101	031370	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2102	031371	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2103						STOP^
  2104	031372	254 04 0 00 031373 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2105	031373	324 00 0 00 031374 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2106									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2107									;IN THE SUBTEST) TO LOOP ON ERROR^
  2108
  2109					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  2110					;IR ADDX [IR1], IR ADSUB [IR1]
  2111
  2112					;**********
  2113					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 5-37
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0068

  2114
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 6
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0069

  2115					;THIS TEST VERIFIES THAT THE ADDITION OF A WORD OF
  2116					;ALL ZEROS TO AN AC OF ALL ZEROS RESULTS IN
  2117					;C(AC)=0. FIRST THE AC IS CLEARED; THEN, A WORD
  2118					;OF ALL ZEROS IS ADDED TO THE AC. THE RESULT IN
  2119					;THE AC IS THEN CHECKED TO INSURE THAT C(AC)=0
  2120
  2121	031374	200 00 0 00 035412 	A11100:	MOVE	[0]		;PRESET AC TO ZERO
  2122	031375	270 00 0 00 035412 		ADD	[0]		;*ADD OF ZERO TO ZERO SHOULD RESULT IN C(AC)=0
  2123	031376	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2124						STOP^
  2125	031377	254 04 0 00 031400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2126	031400	324 00 0 00 031401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2127									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2128									;IN THE SUBTEST) TO LOOP ON ERROR^
  2129
  2130					;FCE[F1], IR AD SUB [IR1]
  2131					;AD FM + EN [ADFP], AD FM + EN A [ADFP],
  2132					;F CYC ACT EN C[F1], IR ADSUB [IR1]
  2133
  2134					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0070

  2135					;ADD ZERO TO A RIPPLED ONE
  2136
  2137			013200		SN=13200
  2138			000000			ZZ=0
  2139
  2140					A13200:	REPEAT	^D36,
  2141					<;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2142					;TO AN AC  OF ALL ZEROS IS ADDED A
  2143					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2144					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2145					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2146					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2147					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2148					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2149					;EVERY BIT OF THE AC.
  2150					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2151					SN=SN+1
  2152						ZZ=ZZ+ZZ
  2153						IFE	ZZ,<ZZ=1>
  2154						MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2155						ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2156						EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2157						EQV	[0]		;RESULTS IN C(AC)=0
  2158						SKIPE			;PASS TEST IF C(AC)=0
  2159						STOP
  2160
  2161					;**********
  2162					>
  2163					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2164					;TO AN AC  OF ALL ZEROS IS ADDED A
  2165					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2166					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2167					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2168					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2169					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2170					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2171					;EVERY BIT OF THE AC.
  2172					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2173			013201		SN=SN+1
  2174			000000			ZZ=ZZ+ZZ
  2175			000001			IFE	ZZ,<ZZ=1>
  2176	031401	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2177	031402	270 00 0 00 035416 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2178	031403	444 00 0 00 035416 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2179	031404	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2180	031405	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2181						STOP^
  2182	031406	254 04 0 00 031407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2183	031407	324 00 0 00 031410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2184									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2185									;IN THE SUBTEST) TO LOOP ON ERROR^
  2186
  2187					;**********
  2188
  2189					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0071

  2190					;TO AN AC  OF ALL ZEROS IS ADDED A
  2191					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2192					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2193					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2194					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2195					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2196					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2197					;EVERY BIT OF THE AC.
  2198					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2199			013202		SN=SN+1
  2200			000002			ZZ=ZZ+ZZ
  2201						IFE	ZZ,<ZZ=1>
  2202	031410	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2203	031411	270 00 0 00 035417 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2204	031412	444 00 0 00 035417 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2205	031413	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2206	031414	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2207						STOP^
  2208	031415	254 04 0 00 031416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2209	031416	324 00 0 00 031417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2210									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2211									;IN THE SUBTEST) TO LOOP ON ERROR^
  2212
  2213					;**********
  2214
  2215					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2216					;TO AN AC  OF ALL ZEROS IS ADDED A
  2217					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2218					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2219					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2220					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2221					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2222					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2223					;EVERY BIT OF THE AC.
  2224					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2225			013203		SN=SN+1
  2226			000004			ZZ=ZZ+ZZ
  2227						IFE	ZZ,<ZZ=1>
  2228	031417	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2229	031420	270 00 0 00 035420 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2230	031421	444 00 0 00 035420 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2231	031422	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2232	031423	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2233						STOP^
  2234	031424	254 04 0 00 031425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2235	031425	324 00 0 00 031426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2236									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2237									;IN THE SUBTEST) TO LOOP ON ERROR^
  2238
  2239					;**********
  2240
  2241					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2242					;TO AN AC  OF ALL ZEROS IS ADDED A
  2243					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2244					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0072

  2245					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2246					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2247					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2248					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2249					;EVERY BIT OF THE AC.
  2250					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2251			013204		SN=SN+1
  2252			000010			ZZ=ZZ+ZZ
  2253						IFE	ZZ,<ZZ=1>
  2254	031426	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2255	031427	270 00 0 00 035421 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2256	031430	444 00 0 00 035421 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2257	031431	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2258	031432	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2259						STOP^
  2260	031433	254 04 0 00 031434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2261	031434	324 00 0 00 031435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2262									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2263									;IN THE SUBTEST) TO LOOP ON ERROR^
  2264
  2265					;**********
  2266
  2267					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2268					;TO AN AC  OF ALL ZEROS IS ADDED A
  2269					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2270					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2271					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2272					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2273					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2274					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2275					;EVERY BIT OF THE AC.
  2276					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2277			013205		SN=SN+1
  2278			000020			ZZ=ZZ+ZZ
  2279						IFE	ZZ,<ZZ=1>
  2280	031435	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2281	031436	270 00 0 00 035422 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2282	031437	444 00 0 00 035422 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2283	031440	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2284	031441	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2285						STOP^
  2286	031442	254 04 0 00 031443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2287	031443	324 00 0 00 031444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2288									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2289									;IN THE SUBTEST) TO LOOP ON ERROR^
  2290
  2291					;**********
  2292
  2293					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2294					;TO AN AC  OF ALL ZEROS IS ADDED A
  2295					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2296					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2297					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2298					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2299					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0073

  2300					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2301					;EVERY BIT OF THE AC.
  2302					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2303			013206		SN=SN+1
  2304			000040			ZZ=ZZ+ZZ
  2305						IFE	ZZ,<ZZ=1>
  2306	031444	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2307	031445	270 00 0 00 035423 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2308	031446	444 00 0 00 035423 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2309	031447	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2310	031450	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2311						STOP^
  2312	031451	254 04 0 00 031452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2313	031452	324 00 0 00 031453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2314									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2315									;IN THE SUBTEST) TO LOOP ON ERROR^
  2316
  2317					;**********
  2318
  2319					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2320					;TO AN AC  OF ALL ZEROS IS ADDED A
  2321					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2322					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2323					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2324					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2325					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2326					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2327					;EVERY BIT OF THE AC.
  2328					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2329			013207		SN=SN+1
  2330			000100			ZZ=ZZ+ZZ
  2331						IFE	ZZ,<ZZ=1>
  2332	031453	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2333	031454	270 00 0 00 035424 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2334	031455	444 00 0 00 035424 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2335	031456	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2336	031457	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2337						STOP^
  2338	031460	254 04 0 00 031461 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2339	031461	324 00 0 00 031462 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2340									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2341									;IN THE SUBTEST) TO LOOP ON ERROR^
  2342
  2343					;**********
  2344
  2345					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2346					;TO AN AC  OF ALL ZEROS IS ADDED A
  2347					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2348					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2349					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2350					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2351					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2352					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2353					;EVERY BIT OF THE AC.
  2354					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0074

  2355			013210		SN=SN+1
  2356			000200			ZZ=ZZ+ZZ
  2357						IFE	ZZ,<ZZ=1>
  2358	031462	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2359	031463	270 00 0 00 035425 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2360	031464	444 00 0 00 035425 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2361	031465	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2362	031466	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2363						STOP^
  2364	031467	254 04 0 00 031470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2365	031470	324 00 0 00 031471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2366									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2367									;IN THE SUBTEST) TO LOOP ON ERROR^
  2368
  2369					;**********
  2370
  2371					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2372					;TO AN AC  OF ALL ZEROS IS ADDED A
  2373					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2374					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2375					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2376					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2377					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2378					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2379					;EVERY BIT OF THE AC.
  2380					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2381			013211		SN=SN+1
  2382			000400			ZZ=ZZ+ZZ
  2383						IFE	ZZ,<ZZ=1>
  2384	031471	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2385	031472	270 00 0 00 035426 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2386	031473	444 00 0 00 035426 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2387	031474	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2388	031475	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2389						STOP^
  2390	031476	254 04 0 00 031477 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2391	031477	324 00 0 00 031500 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2392									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2393									;IN THE SUBTEST) TO LOOP ON ERROR^
  2394
  2395					;**********
  2396
  2397					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2398					;TO AN AC  OF ALL ZEROS IS ADDED A
  2399					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2400					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2401					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2402					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2403					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2404					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2405					;EVERY BIT OF THE AC.
  2406					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2407			013212		SN=SN+1
  2408			001000			ZZ=ZZ+ZZ
  2409						IFE	ZZ,<ZZ=1>
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0075

  2410	031500	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2411	031501	270 00 0 00 035427 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2412	031502	444 00 0 00 035427 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2413	031503	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2414	031504	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2415						STOP^
  2416	031505	254 04 0 00 031506 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2417	031506	324 00 0 00 031507 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2418									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2419									;IN THE SUBTEST) TO LOOP ON ERROR^
  2420
  2421					;**********
  2422
  2423					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2424					;TO AN AC  OF ALL ZEROS IS ADDED A
  2425					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2426					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2427					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2428					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2429					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2430					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2431					;EVERY BIT OF THE AC.
  2432					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2433			013213		SN=SN+1
  2434			002000			ZZ=ZZ+ZZ
  2435						IFE	ZZ,<ZZ=1>
  2436	031507	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2437	031510	270 00 0 00 035430 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2438	031511	444 00 0 00 035430 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2439	031512	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2440	031513	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2441						STOP^
  2442	031514	254 04 0 00 031515 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2443	031515	324 00 0 00 031516 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2444									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2445									;IN THE SUBTEST) TO LOOP ON ERROR^
  2446
  2447					;**********
  2448
  2449					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2450					;TO AN AC  OF ALL ZEROS IS ADDED A
  2451					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2452					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2453					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2454					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2455					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2456					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2457					;EVERY BIT OF THE AC.
  2458					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2459			013214		SN=SN+1
  2460			004000			ZZ=ZZ+ZZ
  2461						IFE	ZZ,<ZZ=1>
  2462	031516	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2463	031517	270 00 0 00 035431 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2464	031520	444 00 0 00 035431 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0076

  2465	031521	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2466	031522	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2467						STOP^
  2468	031523	254 04 0 00 031524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2469	031524	324 00 0 00 031525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2470									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2471									;IN THE SUBTEST) TO LOOP ON ERROR^
  2472
  2473					;**********
  2474
  2475					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2476					;TO AN AC  OF ALL ZEROS IS ADDED A
  2477					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2478					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2479					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2480					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2481					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2482					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2483					;EVERY BIT OF THE AC.
  2484					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2485			013215		SN=SN+1
  2486			010000			ZZ=ZZ+ZZ
  2487						IFE	ZZ,<ZZ=1>
  2488	031525	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2489	031526	270 00 0 00 035432 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2490	031527	444 00 0 00 035432 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2491	031530	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2492	031531	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2493						STOP^
  2494	031532	254 04 0 00 031533 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2495	031533	324 00 0 00 031534 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2496									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2497									;IN THE SUBTEST) TO LOOP ON ERROR^
  2498
  2499					;**********
  2500
  2501					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2502					;TO AN AC  OF ALL ZEROS IS ADDED A
  2503					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2504					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2505					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2506					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2507					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2508					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2509					;EVERY BIT OF THE AC.
  2510					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2511			013216		SN=SN+1
  2512			020000			ZZ=ZZ+ZZ
  2513						IFE	ZZ,<ZZ=1>
  2514	031534	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2515	031535	270 00 0 00 035433 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2516	031536	444 00 0 00 035433 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2517	031537	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2518	031540	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2519						STOP^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-7
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0077

  2520	031541	254 04 0 00 031542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2521	031542	324 00 0 00 031543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2522									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2523									;IN THE SUBTEST) TO LOOP ON ERROR^
  2524
  2525					;**********
  2526
  2527					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2528					;TO AN AC  OF ALL ZEROS IS ADDED A
  2529					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2530					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2531					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2532					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2533					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2534					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2535					;EVERY BIT OF THE AC.
  2536					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2537			013217		SN=SN+1
  2538			040000			ZZ=ZZ+ZZ
  2539						IFE	ZZ,<ZZ=1>
  2540	031543	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2541	031544	270 00 0 00 035434 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2542	031545	444 00 0 00 035434 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2543	031546	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2544	031547	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2545						STOP^
  2546	031550	254 04 0 00 031551 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2547	031551	324 00 0 00 031552 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2548									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2549									;IN THE SUBTEST) TO LOOP ON ERROR^
  2550
  2551					;**********
  2552
  2553					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2554					;TO AN AC  OF ALL ZEROS IS ADDED A
  2555					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2556					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2557					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2558					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2559					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2560					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2561					;EVERY BIT OF THE AC.
  2562					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2563			013220		SN=SN+1
  2564			100000			ZZ=ZZ+ZZ
  2565						IFE	ZZ,<ZZ=1>
  2566	031552	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2567	031553	270 00 0 00 035435 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2568	031554	444 00 0 00 035435 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2569	031555	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2570	031556	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2571						STOP^
  2572	031557	254 04 0 00 031560 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2573	031560	324 00 0 00 031561 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2574									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-8
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0078

  2575									;IN THE SUBTEST) TO LOOP ON ERROR^
  2576
  2577					;**********
  2578
  2579					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2580					;TO AN AC  OF ALL ZEROS IS ADDED A
  2581					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2582					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2583					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2584					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2585					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2586					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2587					;EVERY BIT OF THE AC.
  2588					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2589			013221		SN=SN+1
  2590			200000			ZZ=ZZ+ZZ
  2591						IFE	ZZ,<ZZ=1>
  2592	031561	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2593	031562	270 00 0 00 035436 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2594	031563	444 00 0 00 035436 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2595	031564	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2596	031565	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2597						STOP^
  2598	031566	254 04 0 00 031567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2599	031567	324 00 0 00 031570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2600									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2601									;IN THE SUBTEST) TO LOOP ON ERROR^
  2602
  2603					;**********
  2604
  2605					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2606					;TO AN AC  OF ALL ZEROS IS ADDED A
  2607					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2608					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2609					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2610					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2611					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2612					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2613					;EVERY BIT OF THE AC.
  2614					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2615			013222		SN=SN+1
  2616			400000			ZZ=ZZ+ZZ
  2617						IFE	ZZ,<ZZ=1>
  2618	031570	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2619	031571	270 00 0 00 035437 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2620	031572	444 00 0 00 035437 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2621	031573	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2622	031574	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2623						STOP^
  2624	031575	254 04 0 00 031576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2625	031576	324 00 0 00 031577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2626									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2627									;IN THE SUBTEST) TO LOOP ON ERROR^
  2628
  2629					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-9
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0079

  2630
  2631					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2632					;TO AN AC  OF ALL ZEROS IS ADDED A
  2633					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2634					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2635					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2636					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2637					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2638					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2639					;EVERY BIT OF THE AC.
  2640					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2641			013223		SN=SN+1
  2642		000001	000000			ZZ=ZZ+ZZ
  2643						IFE	ZZ,<ZZ=1>
  2644	031577	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2645	031600	270 00 0 00 035440 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2646	031601	444 00 0 00 035440 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2647	031602	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2648	031603	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2649						STOP^
  2650	031604	254 04 0 00 031605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2651	031605	324 00 0 00 031606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2652									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2653									;IN THE SUBTEST) TO LOOP ON ERROR^
  2654
  2655					;**********
  2656
  2657					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2658					;TO AN AC  OF ALL ZEROS IS ADDED A
  2659					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2660					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2661					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2662					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2663					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2664					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2665					;EVERY BIT OF THE AC.
  2666					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2667			013224		SN=SN+1
  2668		000002	000000			ZZ=ZZ+ZZ
  2669						IFE	ZZ,<ZZ=1>
  2670	031606	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2671	031607	270 00 0 00 035441 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2672	031610	444 00 0 00 035441 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2673	031611	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2674	031612	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2675						STOP^
  2676	031613	254 04 0 00 031614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2677	031614	324 00 0 00 031615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2678									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2679									;IN THE SUBTEST) TO LOOP ON ERROR^
  2680
  2681					;**********
  2682
  2683					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2684					;TO AN AC  OF ALL ZEROS IS ADDED A
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-10
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0080

  2685					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2686					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2687					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2688					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2689					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2690					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2691					;EVERY BIT OF THE AC.
  2692					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2693			013225		SN=SN+1
  2694		000004	000000			ZZ=ZZ+ZZ
  2695						IFE	ZZ,<ZZ=1>
  2696	031615	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2697	031616	270 00 0 00 035442 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2698	031617	444 00 0 00 035442 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2699	031620	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2700	031621	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2701						STOP^
  2702	031622	254 04 0 00 031623 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2703	031623	324 00 0 00 031624 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2704									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2705									;IN THE SUBTEST) TO LOOP ON ERROR^
  2706
  2707					;**********
  2708
  2709					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2710					;TO AN AC  OF ALL ZEROS IS ADDED A
  2711					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2712					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2713					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2714					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2715					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2716					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2717					;EVERY BIT OF THE AC.
  2718					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2719			013226		SN=SN+1
  2720		000010	000000			ZZ=ZZ+ZZ
  2721						IFE	ZZ,<ZZ=1>
  2722	031624	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2723	031625	270 00 0 00 035443 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2724	031626	444 00 0 00 035443 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2725	031627	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2726	031630	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2727						STOP^
  2728	031631	254 04 0 00 031632 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2729	031632	324 00 0 00 031633 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2730									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2731									;IN THE SUBTEST) TO LOOP ON ERROR^
  2732
  2733					;**********
  2734
  2735					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2736					;TO AN AC  OF ALL ZEROS IS ADDED A
  2737					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2738					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2739					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-11
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0081

  2740					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2741					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2742					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2743					;EVERY BIT OF THE AC.
  2744					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2745			013227		SN=SN+1
  2746		000020	000000			ZZ=ZZ+ZZ
  2747						IFE	ZZ,<ZZ=1>
  2748	031633	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2749	031634	270 00 0 00 035444 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2750	031635	444 00 0 00 035444 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2751	031636	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2752	031637	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2753						STOP^
  2754	031640	254 04 0 00 031641 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2755	031641	324 00 0 00 031642 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2756									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2757									;IN THE SUBTEST) TO LOOP ON ERROR^
  2758
  2759					;**********
  2760
  2761					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2762					;TO AN AC  OF ALL ZEROS IS ADDED A
  2763					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2764					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2765					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2766					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2767					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2768					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2769					;EVERY BIT OF THE AC.
  2770					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2771			013230		SN=SN+1
  2772		000040	000000			ZZ=ZZ+ZZ
  2773						IFE	ZZ,<ZZ=1>
  2774	031642	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2775	031643	270 00 0 00 035445 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2776	031644	444 00 0 00 035445 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2777	031645	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2778	031646	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2779						STOP^
  2780	031647	254 04 0 00 031650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2781	031650	324 00 0 00 031651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2782									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2783									;IN THE SUBTEST) TO LOOP ON ERROR^
  2784
  2785					;**********
  2786
  2787					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2788					;TO AN AC  OF ALL ZEROS IS ADDED A
  2789					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2790					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2791					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2792					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2793					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2794					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-12
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0082

  2795					;EVERY BIT OF THE AC.
  2796					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2797			013231		SN=SN+1
  2798		000100	000000			ZZ=ZZ+ZZ
  2799						IFE	ZZ,<ZZ=1>
  2800	031651	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2801	031652	270 00 0 00 035446 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2802	031653	444 00 0 00 035446 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2803	031654	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2804	031655	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2805						STOP^
  2806	031656	254 04 0 00 031657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2807	031657	324 00 0 00 031660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2808									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2809									;IN THE SUBTEST) TO LOOP ON ERROR^
  2810
  2811					;**********
  2812
  2813					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2814					;TO AN AC  OF ALL ZEROS IS ADDED A
  2815					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2816					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2817					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2818					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2819					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2820					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2821					;EVERY BIT OF THE AC.
  2822					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2823			013232		SN=SN+1
  2824		000200	000000			ZZ=ZZ+ZZ
  2825						IFE	ZZ,<ZZ=1>
  2826	031660	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2827	031661	270 00 0 00 035447 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2828	031662	444 00 0 00 035447 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2829	031663	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2830	031664	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2831						STOP^
  2832	031665	254 04 0 00 031666 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2833	031666	324 00 0 00 031667 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2835									;IN THE SUBTEST) TO LOOP ON ERROR^
  2836
  2837					;**********
  2838
  2839					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2840					;TO AN AC  OF ALL ZEROS IS ADDED A
  2841					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2842					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2843					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2844					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2845					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2846					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2847					;EVERY BIT OF THE AC.
  2848					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2849			013233		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-13
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0083

  2850		000400	000000			ZZ=ZZ+ZZ
  2851						IFE	ZZ,<ZZ=1>
  2852	031667	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2853	031670	270 00 0 00 035450 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2854	031671	444 00 0 00 035450 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2855	031672	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2856	031673	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2857						STOP^
  2858	031674	254 04 0 00 031675 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2859	031675	324 00 0 00 031676 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2860									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2861									;IN THE SUBTEST) TO LOOP ON ERROR^
  2862
  2863					;**********
  2864
  2865					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2866					;TO AN AC  OF ALL ZEROS IS ADDED A
  2867					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2868					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2869					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2870					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2871					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2872					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2873					;EVERY BIT OF THE AC.
  2874					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2875			013234		SN=SN+1
  2876		001000	000000			ZZ=ZZ+ZZ
  2877						IFE	ZZ,<ZZ=1>
  2878	031676	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2879	031677	270 00 0 00 035451 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2880	031700	444 00 0 00 035451 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2881	031701	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2882	031702	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2883						STOP^
  2884	031703	254 04 0 00 031704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2885	031704	324 00 0 00 031705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2886									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2887									;IN THE SUBTEST) TO LOOP ON ERROR^
  2888
  2889					;**********
  2890
  2891					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2892					;TO AN AC  OF ALL ZEROS IS ADDED A
  2893					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2894					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2895					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2896					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2897					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2898					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2899					;EVERY BIT OF THE AC.
  2900					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2901			013235		SN=SN+1
  2902		002000	000000			ZZ=ZZ+ZZ
  2903						IFE	ZZ,<ZZ=1>
  2904	031705	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-14
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0084

  2905	031706	270 00 0 00 035452 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2906	031707	444 00 0 00 035452 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2907	031710	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2908	031711	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2909						STOP^
  2910	031712	254 04 0 00 031713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2911	031713	324 00 0 00 031714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2912									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2913									;IN THE SUBTEST) TO LOOP ON ERROR^
  2914
  2915					;**********
  2916
  2917					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2918					;TO AN AC  OF ALL ZEROS IS ADDED A
  2919					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2920					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2921					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2922					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2923					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2924					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2925					;EVERY BIT OF THE AC.
  2926					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2927			013236		SN=SN+1
  2928		004000	000000			ZZ=ZZ+ZZ
  2929						IFE	ZZ,<ZZ=1>
  2930	031714	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2931	031715	270 00 0 00 035453 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2932	031716	444 00 0 00 035453 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2933	031717	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2934	031720	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2935						STOP^
  2936	031721	254 04 0 00 031722 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2937	031722	324 00 0 00 031723 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2938									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2939									;IN THE SUBTEST) TO LOOP ON ERROR^
  2940
  2941					;**********
  2942
  2943					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2944					;TO AN AC  OF ALL ZEROS IS ADDED A
  2945					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2946					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2947					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2948					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2949					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2950					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2951					;EVERY BIT OF THE AC.
  2952					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2953			013237		SN=SN+1
  2954		010000	000000			ZZ=ZZ+ZZ
  2955						IFE	ZZ,<ZZ=1>
  2956	031723	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2957	031724	270 00 0 00 035454 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2958	031725	444 00 0 00 035454 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2959	031726	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-15
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0085

  2960	031727	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2961						STOP^
  2962	031730	254 04 0 00 031731 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2963	031731	324 00 0 00 031732 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2964									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2965									;IN THE SUBTEST) TO LOOP ON ERROR^
  2966
  2967					;**********
  2968
  2969					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2970					;TO AN AC  OF ALL ZEROS IS ADDED A
  2971					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2972					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2973					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  2974					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  2975					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  2976					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  2977					;EVERY BIT OF THE AC.
  2978					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  2979			013240		SN=SN+1
  2980		020000	000000			ZZ=ZZ+ZZ
  2981						IFE	ZZ,<ZZ=1>
  2982	031732	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  2983	031733	270 00 0 00 035455 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  2984	031734	444 00 0 00 035455 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  2985	031735	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  2986	031736	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  2987						STOP^
  2988	031737	254 04 0 00 031740 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2989	031740	324 00 0 00 031741 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2990									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2991									;IN THE SUBTEST) TO LOOP ON ERROR^
  2992
  2993					;**********
  2994
  2995					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  2996					;TO AN AC  OF ALL ZEROS IS ADDED A
  2997					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  2998					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  2999					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  3000					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  3001					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  3002					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  3003					;EVERY BIT OF THE AC.
  3004					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  3005			013241		SN=SN+1
  3006		040000	000000			ZZ=ZZ+ZZ
  3007						IFE	ZZ,<ZZ=1>
  3008	031741	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  3009	031742	270 00 0 00 035456 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  3010	031743	444 00 0 00 035456 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  3011	031744	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3012	031745	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3013						STOP^
  3014	031746	254 04 0 00 031747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-16
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0086

  3015	031747	324 00 0 00 031750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3016									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3017									;IN THE SUBTEST) TO LOOP ON ERROR^
  3018
  3019					;**********
  3020
  3021					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  3022					;TO AN AC  OF ALL ZEROS IS ADDED A
  3023					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  3024					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  3025					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  3026					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  3027					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  3028					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  3029					;EVERY BIT OF THE AC.
  3030					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  3031			013242		SN=SN+1
  3032		100000	000000			ZZ=ZZ+ZZ
  3033						IFE	ZZ,<ZZ=1>
  3034	031750	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  3035	031751	270 00 0 00 035457 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  3036	031752	444 00 0 00 035457 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  3037	031753	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3038	031754	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3039						STOP^
  3040	031755	254 04 0 00 031756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3041	031756	324 00 0 00 031757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3042									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3043									;IN THE SUBTEST) TO LOOP ON ERROR^
  3044
  3045					;**********
  3046
  3047					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  3048					;TO AN AC  OF ALL ZEROS IS ADDED A
  3049					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  3050					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  3051					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  3052					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  3053					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  3054					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  3055					;EVERY BIT OF THE AC.
  3056					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  3057			013243		SN=SN+1
  3058		200000	000000			ZZ=ZZ+ZZ
  3059						IFE	ZZ,<ZZ=1>
  3060	031757	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  3061	031760	270 00 0 00 035460 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  3062	031761	444 00 0 00 035460 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  3063	031762	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3064	031763	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3065						STOP^
  3066	031764	254 04 0 00 031765 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3067	031765	324 00 0 00 031766 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3068									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3069									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-17
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0087

  3070
  3071					;**********
  3072
  3073					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  3074					;TO AN AC  OF ALL ZEROS IS ADDED A
  3075					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  3076					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
  3077					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  3078					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  3079					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  3080					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  3081					;EVERY BIT OF THE AC.
  3082					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  3083			013244		SN=SN+1
  3084		400000	000000			ZZ=ZZ+ZZ
  3085						IFE	ZZ,<ZZ=1>
  3086	031766	200 00 0 00 035412 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
  3087	031767	270 00 0 00 035461 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
  3088	031770	444 00 0 00 035461 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  3089	031771	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3090	031772	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3091						STOP^
  3092	031773	254 04 0 00 031774 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3093	031774	324 00 0 00 031775 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3094									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3095									;IN THE SUBTEST) TO LOOP ON ERROR^
  3096
  3097					;**********
  3098
  3099					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-18
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0088

  3100					;ADD A RIPPLED ONE TO A RIPPLED ONE
  3101
  3102			011200		SN=11200
  3103			000000			ZZ=0
  3104
  3105					A11200:	REPEAT	^D35,
  3106					<;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3107					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3108					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3109					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3110					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3111					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3112					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3113					;SO THAT A ONE WILL BE FLOATED THROUGH
  3114					;BITS 1 THRU 35 OF BOTH AC AND E
  3115					SN=SN+1
  3116						ZZ=ZZ+ZZ
  3117						IFE	ZZ,<ZZ=1>
  3118						MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3119						ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3120						EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3121						EQV	[0]		;RESULTS IN C(AC)=0
  3122						SKIPE			;PASS TEST IF C(AC)=0
  3123						STOP
  3124
  3125					;**********
  3126					>
  3127					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3128					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3129					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3130					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3131					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3132					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3133					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3134					;SO THAT A ONE WILL BE FLOATED THROUGH
  3135					;BITS 1 THRU 35 OF BOTH AC AND E
  3136			011201		SN=SN+1
  3137			000000			ZZ=ZZ+ZZ
  3138			000001			IFE	ZZ,<ZZ=1>
  3139	031775	200 00 0 00 035416 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3140	031776	270 00 0 00 035416 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3141	031777	444 00 0 00 035417 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3142	032000	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3143	032001	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3144						STOP^
  3145	032002	254 04 0 00 032003 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3146	032003	324 00 0 00 032004 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3147									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3148									;IN THE SUBTEST) TO LOOP ON ERROR^
  3149
  3150					;**********
  3151
  3152					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3153					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3154					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-19
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0089

  3155					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3156					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3157					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3158					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3159					;SO THAT A ONE WILL BE FLOATED THROUGH
  3160					;BITS 1 THRU 35 OF BOTH AC AND E
  3161			011202		SN=SN+1
  3162			000002			ZZ=ZZ+ZZ
  3163						IFE	ZZ,<ZZ=1>
  3164	032004	200 00 0 00 035417 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3165	032005	270 00 0 00 035417 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3166	032006	444 00 0 00 035420 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3167	032007	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3168	032010	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3169						STOP^
  3170	032011	254 04 0 00 032012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3171	032012	324 00 0 00 032013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3172									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3173									;IN THE SUBTEST) TO LOOP ON ERROR^
  3174
  3175					;**********
  3176
  3177					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3178					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3179					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3180					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3181					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3182					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3183					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3184					;SO THAT A ONE WILL BE FLOATED THROUGH
  3185					;BITS 1 THRU 35 OF BOTH AC AND E
  3186			011203		SN=SN+1
  3187			000004			ZZ=ZZ+ZZ
  3188						IFE	ZZ,<ZZ=1>
  3189	032013	200 00 0 00 035420 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3190	032014	270 00 0 00 035420 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3191	032015	444 00 0 00 035421 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3192	032016	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3193	032017	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3194						STOP^
  3195	032020	254 04 0 00 032021 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3196	032021	324 00 0 00 032022 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3197									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3198									;IN THE SUBTEST) TO LOOP ON ERROR^
  3199
  3200					;**********
  3201
  3202					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3203					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3204					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3205					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3206					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3207					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3208					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3209					;SO THAT A ONE WILL BE FLOATED THROUGH
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-20
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0090

  3210					;BITS 1 THRU 35 OF BOTH AC AND E
  3211			011204		SN=SN+1
  3212			000010			ZZ=ZZ+ZZ
  3213						IFE	ZZ,<ZZ=1>
  3214	032022	200 00 0 00 035421 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3215	032023	270 00 0 00 035421 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3216	032024	444 00 0 00 035422 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3217	032025	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3218	032026	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3219						STOP^
  3220	032027	254 04 0 00 032030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3221	032030	324 00 0 00 032031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3223									;IN THE SUBTEST) TO LOOP ON ERROR^
  3224
  3225					;**********
  3226
  3227					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3228					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3229					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3230					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3231					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3232					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3233					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3234					;SO THAT A ONE WILL BE FLOATED THROUGH
  3235					;BITS 1 THRU 35 OF BOTH AC AND E
  3236			011205		SN=SN+1
  3237			000020			ZZ=ZZ+ZZ
  3238						IFE	ZZ,<ZZ=1>
  3239	032031	200 00 0 00 035422 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3240	032032	270 00 0 00 035422 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3241	032033	444 00 0 00 035423 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3242	032034	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3243	032035	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3244						STOP^
  3245	032036	254 04 0 00 032037 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3246	032037	324 00 0 00 032040 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3247									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3248									;IN THE SUBTEST) TO LOOP ON ERROR^
  3249
  3250					;**********
  3251
  3252					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3253					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3254					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3255					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3256					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3257					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3258					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3259					;SO THAT A ONE WILL BE FLOATED THROUGH
  3260					;BITS 1 THRU 35 OF BOTH AC AND E
  3261			011206		SN=SN+1
  3262			000040			ZZ=ZZ+ZZ
  3263						IFE	ZZ,<ZZ=1>
  3264	032040	200 00 0 00 035423 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-21
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0091

  3265	032041	270 00 0 00 035423 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3266	032042	444 00 0 00 035424 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3267	032043	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3268	032044	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3269						STOP^
  3270	032045	254 04 0 00 032046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3271	032046	324 00 0 00 032047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3272									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3273									;IN THE SUBTEST) TO LOOP ON ERROR^
  3274
  3275					;**********
  3276
  3277					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3278					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3279					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3280					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3281					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3282					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3283					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3284					;SO THAT A ONE WILL BE FLOATED THROUGH
  3285					;BITS 1 THRU 35 OF BOTH AC AND E
  3286			011207		SN=SN+1
  3287			000100			ZZ=ZZ+ZZ
  3288						IFE	ZZ,<ZZ=1>
  3289	032047	200 00 0 00 035424 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3290	032050	270 00 0 00 035424 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3291	032051	444 00 0 00 035425 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3292	032052	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3293	032053	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3294						STOP^
  3295	032054	254 04 0 00 032055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3296	032055	324 00 0 00 032056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3297									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3298									;IN THE SUBTEST) TO LOOP ON ERROR^
  3299
  3300					;**********
  3301
  3302					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3303					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3304					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3305					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3306					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3307					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3308					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3309					;SO THAT A ONE WILL BE FLOATED THROUGH
  3310					;BITS 1 THRU 35 OF BOTH AC AND E
  3311			011210		SN=SN+1
  3312			000200			ZZ=ZZ+ZZ
  3313						IFE	ZZ,<ZZ=1>
  3314	032056	200 00 0 00 035425 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3315	032057	270 00 0 00 035425 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3316	032060	444 00 0 00 035426 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3317	032061	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3318	032062	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3319						STOP^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-22
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0092

  3320	032063	254 04 0 00 032064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3321	032064	324 00 0 00 032065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3322									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3323									;IN THE SUBTEST) TO LOOP ON ERROR^
  3324
  3325					;**********
  3326
  3327					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3328					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3329					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3330					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3331					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3332					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3333					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3334					;SO THAT A ONE WILL BE FLOATED THROUGH
  3335					;BITS 1 THRU 35 OF BOTH AC AND E
  3336			011211		SN=SN+1
  3337			000400			ZZ=ZZ+ZZ
  3338						IFE	ZZ,<ZZ=1>
  3339	032065	200 00 0 00 035426 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3340	032066	270 00 0 00 035426 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3341	032067	444 00 0 00 035427 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3342	032070	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3343	032071	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3344						STOP^
  3345	032072	254 04 0 00 032073 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3346	032073	324 00 0 00 032074 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3347									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3348									;IN THE SUBTEST) TO LOOP ON ERROR^
  3349
  3350					;**********
  3351
  3352					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3353					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3354					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3355					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3356					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3357					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3358					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3359					;SO THAT A ONE WILL BE FLOATED THROUGH
  3360					;BITS 1 THRU 35 OF BOTH AC AND E
  3361			011212		SN=SN+1
  3362			001000			ZZ=ZZ+ZZ
  3363						IFE	ZZ,<ZZ=1>
  3364	032074	200 00 0 00 035427 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3365	032075	270 00 0 00 035427 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3366	032076	444 00 0 00 035430 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3367	032077	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3368	032100	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3369						STOP^
  3370	032101	254 04 0 00 032102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3371	032102	324 00 0 00 032103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3372									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3373									;IN THE SUBTEST) TO LOOP ON ERROR^
  3374
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-23
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0093

  3375					;**********
  3376
  3377					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3378					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3379					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3380					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3381					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3382					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3383					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3384					;SO THAT A ONE WILL BE FLOATED THROUGH
  3385					;BITS 1 THRU 35 OF BOTH AC AND E
  3386			011213		SN=SN+1
  3387			002000			ZZ=ZZ+ZZ
  3388						IFE	ZZ,<ZZ=1>
  3389	032103	200 00 0 00 035430 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3390	032104	270 00 0 00 035430 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3391	032105	444 00 0 00 035431 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3392	032106	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3393	032107	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3394						STOP^
  3395	032110	254 04 0 00 032111 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3396	032111	324 00 0 00 032112 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3397									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3398									;IN THE SUBTEST) TO LOOP ON ERROR^
  3399
  3400					;**********
  3401
  3402					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3403					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3404					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3405					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3406					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3407					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3408					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3409					;SO THAT A ONE WILL BE FLOATED THROUGH
  3410					;BITS 1 THRU 35 OF BOTH AC AND E
  3411			011214		SN=SN+1
  3412			004000			ZZ=ZZ+ZZ
  3413						IFE	ZZ,<ZZ=1>
  3414	032112	200 00 0 00 035431 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3415	032113	270 00 0 00 035431 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3416	032114	444 00 0 00 035432 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3417	032115	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3418	032116	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3419						STOP^
  3420	032117	254 04 0 00 032120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3421	032120	324 00 0 00 032121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3422									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3423									;IN THE SUBTEST) TO LOOP ON ERROR^
  3424
  3425					;**********
  3426
  3427					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3428					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3429					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-24
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0094

  3430					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3431					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3432					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3433					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3434					;SO THAT A ONE WILL BE FLOATED THROUGH
  3435					;BITS 1 THRU 35 OF BOTH AC AND E
  3436			011215		SN=SN+1
  3437			010000			ZZ=ZZ+ZZ
  3438						IFE	ZZ,<ZZ=1>
  3439	032121	200 00 0 00 035432 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3440	032122	270 00 0 00 035432 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3441	032123	444 00 0 00 035433 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3442	032124	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3443	032125	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3444						STOP^
  3445	032126	254 04 0 00 032127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3446	032127	324 00 0 00 032130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3447									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3448									;IN THE SUBTEST) TO LOOP ON ERROR^
  3449
  3450					;**********
  3451
  3452					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3453					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3454					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3455					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3456					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3457					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3458					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3459					;SO THAT A ONE WILL BE FLOATED THROUGH
  3460					;BITS 1 THRU 35 OF BOTH AC AND E
  3461			011216		SN=SN+1
  3462			020000			ZZ=ZZ+ZZ
  3463						IFE	ZZ,<ZZ=1>
  3464	032130	200 00 0 00 035433 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3465	032131	270 00 0 00 035433 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3466	032132	444 00 0 00 035434 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3467	032133	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3468	032134	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3469						STOP^
  3470	032135	254 04 0 00 032136 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3471	032136	324 00 0 00 032137 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3472									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3473									;IN THE SUBTEST) TO LOOP ON ERROR^
  3474
  3475					;**********
  3476
  3477					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3478					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3479					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3480					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3481					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3482					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3483					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3484					;SO THAT A ONE WILL BE FLOATED THROUGH
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-25
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0095

  3485					;BITS 1 THRU 35 OF BOTH AC AND E
  3486			011217		SN=SN+1
  3487			040000			ZZ=ZZ+ZZ
  3488						IFE	ZZ,<ZZ=1>
  3489	032137	200 00 0 00 035434 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3490	032140	270 00 0 00 035434 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3491	032141	444 00 0 00 035435 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3492	032142	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3493	032143	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3494						STOP^
  3495	032144	254 04 0 00 032145 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3496	032145	324 00 0 00 032146 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3497									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3498									;IN THE SUBTEST) TO LOOP ON ERROR^
  3499
  3500					;**********
  3501
  3502					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3503					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3504					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3505					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3506					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3507					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3508					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3509					;SO THAT A ONE WILL BE FLOATED THROUGH
  3510					;BITS 1 THRU 35 OF BOTH AC AND E
  3511			011220		SN=SN+1
  3512			100000			ZZ=ZZ+ZZ
  3513						IFE	ZZ,<ZZ=1>
  3514	032146	200 00 0 00 035435 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3515	032147	270 00 0 00 035435 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3516	032150	444 00 0 00 035436 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3517	032151	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3518	032152	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3519						STOP^
  3520	032153	254 04 0 00 032154 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3521	032154	324 00 0 00 032155 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3522									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3523									;IN THE SUBTEST) TO LOOP ON ERROR^
  3524
  3525					;**********
  3526
  3527					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3528					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3529					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3530					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3531					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3532					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3533					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3534					;SO THAT A ONE WILL BE FLOATED THROUGH
  3535					;BITS 1 THRU 35 OF BOTH AC AND E
  3536			011221		SN=SN+1
  3537			200000			ZZ=ZZ+ZZ
  3538						IFE	ZZ,<ZZ=1>
  3539	032155	200 00 0 00 035436 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-26
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0096

  3540	032156	270 00 0 00 035436 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3541	032157	444 00 0 00 035437 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3542	032160	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3543	032161	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3544						STOP^
  3545	032162	254 04 0 00 032163 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3546	032163	324 00 0 00 032164 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3547									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3548									;IN THE SUBTEST) TO LOOP ON ERROR^
  3549
  3550					;**********
  3551
  3552					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3553					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3554					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3555					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3556					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3557					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3558					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3559					;SO THAT A ONE WILL BE FLOATED THROUGH
  3560					;BITS 1 THRU 35 OF BOTH AC AND E
  3561			011222		SN=SN+1
  3562			400000			ZZ=ZZ+ZZ
  3563						IFE	ZZ,<ZZ=1>
  3564	032164	200 00 0 00 035437 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3565	032165	270 00 0 00 035437 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3566	032166	444 00 0 00 035440 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3567	032167	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3568	032170	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3569						STOP^
  3570	032171	254 04 0 00 032172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3571	032172	324 00 0 00 032173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3572									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3573									;IN THE SUBTEST) TO LOOP ON ERROR^
  3574
  3575					;**********
  3576
  3577					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3578					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3579					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3580					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3581					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3582					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3583					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3584					;SO THAT A ONE WILL BE FLOATED THROUGH
  3585					;BITS 1 THRU 35 OF BOTH AC AND E
  3586			011223		SN=SN+1
  3587		000001	000000			ZZ=ZZ+ZZ
  3588						IFE	ZZ,<ZZ=1>
  3589	032173	200 00 0 00 035440 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3590	032174	270 00 0 00 035440 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3591	032175	444 00 0 00 035441 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3592	032176	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3593	032177	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3594						STOP^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-27
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0097

  3595	032200	254 04 0 00 032201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3596	032201	324 00 0 00 032202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3598									;IN THE SUBTEST) TO LOOP ON ERROR^
  3599
  3600					;**********
  3601
  3602					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3603					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3604					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3605					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3606					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3607					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3608					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3609					;SO THAT A ONE WILL BE FLOATED THROUGH
  3610					;BITS 1 THRU 35 OF BOTH AC AND E
  3611			011224		SN=SN+1
  3612		000002	000000			ZZ=ZZ+ZZ
  3613						IFE	ZZ,<ZZ=1>
  3614	032202	200 00 0 00 035441 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3615	032203	270 00 0 00 035441 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3616	032204	444 00 0 00 035442 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3617	032205	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3618	032206	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3619						STOP^
  3620	032207	254 04 0 00 032210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3621	032210	324 00 0 00 032211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3622									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3623									;IN THE SUBTEST) TO LOOP ON ERROR^
  3624
  3625					;**********
  3626
  3627					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3628					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3629					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3630					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3631					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3632					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3633					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3634					;SO THAT A ONE WILL BE FLOATED THROUGH
  3635					;BITS 1 THRU 35 OF BOTH AC AND E
  3636			011225		SN=SN+1
  3637		000004	000000			ZZ=ZZ+ZZ
  3638						IFE	ZZ,<ZZ=1>
  3639	032211	200 00 0 00 035442 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3640	032212	270 00 0 00 035442 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3641	032213	444 00 0 00 035443 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3642	032214	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3643	032215	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3644						STOP^
  3645	032216	254 04 0 00 032217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3646	032217	324 00 0 00 032220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3647									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3648									;IN THE SUBTEST) TO LOOP ON ERROR^
  3649
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-28
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0098

  3650					;**********
  3651
  3652					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3653					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3654					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3655					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3656					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3657					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3658					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3659					;SO THAT A ONE WILL BE FLOATED THROUGH
  3660					;BITS 1 THRU 35 OF BOTH AC AND E
  3661			011226		SN=SN+1
  3662		000010	000000			ZZ=ZZ+ZZ
  3663						IFE	ZZ,<ZZ=1>
  3664	032220	200 00 0 00 035443 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3665	032221	270 00 0 00 035443 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3666	032222	444 00 0 00 035444 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3667	032223	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3668	032224	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3669						STOP^
  3670	032225	254 04 0 00 032226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3671	032226	324 00 0 00 032227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3672									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3673									;IN THE SUBTEST) TO LOOP ON ERROR^
  3674
  3675					;**********
  3676
  3677					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3678					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3679					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3680					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3681					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3682					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3683					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3684					;SO THAT A ONE WILL BE FLOATED THROUGH
  3685					;BITS 1 THRU 35 OF BOTH AC AND E
  3686			011227		SN=SN+1
  3687		000020	000000			ZZ=ZZ+ZZ
  3688						IFE	ZZ,<ZZ=1>
  3689	032227	200 00 0 00 035444 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3690	032230	270 00 0 00 035444 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3691	032231	444 00 0 00 035445 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3692	032232	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3693	032233	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3694						STOP^
  3695	032234	254 04 0 00 032235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3696	032235	324 00 0 00 032236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3697									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3698									;IN THE SUBTEST) TO LOOP ON ERROR^
  3699
  3700					;**********
  3701
  3702					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3703					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3704					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-29
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0099

  3705					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3706					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3707					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3708					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3709					;SO THAT A ONE WILL BE FLOATED THROUGH
  3710					;BITS 1 THRU 35 OF BOTH AC AND E
  3711			011230		SN=SN+1
  3712		000040	000000			ZZ=ZZ+ZZ
  3713						IFE	ZZ,<ZZ=1>
  3714	032236	200 00 0 00 035445 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3715	032237	270 00 0 00 035445 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3716	032240	444 00 0 00 035446 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3717	032241	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3718	032242	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3719						STOP^
  3720	032243	254 04 0 00 032244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3721	032244	324 00 0 00 032245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3722									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3723									;IN THE SUBTEST) TO LOOP ON ERROR^
  3724
  3725					;**********
  3726
  3727					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3728					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3729					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3730					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3731					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3732					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3733					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3734					;SO THAT A ONE WILL BE FLOATED THROUGH
  3735					;BITS 1 THRU 35 OF BOTH AC AND E
  3736			011231		SN=SN+1
  3737		000100	000000			ZZ=ZZ+ZZ
  3738						IFE	ZZ,<ZZ=1>
  3739	032245	200 00 0 00 035446 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3740	032246	270 00 0 00 035446 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3741	032247	444 00 0 00 035447 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3742	032250	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3743	032251	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3744						STOP^
  3745	032252	254 04 0 00 032253 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3746	032253	324 00 0 00 032254 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3748									;IN THE SUBTEST) TO LOOP ON ERROR^
  3749
  3750					;**********
  3751
  3752					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3753					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3754					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3755					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3756					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3757					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3758					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3759					;SO THAT A ONE WILL BE FLOATED THROUGH
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-30
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0100

  3760					;BITS 1 THRU 35 OF BOTH AC AND E
  3761			011232		SN=SN+1
  3762		000200	000000			ZZ=ZZ+ZZ
  3763						IFE	ZZ,<ZZ=1>
  3764	032254	200 00 0 00 035447 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3765	032255	270 00 0 00 035447 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3766	032256	444 00 0 00 035450 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3767	032257	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3768	032260	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3769						STOP^
  3770	032261	254 04 0 00 032262 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3771	032262	324 00 0 00 032263 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3773									;IN THE SUBTEST) TO LOOP ON ERROR^
  3774
  3775					;**********
  3776
  3777					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3778					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3779					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3780					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3781					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3782					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3783					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3784					;SO THAT A ONE WILL BE FLOATED THROUGH
  3785					;BITS 1 THRU 35 OF BOTH AC AND E
  3786			011233		SN=SN+1
  3787		000400	000000			ZZ=ZZ+ZZ
  3788						IFE	ZZ,<ZZ=1>
  3789	032263	200 00 0 00 035450 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3790	032264	270 00 0 00 035450 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3791	032265	444 00 0 00 035451 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3792	032266	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3793	032267	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3794						STOP^
  3795	032270	254 04 0 00 032271 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3796	032271	324 00 0 00 032272 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3797									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3798									;IN THE SUBTEST) TO LOOP ON ERROR^
  3799
  3800					;**********
  3801
  3802					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3803					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3804					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3805					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3806					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3807					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3808					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3809					;SO THAT A ONE WILL BE FLOATED THROUGH
  3810					;BITS 1 THRU 35 OF BOTH AC AND E
  3811			011234		SN=SN+1
  3812		001000	000000			ZZ=ZZ+ZZ
  3813						IFE	ZZ,<ZZ=1>
  3814	032272	200 00 0 00 035451 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-31
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0101

  3815	032273	270 00 0 00 035451 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3816	032274	444 00 0 00 035452 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3817	032275	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3818	032276	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3819						STOP^
  3820	032277	254 04 0 00 032300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3821	032300	324 00 0 00 032301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3822									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3823									;IN THE SUBTEST) TO LOOP ON ERROR^
  3824
  3825					;**********
  3826
  3827					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3828					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3829					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3830					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3831					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3832					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3833					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3834					;SO THAT A ONE WILL BE FLOATED THROUGH
  3835					;BITS 1 THRU 35 OF BOTH AC AND E
  3836			011235		SN=SN+1
  3837		002000	000000			ZZ=ZZ+ZZ
  3838						IFE	ZZ,<ZZ=1>
  3839	032301	200 00 0 00 035452 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3840	032302	270 00 0 00 035452 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3841	032303	444 00 0 00 035453 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3842	032304	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3843	032305	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3844						STOP^
  3845	032306	254 04 0 00 032307 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3846	032307	324 00 0 00 032310 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3847									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3848									;IN THE SUBTEST) TO LOOP ON ERROR^
  3849
  3850					;**********
  3851
  3852					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3853					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3854					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3855					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3856					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3857					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3858					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3859					;SO THAT A ONE WILL BE FLOATED THROUGH
  3860					;BITS 1 THRU 35 OF BOTH AC AND E
  3861			011236		SN=SN+1
  3862		004000	000000			ZZ=ZZ+ZZ
  3863						IFE	ZZ,<ZZ=1>
  3864	032310	200 00 0 00 035453 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3865	032311	270 00 0 00 035453 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3866	032312	444 00 0 00 035454 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3867	032313	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3868	032314	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3869						STOP^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-32
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0102

  3870	032315	254 04 0 00 032316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3871	032316	324 00 0 00 032317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3872									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3873									;IN THE SUBTEST) TO LOOP ON ERROR^
  3874
  3875					;**********
  3876
  3877					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3878					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3879					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3880					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3881					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3882					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3883					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3884					;SO THAT A ONE WILL BE FLOATED THROUGH
  3885					;BITS 1 THRU 35 OF BOTH AC AND E
  3886			011237		SN=SN+1
  3887		010000	000000			ZZ=ZZ+ZZ
  3888						IFE	ZZ,<ZZ=1>
  3889	032317	200 00 0 00 035454 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3890	032320	270 00 0 00 035454 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3891	032321	444 00 0 00 035455 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3892	032322	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3893	032323	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3894						STOP^
  3895	032324	254 04 0 00 032325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3896	032325	324 00 0 00 032326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3897									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3898									;IN THE SUBTEST) TO LOOP ON ERROR^
  3899
  3900					;**********
  3901
  3902					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3903					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3904					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3905					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3906					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3907					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3908					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3909					;SO THAT A ONE WILL BE FLOATED THROUGH
  3910					;BITS 1 THRU 35 OF BOTH AC AND E
  3911			011240		SN=SN+1
  3912		020000	000000			ZZ=ZZ+ZZ
  3913						IFE	ZZ,<ZZ=1>
  3914	032326	200 00 0 00 035455 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3915	032327	270 00 0 00 035455 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3916	032330	444 00 0 00 035456 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3917	032331	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3918	032332	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3919						STOP^
  3920	032333	254 04 0 00 032334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3921	032334	324 00 0 00 032335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3922									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3923									;IN THE SUBTEST) TO LOOP ON ERROR^
  3924
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-33
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0103

  3925					;**********
  3926
  3927					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3928					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3929					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3930					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3931					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3932					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3933					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3934					;SO THAT A ONE WILL BE FLOATED THROUGH
  3935					;BITS 1 THRU 35 OF BOTH AC AND E
  3936			011241		SN=SN+1
  3937		040000	000000			ZZ=ZZ+ZZ
  3938						IFE	ZZ,<ZZ=1>
  3939	032335	200 00 0 00 035456 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3940	032336	270 00 0 00 035456 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3941	032337	444 00 0 00 035457 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3942	032340	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3943	032341	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3944						STOP^
  3945	032342	254 04 0 00 032343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3946	032343	324 00 0 00 032344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3947									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3948									;IN THE SUBTEST) TO LOOP ON ERROR^
  3949
  3950					;**********
  3951
  3952					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3953					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3954					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
  3955					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3956					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3957					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3958					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3959					;SO THAT A ONE WILL BE FLOATED THROUGH
  3960					;BITS 1 THRU 35 OF BOTH AC AND E
  3961			011242		SN=SN+1
  3962		100000	000000			ZZ=ZZ+ZZ
  3963						IFE	ZZ,<ZZ=1>
  3964	032344	200 00 0 00 035457 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3965	032345	270 00 0 00 035457 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3966	032346	444 00 0 00 035460 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3967	032347	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3968	032350	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3969						STOP^
  3970	032351	254 04 0 00 032352 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3971	032352	324 00 0 00 032353 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3972									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3973									;IN THE SUBTEST) TO LOOP ON ERROR^
  3974
  3975					;**********
  3976
  3977					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
  3978					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
  3979					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 7-34
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0104

  3980					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
  3981					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
  3982					;RESULT IN THE AC WILL BE ZERO AND THE TEST
  3983					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
  3984					;SO THAT A ONE WILL BE FLOATED THROUGH
  3985					;BITS 1 THRU 35 OF BOTH AC AND E
  3986			011243		SN=SN+1
  3987		200000	000000			ZZ=ZZ+ZZ
  3988						IFE	ZZ,<ZZ=1>
  3989	032353	200 00 0 00 035460 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
  3990	032354	270 00 0 00 035460 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
  3991	032355	444 00 0 00 035461 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
  3992	032356	444 00 0 00 035412 		EQV	[0]		;RESULTS IN C(AC)=0
  3993	032357	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  3994						STOP^
  3995	032360	254 04 0 00 032361 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3996	032361	324 00 0 00 032362 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3997									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3998									;IN THE SUBTEST) TO LOOP ON ERROR^
  3999
  4000					;**********
  4001
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0105

  4002			011300		SN=11300
  4003			000000			ZZ=0
  4004			000000			YY=0
  4005
  4006					A11300:	REPEAT	^D18,
  4007					<;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4008					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4009					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4010					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4011					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4012					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4013					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4014					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4015					;FORMER VALUE PLUS THE CURRENT C(AC)
  4016					SN=SN+1
  4017						YY=YY/2
  4018						ZZ=ZZ+YY
  4019						IFE	YY,<YY=400000>
  4020						IFE	ZZ,<ZZ=400000>
  4021						MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4022						ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4023									;POWER SHOULD RESULT IN C(AC)=0.
  4024						SKIPE			;PASS TEST IF C(AC)=0
  4025						STOP
  4026
  4027					;**********
  4028					>
  4029					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4030					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4031					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4032					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4033					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4034					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4035					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4036					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4037					;FORMER VALUE PLUS THE CURRENT C(AC)
  4038			011301		SN=SN+1
  4039			000000			YY=YY/2
  4040			000000			ZZ=ZZ+YY
  4041			400000			IFE	YY,<YY=400000>
  4042			400000			IFE	ZZ,<ZZ=400000>
  4043	032362	200 00 0 00 035461 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4044	032363	270 00 0 00 035461 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4045									;POWER SHOULD RESULT IN C(AC)=0.
  4046	032364	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4047						STOP^
  4048	032365	254 04 0 00 032366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4049	032366	324 00 0 00 032367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4050									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4051									;IN THE SUBTEST) TO LOOP ON ERROR^
  4052
  4053					;**********
  4054
  4055					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4056					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0106

  4057					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4058					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4059					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4060					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4061					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4062					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4063					;FORMER VALUE PLUS THE CURRENT C(AC)
  4064			011302		SN=SN+1
  4065			200000			YY=YY/2
  4066			600000			ZZ=ZZ+YY
  4067						IFE	YY,<YY=400000>
  4068						IFE	ZZ,<ZZ=400000>
  4069	032367	200 00 0 00 035462 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4070	032370	270 00 0 00 035460 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4071									;POWER SHOULD RESULT IN C(AC)=0.
  4072	032371	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4073						STOP^
  4074	032372	254 04 0 00 032373 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4075	032373	324 00 0 00 032374 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4076									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4077									;IN THE SUBTEST) TO LOOP ON ERROR^
  4078
  4079					;**********
  4080
  4081					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4082					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4083					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4084					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4085					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4086					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4087					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4088					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4089					;FORMER VALUE PLUS THE CURRENT C(AC)
  4090			011303		SN=SN+1
  4091			100000			YY=YY/2
  4092			700000			ZZ=ZZ+YY
  4093						IFE	YY,<YY=400000>
  4094						IFE	ZZ,<ZZ=400000>
  4095	032374	200 00 0 00 035463 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4096	032375	270 00 0 00 035457 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4097									;POWER SHOULD RESULT IN C(AC)=0.
  4098	032376	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4099						STOP^
  4100	032377	254 04 0 00 032400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4101	032400	324 00 0 00 032401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4102									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4103									;IN THE SUBTEST) TO LOOP ON ERROR^
  4104
  4105					;**********
  4106
  4107					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4108					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4109					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4110					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4111					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0107

  4112					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4113					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4114					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4115					;FORMER VALUE PLUS THE CURRENT C(AC)
  4116			011304		SN=SN+1
  4117			040000			YY=YY/2
  4118			740000			ZZ=ZZ+YY
  4119						IFE	YY,<YY=400000>
  4120						IFE	ZZ,<ZZ=400000>
  4121	032401	200 00 0 00 035464 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4122	032402	270 00 0 00 035456 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4123									;POWER SHOULD RESULT IN C(AC)=0.
  4124	032403	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4125						STOP^
  4126	032404	254 04 0 00 032405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4127	032405	324 00 0 00 032406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4128									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4129									;IN THE SUBTEST) TO LOOP ON ERROR^
  4130
  4131					;**********
  4132
  4133					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4134					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4135					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4136					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4137					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4138					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4139					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4140					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4141					;FORMER VALUE PLUS THE CURRENT C(AC)
  4142			011305		SN=SN+1
  4143			020000			YY=YY/2
  4144			760000			ZZ=ZZ+YY
  4145						IFE	YY,<YY=400000>
  4146						IFE	ZZ,<ZZ=400000>
  4147	032406	200 00 0 00 035465 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4148	032407	270 00 0 00 035455 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4149									;POWER SHOULD RESULT IN C(AC)=0.
  4150	032410	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4151						STOP^
  4152	032411	254 04 0 00 032412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4153	032412	324 00 0 00 032413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4154									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4155									;IN THE SUBTEST) TO LOOP ON ERROR^
  4156
  4157					;**********
  4158
  4159					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4160					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4161					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4162					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4163					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4164					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4165					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4166					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0108

  4167					;FORMER VALUE PLUS THE CURRENT C(AC)
  4168			011306		SN=SN+1
  4169			010000			YY=YY/2
  4170			770000			ZZ=ZZ+YY
  4171						IFE	YY,<YY=400000>
  4172						IFE	ZZ,<ZZ=400000>
  4173	032413	200 00 0 00 035466 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4174	032414	270 00 0 00 035454 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4175									;POWER SHOULD RESULT IN C(AC)=0.
  4176	032415	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4177						STOP^
  4178	032416	254 04 0 00 032417 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4179	032417	324 00 0 00 032420 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4180									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4181									;IN THE SUBTEST) TO LOOP ON ERROR^
  4182
  4183					;**********
  4184
  4185					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4186					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4187					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4188					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4189					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4190					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4191					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4192					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4193					;FORMER VALUE PLUS THE CURRENT C(AC)
  4194			011307		SN=SN+1
  4195			004000			YY=YY/2
  4196			774000			ZZ=ZZ+YY
  4197						IFE	YY,<YY=400000>
  4198						IFE	ZZ,<ZZ=400000>
  4199	032420	200 00 0 00 035467 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4200	032421	270 00 0 00 035453 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4201									;POWER SHOULD RESULT IN C(AC)=0.
  4202	032422	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4203						STOP^
  4204	032423	254 04 0 00 032424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4205	032424	324 00 0 00 032425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4206									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4207									;IN THE SUBTEST) TO LOOP ON ERROR^
  4208
  4209					;**********
  4210
  4211					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4212					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4213					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4214					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4215					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4216					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4217					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4218					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4219					;FORMER VALUE PLUS THE CURRENT C(AC)
  4220			011310		SN=SN+1
  4221			002000			YY=YY/2
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0109

  4222			776000			ZZ=ZZ+YY
  4223						IFE	YY,<YY=400000>
  4224						IFE	ZZ,<ZZ=400000>
  4225	032425	200 00 0 00 035470 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4226	032426	270 00 0 00 035452 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4227									;POWER SHOULD RESULT IN C(AC)=0.
  4228	032427	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4229						STOP^
  4230	032430	254 04 0 00 032431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4231	032431	324 00 0 00 032432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4232									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4233									;IN THE SUBTEST) TO LOOP ON ERROR^
  4234
  4235					;**********
  4236
  4237					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4238					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4239					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4240					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4241					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4242					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4243					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4244					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4245					;FORMER VALUE PLUS THE CURRENT C(AC)
  4246			011311		SN=SN+1
  4247			001000			YY=YY/2
  4248			777000			ZZ=ZZ+YY
  4249						IFE	YY,<YY=400000>
  4250						IFE	ZZ,<ZZ=400000>
  4251	032432	200 00 0 00 035471 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4252	032433	270 00 0 00 035451 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4253									;POWER SHOULD RESULT IN C(AC)=0.
  4254	032434	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4255						STOP^
  4256	032435	254 04 0 00 032436 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4257	032436	324 00 0 00 032437 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4258									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4259									;IN THE SUBTEST) TO LOOP ON ERROR^
  4260
  4261					;**********
  4262
  4263					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4264					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4265					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4266					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4267					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4268					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4269					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4270					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4271					;FORMER VALUE PLUS THE CURRENT C(AC)
  4272			011312		SN=SN+1
  4273			000400			YY=YY/2
  4274			777400			ZZ=ZZ+YY
  4275						IFE	YY,<YY=400000>
  4276						IFE	ZZ,<ZZ=400000>
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0110

  4277	032437	200 00 0 00 035472 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4278	032440	270 00 0 00 035450 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4279									;POWER SHOULD RESULT IN C(AC)=0.
  4280	032441	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4281						STOP^
  4282	032442	254 04 0 00 032443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4283	032443	324 00 0 00 032444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4284									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4285									;IN THE SUBTEST) TO LOOP ON ERROR^
  4286
  4287					;**********
  4288
  4289					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4290					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4291					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4292					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4293					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4294					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4295					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4296					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4297					;FORMER VALUE PLUS THE CURRENT C(AC)
  4298			011313		SN=SN+1
  4299			000200			YY=YY/2
  4300			777600			ZZ=ZZ+YY
  4301						IFE	YY,<YY=400000>
  4302						IFE	ZZ,<ZZ=400000>
  4303	032444	200 00 0 00 035473 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4304	032445	270 00 0 00 035447 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4305									;POWER SHOULD RESULT IN C(AC)=0.
  4306	032446	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4307						STOP^
  4308	032447	254 04 0 00 032450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4309	032450	324 00 0 00 032451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4310									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4311									;IN THE SUBTEST) TO LOOP ON ERROR^
  4312
  4313					;**********
  4314
  4315					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4316					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4317					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4318					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4319					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4320					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4321					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4322					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4323					;FORMER VALUE PLUS THE CURRENT C(AC)
  4324			011314		SN=SN+1
  4325			000100			YY=YY/2
  4326			777700			ZZ=ZZ+YY
  4327						IFE	YY,<YY=400000>
  4328						IFE	ZZ,<ZZ=400000>
  4329	032451	200 00 0 00 035474 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4330	032452	270 00 0 00 035446 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4331									;POWER SHOULD RESULT IN C(AC)=0.
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0111

  4332	032453	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4333						STOP^
  4334	032454	254 04 0 00 032455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4335	032455	324 00 0 00 032456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4336									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4337									;IN THE SUBTEST) TO LOOP ON ERROR^
  4338
  4339					;**********
  4340
  4341					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4342					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4343					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4344					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4345					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4346					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4347					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4348					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4349					;FORMER VALUE PLUS THE CURRENT C(AC)
  4350			011315		SN=SN+1
  4351			000040			YY=YY/2
  4352			777740			ZZ=ZZ+YY
  4353						IFE	YY,<YY=400000>
  4354						IFE	ZZ,<ZZ=400000>
  4355	032456	200 00 0 00 035475 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4356	032457	270 00 0 00 035445 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4357									;POWER SHOULD RESULT IN C(AC)=0.
  4358	032460	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4359						STOP^
  4360	032461	254 04 0 00 032462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4361	032462	324 00 0 00 032463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4362									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4363									;IN THE SUBTEST) TO LOOP ON ERROR^
  4364
  4365					;**********
  4366
  4367					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4368					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4369					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4370					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4371					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4372					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4373					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4374					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4375					;FORMER VALUE PLUS THE CURRENT C(AC)
  4376			011316		SN=SN+1
  4377			000020			YY=YY/2
  4378			777760			ZZ=ZZ+YY
  4379						IFE	YY,<YY=400000>
  4380						IFE	ZZ,<ZZ=400000>
  4381	032463	200 00 0 00 035476 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4382	032464	270 00 0 00 035444 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4383									;POWER SHOULD RESULT IN C(AC)=0.
  4384	032465	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4385						STOP^
  4386	032466	254 04 0 00 032467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-7
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0112

  4387	032467	324 00 0 00 032470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4388									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4389									;IN THE SUBTEST) TO LOOP ON ERROR^
  4390
  4391					;**********
  4392
  4393					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4394					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4395					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4396					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4397					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4398					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4399					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4400					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4401					;FORMER VALUE PLUS THE CURRENT C(AC)
  4402			011317		SN=SN+1
  4403			000010			YY=YY/2
  4404			777770			ZZ=ZZ+YY
  4405						IFE	YY,<YY=400000>
  4406						IFE	ZZ,<ZZ=400000>
  4407	032470	200 00 0 00 035477 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4408	032471	270 00 0 00 035443 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4409									;POWER SHOULD RESULT IN C(AC)=0.
  4410	032472	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4411						STOP^
  4412	032473	254 04 0 00 032474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4413	032474	324 00 0 00 032475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4414									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4415									;IN THE SUBTEST) TO LOOP ON ERROR^
  4416
  4417					;**********
  4418
  4419					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4420					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4421					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4422					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4423					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4424					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4425					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4426					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4427					;FORMER VALUE PLUS THE CURRENT C(AC)
  4428			011320		SN=SN+1
  4429			000004			YY=YY/2
  4430			777774			ZZ=ZZ+YY
  4431						IFE	YY,<YY=400000>
  4432						IFE	ZZ,<ZZ=400000>
  4433	032475	200 00 0 00 035500 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4434	032476	270 00 0 00 035442 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4435									;POWER SHOULD RESULT IN C(AC)=0.
  4436	032477	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4437						STOP^
  4438	032500	254 04 0 00 032501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4439	032501	324 00 0 00 032502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4441									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-8
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0113

  4442
  4443					;**********
  4444
  4445					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4446					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4447					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4448					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4449					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4450					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4451					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4452					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4453					;FORMER VALUE PLUS THE CURRENT C(AC)
  4454			011321		SN=SN+1
  4455			000002			YY=YY/2
  4456			777776			ZZ=ZZ+YY
  4457						IFE	YY,<YY=400000>
  4458						IFE	ZZ,<ZZ=400000>
  4459	032502	200 00 0 00 035501 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4460	032503	270 00 0 00 035441 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4461									;POWER SHOULD RESULT IN C(AC)=0.
  4462	032504	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4463						STOP^
  4464	032505	254 04 0 00 032506 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4465	032506	324 00 0 00 032507 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4466									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4467									;IN THE SUBTEST) TO LOOP ON ERROR^
  4468
  4469					;**********
  4470
  4471					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4472					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4473					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4474					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
  4475					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4476					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4477					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4478					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
  4479					;FORMER VALUE PLUS THE CURRENT C(AC)
  4480			011322		SN=SN+1
  4481			000001			YY=YY/2
  4482			777777			ZZ=ZZ+YY
  4483						IFE	YY,<YY=400000>
  4484						IFE	ZZ,<ZZ=400000>
  4485	032507	200 00 0 00 035502 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4486	032510	270 00 0 00 035440 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4487									;POWER SHOULD RESULT IN C(AC)=0.
  4488	032511	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  4489						STOP^
  4490	032512	254 04 0 00 032513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4491	032513	324 00 0 00 032514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4492									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4493									;IN THE SUBTEST) TO LOOP ON ERROR^
  4494
  4495					;**********
  4496
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-9
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0114

  4497					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-10
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0115

  4498			011400		SN=11400
  4499			000000			ZZ=0
  4500			000000			YY=0
  4501
  4502					A11400:	REPEAT	^D18,
  4503					<;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4504					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4505					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4506					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4507					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4508					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4509					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4510					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4511					;FORMER VALUE PLUS THE CURRENT C(AC)
  4512					SN=SN+1
  4513						YY=YY/2
  4514						ZZ=ZZ+YY
  4515						IFE	YY,<YY=400000>
  4516						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4517						MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4518									;POWER SHOULD RESULT IN C(AC)=0.
  4519						ADD	[YY]		;PASS TEST IF C(AC)=0
  4520						SKIPE
  4521						STOP
  4522
  4523					;**********
  4524					>
  4525					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4526					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4527					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4528					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4529					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4530					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4531					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4532					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4533					;FORMER VALUE PLUS THE CURRENT C(AC)
  4534			011401		SN=SN+1
  4535			000000			YY=YY/2
  4536			000000			ZZ=ZZ+YY
  4537			400000			IFE	YY,<YY=400000>
  4538			400000			IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4539	032514	200 00 0 00 035503 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4540									;POWER SHOULD RESULT IN C(AC)=0.
  4541	032515	270 00 0 00 035437 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4542	032516	332 00 0 00 000000 		SKIPE
  4543						STOP^
  4544	032517	254 04 0 00 032520 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4545	032520	324 00 0 00 032521 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4546									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4547									;IN THE SUBTEST) TO LOOP ON ERROR^
  4548
  4549					;**********
  4550
  4551					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4552					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-11
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0116

  4553					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4554					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4555					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4556					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4557					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4558					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4559					;FORMER VALUE PLUS THE CURRENT C(AC)
  4560			011402		SN=SN+1
  4561			200000			YY=YY/2
  4562			600000			ZZ=ZZ+YY
  4563						IFE	YY,<YY=400000>
  4564						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4565	032521	200 00 0 00 035504 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4566									;POWER SHOULD RESULT IN C(AC)=0.
  4567	032522	270 00 0 00 035436 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4568	032523	332 00 0 00 000000 		SKIPE
  4569						STOP^
  4570	032524	254 04 0 00 032525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4571	032525	324 00 0 00 032526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4572									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4573									;IN THE SUBTEST) TO LOOP ON ERROR^
  4574
  4575					;**********
  4576
  4577					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4578					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4579					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4580					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4581					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4582					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4583					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4584					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4585					;FORMER VALUE PLUS THE CURRENT C(AC)
  4586			011403		SN=SN+1
  4587			100000			YY=YY/2
  4588			700000			ZZ=ZZ+YY
  4589						IFE	YY,<YY=400000>
  4590						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4591	032526	200 00 0 00 035505 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4592									;POWER SHOULD RESULT IN C(AC)=0.
  4593	032527	270 00 0 00 035435 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4594	032530	332 00 0 00 000000 		SKIPE
  4595						STOP^
  4596	032531	254 04 0 00 032532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4597	032532	324 00 0 00 032533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4598									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4599									;IN THE SUBTEST) TO LOOP ON ERROR^
  4600
  4601					;**********
  4602
  4603					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4604					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4605					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4606					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4607					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-12
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0117

  4608					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4609					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4610					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4611					;FORMER VALUE PLUS THE CURRENT C(AC)
  4612			011404		SN=SN+1
  4613			040000			YY=YY/2
  4614			740000			ZZ=ZZ+YY
  4615						IFE	YY,<YY=400000>
  4616						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4617	032533	200 00 0 00 035506 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4618									;POWER SHOULD RESULT IN C(AC)=0.
  4619	032534	270 00 0 00 035434 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4620	032535	332 00 0 00 000000 		SKIPE
  4621						STOP^
  4622	032536	254 04 0 00 032537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4623	032537	324 00 0 00 032540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4624									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4625									;IN THE SUBTEST) TO LOOP ON ERROR^
  4626
  4627					;**********
  4628
  4629					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4630					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4631					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4632					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4633					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4634					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4635					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4636					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4637					;FORMER VALUE PLUS THE CURRENT C(AC)
  4638			011405		SN=SN+1
  4639			020000			YY=YY/2
  4640			760000			ZZ=ZZ+YY
  4641						IFE	YY,<YY=400000>
  4642						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4643	032540	200 00 0 00 035507 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4644									;POWER SHOULD RESULT IN C(AC)=0.
  4645	032541	270 00 0 00 035433 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4646	032542	332 00 0 00 000000 		SKIPE
  4647						STOP^
  4648	032543	254 04 0 00 032544 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4649	032544	324 00 0 00 032545 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4650									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4651									;IN THE SUBTEST) TO LOOP ON ERROR^
  4652
  4653					;**********
  4654
  4655					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4656					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4657					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4658					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4659					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4660					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4661					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4662					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-13
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0118

  4663					;FORMER VALUE PLUS THE CURRENT C(AC)
  4664			011406		SN=SN+1
  4665			010000			YY=YY/2
  4666			770000			ZZ=ZZ+YY
  4667						IFE	YY,<YY=400000>
  4668						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4669	032545	200 00 0 00 035510 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4670									;POWER SHOULD RESULT IN C(AC)=0.
  4671	032546	270 00 0 00 035432 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4672	032547	332 00 0 00 000000 		SKIPE
  4673						STOP^
  4674	032550	254 04 0 00 032551 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4675	032551	324 00 0 00 032552 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4676									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4677									;IN THE SUBTEST) TO LOOP ON ERROR^
  4678
  4679					;**********
  4680
  4681					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4682					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4683					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4684					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4685					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4686					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4687					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4688					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4689					;FORMER VALUE PLUS THE CURRENT C(AC)
  4690			011407		SN=SN+1
  4691			004000			YY=YY/2
  4692			774000			ZZ=ZZ+YY
  4693						IFE	YY,<YY=400000>
  4694						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4695	032552	200 00 0 00 035511 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4696									;POWER SHOULD RESULT IN C(AC)=0.
  4697	032553	270 00 0 00 035431 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4698	032554	332 00 0 00 000000 		SKIPE
  4699						STOP^
  4700	032555	254 04 0 00 032556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4701	032556	324 00 0 00 032557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4702									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4703									;IN THE SUBTEST) TO LOOP ON ERROR^
  4704
  4705					;**********
  4706
  4707					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4708					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4709					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4710					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4711					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4712					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4713					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4714					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4715					;FORMER VALUE PLUS THE CURRENT C(AC)
  4716			011410		SN=SN+1
  4717			002000			YY=YY/2
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-14
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0119

  4718			776000			ZZ=ZZ+YY
  4719						IFE	YY,<YY=400000>
  4720						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4721	032557	200 00 0 00 035512 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4722									;POWER SHOULD RESULT IN C(AC)=0.
  4723	032560	270 00 0 00 035430 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4724	032561	332 00 0 00 000000 		SKIPE
  4725						STOP^
  4726	032562	254 04 0 00 032563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4727	032563	324 00 0 00 032564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4728									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4729									;IN THE SUBTEST) TO LOOP ON ERROR^
  4730
  4731					;**********
  4732
  4733					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4734					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4735					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4736					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4737					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4738					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4739					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4740					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4741					;FORMER VALUE PLUS THE CURRENT C(AC)
  4742			011411		SN=SN+1
  4743			001000			YY=YY/2
  4744			777000			ZZ=ZZ+YY
  4745						IFE	YY,<YY=400000>
  4746						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4747	032564	200 00 0 00 035513 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4748									;POWER SHOULD RESULT IN C(AC)=0.
  4749	032565	270 00 0 00 035427 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4750	032566	332 00 0 00 000000 		SKIPE
  4751						STOP^
  4752	032567	254 04 0 00 032570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4753	032570	324 00 0 00 032571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4754									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4755									;IN THE SUBTEST) TO LOOP ON ERROR^
  4756
  4757					;**********
  4758
  4759					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4760					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4761					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4762					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4763					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4764					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4765					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4766					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4767					;FORMER VALUE PLUS THE CURRENT C(AC)
  4768			011412		SN=SN+1
  4769			000400			YY=YY/2
  4770			777400			ZZ=ZZ+YY
  4771						IFE	YY,<YY=400000>
  4772						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-15
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0120

  4773	032571	200 00 0 00 035514 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4774									;POWER SHOULD RESULT IN C(AC)=0.
  4775	032572	270 00 0 00 035426 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4776	032573	332 00 0 00 000000 		SKIPE
  4777						STOP^
  4778	032574	254 04 0 00 032575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4779	032575	324 00 0 00 032576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4781									;IN THE SUBTEST) TO LOOP ON ERROR^
  4782
  4783					;**********
  4784
  4785					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4786					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4787					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4788					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4789					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4790					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4791					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4792					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4793					;FORMER VALUE PLUS THE CURRENT C(AC)
  4794			011413		SN=SN+1
  4795			000200			YY=YY/2
  4796			777600			ZZ=ZZ+YY
  4797						IFE	YY,<YY=400000>
  4798						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4799	032576	200 00 0 00 035515 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4800									;POWER SHOULD RESULT IN C(AC)=0.
  4801	032577	270 00 0 00 035425 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4802	032600	332 00 0 00 000000 		SKIPE
  4803						STOP^
  4804	032601	254 04 0 00 032602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4805	032602	324 00 0 00 032603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4807									;IN THE SUBTEST) TO LOOP ON ERROR^
  4808
  4809					;**********
  4810
  4811					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4812					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4813					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4814					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4815					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4816					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4817					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4818					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4819					;FORMER VALUE PLUS THE CURRENT C(AC)
  4820			011414		SN=SN+1
  4821			000100			YY=YY/2
  4822			777700			ZZ=ZZ+YY
  4823						IFE	YY,<YY=400000>
  4824						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4825	032603	200 00 0 00 035516 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4826									;POWER SHOULD RESULT IN C(AC)=0.
  4827	032604	270 00 0 00 035424 		ADD	[YY]		;PASS TEST IF C(AC)=0
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-16
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0121

  4828	032605	332 00 0 00 000000 		SKIPE
  4829						STOP^
  4830	032606	254 04 0 00 032607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4831	032607	324 00 0 00 032610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4832									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4833									;IN THE SUBTEST) TO LOOP ON ERROR^
  4834
  4835					;**********
  4836
  4837					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4838					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4839					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4840					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4841					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4842					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4843					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4844					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4845					;FORMER VALUE PLUS THE CURRENT C(AC)
  4846			011415		SN=SN+1
  4847			000040			YY=YY/2
  4848			777740			ZZ=ZZ+YY
  4849						IFE	YY,<YY=400000>
  4850						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4851	032610	200 00 0 00 035517 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4852									;POWER SHOULD RESULT IN C(AC)=0.
  4853	032611	270 00 0 00 035423 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4854	032612	332 00 0 00 000000 		SKIPE
  4855						STOP^
  4856	032613	254 04 0 00 032614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4857	032614	324 00 0 00 032615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4858									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4859									;IN THE SUBTEST) TO LOOP ON ERROR^
  4860
  4861					;**********
  4862
  4863					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4864					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4865					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4866					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4867					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4868					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4869					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4870					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4871					;FORMER VALUE PLUS THE CURRENT C(AC)
  4872			011416		SN=SN+1
  4873			000020			YY=YY/2
  4874			777760			ZZ=ZZ+YY
  4875						IFE	YY,<YY=400000>
  4876						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4877	032615	200 00 0 00 035520 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4878									;POWER SHOULD RESULT IN C(AC)=0.
  4879	032616	270 00 0 00 035422 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4880	032617	332 00 0 00 000000 		SKIPE
  4881						STOP^
  4882	032620	254 04 0 00 032621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-17
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0122

  4883	032621	324 00 0 00 032622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4884									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4885									;IN THE SUBTEST) TO LOOP ON ERROR^
  4886
  4887					;**********
  4888
  4889					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4890					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4891					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4892					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4893					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4894					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4895					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4896					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4897					;FORMER VALUE PLUS THE CURRENT C(AC)
  4898			011417		SN=SN+1
  4899			000010			YY=YY/2
  4900			777770			ZZ=ZZ+YY
  4901						IFE	YY,<YY=400000>
  4902						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4903	032622	200 00 0 00 035521 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4904									;POWER SHOULD RESULT IN C(AC)=0.
  4905	032623	270 00 0 00 035421 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4906	032624	332 00 0 00 000000 		SKIPE
  4907						STOP^
  4908	032625	254 04 0 00 032626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4909	032626	324 00 0 00 032627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4910									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4911									;IN THE SUBTEST) TO LOOP ON ERROR^
  4912
  4913					;**********
  4914
  4915					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4916					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4917					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4918					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4919					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4920					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4921					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4922					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4923					;FORMER VALUE PLUS THE CURRENT C(AC)
  4924			011420		SN=SN+1
  4925			000004			YY=YY/2
  4926			777774			ZZ=ZZ+YY
  4927						IFE	YY,<YY=400000>
  4928						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4929	032627	200 00 0 00 035522 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4930									;POWER SHOULD RESULT IN C(AC)=0.
  4931	032630	270 00 0 00 035420 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4932	032631	332 00 0 00 000000 		SKIPE
  4933						STOP^
  4934	032632	254 04 0 00 032633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4935	032633	324 00 0 00 032634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4936									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4937									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 8-18
DAKABM	MAC	19-JAN-77 13:39		TEST OF THE ADD INSTRUCTION                                                        SEQ 0123

  4938
  4939					;**********
  4940
  4941					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4942					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4943					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4944					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4945					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4946					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4947					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4948					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4949					;FORMER VALUE PLUS THE CURRENT C(AC)
  4950			011421		SN=SN+1
  4951			000002			YY=YY/2
  4952			777776			ZZ=ZZ+YY
  4953						IFE	YY,<YY=400000>
  4954						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4955	032634	200 00 0 00 035523 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4956									;POWER SHOULD RESULT IN C(AC)=0.
  4957	032635	270 00 0 00 035417 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4958	032636	332 00 0 00 000000 		SKIPE
  4959						STOP^
  4960	032637	254 04 0 00 032640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4961	032640	324 00 0 00 032641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4962									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4963									;IN THE SUBTEST) TO LOOP ON ERROR^
  4964
  4965					;**********
  4966
  4967					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
  4968					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
  4969					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
  4970					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
  4971					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
  4972					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
  4973					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
  4974					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
  4975					;FORMER VALUE PLUS THE CURRENT C(AC)
  4976			011422		SN=SN+1
  4977			000001			YY=YY/2
  4978			777777			ZZ=ZZ+YY
  4979						IFE	YY,<YY=400000>
  4980						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
  4981	032641	200 00 0 00 035524 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
  4982									;POWER SHOULD RESULT IN C(AC)=0.
  4983	032642	270 00 0 00 035416 		ADD	[YY]		;PASS TEST IF C(AC)=0
  4984	032643	332 00 0 00 000000 		SKIPE
  4985						STOP^
  4986	032644	254 04 0 00 032645 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4987	032645	324 00 0 00 032646 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4988									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4989									;IN THE SUBTEST) TO LOOP ON ERROR^
  4990
  4991					;**********
  4992
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 9
DAKABM	MAC	19-JAN-77 13:39		SPECIAL KI10 FOUR BIT ADDER TEST                                                   SEQ 0124

  4993					SUBTTL	SPECIAL KI10 FOUR BIT ADDER TEST
  4994
  4995					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  4996					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  4997					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 33 TO BIT 32.
  4998
  4999	032646	200 00 0 00 035525 	A13500:	MOVE	[-1,,-5]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 33
  5000	032647	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 33 TO BIT 32
  5001	032650	444 00 0 00 035522 		EQV	[-1,,-4]	;RESULT IN AC=ALL ONES
  5002	032651	444 00 0 00 035412 		EQV	[0]		;RESULT IN AC=0
  5003	032652	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5004						STOP^
  5005	032653	254 04 0 00 032654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5006	032654	324 00 0 00 032655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5007									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5008									;IN THE SUBTEST) TO LOOP ON ERROR^
  5009
  5010					;**********
  5011
  5012					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  5013					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  5014					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 29 TO BIT 28.
  5015
  5016	032655	200 00 0 00 035526 	A13600:	MOVE	[-1,,-101]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 29
  5017	032656	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 29 TO BIT 28
  5018	032657	444 00 0 00 035516 		EQV	[-1,,-100]	;RESULT IN AC=ALL ONES
  5019	032660	444 00 0 00 035412 		EQV	[0]		;RESULT IN AC=0
  5020	032661	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5021						STOP^
  5022	032662	254 04 0 00 032663 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5023	032663	324 00 0 00 032664 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5024									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5025									;IN THE SUBTEST) TO LOOP ON ERROR^
  5026
  5027					;**********
  5028
  5029					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  5030					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  5031					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 25 TO BIT 24.
  5032
  5033	032664	200 00 0 00 035527 	A13700:	MOVE	[-1,,-2001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 25
  5034	032665	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 25 TO BIT 24
  5035	032666	444 00 0 00 035512 		EQV	[-1,,-2000]	;RESULT IN AC=ALL ONES
  5036	032667	444 00 0 00 035412 		EQV	[0]		;RESULT IN AC=0
  5037	032670	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5038						STOP^
  5039	032671	254 04 0 00 032672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5040	032672	324 00 0 00 032673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5041									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5042									;IN THE SUBTEST) TO LOOP ON ERROR^
  5043
  5044					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 10
DAKABM	MAC	19-JAN-77 13:39		SPECIAL KI10 FOUR BIT ADDER TEST                                                   SEQ 0125

  5045					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  5046					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  5047					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 21 TO BIT 20.
  5048
  5049	032673	200 00 0 00 035530 	A14000:	MOVE	[-1,,-40001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 21
  5050	032674	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 21 TO BIT 20
  5051	032675	444 00 0 00 035506 		EQV	[-1,,-40000]	;RESULT IN AC=ALL ONES
  5052	032676	444 00 0 00 035412 		EQV	[0]		;RESULT IN AC=0
  5053	032677	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5054						STOP^
  5055	032700	254 04 0 00 032701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5056	032701	324 00 0 00 032702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5057									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5058									;IN THE SUBTEST) TO LOOP ON ERROR^
  5059
  5060					;**********
  5061
  5062					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  5063					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  5064					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 18 TO BIT 17.
  5065
  5066	032702	200 00 0 00 035531 	A14100:	MOVE	[-1,,-400001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 18
  5067	032703	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 18 TO BIT 17
  5068	032704	444 00 0 00 035503 		EQV	[-1,,400000]	;RESULT IN AC=ALL ONES
  5069	032705	444 00 0 00 035412 		EQV	[0]		;RESULT IN AC=0
  5070	032706	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5071						STOP^
  5072	032707	254 04 0 00 032710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5073	032710	324 00 0 00 032711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5074									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5075									;IN THE SUBTEST) TO LOOP ON ERROR^
  5076
  5077					;**********
  5078
  5079					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  5080					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  5081					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 14 TO BIT 13.
  5082
  5083	032711	200 00 0 00 035532 	A14200:	MOVE	[-11,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 14
  5084	032712	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 14 TO BIT 13
  5085	032713	444 00 0 00 035477 		EQV	[-10,,0]	;RESULT IN AC=ALL ONES
  5086	032714	444 00 0 00 035412 		EQV	[0]		;RESULT IN AC=0
  5087	032715	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5088						STOP^
  5089	032716	254 04 0 00 032717 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5090	032717	324 00 0 00 032720 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5091									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5092									;IN THE SUBTEST) TO LOOP ON ERROR^
  5093
  5094					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 11
DAKABM	MAC	19-JAN-77 13:39		SPECIAL KI10 FOUR BIT ADDER TEST                                                   SEQ 0126

  5095					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  5096					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  5097					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 10 TO BIT 9.
  5098
  5099	032720	200 00 0 00 035533 	A14300:	MOVE	[-201,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 10
  5100	032721	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 10 TO BIT 9
  5101	032722	444 00 0 00 035473 		EQV	[-200,,0]	;RESULT IN AC=ALL ONES
  5102	032723	444 00 0 00 035412 		EQV	[0]		;RESULT IN AC=0
  5103	032724	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5104						STOP^
  5105	032725	254 04 0 00 032726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5106	032726	324 00 0 00 032727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5107									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5108									;IN THE SUBTEST) TO LOOP ON ERROR^
  5109
  5110					;**********
  5111
  5112					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  5113					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  5114					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 6 TO BIT 5.
  5115
  5116	032727	200 00 0 00 035534 	A14400:	MOVE	[-4001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 6
  5117	032730	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 6 TO BIT 5
  5118	032731	444 00 0 00 035467 		EQV	[-4000,,0]	;RESULT IN AC=ALL ONES
  5119	032732	444 00 0 00 035412 		EQV	[0]		;RESULT IN AC=0
  5120	032733	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5121						STOP^
  5122	032734	254 04 0 00 032735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5123	032735	324 00 0 00 032736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5124									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5125									;IN THE SUBTEST) TO LOOP ON ERROR^
  5126
  5127					;**********
  5128
  5129					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  5130					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  5131					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 2 TO BIT 1.
  5132
  5133	032736	200 00 0 00 035535 	A14500:	MOVE	[-100001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 2
  5134	032737	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 2 TO BIT 1
  5135	032740	444 00 0 00 035463 		EQV	[-100000,,0]	;RESULT IN AC=ALL ONES
  5136	032741	444 00 0 00 035412 		EQV	[0]		;RESULT IN AC=0
  5137	032742	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5138						STOP^
  5139	032743	254 04 0 00 032744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5140	032744	324 00 0 00 032745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5141									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5142									;IN THE SUBTEST) TO LOOP ON ERROR^
  5143
  5144					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 12
DAKABM	MAC	19-JAN-77 13:39		SPECIAL KI10 FOUR BIT ADDER TEST                                                   SEQ 0127

  5145					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  5146					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  5147					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 1 TO BIT 0.
  5148
  5149	032745	200 00 0 00 035536 	A14600:	MOVE	[-200001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 1
  5150	032746	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 1 TO BIT 0
  5151	032747	444 00 0 00 035462 		EQV	[600000,,0]	;RESULT IN AC=ALL ONES
  5152	032750	444 00 0 00 035412 		EQV	[0]		;RESULT IN AC=0
  5153	032751	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5154						STOP^
  5155	032752	254 04 0 00 032753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5156	032753	324 00 0 00 032754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5157									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5158									;IN THE SUBTEST) TO LOOP ON ERROR^
  5159
  5160					;**********
  5161
  5162					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
  5163					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
  5164					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT -1TO BIT 35.
  5165
  5166	032754	200 00 0 00 035524 	A14700:	MOVE	[-1,,-1]	;PRESET AC WITH ALL ONES
  5167	032755	270 00 0 00 035416 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT -1 TO BIT 35
  5168	032756	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5169						STOP^
  5170	032757	254 04 0 00 032760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5171	032760	324 00 0 00 032761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5172									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5173									;IN THE SUBTEST) TO LOOP ON ERROR^
  5174
  5175					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0128

  5176					SUBTTL	TEST OF SUB AND COMPARE INSTRUCTIONS
  5177
  5178					;THIS TEST VERIFIES THAT IF A NON ZERO POSITIVE NUMBER IN E IS
  5179					;SUBTRACTED FROM THE AC WHEN C(AC)=0, THE RESULT IN THE AC
  5180					;IS NEGATIVE
  5181
  5182	032761	200 00 0 00 035412 	A11500:	MOVE	[0]		;PRESET AC TO ZERO
  5183	032762	274 00 0 00 035537 		SUB	[XWD 0,-1]	;*SUB OF POSITIVE NONZERO NUMBER FROM AC OF ALL ZEROS
  5184									;SHOULD RESULT IN C(AC) NEGATIVE
  5185	032763	331 00 0 00 000000 		SKIPL			;PASS TEST IF C(AC) IS NEGATIVE
  5186						STOP^
  5187	032764	254 04 0 00 032765 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5188	032765	324 00 0 00 032766 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5189									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5190									;IN THE SUBTEST) TO LOOP ON ERROR^
  5191
  5192					;AD AR- EN D [ADAM], F CYC ACT ENB [F1],
  5193					;IR SUBX[IR1], IR ADSUB[IR1]
  5194
  5195					;**********
  5196
  5197					;THIS TEST VERIFIES THAT IF A WORD OF ALL ZEROS IS
  5198					;SUBTRACTED FROM AN AC OF ALL ZEROS, THE RESULT
  5199					;IS AN AC OF ZEROS.
  5200
  5201	032766	200 00 0 00 035412 	A11600:	MOVE	[0]		;PRESET AC TO ZERO
  5202	032767	274 00 0 00 035412 		SUB	[0]		;*SUB OF 0 FROM 0 SHOULD RESULT IN C(AC)=0
  5203	032770	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5204						STOP^
  5205	032771	254 04 0 00 032772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5206	032772	324 00 0 00 032773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5207									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5208									;IN THE SUBTEST) TO LOOP ON ERROR^
  5209					;AD CRY 36[ADCR], F CYC ACT EN D[F1], IF SUBX [IR1]
  5210
  5211					;**********
  5212					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0129

  5213			011700		SN=11700
  5214			000000			ZZ=0
  5215
  5216					A11700:	REPEAT	^D36,
  5217					<;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5218					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5219					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5220					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5221					SN=SN+1
  5222						ZZ=ZZ+ZZ
  5223						IFE	ZZ,<ZZ=1>
  5224						MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5225						SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5226						SKIPE			;PASS TEST IF C(AC)=0
  5227						STOP
  5228
  5229					;**********
  5230					>
  5231					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5232					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5233					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5234					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5235			011701		SN=SN+1
  5236			000000			ZZ=ZZ+ZZ
  5237			000001			IFE	ZZ,<ZZ=1>
  5238	032773	200 00 0 00 035416 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5239	032774	274 00 0 00 035416 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5240	032775	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5241						STOP^
  5242	032776	254 04 0 00 032777 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5243	032777	324 00 0 00 033000 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5244									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5245									;IN THE SUBTEST) TO LOOP ON ERROR^
  5246
  5247					;**********
  5248
  5249					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5250					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5251					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5252					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5253			011702		SN=SN+1
  5254			000002			ZZ=ZZ+ZZ
  5255						IFE	ZZ,<ZZ=1>
  5256	033000	200 00 0 00 035417 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5257	033001	274 00 0 00 035417 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5258	033002	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5259						STOP^
  5260	033003	254 04 0 00 033004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5261	033004	324 00 0 00 033005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5262									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5263									;IN THE SUBTEST) TO LOOP ON ERROR^
  5264
  5265					;**********
  5266
  5267					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0130

  5268					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5269					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5270					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5271			011703		SN=SN+1
  5272			000004			ZZ=ZZ+ZZ
  5273						IFE	ZZ,<ZZ=1>
  5274	033005	200 00 0 00 035420 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5275	033006	274 00 0 00 035420 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5276	033007	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5277						STOP^
  5278	033010	254 04 0 00 033011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5279	033011	324 00 0 00 033012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5280									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5281									;IN THE SUBTEST) TO LOOP ON ERROR^
  5282
  5283					;**********
  5284
  5285					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5286					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5287					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5288					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5289			011704		SN=SN+1
  5290			000010			ZZ=ZZ+ZZ
  5291						IFE	ZZ,<ZZ=1>
  5292	033012	200 00 0 00 035421 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5293	033013	274 00 0 00 035421 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5294	033014	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5295						STOP^
  5296	033015	254 04 0 00 033016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5297	033016	324 00 0 00 033017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5298									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5299									;IN THE SUBTEST) TO LOOP ON ERROR^
  5300
  5301					;**********
  5302
  5303					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5304					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5305					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5306					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5307			011705		SN=SN+1
  5308			000020			ZZ=ZZ+ZZ
  5309						IFE	ZZ,<ZZ=1>
  5310	033017	200 00 0 00 035422 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5311	033020	274 00 0 00 035422 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5312	033021	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5313						STOP^
  5314	033022	254 04 0 00 033023 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5315	033023	324 00 0 00 033024 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5316									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5317									;IN THE SUBTEST) TO LOOP ON ERROR^
  5318
  5319					;**********
  5320
  5321					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5322					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0131

  5323					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5324					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5325			011706		SN=SN+1
  5326			000040			ZZ=ZZ+ZZ
  5327						IFE	ZZ,<ZZ=1>
  5328	033024	200 00 0 00 035423 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5329	033025	274 00 0 00 035423 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5330	033026	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5331						STOP^
  5332	033027	254 04 0 00 033030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5333	033030	324 00 0 00 033031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5334									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5335									;IN THE SUBTEST) TO LOOP ON ERROR^
  5336
  5337					;**********
  5338
  5339					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5340					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5341					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5342					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5343			011707		SN=SN+1
  5344			000100			ZZ=ZZ+ZZ
  5345						IFE	ZZ,<ZZ=1>
  5346	033031	200 00 0 00 035424 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5347	033032	274 00 0 00 035424 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5348	033033	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5349						STOP^
  5350	033034	254 04 0 00 033035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5351	033035	324 00 0 00 033036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5352									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5353									;IN THE SUBTEST) TO LOOP ON ERROR^
  5354
  5355					;**********
  5356
  5357					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5358					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5359					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5360					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5361			011710		SN=SN+1
  5362			000200			ZZ=ZZ+ZZ
  5363						IFE	ZZ,<ZZ=1>
  5364	033036	200 00 0 00 035425 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5365	033037	274 00 0 00 035425 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5366	033040	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5367						STOP^
  5368	033041	254 04 0 00 033042 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5369	033042	324 00 0 00 033043 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5370									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5371									;IN THE SUBTEST) TO LOOP ON ERROR^
  5372
  5373					;**********
  5374
  5375					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5376					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5377					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0132

  5378					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5379			011711		SN=SN+1
  5380			000400			ZZ=ZZ+ZZ
  5381						IFE	ZZ,<ZZ=1>
  5382	033043	200 00 0 00 035426 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5383	033044	274 00 0 00 035426 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5384	033045	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5385						STOP^
  5386	033046	254 04 0 00 033047 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5387	033047	324 00 0 00 033050 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5388									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5389									;IN THE SUBTEST) TO LOOP ON ERROR^
  5390
  5391					;**********
  5392
  5393					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5394					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5395					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5396					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5397			011712		SN=SN+1
  5398			001000			ZZ=ZZ+ZZ
  5399						IFE	ZZ,<ZZ=1>
  5400	033050	200 00 0 00 035427 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5401	033051	274 00 0 00 035427 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5402	033052	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5403						STOP^
  5404	033053	254 04 0 00 033054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5405	033054	324 00 0 00 033055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5406									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5407									;IN THE SUBTEST) TO LOOP ON ERROR^
  5408
  5409					;**********
  5410
  5411					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5412					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5413					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5414					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5415			011713		SN=SN+1
  5416			002000			ZZ=ZZ+ZZ
  5417						IFE	ZZ,<ZZ=1>
  5418	033055	200 00 0 00 035430 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5419	033056	274 00 0 00 035430 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5420	033057	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5421						STOP^
  5422	033060	254 04 0 00 033061 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5423	033061	324 00 0 00 033062 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5424									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5425									;IN THE SUBTEST) TO LOOP ON ERROR^
  5426
  5427					;**********
  5428
  5429					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5430					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5431					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5432					;TIMES IN ORDER TO TEST ALL 36 BITS.
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0133

  5433			011714		SN=SN+1
  5434			004000			ZZ=ZZ+ZZ
  5435						IFE	ZZ,<ZZ=1>
  5436	033062	200 00 0 00 035431 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5437	033063	274 00 0 00 035431 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5438	033064	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5439						STOP^
  5440	033065	254 04 0 00 033066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5441	033066	324 00 0 00 033067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5442									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5443									;IN THE SUBTEST) TO LOOP ON ERROR^
  5444
  5445					;**********
  5446
  5447					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5448					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5449					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5450					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5451			011715		SN=SN+1
  5452			010000			ZZ=ZZ+ZZ
  5453						IFE	ZZ,<ZZ=1>
  5454	033067	200 00 0 00 035432 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5455	033070	274 00 0 00 035432 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5456	033071	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5457						STOP^
  5458	033072	254 04 0 00 033073 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5459	033073	324 00 0 00 033074 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5460									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5461									;IN THE SUBTEST) TO LOOP ON ERROR^
  5462
  5463					;**********
  5464
  5465					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5466					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5467					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5468					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5469			011716		SN=SN+1
  5470			020000			ZZ=ZZ+ZZ
  5471						IFE	ZZ,<ZZ=1>
  5472	033074	200 00 0 00 035433 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5473	033075	274 00 0 00 035433 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5474	033076	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5475						STOP^
  5476	033077	254 04 0 00 033100 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5477	033100	324 00 0 00 033101 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5478									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5479									;IN THE SUBTEST) TO LOOP ON ERROR^
  5480
  5481					;**********
  5482
  5483					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5484					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5485					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5486					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5487			011717		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0134

  5488			040000			ZZ=ZZ+ZZ
  5489						IFE	ZZ,<ZZ=1>
  5490	033101	200 00 0 00 035434 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5491	033102	274 00 0 00 035434 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5492	033103	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5493						STOP^
  5494	033104	254 04 0 00 033105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5495	033105	324 00 0 00 033106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5496									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5497									;IN THE SUBTEST) TO LOOP ON ERROR^
  5498
  5499					;**********
  5500
  5501					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5502					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5503					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5504					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5505			011720		SN=SN+1
  5506			100000			ZZ=ZZ+ZZ
  5507						IFE	ZZ,<ZZ=1>
  5508	033106	200 00 0 00 035435 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5509	033107	274 00 0 00 035435 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5510	033110	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5511						STOP^
  5512	033111	254 04 0 00 033112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5513	033112	324 00 0 00 033113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5514									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5515									;IN THE SUBTEST) TO LOOP ON ERROR^
  5516
  5517					;**********
  5518
  5519					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5520					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5521					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5522					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5523			011721		SN=SN+1
  5524			200000			ZZ=ZZ+ZZ
  5525						IFE	ZZ,<ZZ=1>
  5526	033113	200 00 0 00 035436 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5527	033114	274 00 0 00 035436 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5528	033115	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5529						STOP^
  5530	033116	254 04 0 00 033117 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5531	033117	324 00 0 00 033120 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5532									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5533									;IN THE SUBTEST) TO LOOP ON ERROR^
  5534
  5535					;**********
  5536
  5537					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5538					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5539					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5540					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5541			011722		SN=SN+1
  5542			400000			ZZ=ZZ+ZZ
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-7
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0135

  5543						IFE	ZZ,<ZZ=1>
  5544	033120	200 00 0 00 035437 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5545	033121	274 00 0 00 035437 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5546	033122	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5547						STOP^
  5548	033123	254 04 0 00 033124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5549	033124	324 00 0 00 033125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5550									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5551									;IN THE SUBTEST) TO LOOP ON ERROR^
  5552
  5553					;**********
  5554
  5555					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5556					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5557					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5558					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5559			011723		SN=SN+1
  5560		000001	000000			ZZ=ZZ+ZZ
  5561						IFE	ZZ,<ZZ=1>
  5562	033125	200 00 0 00 035440 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5563	033126	274 00 0 00 035440 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5564	033127	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5565						STOP^
  5566	033130	254 04 0 00 033131 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5567	033131	324 00 0 00 033132 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5568									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5569									;IN THE SUBTEST) TO LOOP ON ERROR^
  5570
  5571					;**********
  5572
  5573					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5574					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5575					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5576					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5577			011724		SN=SN+1
  5578		000002	000000			ZZ=ZZ+ZZ
  5579						IFE	ZZ,<ZZ=1>
  5580	033132	200 00 0 00 035441 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5581	033133	274 00 0 00 035441 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5582	033134	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5583						STOP^
  5584	033135	254 04 0 00 033136 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5585	033136	324 00 0 00 033137 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5586									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5587									;IN THE SUBTEST) TO LOOP ON ERROR^
  5588
  5589					;**********
  5590
  5591					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5592					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5593					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5594					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5595			011725		SN=SN+1
  5596		000004	000000			ZZ=ZZ+ZZ
  5597						IFE	ZZ,<ZZ=1>
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-8
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0136

  5598	033137	200 00 0 00 035442 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5599	033140	274 00 0 00 035442 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5600	033141	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5601						STOP^
  5602	033142	254 04 0 00 033143 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5603	033143	324 00 0 00 033144 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5604									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5605									;IN THE SUBTEST) TO LOOP ON ERROR^
  5606
  5607					;**********
  5608
  5609					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5610					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5611					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5612					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5613			011726		SN=SN+1
  5614		000010	000000			ZZ=ZZ+ZZ
  5615						IFE	ZZ,<ZZ=1>
  5616	033144	200 00 0 00 035443 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5617	033145	274 00 0 00 035443 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5618	033146	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5619						STOP^
  5620	033147	254 04 0 00 033150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5621	033150	324 00 0 00 033151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5622									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5623									;IN THE SUBTEST) TO LOOP ON ERROR^
  5624
  5625					;**********
  5626
  5627					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5628					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5629					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5630					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5631			011727		SN=SN+1
  5632		000020	000000			ZZ=ZZ+ZZ
  5633						IFE	ZZ,<ZZ=1>
  5634	033151	200 00 0 00 035444 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5635	033152	274 00 0 00 035444 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5636	033153	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5637						STOP^
  5638	033154	254 04 0 00 033155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5639	033155	324 00 0 00 033156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5640									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5641									;IN THE SUBTEST) TO LOOP ON ERROR^
  5642
  5643					;**********
  5644
  5645					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5646					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5647					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5648					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5649			011730		SN=SN+1
  5650		000040	000000			ZZ=ZZ+ZZ
  5651						IFE	ZZ,<ZZ=1>
  5652	033156	200 00 0 00 035445 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-9
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0137

  5653	033157	274 00 0 00 035445 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5654	033160	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5655						STOP^
  5656	033161	254 04 0 00 033162 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5657	033162	324 00 0 00 033163 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5658									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5659									;IN THE SUBTEST) TO LOOP ON ERROR^
  5660
  5661					;**********
  5662
  5663					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5664					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5665					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5666					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5667			011731		SN=SN+1
  5668		000100	000000			ZZ=ZZ+ZZ
  5669						IFE	ZZ,<ZZ=1>
  5670	033163	200 00 0 00 035446 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5671	033164	274 00 0 00 035446 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5672	033165	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5673						STOP^
  5674	033166	254 04 0 00 033167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5675	033167	324 00 0 00 033170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5676									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5677									;IN THE SUBTEST) TO LOOP ON ERROR^
  5678
  5679					;**********
  5680
  5681					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5682					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5683					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5684					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5685			011732		SN=SN+1
  5686		000200	000000			ZZ=ZZ+ZZ
  5687						IFE	ZZ,<ZZ=1>
  5688	033170	200 00 0 00 035447 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5689	033171	274 00 0 00 035447 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5690	033172	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5691						STOP^
  5692	033173	254 04 0 00 033174 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5693	033174	324 00 0 00 033175 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5694									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5695									;IN THE SUBTEST) TO LOOP ON ERROR^
  5696
  5697					;**********
  5698
  5699					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5700					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5701					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5702					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5703			011733		SN=SN+1
  5704		000400	000000			ZZ=ZZ+ZZ
  5705						IFE	ZZ,<ZZ=1>
  5706	033175	200 00 0 00 035450 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5707	033176	274 00 0 00 035450 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-10
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0138

  5708	033177	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5709						STOP^
  5710	033200	254 04 0 00 033201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5711	033201	324 00 0 00 033202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5712									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5713									;IN THE SUBTEST) TO LOOP ON ERROR^
  5714
  5715					;**********
  5716
  5717					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5718					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5719					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5720					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5721			011734		SN=SN+1
  5722		001000	000000			ZZ=ZZ+ZZ
  5723						IFE	ZZ,<ZZ=1>
  5724	033202	200 00 0 00 035451 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5725	033203	274 00 0 00 035451 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5726	033204	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5727						STOP^
  5728	033205	254 04 0 00 033206 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5729	033206	324 00 0 00 033207 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5730									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5731									;IN THE SUBTEST) TO LOOP ON ERROR^
  5732
  5733					;**********
  5734
  5735					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5736					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5737					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5738					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5739			011735		SN=SN+1
  5740		002000	000000			ZZ=ZZ+ZZ
  5741						IFE	ZZ,<ZZ=1>
  5742	033207	200 00 0 00 035452 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5743	033210	274 00 0 00 035452 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5744	033211	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5745						STOP^
  5746	033212	254 04 0 00 033213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5747	033213	324 00 0 00 033214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5748									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5749									;IN THE SUBTEST) TO LOOP ON ERROR^
  5750
  5751					;**********
  5752
  5753					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5754					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5755					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5756					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5757			011736		SN=SN+1
  5758		004000	000000			ZZ=ZZ+ZZ
  5759						IFE	ZZ,<ZZ=1>
  5760	033214	200 00 0 00 035453 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5761	033215	274 00 0 00 035453 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5762	033216	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-11
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0139

  5763						STOP^
  5764	033217	254 04 0 00 033220 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5765	033220	324 00 0 00 033221 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5766									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5767									;IN THE SUBTEST) TO LOOP ON ERROR^
  5768
  5769					;**********
  5770
  5771					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5772					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5773					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5774					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5775			011737		SN=SN+1
  5776		010000	000000			ZZ=ZZ+ZZ
  5777						IFE	ZZ,<ZZ=1>
  5778	033221	200 00 0 00 035454 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5779	033222	274 00 0 00 035454 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5780	033223	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5781						STOP^
  5782	033224	254 04 0 00 033225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5783	033225	324 00 0 00 033226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5784									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5785									;IN THE SUBTEST) TO LOOP ON ERROR^
  5786
  5787					;**********
  5788
  5789					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5790					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5791					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5792					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5793			011740		SN=SN+1
  5794		020000	000000			ZZ=ZZ+ZZ
  5795						IFE	ZZ,<ZZ=1>
  5796	033226	200 00 0 00 035455 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5797	033227	274 00 0 00 035455 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5798	033230	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5799						STOP^
  5800	033231	254 04 0 00 033232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5801	033232	324 00 0 00 033233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5802									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5803									;IN THE SUBTEST) TO LOOP ON ERROR^
  5804
  5805					;**********
  5806
  5807					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5808					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5809					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5810					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5811			011741		SN=SN+1
  5812		040000	000000			ZZ=ZZ+ZZ
  5813						IFE	ZZ,<ZZ=1>
  5814	033233	200 00 0 00 035456 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5815	033234	274 00 0 00 035456 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5816	033235	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5817						STOP^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-12
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0140

  5818	033236	254 04 0 00 033237 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5819	033237	324 00 0 00 033240 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5820									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5821									;IN THE SUBTEST) TO LOOP ON ERROR^
  5822
  5823					;**********
  5824
  5825					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5826					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5827					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5828					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5829			011742		SN=SN+1
  5830		100000	000000			ZZ=ZZ+ZZ
  5831						IFE	ZZ,<ZZ=1>
  5832	033240	200 00 0 00 035457 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5833	033241	274 00 0 00 035457 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5834	033242	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5835						STOP^
  5836	033243	254 04 0 00 033244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5837	033244	324 00 0 00 033245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5838									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5839									;IN THE SUBTEST) TO LOOP ON ERROR^
  5840
  5841					;**********
  5842
  5843					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5844					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5845					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5846					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5847			011743		SN=SN+1
  5848		200000	000000			ZZ=ZZ+ZZ
  5849						IFE	ZZ,<ZZ=1>
  5850	033245	200 00 0 00 035460 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5851	033246	274 00 0 00 035460 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5852	033247	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5853						STOP^
  5854	033250	254 04 0 00 033251 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5855	033251	324 00 0 00 033252 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5856									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5857									;IN THE SUBTEST) TO LOOP ON ERROR^
  5858
  5859					;**********
  5860
  5861					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
  5862					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
  5863					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
  5864					;TIMES IN ORDER TO TEST ALL 36 BITS.
  5865			011744		SN=SN+1
  5866		400000	000000			ZZ=ZZ+ZZ
  5867						IFE	ZZ,<ZZ=1>
  5868	033252	200 00 0 00 035461 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  5869	033253	274 00 0 00 035461 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
  5870	033254	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5871						STOP^
  5872	033255	254 04 0 00 033256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-13
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0141

  5873	033256	324 00 0 00 033257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5874									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5875									;IN THE SUBTEST) TO LOOP ON ERROR^
  5876
  5877					;**********
  5878
  5879					PAGE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 13-14
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0142

  5880					;THIS TEST VERIFIES THAT IF A WORD OF ALL
  5881					;ONES IS SUBTRACTED FROM ITSELF, THE RESULT
  5882					;IN THE AC IS ZERO.
  5883
  5884	033257	200 00 0 00 035524 	A12000:	MOVE	[-1]		;PRESET AC TO ALL ONES
  5885	033260	274 00 0 00 035524 		SUB	[-1]		;*SUB OF -1 FROM ITSELF SHOULD RESULT IN C(AC)=0
  5886	033261	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5887						STOP^
  5888	033262	254 04 0 00 033263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5889	033263	324 00 0 00 033264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5890									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5891									;IN THE SUBTEST) TO LOOP ON ERROR^
  5892
  5893					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 14
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0143

  5894					;THIS TEST VERIFIES THAT CAMA ALWAYS SKIPS THE
  5895					;NEXT INSTRUCTION INDEPENDENT OF THE DATA WITH AC
  5896					;AND E. THIS TEST FAILS IF CAMA DOES NOT SKIP ALWAYS.
  5897
  5898	033264	200 00 0 00 035412 	A12100:	MOVE	[0]		;PRESET AC, E TO ZERO
  5899	033265	314 00 0 00 000000 		CAMA			;*CAMA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION,
  5900									;OTHERWISE THIS TEST FAILS
  5901						STOP^
  5902	033266	254 04 0 00 033267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5903	033267	324 00 0 00 033270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5904									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5905									;IN THE SUBTEST) TO LOOP ON ERROR^
  5906
  5907					;ET0 [E], ET0 EN[E], IR CAXX[IR3], AD CRY 3C[ADCR],
  5908					;FCYC ACT EN D [ADCR], AD CRY 36 F/F'S [ADCR],
  5909					;PC CLOCK EN [PCC], ET0 C F/F[E], IR CAXX[IR3],
  5910					;ADZ COND P[ADZ] AND ADZ COND Z[ADZ]
  5911
  5912					;**********
  5913
  5914					;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE.
  5915					;IT SKIPS THE NEXT INSTRUCTION IF AND ONLY
  5916					;IF C(AC)=C(E). IN THIS TEST AC=E=0 AND
  5917					;C(AC)=C(E)=0. HENCE, CAME MUST
  5918					;SKIP THE NEXT INSTRUCTION
  5919					;IN THIS TEST
  5920
  5921	033270	200 00 0 00 035412 	A12200:	MOVE	[0]		;PRESET AC, E TO ZERO
  5922	033271	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP SINCE E=AC
  5923						STOP^
  5924	033272	254 04 0 00 033273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5925	033273	324 00 0 00 033274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5926									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5927									;IN THE SUBTEST) TO LOOP ON ERROR^
  5928
  5929					;AD FM + EN [ADFP], F CXC ACT ENC[F1], IRCAXX[IR3]
  5930
  5931					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 15
DAKABM	MAC	19-JAN-77 13:39		TEST OF SUB AND COMPARE INSTRUCTIONS                                               SEQ 0144

  5932					;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE
  5933					;IT SKIPS THE NEXT INSTRUCTION OF AND ONLY IF
  5934					;C(AC)=C(E). IN THIS TEST C(AC)=C(E)=0;
  5935					;BUT, E IS NOT WITHIN THE AC RANGE.
  5936					;HENCE, CAME MUST SKIP
  5937					;THE NEXT INSTRUCTION IN THIS TEST.
  5938
  5939	033274	200 00 0 00 035412 	A12300:	MOVE	[0]		;*CAME SHOULD SKIP WHEN C(AC)=C(E)=0
  5940	033275	312 00 0 00 035412 		CAME	[0]
  5941						STOP^
  5942	033276	254 04 0 00 033277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5943	033277	324 00 0 00 033300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5945									;IN THE SUBTEST) TO LOOP ON ERROR^
  5946
  5947					;CAMX: FCE[F1], IR CAMX[IR1]
  5948
  5949					;**********
  5950
  5951					;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE.
  5952					;IT SKIPS THE NEXT INSTRUCTION IF AND ONLY IF
  5953					;C(AC)=C(E). IN THIS TEST C(AC)=0 AND
  5954					;C(E)=-1. HENCE, CAME SHOULD NOT
  5955					;SKIP THE NEXT INSTRUCTION IN THIS TEST.
  5956
  5957	033300	200 00 0 00 035412 	A12400:	MOVE	[0]		;PRESET AC TO ZERO
  5958	033301	312 00 0 00 035524 		CAME	[-1]		;*CAME SHOULD NOT SKIP BECAUSE C(AC)=0 ANDC(E)=-
  5959	033302	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAME PASSES TEST
  5960						STOP^
  5961	033303	254 04 0 00 033304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5962	033304	324 00 0 00 033305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5963									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5964									;IN THE SUBTEST) TO LOOP ON ERROR^
  5965
  5966					;AD AR- EN [ADAM], IR CAXX [IR3], F CYC ACT EN B [F1],
  5967					;AD AR- F/F'S [ADAM], AD ADD [ADC1], AD FM + FETCH EN A [ADFP],
  5968					;F CYC ACT EN A [F1], AD ADD EN C [ADC1], AD ADD F/F'S [ADC1]
  5969
  5970					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 16
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0145

  5971					SUBTTL	TEST OF COMPARE (CAMX) INSTRUCTIONS
  5972
  5973					;**********
  5974
  5975					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  5976					;ONLY WHEN C(AC) IS LESS THAN C(E).
  5977					;IN THIS TEST, C(AC)=-1 AND C(E)=0; HENCE, CAML SHOULD SKIP.  OTHERWISE,THE
  5978					;PROGRAM HALTS.
  5979
  5980	033305	200 00 0 00 035524 	B100:	MOVE	[-1]		;PRELOAD AC WITH -1
  5981	033306	311 00 0 00 035412 		CAML	[0]		;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
  5982						STOP^
  5983	033307	254 04 0 00 033310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5984	033310	324 00 0 00 033311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5985									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5986									;IN THE SUBTEST) TO LOOP ON ERROR^
  5987
  5988					;*****     FAILURE ANALYSIS     *****
  5989					;C(AC0)		C(AC1)		FAILING SIGNAL
  5990
  5991					;				FC: AB PC EN
  5992					;				ET0: COND Q: PC CLK EN
  5993
  5994					;**********
  5995
  5996					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  5997					;ONLY WHEN C(AC) IS LESS THAN C(E).
  5998					;IN THIS CASE, C(AC)=0 AND C(E)=-1; HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
  5999					;THE PROGRAM HALTS.
  6000
  6001	033311	200 00 0 00 035412 	B200:	MOVE	[0]		;PRELOAD AC WITH 0
  6002	033312	311 00 0 00 035524 		CAML	[-1]		;*CAML SHOULD NOT SKIP BECAUSE
  6003									;C(AC) IS GREATER THAN C(E)
  6004	033313	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
  6005						STOP^
  6006	033314	254 04 0 00 033315 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6007	033315	324 00 0 00 033316 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6008									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6009									;IN THE SUBTEST) TO LOOP ON ERROR^
  6010
  6011					;*****     FAILURE ANALYSIS     *****
  6012					;C(AC0)		C(AC1)		FAILING SIGNAL
  6013
  6014					;				SW: FCE
  6015					;				FC: PC CHANGE
  6016
  6017					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 17
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0146

  6018					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  6019					;ONLY WHEN C(AC) IS LESS THAN C(E).
  6020					;IN THIS CASE, C(AC)=400000,,0 (THE MOST
  6021					;NEGATIVE NUMBER) AND C(E)=377777,,-1
  6022					;(THE MOST POSITIVE NUMBER); HENCE,
  6023					;CAML SHOULD SKIP.  OTHERWISE, THE
  6024					;PROGRAM HALTS
  6025
  6026	033316	200 00 0 00 035461 	B300:	MOVE	[XWD 400000,0]	;PRELOAD AC WITH 400000,,0
  6027	033317	311 00 0 00 035540 		CAML	[XWD 377777,-1]	;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
  6028						STOP^
  6029	033320	254 04 0 00 033321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6030	033321	324 00 0 00 033322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6031									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6032									;IN THE SUBTEST) TO LOOP ON ERROR^
  6033
  6034					;*****     FAILURE ANALYSIS     *****
  6035					;C(AC0)		C(AC1)		FAILING SIGNAL
  6036
  6037					;				FC: AD ADD
  6038
  6039					;**********
  6040
  6041					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  6042					;ONLY WHEN C(AC) IS LESS THAN C(E).
  6043					;IN THIS CASE, C(AC)=377777,,-1 (THE MOST POSITIVE NUMBER) AND C(E)=400000,,0 (THE MOST NEG
  6044					ATIVE NUMBER)
  6045					;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE, THE PROGRAM HALTS.
  6046
  6047	033322	200 00 0 00 035540 	B400:	MOVE	[XWD 377777,-1]	;PRELOAD AC WITH 377777,,-1
  6048	033323	311 00 0 00 035461 		CAML	[XWD 400000,0]	;*CAML SHOULD NOT SKIP BECAUSE
  6049									;C(AC) IS GREATER THAN C(E)
  6050	033324	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
  6051						STOP^
  6052	033325	254 04 0 00 033326 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6053	033326	324 00 0 00 033327 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6054									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6055									;IN THE SUBTEST) TO LOOP ON ERROR^
  6056
  6057					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 18
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0147

  6058					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  6059					;ONLY WHEN C(AC) IS LESS THAN C(E).
  6060					;IN THIS CASE, C(AC)=400000,,0 (THE MOST NEGTIVE NUMBER) AND C(E)=-1;
  6061					;HENCE, CAML SHOULD SKIP.  OTHERWISE, THE PROGRAM HALTS
  6062
  6063	033327	200 00 0 00 035461 	B500:	MOVE	[XWD 400000,0]	;PRELOAD AC WITH 400000,,0
  6064	033330	311 00 0 00 035524 		CAML	[-1]		;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
  6065						STOP^
  6066	033331	254 04 0 00 033332 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6067	033332	324 00 0 00 033333 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6068									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6069									;IN THE SUBTEST) TO LOOP ON ERROR^
  6070
  6071					;*****     FAILURE ANALYSIS     *****
  6072					;C(AC0)		C(AC1)		FAILING SIGNAL
  6073
  6074					;				FC: AD FM + EN
  6075
  6076					;**********
  6077
  6078					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  6079					;ONLY WHEN C(AC) IS LESS THAN C(E).
  6080					;IN THIS CASE, C(AC)=0 AND C(E)=-1 ;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
  6081					;THE PROGRAM HALTS.
  6082
  6083	033333	400 00 0 00 000000 	B600:	SETZ			;PRELOAD AC WITH 0
  6084	033334	311 00 0 00 035524 		CAML	[-1]		;*CAML SHOULD NOT SKIP BECAUSE
  6085									;C(AC) IS GREATER THAN C(E)
  6086	033335	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES.
  6087						STOP^
  6088	033336	254 04 0 00 033337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6089	033337	324 00 0 00 033340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6090									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6091									;IN THE SUBTEST) TO LOOP ON ERROR^
  6092
  6093					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 19
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0148

  6094					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT INSTRUCTION WHEN AND
  6095					;ONLY WHEN C(AC) IS LESS THAN C(E).
  6096					;IN THIS CASE, C(AC)=0 AND C(E)=0 ;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
  6097					;THE PROGRAM HALTS.
  6098
  6099	033340	400 00 0 00 000000 	B700:	SETZ			;PRELOAD AS WITH 0
  6100	033341	311 00 0 00 035412 		CAML	[0]		;*CAML SHOULD NOT SKIP BECAUSE C(AC)=C(E)
  6101	033342	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
  6102						STOP^
  6103	033343	254 04 0 00 033344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6104	033344	324 00 0 00 033345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6105									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6106									;IN THE SUBTEST) TO LOOP ON ERROR^
  6107
  6108					;*****     FAILURE ANALYSIS     *****
  6109					;C(AC0)		C(AC1)		FAILING SIGNAL
  6110
  6111					;				FC: AD CRY 36
  6112
  6113					;**********
  6114
  6115					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  6116					;ONLY WHEN C(AC) IS LESS THAN C(E).
  6117					;IN THIS CASE, C(AC)=0 AND C(E)=400000,,O (THE MOST NEGATIVE NUMBER);
  6118					;HENCE CAML SHOULD NOT SKIP.  OTHERWISE, THE PROGRAM HALTS.
  6119
  6120	033345	400 00 0 00 000000 	B1000:	SETZ			;PRELOAD AC WITH 0
  6121	033346	311 00 0 00 035461 		CAML	[XWD 400000,0]	;*CAML SHOULD NOT SKIP BECAUSE
  6122									;C(AC) IS GREATER THAN C(E)
  6123	033347	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
  6124						STOP^
  6125	033350	254 04 0 00 033351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6126	033351	324 00 0 00 033352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6127									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6128									;IN THE SUBTEST) TO LOOP ON ERROR^
  6129
  6130					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 20
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0149

  6131					;THIS TEST VERIFIES THAT CAM IS DATA INDEPENDENT.  IT NEVER SKIPS
  6132					;THE NEXT SEQUENTIAL INSTRUCTION
  6133					;IN THIS CASE, C(AC)=-1 AND C(E)=0
  6134					;IF IT DOES SKIP THE NEXT INSTRUCTION, THE PROGRAM HALTS
  6135
  6136	033352	200 00 0 00 035524 	B1100:	MOVE	[-1]		;PRELOAD AC WITH -1
  6137	033353	310 00 0 00 035412 		CAM	[0]		;*CAM SHOULD NEVER SKIP
  6138	033354	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAM PASSES
  6139						STOP^
  6140	033355	254 04 0 00 033356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6141	033356	324 00 0 00 033357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6142									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6143									;IN THE SUBTEST) TO LOOP ON ERROR^
  6144
  6145					;**********
  6146
  6147					;THIS TEST VERIFIES THAT CAMGE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  6148					;ONLY WHEN C(AC) IS GREATER THAN OR EQUAL TO C(E).
  6149					;IN THIS CASE, C(AC)=-1 AND C(E)=0;  HENCE, CAMGE SHOULD NOT SKIP.
  6150					;OTHERWISE, THE PROGRAM HALTS.
  6151
  6152	033357	200 00 0 00 035524 	B1200:	MOVE	[-1]		;PRELOAD AC WITH-1
  6153	033360	315 00 0 00 035412 		CAMGE	[0]		;*CAMGE SHOULD NOT SKIP BECAUSE C(AC) IS LESS THAN C(E)
  6154	033361	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAMGE PASSES.
  6155						STOP^
  6156	033362	254 04 0 00 033363 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6157	033363	324 00 0 00 033364 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6158									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6159									;IN THE SUBTEST) TO LOOP ON ERROR^
  6160
  6161					;*****     FAILURE ANALYSIS     *****
  6162					;C(AC0)		C(AC1)		FAILING SIGNAL
  6163
  6164					;				FC: PC CHANGE
  6165					;				FC: AB PC EN
  6166
  6167					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 21
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0150

  6168					;THIS TEST VERIFIES THAT CAMGE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  6169					;ONLY WHEN C(AC) IS GREATER THAN OR EQUAL TO C(E)
  6170					;IN THIS CASE, C(AC)=0 AND C(E)=-1;  HENCE CAMGE SHOULD SKIP.
  6171					;OTHEWISE, THE PROGRAM HALTS.
  6172
  6173	033364	400 00 0 00 000000 	B1300:	SETZ			;PRELOAD AC WITH 0
  6174	033365	315 00 0 00 035524 		CAMGE	[-1]		;*CAMGE SHOULD SKIP BECAUSE C(AC) IS GREATER THAN C(E)
  6175						STOP^
  6176	033366	254 04 0 00 033367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6177	033367	324 00 0 00 033370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6178									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6179									;IN THE SUBTEST) TO LOOP ON ERROR^
  6180
  6181					;*****     FAILURE ANALYSIS     *****
  6182					;C(AC0)		C(AC1)		FAILING SIGNAL
  6183
  6184					;				SW: FCE
  6185					;				ET0: COND Q: PC CLK EN
  6186
  6187					;**********
  6188
  6189					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  6190					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E)
  6191					;IN THIS CASE C(AC)=0 AND C(E)=-1;  HENCE CAMN SHOULD SKIP.
  6192					;OTHERWISE, THE PROGRAM HALTS
  6193
  6194	033370	400 00 0 00 000000 	B1400:	SETZ			;PRELOAD AC WITH 0
  6195	033371	316 00 0 00 035524 		CAMN	[-1]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  6196						STOP^
  6197	033372	254 04 0 00 033373 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6198	033373	324 00 0 00 033374 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6199									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6200									;IN THE SUBTEST) TO LOOP ON ERROR^
  6201
  6202					;*****     FAILURE ANALYSIS     *****
  6203					;C(AC0)		C(AC1)		FAILING SIGNAL
  6204
  6205					;				FC:AD FM + EN
  6206					;				FC: AD AR - EN
  6207					;				FC: AD CRY 36
  6208					;				FC: AD ADD
  6209					;				FC: AB PC EN
  6210					;				ET0: PC CLK EN
  6211
  6212					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 22
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0151

  6213					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  6214					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E)
  6215					;IN THIS CASE, C(AC)=0 AND C(E)=0;  HENCE CAMN SHOULD NOT SKIP.
  6216					;OTHERWISE, THE PROGRAM HALTS
  6217
  6218	033374	400 00 0 00 000000 	B1500:	SETZ			;PRELOAD AC WITH 0
  6219	033375	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD NOT SKIP BECAUSE C(AC)=C(E).
  6220	033376	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAMN PASSES
  6221						STOP^
  6222	033377	254 04 0 00 033400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6223	033400	324 00 0 00 033401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6224									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6225									;IN THE SUBTEST) TO LOOP ON ERROR^
  6226
  6227					;*****     FAILURE ANALYSIS     *****
  6228					;C(AC0)		C(AC1)		FAILING SIGNAL
  6229
  6230					;				SW: FCE
  6231					;				FC: PC CHANGE
  6232
  6233					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 23
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0152

  6234			001600		SN=1600
  6235			000000			ZZ=0
  6236
  6237					B1600:	REPEAT	^D18,<
  6238					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6239					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6240					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6241					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6242					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6243					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6244
  6245					SN=SN+1
  6246						ZZ=ZZ+ZZ
  6247						IFE	ZZ,<ZZ=1>
  6248						MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6249						CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6250						CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6251						STOP
  6252
  6253					;*****     FAILURE ANALYSIS     *****
  6254					;C(AC0)		C(AC1)		FAILING SIGNAL
  6255
  6256					;				ET0: COND P
  6257
  6258					;**********
  6259					>
  6260
  6261					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6262					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6263					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6264					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6265					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6266					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6267
  6268			001601		SN=SN+1
  6269			000000			ZZ=ZZ+ZZ
  6270			000001			IFE	ZZ,<ZZ=1>
  6271	033401	200 00 0 00 035416 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6272	033402	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6273	033403	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6274						STOP^
  6275	033404	254 04 0 00 033405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6276	033405	324 00 0 00 033406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6277									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6278									;IN THE SUBTEST) TO LOOP ON ERROR^
  6279
  6280					;*****     FAILURE ANALYSIS     *****
  6281					;C(AC0)		C(AC1)		FAILING SIGNAL
  6282
  6283					;				ET0: COND P
  6284
  6285					;**********
  6286
  6287
  6288					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 23-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0153

  6289					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6290					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6291					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6292					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6293					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6294
  6295			001602		SN=SN+1
  6296			000002			ZZ=ZZ+ZZ
  6297						IFE	ZZ,<ZZ=1>
  6298	033406	200 00 0 00 035417 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6299	033407	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6300	033410	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6301						STOP^
  6302	033411	254 04 0 00 033412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6303	033412	324 00 0 00 033413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6304									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6305									;IN THE SUBTEST) TO LOOP ON ERROR^
  6306
  6307					;*****     FAILURE ANALYSIS     *****
  6308					;C(AC0)		C(AC1)		FAILING SIGNAL
  6309
  6310					;				ET0: COND P
  6311
  6312					;**********
  6313
  6314
  6315					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6316					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6317					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6318					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6319					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6320					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6321
  6322			001603		SN=SN+1
  6323			000004			ZZ=ZZ+ZZ
  6324						IFE	ZZ,<ZZ=1>
  6325	033413	200 00 0 00 035420 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6326	033414	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6327	033415	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6328						STOP^
  6329	033416	254 04 0 00 033417 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6330	033417	324 00 0 00 033420 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6331									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6332									;IN THE SUBTEST) TO LOOP ON ERROR^
  6333
  6334					;*****     FAILURE ANALYSIS     *****
  6335					;C(AC0)		C(AC1)		FAILING SIGNAL
  6336
  6337					;				ET0: COND P
  6338
  6339					;**********
  6340
  6341
  6342					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6343					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 23-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0154

  6344					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6345					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6346					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6347					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6348
  6349			001604		SN=SN+1
  6350			000010			ZZ=ZZ+ZZ
  6351						IFE	ZZ,<ZZ=1>
  6352	033420	200 00 0 00 035421 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6353	033421	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6354	033422	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6355						STOP^
  6356	033423	254 04 0 00 033424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6357	033424	324 00 0 00 033425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6358									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6359									;IN THE SUBTEST) TO LOOP ON ERROR^
  6360
  6361					;*****     FAILURE ANALYSIS     *****
  6362					;C(AC0)		C(AC1)		FAILING SIGNAL
  6363
  6364					;				ET0: COND P
  6365
  6366					;**********
  6367
  6368
  6369					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6370					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6371					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6372					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6373					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6374					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6375
  6376			001605		SN=SN+1
  6377			000020			ZZ=ZZ+ZZ
  6378						IFE	ZZ,<ZZ=1>
  6379	033425	200 00 0 00 035422 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6380	033426	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6381	033427	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6382						STOP^
  6383	033430	254 04 0 00 033431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6384	033431	324 00 0 00 033432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6385									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6386									;IN THE SUBTEST) TO LOOP ON ERROR^
  6387
  6388					;*****     FAILURE ANALYSIS     *****
  6389					;C(AC0)		C(AC1)		FAILING SIGNAL
  6390
  6391					;				ET0: COND P
  6392
  6393					;**********
  6394
  6395
  6396					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6397					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6398					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 23-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0155

  6399					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6400					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6401					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6402
  6403			001606		SN=SN+1
  6404			000040			ZZ=ZZ+ZZ
  6405						IFE	ZZ,<ZZ=1>
  6406	033432	200 00 0 00 035423 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6407	033433	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6408	033434	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6409						STOP^
  6410	033435	254 04 0 00 033436 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6411	033436	324 00 0 00 033437 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6412									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6413									;IN THE SUBTEST) TO LOOP ON ERROR^
  6414
  6415					;*****     FAILURE ANALYSIS     *****
  6416					;C(AC0)		C(AC1)		FAILING SIGNAL
  6417
  6418					;				ET0: COND P
  6419
  6420					;**********
  6421
  6422
  6423					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6424					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6425					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6426					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6427					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6428					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6429
  6430			001607		SN=SN+1
  6431			000100			ZZ=ZZ+ZZ
  6432						IFE	ZZ,<ZZ=1>
  6433	033437	200 00 0 00 035424 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6434	033440	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6435	033441	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6436						STOP^
  6437	033442	254 04 0 00 033443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6438	033443	324 00 0 00 033444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6439									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6440									;IN THE SUBTEST) TO LOOP ON ERROR^
  6441
  6442					;*****     FAILURE ANALYSIS     *****
  6443					;C(AC0)		C(AC1)		FAILING SIGNAL
  6444
  6445					;				ET0: COND P
  6446
  6447					;**********
  6448
  6449
  6450					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6451					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6452					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6453					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 23-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0156

  6454					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6455					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6456
  6457			001610		SN=SN+1
  6458			000200			ZZ=ZZ+ZZ
  6459						IFE	ZZ,<ZZ=1>
  6460	033444	200 00 0 00 035425 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6461	033445	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6462	033446	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6463						STOP^
  6464	033447	254 04 0 00 033450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6465	033450	324 00 0 00 033451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6466									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6467									;IN THE SUBTEST) TO LOOP ON ERROR^
  6468
  6469					;*****     FAILURE ANALYSIS     *****
  6470					;C(AC0)		C(AC1)		FAILING SIGNAL
  6471
  6472					;				ET0: COND P
  6473
  6474					;**********
  6475
  6476
  6477					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6478					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6479					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6480					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6481					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6482					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6483
  6484			001611		SN=SN+1
  6485			000400			ZZ=ZZ+ZZ
  6486						IFE	ZZ,<ZZ=1>
  6487	033451	200 00 0 00 035426 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6488	033452	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6489	033453	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6490						STOP^
  6491	033454	254 04 0 00 033455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6492	033455	324 00 0 00 033456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6493									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6494									;IN THE SUBTEST) TO LOOP ON ERROR^
  6495
  6496					;*****     FAILURE ANALYSIS     *****
  6497					;C(AC0)		C(AC1)		FAILING SIGNAL
  6498
  6499					;				ET0: COND P
  6500
  6501					;**********
  6502
  6503
  6504					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6505					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6506					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6507					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6508					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 23-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0157

  6509					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6510
  6511			001612		SN=SN+1
  6512			001000			ZZ=ZZ+ZZ
  6513						IFE	ZZ,<ZZ=1>
  6514	033456	200 00 0 00 035427 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6515	033457	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6516	033460	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6517						STOP^
  6518	033461	254 04 0 00 033462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6519	033462	324 00 0 00 033463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6520									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6521									;IN THE SUBTEST) TO LOOP ON ERROR^
  6522
  6523					;*****     FAILURE ANALYSIS     *****
  6524					;C(AC0)		C(AC1)		FAILING SIGNAL
  6525
  6526					;				ET0: COND P
  6527
  6528					;**********
  6529
  6530
  6531					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6532					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6533					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6534					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6535					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6536					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6537
  6538			001613		SN=SN+1
  6539			002000			ZZ=ZZ+ZZ
  6540						IFE	ZZ,<ZZ=1>
  6541	033463	200 00 0 00 035430 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6542	033464	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6543	033465	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6544						STOP^
  6545	033466	254 04 0 00 033467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6546	033467	324 00 0 00 033470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6547									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6548									;IN THE SUBTEST) TO LOOP ON ERROR^
  6549
  6550					;*****     FAILURE ANALYSIS     *****
  6551					;C(AC0)		C(AC1)		FAILING SIGNAL
  6552
  6553					;				ET0: COND P
  6554
  6555					;**********
  6556
  6557
  6558					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6559					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6560					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6561					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6562					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6563					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 23-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0158

  6564
  6565			001614		SN=SN+1
  6566			004000			ZZ=ZZ+ZZ
  6567						IFE	ZZ,<ZZ=1>
  6568	033470	200 00 0 00 035431 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6569	033471	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6570	033472	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6571						STOP^
  6572	033473	254 04 0 00 033474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6573	033474	324 00 0 00 033475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6574									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6575									;IN THE SUBTEST) TO LOOP ON ERROR^
  6576
  6577					;*****     FAILURE ANALYSIS     *****
  6578					;C(AC0)		C(AC1)		FAILING SIGNAL
  6579
  6580					;				ET0: COND P
  6581
  6582					;**********
  6583
  6584
  6585					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6586					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6587					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6588					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6589					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6590					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6591
  6592			001615		SN=SN+1
  6593			010000			ZZ=ZZ+ZZ
  6594						IFE	ZZ,<ZZ=1>
  6595	033475	200 00 0 00 035432 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6596	033476	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6597	033477	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6598						STOP^
  6599	033500	254 04 0 00 033501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6600	033501	324 00 0 00 033502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6601									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6602									;IN THE SUBTEST) TO LOOP ON ERROR^
  6603
  6604					;*****     FAILURE ANALYSIS     *****
  6605					;C(AC0)		C(AC1)		FAILING SIGNAL
  6606
  6607					;				ET0: COND P
  6608
  6609					;**********
  6610
  6611
  6612					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6613					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6614					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6615					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6616					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6617					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6618
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 23-7
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0159

  6619			001616		SN=SN+1
  6620			020000			ZZ=ZZ+ZZ
  6621						IFE	ZZ,<ZZ=1>
  6622	033502	200 00 0 00 035433 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6623	033503	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6624	033504	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6625						STOP^
  6626	033505	254 04 0 00 033506 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6627	033506	324 00 0 00 033507 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6628									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6629									;IN THE SUBTEST) TO LOOP ON ERROR^
  6630
  6631					;*****     FAILURE ANALYSIS     *****
  6632					;C(AC0)		C(AC1)		FAILING SIGNAL
  6633
  6634					;				ET0: COND P
  6635
  6636					;**********
  6637
  6638
  6639					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6640					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6641					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6642					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6643					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6644					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6645
  6646			001617		SN=SN+1
  6647			040000			ZZ=ZZ+ZZ
  6648						IFE	ZZ,<ZZ=1>
  6649	033507	200 00 0 00 035434 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6650	033510	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6651	033511	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6652						STOP^
  6653	033512	254 04 0 00 033513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6654	033513	324 00 0 00 033514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6655									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6656									;IN THE SUBTEST) TO LOOP ON ERROR^
  6657
  6658					;*****     FAILURE ANALYSIS     *****
  6659					;C(AC0)		C(AC1)		FAILING SIGNAL
  6660
  6661					;				ET0: COND P
  6662
  6663					;**********
  6664
  6665
  6666					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6667					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6668					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6669					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6670					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6671					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6672
  6673			001620		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 23-8
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0160

  6674			100000			ZZ=ZZ+ZZ
  6675						IFE	ZZ,<ZZ=1>
  6676	033514	200 00 0 00 035435 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6677	033515	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6678	033516	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6679						STOP^
  6680	033517	254 04 0 00 033520 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6681	033520	324 00 0 00 033521 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6682									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6683									;IN THE SUBTEST) TO LOOP ON ERROR^
  6684
  6685					;*****     FAILURE ANALYSIS     *****
  6686					;C(AC0)		C(AC1)		FAILING SIGNAL
  6687
  6688					;				ET0: COND P
  6689
  6690					;**********
  6691
  6692
  6693					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6694					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6695					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6696					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6697					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6698					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6699
  6700			001621		SN=SN+1
  6701			200000			ZZ=ZZ+ZZ
  6702						IFE	ZZ,<ZZ=1>
  6703	033521	200 00 0 00 035436 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6704	033522	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6705	033523	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6706						STOP^
  6707	033524	254 04 0 00 033525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6708	033525	324 00 0 00 033526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6709									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6710									;IN THE SUBTEST) TO LOOP ON ERROR^
  6711
  6712					;*****     FAILURE ANALYSIS     *****
  6713					;C(AC0)		C(AC1)		FAILING SIGNAL
  6714
  6715					;				ET0: COND P
  6716
  6717					;**********
  6718
  6719
  6720					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6721					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6722					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6723					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6724					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6725					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6726
  6727			001622		SN=SN+1
  6728			400000			ZZ=ZZ+ZZ
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 23-9
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0161

  6729						IFE	ZZ,<ZZ=1>
  6730	033526	200 00 0 00 035437 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
  6731	033527	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6732	033530	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6733						STOP^
  6734	033531	254 04 0 00 033532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6735	033532	324 00 0 00 033533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6736									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6737									;IN THE SUBTEST) TO LOOP ON ERROR^
  6738
  6739					;*****     FAILURE ANALYSIS     *****
  6740					;C(AC0)		C(AC1)		FAILING SIGNAL
  6741
  6742					;				ET0: COND P
  6743
  6744					;**********
  6745
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 24
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0162

  6746			000000			ZZ=0
  6747
  6748						REPEAT	^D18,<
  6749					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6750					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6751					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6752					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6753					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6754					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6755
  6756					SN=SN+1
  6757						ZZ=ZZ+ZZ
  6758						IFE	ZZ,<ZZ=1>
  6759						MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6760						CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6761						CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6762						STOP
  6763
  6764					;**********
  6765					>
  6766
  6767					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6768					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6769					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6770					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6771					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6772					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6773
  6774			001623		SN=SN+1
  6775			000000			ZZ=ZZ+ZZ
  6776			000001			IFE	ZZ,<ZZ=1>
  6777	033533	200 00 0 00 035440 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6778	033534	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6779	033535	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6780						STOP^
  6781	033536	254 04 0 00 033537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6782	033537	324 00 0 00 033540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6783									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6784									;IN THE SUBTEST) TO LOOP ON ERROR^
  6785
  6786					;**********
  6787
  6788
  6789					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6790					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6791					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6792					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6793					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6794					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6795
  6796			001624		SN=SN+1
  6797			000002			ZZ=ZZ+ZZ
  6798						IFE	ZZ,<ZZ=1>
  6799	033540	200 00 0 00 035441 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6800	033541	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 24-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0163

  6801	033542	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6802						STOP^
  6803	033543	254 04 0 00 033544 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6804	033544	324 00 0 00 033545 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6805									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6806									;IN THE SUBTEST) TO LOOP ON ERROR^
  6807
  6808					;**********
  6809
  6810
  6811					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6812					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6813					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6814					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6815					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6816					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6817
  6818			001625		SN=SN+1
  6819			000004			ZZ=ZZ+ZZ
  6820						IFE	ZZ,<ZZ=1>
  6821	033545	200 00 0 00 035442 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6822	033546	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6823	033547	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6824						STOP^
  6825	033550	254 04 0 00 033551 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6826	033551	324 00 0 00 033552 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6827									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6828									;IN THE SUBTEST) TO LOOP ON ERROR^
  6829
  6830					;**********
  6831
  6832
  6833					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6834					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6835					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6836					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6837					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6838					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6839
  6840			001626		SN=SN+1
  6841			000010			ZZ=ZZ+ZZ
  6842						IFE	ZZ,<ZZ=1>
  6843	033552	200 00 0 00 035443 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6844	033553	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6845	033554	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6846						STOP^
  6847	033555	254 04 0 00 033556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6848	033556	324 00 0 00 033557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6849									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6850									;IN THE SUBTEST) TO LOOP ON ERROR^
  6851
  6852					;**********
  6853
  6854
  6855					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 24-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0164

  6856					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6857					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6858					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6859					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6860					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6861
  6862			001627		SN=SN+1
  6863			000020			ZZ=ZZ+ZZ
  6864						IFE	ZZ,<ZZ=1>
  6865	033557	200 00 0 00 035444 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6866	033560	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6867	033561	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6868						STOP^
  6869	033562	254 04 0 00 033563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6870	033563	324 00 0 00 033564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6871									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6872									;IN THE SUBTEST) TO LOOP ON ERROR^
  6873
  6874					;**********
  6875
  6876
  6877					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6878					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6879					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6880					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6881					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6882					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6883
  6884			001630		SN=SN+1
  6885			000040			ZZ=ZZ+ZZ
  6886						IFE	ZZ,<ZZ=1>
  6887	033564	200 00 0 00 035445 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6888	033565	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6889	033566	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6890						STOP^
  6891	033567	254 04 0 00 033570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6892	033570	324 00 0 00 033571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6893									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6894									;IN THE SUBTEST) TO LOOP ON ERROR^
  6895
  6896					;**********
  6897
  6898
  6899					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6900					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6901					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6902					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6903					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6904					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6905
  6906			001631		SN=SN+1
  6907			000100			ZZ=ZZ+ZZ
  6908						IFE	ZZ,<ZZ=1>
  6909	033571	200 00 0 00 035446 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6910	033572	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 24-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0165

  6911	033573	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6912						STOP^
  6913	033574	254 04 0 00 033575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6914	033575	324 00 0 00 033576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6915									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6916									;IN THE SUBTEST) TO LOOP ON ERROR^
  6917
  6918					;**********
  6919
  6920
  6921					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6922					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6923					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6924					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6925					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6926					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6927
  6928			001632		SN=SN+1
  6929			000200			ZZ=ZZ+ZZ
  6930						IFE	ZZ,<ZZ=1>
  6931	033576	200 00 0 00 035447 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6932	033577	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6933	033600	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6934						STOP^
  6935	033601	254 04 0 00 033602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6936	033602	324 00 0 00 033603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6937									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6938									;IN THE SUBTEST) TO LOOP ON ERROR^
  6939
  6940					;**********
  6941
  6942
  6943					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6944					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6945					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6946					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6947					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6948					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6949
  6950			001633		SN=SN+1
  6951			000400			ZZ=ZZ+ZZ
  6952						IFE	ZZ,<ZZ=1>
  6953	033603	200 00 0 00 035450 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6954	033604	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6955	033605	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6956						STOP^
  6957	033606	254 04 0 00 033607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6958	033607	324 00 0 00 033610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6959									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6960									;IN THE SUBTEST) TO LOOP ON ERROR^
  6961
  6962					;**********
  6963
  6964
  6965					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 24-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0166

  6966					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6967					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6968					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6969					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6970					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6971
  6972			001634		SN=SN+1
  6973			001000			ZZ=ZZ+ZZ
  6974						IFE	ZZ,<ZZ=1>
  6975	033610	200 00 0 00 035451 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6976	033611	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6977	033612	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  6978						STOP^
  6979	033613	254 04 0 00 033614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6980	033614	324 00 0 00 033615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6981									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6982									;IN THE SUBTEST) TO LOOP ON ERROR^
  6983
  6984					;**********
  6985
  6986
  6987					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  6988					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  6989					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  6990					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  6991					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  6992					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  6993
  6994			001635		SN=SN+1
  6995			002000			ZZ=ZZ+ZZ
  6996						IFE	ZZ,<ZZ=1>
  6997	033615	200 00 0 00 035452 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  6998	033616	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  6999	033617	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  7000						STOP^
  7001	033620	254 04 0 00 033621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7002	033621	324 00 0 00 033622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7003									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7004									;IN THE SUBTEST) TO LOOP ON ERROR^
  7005
  7006					;**********
  7007
  7008
  7009					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  7010					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  7011					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  7012					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  7013					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  7014					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  7015
  7016			001636		SN=SN+1
  7017			004000			ZZ=ZZ+ZZ
  7018						IFE	ZZ,<ZZ=1>
  7019	033622	200 00 0 00 035453 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  7020	033623	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 24-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0167

  7021	033624	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  7022						STOP^
  7023	033625	254 04 0 00 033626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7024	033626	324 00 0 00 033627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7025									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7026									;IN THE SUBTEST) TO LOOP ON ERROR^
  7027
  7028					;**********
  7029
  7030
  7031					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  7032					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  7033					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  7034					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  7035					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  7036					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  7037
  7038			001637		SN=SN+1
  7039			010000			ZZ=ZZ+ZZ
  7040						IFE	ZZ,<ZZ=1>
  7041	033627	200 00 0 00 035454 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  7042	033630	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  7043	033631	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  7044						STOP^
  7045	033632	254 04 0 00 033633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7046	033633	324 00 0 00 033634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7047									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7048									;IN THE SUBTEST) TO LOOP ON ERROR^
  7049
  7050					;**********
  7051
  7052
  7053					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  7054					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  7055					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  7056					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  7057					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  7058					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  7059
  7060			001640		SN=SN+1
  7061			020000			ZZ=ZZ+ZZ
  7062						IFE	ZZ,<ZZ=1>
  7063	033634	200 00 0 00 035455 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  7064	033635	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  7065	033636	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  7066						STOP^
  7067	033637	254 04 0 00 033640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7068	033640	324 00 0 00 033641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7069									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7070									;IN THE SUBTEST) TO LOOP ON ERROR^
  7071
  7072					;**********
  7073
  7074
  7075					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 24-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0168

  7076					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  7077					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  7078					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  7079					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  7080					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  7081
  7082			001641		SN=SN+1
  7083			040000			ZZ=ZZ+ZZ
  7084						IFE	ZZ,<ZZ=1>
  7085	033641	200 00 0 00 035456 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  7086	033642	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  7087	033643	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  7088						STOP^
  7089	033644	254 04 0 00 033645 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7090	033645	324 00 0 00 033646 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7091									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7092									;IN THE SUBTEST) TO LOOP ON ERROR^
  7093
  7094					;**********
  7095
  7096
  7097					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  7098					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  7099					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  7100					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  7101					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  7102					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  7103
  7104			001642		SN=SN+1
  7105			100000			ZZ=ZZ+ZZ
  7106						IFE	ZZ,<ZZ=1>
  7107	033646	200 00 0 00 035457 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  7108	033647	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  7109	033650	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  7110						STOP^
  7111	033651	254 04 0 00 033652 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7112	033652	324 00 0 00 033653 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7113									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7114									;IN THE SUBTEST) TO LOOP ON ERROR^
  7115
  7116					;**********
  7117
  7118
  7119					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  7120					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  7121					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  7122					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  7123					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  7124					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  7125
  7126			001643		SN=SN+1
  7127			200000			ZZ=ZZ+ZZ
  7128						IFE	ZZ,<ZZ=1>
  7129	033653	200 00 0 00 035460 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  7130	033654	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 24-7
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0169

  7131	033655	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  7132						STOP^
  7133	033656	254 04 0 00 033657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7134	033657	324 00 0 00 033660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7135									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7136									;IN THE SUBTEST) TO LOOP ON ERROR^
  7137
  7138					;**********
  7139
  7140
  7141					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
  7142					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
  7143					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
  7144					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
  7145					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
  7146					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
  7147
  7148			001644		SN=SN+1
  7149			400000			ZZ=ZZ+ZZ
  7150						IFE	ZZ,<ZZ=1>
  7151	033660	200 00 0 00 035461 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
  7152	033661	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)
  7153	033662	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
  7154						STOP^
  7155	033663	254 04 0 00 033664 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7156	033664	324 00 0 00 033665 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7157									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7158									;IN THE SUBTEST) TO LOOP ON ERROR^
  7159
  7160					;**********
  7161
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0170

  7162			001700		SN=1700
  7163			000000			ZZ=0
  7164
  7165					B1700:	REPEAT	^D36,<
  7166					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7167					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7168					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7169					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7170					SN=SN+1
  7171						ZZ=ZZ+ZZ
  7172						IFE	ZZ,<ZZ=1>
  7173						SETZ			;PRELOAD AC WITH 0
  7174						CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7175						STOP
  7176
  7177					;**********
  7178					>
  7179
  7180					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7181					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7182					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7183					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7184			001701		SN=SN+1
  7185			000000			ZZ=ZZ+ZZ
  7186			000001			IFE	ZZ,<ZZ=1>
  7187	033665	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7188	033666	316 00 0 00 035416 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7189						STOP		^
  7190	033667	254 04 0 00 033670 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7191	033670	324 00 0 00 033671 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7192									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7193									;IN THE SUBTEST) TO LOOP ON ERROR^
  7194
  7195					;**********
  7196
  7197
  7198					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7199					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7200					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7201					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7202			001702		SN=SN+1
  7203			000002			ZZ=ZZ+ZZ
  7204						IFE	ZZ,<ZZ=1>
  7205	033671	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7206	033672	316 00 0 00 035417 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7207						STOP		^
  7208	033673	254 04 0 00 033674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7209	033674	324 00 0 00 033675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7210									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7211									;IN THE SUBTEST) TO LOOP ON ERROR^
  7212
  7213					;**********
  7214
  7215
  7216					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0171

  7217					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7218					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7219					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7220			001703		SN=SN+1
  7221			000004			ZZ=ZZ+ZZ
  7222						IFE	ZZ,<ZZ=1>
  7223	033675	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7224	033676	316 00 0 00 035420 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7225						STOP		^
  7226	033677	254 04 0 00 033700 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7227	033700	324 00 0 00 033701 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7228									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7229									;IN THE SUBTEST) TO LOOP ON ERROR^
  7230
  7231					;**********
  7232
  7233
  7234					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7235					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7236					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7237					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7238			001704		SN=SN+1
  7239			000010			ZZ=ZZ+ZZ
  7240						IFE	ZZ,<ZZ=1>
  7241	033701	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7242	033702	316 00 0 00 035421 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7243						STOP		^
  7244	033703	254 04 0 00 033704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7245	033704	324 00 0 00 033705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7246									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7247									;IN THE SUBTEST) TO LOOP ON ERROR^
  7248
  7249					;**********
  7250
  7251
  7252					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7253					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7254					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7255					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7256			001705		SN=SN+1
  7257			000020			ZZ=ZZ+ZZ
  7258						IFE	ZZ,<ZZ=1>
  7259	033705	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7260	033706	316 00 0 00 035422 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7261						STOP		^
  7262	033707	254 04 0 00 033710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7263	033710	324 00 0 00 033711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7264									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7265									;IN THE SUBTEST) TO LOOP ON ERROR^
  7266
  7267					;**********
  7268
  7269
  7270					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7271					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0172

  7272					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7273					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7274			001706		SN=SN+1
  7275			000040			ZZ=ZZ+ZZ
  7276						IFE	ZZ,<ZZ=1>
  7277	033711	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7278	033712	316 00 0 00 035423 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7279						STOP		^
  7280	033713	254 04 0 00 033714 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7281	033714	324 00 0 00 033715 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7282									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7283									;IN THE SUBTEST) TO LOOP ON ERROR^
  7284
  7285					;**********
  7286
  7287
  7288					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7289					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7290					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7291					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7292			001707		SN=SN+1
  7293			000100			ZZ=ZZ+ZZ
  7294						IFE	ZZ,<ZZ=1>
  7295	033715	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7296	033716	316 00 0 00 035424 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7297						STOP		^
  7298	033717	254 04 0 00 033720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7299	033720	324 00 0 00 033721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7300									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7301									;IN THE SUBTEST) TO LOOP ON ERROR^
  7302
  7303					;**********
  7304
  7305
  7306					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7307					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7308					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7309					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7310			001710		SN=SN+1
  7311			000200			ZZ=ZZ+ZZ
  7312						IFE	ZZ,<ZZ=1>
  7313	033721	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7314	033722	316 00 0 00 035425 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7315						STOP		^
  7316	033723	254 04 0 00 033724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7317	033724	324 00 0 00 033725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7318									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7319									;IN THE SUBTEST) TO LOOP ON ERROR^
  7320
  7321					;**********
  7322
  7323
  7324					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7325					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7326					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0173

  7327					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7328			001711		SN=SN+1
  7329			000400			ZZ=ZZ+ZZ
  7330						IFE	ZZ,<ZZ=1>
  7331	033725	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7332	033726	316 00 0 00 035426 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7333						STOP		^
  7334	033727	254 04 0 00 033730 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7335	033730	324 00 0 00 033731 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7336									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7337									;IN THE SUBTEST) TO LOOP ON ERROR^
  7338
  7339					;**********
  7340
  7341
  7342					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7343					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7344					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7345					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7346			001712		SN=SN+1
  7347			001000			ZZ=ZZ+ZZ
  7348						IFE	ZZ,<ZZ=1>
  7349	033731	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7350	033732	316 00 0 00 035427 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7351						STOP		^
  7352	033733	254 04 0 00 033734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7353	033734	324 00 0 00 033735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7354									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7355									;IN THE SUBTEST) TO LOOP ON ERROR^
  7356
  7357					;**********
  7358
  7359
  7360					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7361					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7362					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7363					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7364			001713		SN=SN+1
  7365			002000			ZZ=ZZ+ZZ
  7366						IFE	ZZ,<ZZ=1>
  7367	033735	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7368	033736	316 00 0 00 035430 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7369						STOP		^
  7370	033737	254 04 0 00 033740 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7371	033740	324 00 0 00 033741 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7372									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7373									;IN THE SUBTEST) TO LOOP ON ERROR^
  7374
  7375					;**********
  7376
  7377
  7378					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7379					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7380					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7381					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0174

  7382			001714		SN=SN+1
  7383			004000			ZZ=ZZ+ZZ
  7384						IFE	ZZ,<ZZ=1>
  7385	033741	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7386	033742	316 00 0 00 035431 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7387						STOP		^
  7388	033743	254 04 0 00 033744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7389	033744	324 00 0 00 033745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7390									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7391									;IN THE SUBTEST) TO LOOP ON ERROR^
  7392
  7393					;**********
  7394
  7395
  7396					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7397					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7398					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7399					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7400			001715		SN=SN+1
  7401			010000			ZZ=ZZ+ZZ
  7402						IFE	ZZ,<ZZ=1>
  7403	033745	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7404	033746	316 00 0 00 035432 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7405						STOP		^
  7406	033747	254 04 0 00 033750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7407	033750	324 00 0 00 033751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7408									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7409									;IN THE SUBTEST) TO LOOP ON ERROR^
  7410
  7411					;**********
  7412
  7413
  7414					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7415					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7416					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7417					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7418			001716		SN=SN+1
  7419			020000			ZZ=ZZ+ZZ
  7420						IFE	ZZ,<ZZ=1>
  7421	033751	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7422	033752	316 00 0 00 035433 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7423						STOP		^
  7424	033753	254 04 0 00 033754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7425	033754	324 00 0 00 033755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7426									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7427									;IN THE SUBTEST) TO LOOP ON ERROR^
  7428
  7429					;**********
  7430
  7431
  7432					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7433					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7434					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7435					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7436			001717		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0175

  7437			040000			ZZ=ZZ+ZZ
  7438						IFE	ZZ,<ZZ=1>
  7439	033755	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7440	033756	316 00 0 00 035434 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7441						STOP		^
  7442	033757	254 04 0 00 033760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7443	033760	324 00 0 00 033761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7444									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7445									;IN THE SUBTEST) TO LOOP ON ERROR^
  7446
  7447					;**********
  7448
  7449
  7450					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7451					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7452					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7453					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7454			001720		SN=SN+1
  7455			100000			ZZ=ZZ+ZZ
  7456						IFE	ZZ,<ZZ=1>
  7457	033761	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7458	033762	316 00 0 00 035435 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7459						STOP		^
  7460	033763	254 04 0 00 033764 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7461	033764	324 00 0 00 033765 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7462									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7463									;IN THE SUBTEST) TO LOOP ON ERROR^
  7464
  7465					;**********
  7466
  7467
  7468					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7469					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7470					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7471					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7472			001721		SN=SN+1
  7473			200000			ZZ=ZZ+ZZ
  7474						IFE	ZZ,<ZZ=1>
  7475	033765	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7476	033766	316 00 0 00 035436 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7477						STOP		^
  7478	033767	254 04 0 00 033770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7479	033770	324 00 0 00 033771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7480									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7481									;IN THE SUBTEST) TO LOOP ON ERROR^
  7482
  7483					;**********
  7484
  7485
  7486					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7487					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7488					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7489					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7490			001722		SN=SN+1
  7491			400000			ZZ=ZZ+ZZ
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0176

  7492						IFE	ZZ,<ZZ=1>
  7493	033771	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7494	033772	316 00 0 00 035437 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7495						STOP		^
  7496	033773	254 04 0 00 033774 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7497	033774	324 00 0 00 033775 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7498									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7499									;IN THE SUBTEST) TO LOOP ON ERROR^
  7500
  7501					;**********
  7502
  7503
  7504					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7505					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7506					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7507					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7508			001723		SN=SN+1
  7509		000001	000000			ZZ=ZZ+ZZ
  7510						IFE	ZZ,<ZZ=1>
  7511	033775	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7512	033776	316 00 0 00 035440 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7513						STOP		^
  7514	033777	254 04 0 00 034000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7515	034000	324 00 0 00 034001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7516									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7517									;IN THE SUBTEST) TO LOOP ON ERROR^
  7518
  7519					;**********
  7520
  7521
  7522					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7523					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7524					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7525					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7526			001724		SN=SN+1
  7527		000002	000000			ZZ=ZZ+ZZ
  7528						IFE	ZZ,<ZZ=1>
  7529	034001	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7530	034002	316 00 0 00 035441 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7531						STOP		^
  7532	034003	254 04 0 00 034004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7533	034004	324 00 0 00 034005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7534									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7535									;IN THE SUBTEST) TO LOOP ON ERROR^
  7536
  7537					;**********
  7538
  7539
  7540					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7541					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7542					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7543					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7544			001725		SN=SN+1
  7545		000004	000000			ZZ=ZZ+ZZ
  7546						IFE	ZZ,<ZZ=1>
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-7
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0177

  7547	034005	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7548	034006	316 00 0 00 035442 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7549						STOP		^
  7550	034007	254 04 0 00 034010 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7551	034010	324 00 0 00 034011 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7552									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7553									;IN THE SUBTEST) TO LOOP ON ERROR^
  7554
  7555					;**********
  7556
  7557
  7558					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7559					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7560					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7561					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7562			001726		SN=SN+1
  7563		000010	000000			ZZ=ZZ+ZZ
  7564						IFE	ZZ,<ZZ=1>
  7565	034011	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7566	034012	316 00 0 00 035443 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7567						STOP		^
  7568	034013	254 04 0 00 034014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7569	034014	324 00 0 00 034015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7570									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7571									;IN THE SUBTEST) TO LOOP ON ERROR^
  7572
  7573					;**********
  7574
  7575
  7576					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7577					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7578					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7579					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7580			001727		SN=SN+1
  7581		000020	000000			ZZ=ZZ+ZZ
  7582						IFE	ZZ,<ZZ=1>
  7583	034015	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7584	034016	316 00 0 00 035444 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7585						STOP		^
  7586	034017	254 04 0 00 034020 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7587	034020	324 00 0 00 034021 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7588									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7589									;IN THE SUBTEST) TO LOOP ON ERROR^
  7590
  7591					;**********
  7592
  7593
  7594					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7595					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7596					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7597					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7598			001730		SN=SN+1
  7599		000040	000000			ZZ=ZZ+ZZ
  7600						IFE	ZZ,<ZZ=1>
  7601	034021	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-8
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0178

  7602	034022	316 00 0 00 035445 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7603						STOP		^
  7604	034023	254 04 0 00 034024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7605	034024	324 00 0 00 034025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7606									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7607									;IN THE SUBTEST) TO LOOP ON ERROR^
  7608
  7609					;**********
  7610
  7611
  7612					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7613					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7614					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7615					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7616			001731		SN=SN+1
  7617		000100	000000			ZZ=ZZ+ZZ
  7618						IFE	ZZ,<ZZ=1>
  7619	034025	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7620	034026	316 00 0 00 035446 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7621						STOP		^
  7622	034027	254 04 0 00 034030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7623	034030	324 00 0 00 034031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7624									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7625									;IN THE SUBTEST) TO LOOP ON ERROR^
  7626
  7627					;**********
  7628
  7629
  7630					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7631					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7632					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7633					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7634			001732		SN=SN+1
  7635		000200	000000			ZZ=ZZ+ZZ
  7636						IFE	ZZ,<ZZ=1>
  7637	034031	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7638	034032	316 00 0 00 035447 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7639						STOP		^
  7640	034033	254 04 0 00 034034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7641	034034	324 00 0 00 034035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7642									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7643									;IN THE SUBTEST) TO LOOP ON ERROR^
  7644
  7645					;**********
  7646
  7647
  7648					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7649					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7650					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7651					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7652			001733		SN=SN+1
  7653		000400	000000			ZZ=ZZ+ZZ
  7654						IFE	ZZ,<ZZ=1>
  7655	034035	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7656	034036	316 00 0 00 035450 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-9
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0179

  7657						STOP		^
  7658	034037	254 04 0 00 034040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7659	034040	324 00 0 00 034041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7660									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7661									;IN THE SUBTEST) TO LOOP ON ERROR^
  7662
  7663					;**********
  7664
  7665
  7666					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7667					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7668					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7669					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7670			001734		SN=SN+1
  7671		001000	000000			ZZ=ZZ+ZZ
  7672						IFE	ZZ,<ZZ=1>
  7673	034041	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7674	034042	316 00 0 00 035451 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7675						STOP		^
  7676	034043	254 04 0 00 034044 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7677	034044	324 00 0 00 034045 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7678									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7679									;IN THE SUBTEST) TO LOOP ON ERROR^
  7680
  7681					;**********
  7682
  7683
  7684					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7685					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7686					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7687					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7688			001735		SN=SN+1
  7689		002000	000000			ZZ=ZZ+ZZ
  7690						IFE	ZZ,<ZZ=1>
  7691	034045	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7692	034046	316 00 0 00 035452 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7693						STOP		^
  7694	034047	254 04 0 00 034050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7695	034050	324 00 0 00 034051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7696									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7697									;IN THE SUBTEST) TO LOOP ON ERROR^
  7698
  7699					;**********
  7700
  7701
  7702					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7703					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7704					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7705					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7706			001736		SN=SN+1
  7707		004000	000000			ZZ=ZZ+ZZ
  7708						IFE	ZZ,<ZZ=1>
  7709	034051	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7710	034052	316 00 0 00 035453 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7711						STOP		^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-10
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0180

  7712	034053	254 04 0 00 034054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7713	034054	324 00 0 00 034055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7714									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7715									;IN THE SUBTEST) TO LOOP ON ERROR^
  7716
  7717					;**********
  7718
  7719
  7720					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7721					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7722					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7723					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7724			001737		SN=SN+1
  7725		010000	000000			ZZ=ZZ+ZZ
  7726						IFE	ZZ,<ZZ=1>
  7727	034055	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7728	034056	316 00 0 00 035454 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7729						STOP		^
  7730	034057	254 04 0 00 034060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7731	034060	324 00 0 00 034061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7732									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7733									;IN THE SUBTEST) TO LOOP ON ERROR^
  7734
  7735					;**********
  7736
  7737
  7738					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7739					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7740					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7741					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7742			001740		SN=SN+1
  7743		020000	000000			ZZ=ZZ+ZZ
  7744						IFE	ZZ,<ZZ=1>
  7745	034061	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7746	034062	316 00 0 00 035455 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7747						STOP		^
  7748	034063	254 04 0 00 034064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7749	034064	324 00 0 00 034065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7750									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7751									;IN THE SUBTEST) TO LOOP ON ERROR^
  7752
  7753					;**********
  7754
  7755
  7756					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7757					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7758					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7759					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7760			001741		SN=SN+1
  7761		040000	000000			ZZ=ZZ+ZZ
  7762						IFE	ZZ,<ZZ=1>
  7763	034065	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7764	034066	316 00 0 00 035456 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7765						STOP		^
  7766	034067	254 04 0 00 034070 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-11
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0181

  7767	034070	324 00 0 00 034071 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7768									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7769									;IN THE SUBTEST) TO LOOP ON ERROR^
  7770
  7771					;**********
  7772
  7773
  7774					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7775					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7776					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7777					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7778			001742		SN=SN+1
  7779		100000	000000			ZZ=ZZ+ZZ
  7780						IFE	ZZ,<ZZ=1>
  7781	034071	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7782	034072	316 00 0 00 035457 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7783						STOP		^
  7784	034073	254 04 0 00 034074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7785	034074	324 00 0 00 034075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7786									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7787									;IN THE SUBTEST) TO LOOP ON ERROR^
  7788
  7789					;**********
  7790
  7791
  7792					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7793					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7794					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7795					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7796			001743		SN=SN+1
  7797		200000	000000			ZZ=ZZ+ZZ
  7798						IFE	ZZ,<ZZ=1>
  7799	034075	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7800	034076	316 00 0 00 035460 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7801						STOP		^
  7802	034077	254 04 0 00 034100 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7803	034100	324 00 0 00 034101 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7804									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7805									;IN THE SUBTEST) TO LOOP ON ERROR^
  7806
  7807					;**********
  7808
  7809
  7810					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
  7811					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
  7812					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
  7813					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
  7814			001744		SN=SN+1
  7815		400000	000000			ZZ=ZZ+ZZ
  7816						IFE	ZZ,<ZZ=1>
  7817	034101	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
  7818	034102	316 00 0 00 035461 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7819						STOP		^
  7820	034103	254 04 0 00 034104 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7821	034104	324 00 0 00 034105 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 25-12
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0182

  7822									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7823									;IN THE SUBTEST) TO LOOP ON ERROR^
  7824
  7825					;**********
  7826
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0183

  7827			002000		SN=2000
  7828			000000			ZZ=0
  7829
  7830					B2000:	REPEAT	^D36,<
  7831					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  7832					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  7833					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  7834					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  7835					SN=SN+1
  7836						ZZ=ZZ+ZZ
  7837						IFE	ZZ,<ZZ=1>
  7838						MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  7839						CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7840						STOP
  7841
  7842					;**********
  7843					>
  7844
  7845					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  7846					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  7847					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  7848					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  7849			002001		SN=SN+1
  7850			000000			ZZ=ZZ+ZZ
  7851			000001			IFE	ZZ,<ZZ=1>
  7852	034105	200 00 0 00 035416 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  7853	034106	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7854						STOP^
  7855	034107	254 04 0 00 034110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7856	034110	324 00 0 00 034111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7857									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7858									;IN THE SUBTEST) TO LOOP ON ERROR^
  7859
  7860					;**********
  7861
  7862
  7863					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  7864					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  7865					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  7866					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  7867			002002		SN=SN+1
  7868			000002			ZZ=ZZ+ZZ
  7869						IFE	ZZ,<ZZ=1>
  7870	034111	200 00 0 00 035417 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  7871	034112	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7872						STOP^
  7873	034113	254 04 0 00 034114 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7874	034114	324 00 0 00 034115 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7875									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7876									;IN THE SUBTEST) TO LOOP ON ERROR^
  7877
  7878					;**********
  7879
  7880
  7881					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0184

  7882					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  7883					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  7884					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  7885			002003		SN=SN+1
  7886			000004			ZZ=ZZ+ZZ
  7887						IFE	ZZ,<ZZ=1>
  7888	034115	200 00 0 00 035420 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  7889	034116	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7890						STOP^
  7891	034117	254 04 0 00 034120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7892	034120	324 00 0 00 034121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7893									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7894									;IN THE SUBTEST) TO LOOP ON ERROR^
  7895
  7896					;**********
  7897
  7898
  7899					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  7900					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  7901					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  7902					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  7903			002004		SN=SN+1
  7904			000010			ZZ=ZZ+ZZ
  7905						IFE	ZZ,<ZZ=1>
  7906	034121	200 00 0 00 035421 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  7907	034122	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7908						STOP^
  7909	034123	254 04 0 00 034124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7910	034124	324 00 0 00 034125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7911									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7912									;IN THE SUBTEST) TO LOOP ON ERROR^
  7913
  7914					;**********
  7915
  7916
  7917					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  7918					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  7919					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  7920					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  7921			002005		SN=SN+1
  7922			000020			ZZ=ZZ+ZZ
  7923						IFE	ZZ,<ZZ=1>
  7924	034125	200 00 0 00 035422 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  7925	034126	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7926						STOP^
  7927	034127	254 04 0 00 034130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7928	034130	324 00 0 00 034131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7929									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7930									;IN THE SUBTEST) TO LOOP ON ERROR^
  7931
  7932					;**********
  7933
  7934
  7935					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  7936					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0185

  7937					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  7938					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  7939			002006		SN=SN+1
  7940			000040			ZZ=ZZ+ZZ
  7941						IFE	ZZ,<ZZ=1>
  7942	034131	200 00 0 00 035423 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  7943	034132	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7944						STOP^
  7945	034133	254 04 0 00 034134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7946	034134	324 00 0 00 034135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7947									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7948									;IN THE SUBTEST) TO LOOP ON ERROR^
  7949
  7950					;**********
  7951
  7952
  7953					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  7954					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  7955					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  7956					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  7957			002007		SN=SN+1
  7958			000100			ZZ=ZZ+ZZ
  7959						IFE	ZZ,<ZZ=1>
  7960	034135	200 00 0 00 035424 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  7961	034136	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7962						STOP^
  7963	034137	254 04 0 00 034140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7964	034140	324 00 0 00 034141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7965									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7966									;IN THE SUBTEST) TO LOOP ON ERROR^
  7967
  7968					;**********
  7969
  7970
  7971					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  7972					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  7973					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  7974					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  7975			002010		SN=SN+1
  7976			000200			ZZ=ZZ+ZZ
  7977						IFE	ZZ,<ZZ=1>
  7978	034141	200 00 0 00 035425 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  7979	034142	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7980						STOP^
  7981	034143	254 04 0 00 034144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7982	034144	324 00 0 00 034145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7983									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7984									;IN THE SUBTEST) TO LOOP ON ERROR^
  7985
  7986					;**********
  7987
  7988
  7989					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  7990					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  7991					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0186

  7992					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  7993			002011		SN=SN+1
  7994			000400			ZZ=ZZ+ZZ
  7995						IFE	ZZ,<ZZ=1>
  7996	034145	200 00 0 00 035426 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  7997	034146	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  7998						STOP^
  7999	034147	254 04 0 00 034150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8000	034150	324 00 0 00 034151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8001									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8002									;IN THE SUBTEST) TO LOOP ON ERROR^
  8003
  8004					;**********
  8005
  8006
  8007					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8008					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8009					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8010					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8011			002012		SN=SN+1
  8012			001000			ZZ=ZZ+ZZ
  8013						IFE	ZZ,<ZZ=1>
  8014	034151	200 00 0 00 035427 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8015	034152	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8016						STOP^
  8017	034153	254 04 0 00 034154 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8018	034154	324 00 0 00 034155 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8019									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8020									;IN THE SUBTEST) TO LOOP ON ERROR^
  8021
  8022					;**********
  8023
  8024
  8025					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8026					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8027					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8028					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8029			002013		SN=SN+1
  8030			002000			ZZ=ZZ+ZZ
  8031						IFE	ZZ,<ZZ=1>
  8032	034155	200 00 0 00 035430 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8033	034156	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8034						STOP^
  8035	034157	254 04 0 00 034160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8036	034160	324 00 0 00 034161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8037									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8038									;IN THE SUBTEST) TO LOOP ON ERROR^
  8039
  8040					;**********
  8041
  8042
  8043					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8044					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8045					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8046					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0187

  8047			002014		SN=SN+1
  8048			004000			ZZ=ZZ+ZZ
  8049						IFE	ZZ,<ZZ=1>
  8050	034161	200 00 0 00 035431 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8051	034162	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8052						STOP^
  8053	034163	254 04 0 00 034164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8054	034164	324 00 0 00 034165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8055									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8056									;IN THE SUBTEST) TO LOOP ON ERROR^
  8057
  8058					;**********
  8059
  8060
  8061					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8062					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8063					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8064					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8065			002015		SN=SN+1
  8066			010000			ZZ=ZZ+ZZ
  8067						IFE	ZZ,<ZZ=1>
  8068	034165	200 00 0 00 035432 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8069	034166	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8070						STOP^
  8071	034167	254 04 0 00 034170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8072	034170	324 00 0 00 034171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8073									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8074									;IN THE SUBTEST) TO LOOP ON ERROR^
  8075
  8076					;**********
  8077
  8078
  8079					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8080					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8081					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8082					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8083			002016		SN=SN+1
  8084			020000			ZZ=ZZ+ZZ
  8085						IFE	ZZ,<ZZ=1>
  8086	034171	200 00 0 00 035433 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8087	034172	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8088						STOP^
  8089	034173	254 04 0 00 034174 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8090	034174	324 00 0 00 034175 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8091									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8092									;IN THE SUBTEST) TO LOOP ON ERROR^
  8093
  8094					;**********
  8095
  8096
  8097					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8098					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8099					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8100					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8101			002017		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0188

  8102			040000			ZZ=ZZ+ZZ
  8103						IFE	ZZ,<ZZ=1>
  8104	034175	200 00 0 00 035434 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8105	034176	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8106						STOP^
  8107	034177	254 04 0 00 034200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8108	034200	324 00 0 00 034201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8109									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8110									;IN THE SUBTEST) TO LOOP ON ERROR^
  8111
  8112					;**********
  8113
  8114
  8115					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8116					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8117					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8118					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8119			002020		SN=SN+1
  8120			100000			ZZ=ZZ+ZZ
  8121						IFE	ZZ,<ZZ=1>
  8122	034201	200 00 0 00 035435 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8123	034202	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8124						STOP^
  8125	034203	254 04 0 00 034204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8126	034204	324 00 0 00 034205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8127									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8128									;IN THE SUBTEST) TO LOOP ON ERROR^
  8129
  8130					;**********
  8131
  8132
  8133					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8134					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8135					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8136					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8137			002021		SN=SN+1
  8138			200000			ZZ=ZZ+ZZ
  8139						IFE	ZZ,<ZZ=1>
  8140	034205	200 00 0 00 035436 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8141	034206	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8142						STOP^
  8143	034207	254 04 0 00 034210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8144	034210	324 00 0 00 034211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8145									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8146									;IN THE SUBTEST) TO LOOP ON ERROR^
  8147
  8148					;**********
  8149
  8150
  8151					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8152					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8153					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8154					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8155			002022		SN=SN+1
  8156			400000			ZZ=ZZ+ZZ
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0189

  8157						IFE	ZZ,<ZZ=1>
  8158	034211	200 00 0 00 035437 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8159	034212	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8160						STOP^
  8161	034213	254 04 0 00 034214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8162	034214	324 00 0 00 034215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8163									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8164									;IN THE SUBTEST) TO LOOP ON ERROR^
  8165
  8166					;**********
  8167
  8168
  8169					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8170					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8171					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8172					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8173			002023		SN=SN+1
  8174		000001	000000			ZZ=ZZ+ZZ
  8175						IFE	ZZ,<ZZ=1>
  8176	034215	200 00 0 00 035440 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8177	034216	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8178						STOP^
  8179	034217	254 04 0 00 034220 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8180	034220	324 00 0 00 034221 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8181									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8182									;IN THE SUBTEST) TO LOOP ON ERROR^
  8183
  8184					;**********
  8185
  8186
  8187					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8188					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8189					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8190					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8191			002024		SN=SN+1
  8192		000002	000000			ZZ=ZZ+ZZ
  8193						IFE	ZZ,<ZZ=1>
  8194	034221	200 00 0 00 035441 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8195	034222	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8196						STOP^
  8197	034223	254 04 0 00 034224 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8198	034224	324 00 0 00 034225 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8199									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8200									;IN THE SUBTEST) TO LOOP ON ERROR^
  8201
  8202					;**********
  8203
  8204
  8205					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8206					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8207					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8208					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8209			002025		SN=SN+1
  8210		000004	000000			ZZ=ZZ+ZZ
  8211						IFE	ZZ,<ZZ=1>
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-7
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0190

  8212	034225	200 00 0 00 035442 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8213	034226	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8214						STOP^
  8215	034227	254 04 0 00 034230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8216	034230	324 00 0 00 034231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8217									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8218									;IN THE SUBTEST) TO LOOP ON ERROR^
  8219
  8220					;**********
  8221
  8222
  8223					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8224					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8225					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8226					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8227			002026		SN=SN+1
  8228		000010	000000			ZZ=ZZ+ZZ
  8229						IFE	ZZ,<ZZ=1>
  8230	034231	200 00 0 00 035443 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8231	034232	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8232						STOP^
  8233	034233	254 04 0 00 034234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8234	034234	324 00 0 00 034235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8235									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8236									;IN THE SUBTEST) TO LOOP ON ERROR^
  8237
  8238					;**********
  8239
  8240
  8241					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8242					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8243					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8244					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8245			002027		SN=SN+1
  8246		000020	000000			ZZ=ZZ+ZZ
  8247						IFE	ZZ,<ZZ=1>
  8248	034235	200 00 0 00 035444 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8249	034236	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8250						STOP^
  8251	034237	254 04 0 00 034240 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8252	034240	324 00 0 00 034241 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8253									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8254									;IN THE SUBTEST) TO LOOP ON ERROR^
  8255
  8256					;**********
  8257
  8258
  8259					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8260					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8261					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8262					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8263			002030		SN=SN+1
  8264		000040	000000			ZZ=ZZ+ZZ
  8265						IFE	ZZ,<ZZ=1>
  8266	034241	200 00 0 00 035445 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-8
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0191

  8267	034242	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8268						STOP^
  8269	034243	254 04 0 00 034244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8270	034244	324 00 0 00 034245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8271									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8272									;IN THE SUBTEST) TO LOOP ON ERROR^
  8273
  8274					;**********
  8275
  8276
  8277					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8278					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8279					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8280					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8281			002031		SN=SN+1
  8282		000100	000000			ZZ=ZZ+ZZ
  8283						IFE	ZZ,<ZZ=1>
  8284	034245	200 00 0 00 035446 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8285	034246	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8286						STOP^
  8287	034247	254 04 0 00 034250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8288	034250	324 00 0 00 034251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8289									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8290									;IN THE SUBTEST) TO LOOP ON ERROR^
  8291
  8292					;**********
  8293
  8294
  8295					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8296					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8297					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8298					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8299			002032		SN=SN+1
  8300		000200	000000			ZZ=ZZ+ZZ
  8301						IFE	ZZ,<ZZ=1>
  8302	034251	200 00 0 00 035447 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8303	034252	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8304						STOP^
  8305	034253	254 04 0 00 034254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8306	034254	324 00 0 00 034255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8307									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8308									;IN THE SUBTEST) TO LOOP ON ERROR^
  8309
  8310					;**********
  8311
  8312
  8313					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8314					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8315					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8316					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8317			002033		SN=SN+1
  8318		000400	000000			ZZ=ZZ+ZZ
  8319						IFE	ZZ,<ZZ=1>
  8320	034255	200 00 0 00 035450 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8321	034256	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-9
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0192

  8322						STOP^
  8323	034257	254 04 0 00 034260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8324	034260	324 00 0 00 034261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8325									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8326									;IN THE SUBTEST) TO LOOP ON ERROR^
  8327
  8328					;**********
  8329
  8330
  8331					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8332					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8333					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8334					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8335			002034		SN=SN+1
  8336		001000	000000			ZZ=ZZ+ZZ
  8337						IFE	ZZ,<ZZ=1>
  8338	034261	200 00 0 00 035451 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8339	034262	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8340						STOP^
  8341	034263	254 04 0 00 034264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8342	034264	324 00 0 00 034265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8343									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8344									;IN THE SUBTEST) TO LOOP ON ERROR^
  8345
  8346					;**********
  8347
  8348
  8349					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8350					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8351					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8352					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8353			002035		SN=SN+1
  8354		002000	000000			ZZ=ZZ+ZZ
  8355						IFE	ZZ,<ZZ=1>
  8356	034265	200 00 0 00 035452 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8357	034266	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8358						STOP^
  8359	034267	254 04 0 00 034270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8360	034270	324 00 0 00 034271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8361									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8362									;IN THE SUBTEST) TO LOOP ON ERROR^
  8363
  8364					;**********
  8365
  8366
  8367					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8368					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8369					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8370					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8371			002036		SN=SN+1
  8372		004000	000000			ZZ=ZZ+ZZ
  8373						IFE	ZZ,<ZZ=1>
  8374	034271	200 00 0 00 035453 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8375	034272	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8376						STOP^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-10
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0193

  8377	034273	254 04 0 00 034274 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8378	034274	324 00 0 00 034275 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8379									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8380									;IN THE SUBTEST) TO LOOP ON ERROR^
  8381
  8382					;**********
  8383
  8384
  8385					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8386					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8387					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8388					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8389			002037		SN=SN+1
  8390		010000	000000			ZZ=ZZ+ZZ
  8391						IFE	ZZ,<ZZ=1>
  8392	034275	200 00 0 00 035454 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8393	034276	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8394						STOP^
  8395	034277	254 04 0 00 034300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8396	034300	324 00 0 00 034301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8397									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8398									;IN THE SUBTEST) TO LOOP ON ERROR^
  8399
  8400					;**********
  8401
  8402
  8403					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8404					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8405					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8406					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8407			002040		SN=SN+1
  8408		020000	000000			ZZ=ZZ+ZZ
  8409						IFE	ZZ,<ZZ=1>
  8410	034301	200 00 0 00 035455 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8411	034302	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8412						STOP^
  8413	034303	254 04 0 00 034304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8414	034304	324 00 0 00 034305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8415									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8416									;IN THE SUBTEST) TO LOOP ON ERROR^
  8417
  8418					;**********
  8419
  8420
  8421					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8422					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8423					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8424					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8425			002041		SN=SN+1
  8426		040000	000000			ZZ=ZZ+ZZ
  8427						IFE	ZZ,<ZZ=1>
  8428	034305	200 00 0 00 035456 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8429	034306	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8430						STOP^
  8431	034307	254 04 0 00 034310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-11
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0194

  8432	034310	324 00 0 00 034311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8433									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8434									;IN THE SUBTEST) TO LOOP ON ERROR^
  8435
  8436					;**********
  8437
  8438
  8439					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8440					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8441					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8442					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8443			002042		SN=SN+1
  8444		100000	000000			ZZ=ZZ+ZZ
  8445						IFE	ZZ,<ZZ=1>
  8446	034311	200 00 0 00 035457 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8447	034312	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8448						STOP^
  8449	034313	254 04 0 00 034314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8450	034314	324 00 0 00 034315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8452									;IN THE SUBTEST) TO LOOP ON ERROR^
  8453
  8454					;**********
  8455
  8456
  8457					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8458					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8459					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8460					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8461			002043		SN=SN+1
  8462		200000	000000			ZZ=ZZ+ZZ
  8463						IFE	ZZ,<ZZ=1>
  8464	034315	200 00 0 00 035460 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8465	034316	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8466						STOP^
  8467	034317	254 04 0 00 034320 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8468	034320	324 00 0 00 034321 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8469									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8470									;IN THE SUBTEST) TO LOOP ON ERROR^
  8471
  8472					;**********
  8473
  8474
  8475					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
  8476					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
  8477					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
  8478					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
  8479			002044		SN=SN+1
  8480		400000	000000			ZZ=ZZ+ZZ
  8481						IFE	ZZ,<ZZ=1>
  8482	034321	200 00 0 00 035461 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1
  8483	034322	316 00 0 00 035412 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
  8484						STOP^
  8485	034323	254 04 0 00 034324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8486	034324	324 00 0 00 034325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 26-12
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAMX) INSTRUCTIONS                                                SEQ 0195

  8487									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8488									;IN THE SUBTEST) TO LOOP ON ERROR^
  8489
  8490					;**********
  8491
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 27
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0196

  8492					SUBTTL	TEST OF MOVS INSTRUCTION
  8493
  8494					;**********
  8495
  8496			002100		SN=2100
  8497			000000			ZZ=0
  8498
  8499					B2100:	REPEAT	^D18,<
  8500					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8501					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8502					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8503					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8504
  8505					SN=SN+1
  8506						ZZ=ZZ+ZZ
  8507						IFE	ZZ,<ZZ=1>
  8508						MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8509									;AND MOVE RESULT INTO AC
  8510						CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8511						STOP
  8512
  8513					;**********
  8514					>
  8515
  8516					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8517					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8518					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8519					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8520
  8521			002101		SN=SN+1
  8522			000000			ZZ=ZZ+ZZ
  8523			000001			IFE	ZZ,<ZZ=1>
  8524	034325	204 00 0 00 035410 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8525									;AND MOVE RESULT INTO AC
  8526	034326	312 00 0 00 035410 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8527						STOP		^
  8528	034327	254 04 0 00 034330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8529	034330	324 00 0 00 034331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8530									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8531									;IN THE SUBTEST) TO LOOP ON ERROR^
  8532
  8533					;**********
  8534
  8535
  8536					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8537					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8538					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8539					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8540
  8541			002102		SN=SN+1
  8542			000002			ZZ=ZZ+ZZ
  8543						IFE	ZZ,<ZZ=1>
  8544	034331	204 00 0 00 035541 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8545									;AND MOVE RESULT INTO AC
  8546	034332	312 00 0 00 035541 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 27-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0197

  8547						STOP		^
  8548	034333	254 04 0 00 034334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8549	034334	324 00 0 00 034335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8550									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8551									;IN THE SUBTEST) TO LOOP ON ERROR^
  8552
  8553					;**********
  8554
  8555
  8556					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8557					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8558					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8559					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8560
  8561			002103		SN=SN+1
  8562			000004			ZZ=ZZ+ZZ
  8563						IFE	ZZ,<ZZ=1>
  8564	034335	204 00 0 00 035542 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8565									;AND MOVE RESULT INTO AC
  8566	034336	312 00 0 00 035542 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8567						STOP		^
  8568	034337	254 04 0 00 034340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8569	034340	324 00 0 00 034341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8570									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8571									;IN THE SUBTEST) TO LOOP ON ERROR^
  8572
  8573					;**********
  8574
  8575
  8576					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8577					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8578					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8579					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8580
  8581			002104		SN=SN+1
  8582			000010			ZZ=ZZ+ZZ
  8583						IFE	ZZ,<ZZ=1>
  8584	034341	204 00 0 00 035543 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8585									;AND MOVE RESULT INTO AC
  8586	034342	312 00 0 00 035543 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8587						STOP		^
  8588	034343	254 04 0 00 034344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8589	034344	324 00 0 00 034345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8590									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8591									;IN THE SUBTEST) TO LOOP ON ERROR^
  8592
  8593					;**********
  8594
  8595
  8596					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8597					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8598					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8599					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8600
  8601			002105		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 27-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0198

  8602			000020			ZZ=ZZ+ZZ
  8603						IFE	ZZ,<ZZ=1>
  8604	034345	204 00 0 00 035544 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8605									;AND MOVE RESULT INTO AC
  8606	034346	312 00 0 00 035544 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8607						STOP		^
  8608	034347	254 04 0 00 034350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8609	034350	324 00 0 00 034351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8610									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8611									;IN THE SUBTEST) TO LOOP ON ERROR^
  8612
  8613					;**********
  8614
  8615
  8616					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8617					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8618					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8619					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8620
  8621			002106		SN=SN+1
  8622			000040			ZZ=ZZ+ZZ
  8623						IFE	ZZ,<ZZ=1>
  8624	034351	204 00 0 00 035545 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8625									;AND MOVE RESULT INTO AC
  8626	034352	312 00 0 00 035545 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8627						STOP		^
  8628	034353	254 04 0 00 034354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8629	034354	324 00 0 00 034355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8630									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8631									;IN THE SUBTEST) TO LOOP ON ERROR^
  8632
  8633					;**********
  8634
  8635
  8636					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8637					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8638					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8639					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8640
  8641			002107		SN=SN+1
  8642			000100			ZZ=ZZ+ZZ
  8643						IFE	ZZ,<ZZ=1>
  8644	034355	204 00 0 00 035546 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8645									;AND MOVE RESULT INTO AC
  8646	034356	312 00 0 00 035546 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8647						STOP		^
  8648	034357	254 04 0 00 034360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8649	034360	324 00 0 00 034361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8650									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8651									;IN THE SUBTEST) TO LOOP ON ERROR^
  8652
  8653					;**********
  8654
  8655
  8656					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 27-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0199

  8657					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8658					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8659					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8660
  8661			002110		SN=SN+1
  8662			000200			ZZ=ZZ+ZZ
  8663						IFE	ZZ,<ZZ=1>
  8664	034361	204 00 0 00 035547 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8665									;AND MOVE RESULT INTO AC
  8666	034362	312 00 0 00 035547 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8667						STOP		^
  8668	034363	254 04 0 00 034364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8669	034364	324 00 0 00 034365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8670									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8671									;IN THE SUBTEST) TO LOOP ON ERROR^
  8672
  8673					;**********
  8674
  8675
  8676					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8677					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8678					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8679					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8680
  8681			002111		SN=SN+1
  8682			000400			ZZ=ZZ+ZZ
  8683						IFE	ZZ,<ZZ=1>
  8684	034365	204 00 0 00 035550 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8685									;AND MOVE RESULT INTO AC
  8686	034366	312 00 0 00 035550 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8687						STOP		^
  8688	034367	254 04 0 00 034370 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8689	034370	324 00 0 00 034371 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8691									;IN THE SUBTEST) TO LOOP ON ERROR^
  8692
  8693					;**********
  8694
  8695
  8696					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8697					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8698					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8699					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8700
  8701			002112		SN=SN+1
  8702			001000			ZZ=ZZ+ZZ
  8703						IFE	ZZ,<ZZ=1>
  8704	034371	204 00 0 00 035551 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8705									;AND MOVE RESULT INTO AC
  8706	034372	312 00 0 00 035551 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8707						STOP		^
  8708	034373	254 04 0 00 034374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8709	034374	324 00 0 00 034375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8710									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8711									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 27-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0200

  8712
  8713					;**********
  8714
  8715
  8716					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8717					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8718					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8719					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8720
  8721			002113		SN=SN+1
  8722			002000			ZZ=ZZ+ZZ
  8723						IFE	ZZ,<ZZ=1>
  8724	034375	204 00 0 00 035552 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8725									;AND MOVE RESULT INTO AC
  8726	034376	312 00 0 00 035552 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8727						STOP		^
  8728	034377	254 04 0 00 034400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8729	034400	324 00 0 00 034401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8730									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8731									;IN THE SUBTEST) TO LOOP ON ERROR^
  8732
  8733					;**********
  8734
  8735
  8736					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8737					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8738					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8739					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8740
  8741			002114		SN=SN+1
  8742			004000			ZZ=ZZ+ZZ
  8743						IFE	ZZ,<ZZ=1>
  8744	034401	204 00 0 00 035553 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8745									;AND MOVE RESULT INTO AC
  8746	034402	312 00 0 00 035553 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8747						STOP		^
  8748	034403	254 04 0 00 034404 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8749	034404	324 00 0 00 034405 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8750									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8751									;IN THE SUBTEST) TO LOOP ON ERROR^
  8752
  8753					;**********
  8754
  8755
  8756					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8757					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8758					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8759					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8760
  8761			002115		SN=SN+1
  8762			010000			ZZ=ZZ+ZZ
  8763						IFE	ZZ,<ZZ=1>
  8764	034405	204 00 0 00 035554 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8765									;AND MOVE RESULT INTO AC
  8766	034406	312 00 0 00 035554 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 27-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0201

  8767						STOP		^
  8768	034407	254 04 0 00 034410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8769	034410	324 00 0 00 034411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8770									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8771									;IN THE SUBTEST) TO LOOP ON ERROR^
  8772
  8773					;**********
  8774
  8775
  8776					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8777					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8778					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8779					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8780
  8781			002116		SN=SN+1
  8782			020000			ZZ=ZZ+ZZ
  8783						IFE	ZZ,<ZZ=1>
  8784	034411	204 00 0 00 035555 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8785									;AND MOVE RESULT INTO AC
  8786	034412	312 00 0 00 035555 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8787						STOP		^
  8788	034413	254 04 0 00 034414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8789	034414	324 00 0 00 034415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8790									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8791									;IN THE SUBTEST) TO LOOP ON ERROR^
  8792
  8793					;**********
  8794
  8795
  8796					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8797					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8798					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8799					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8800
  8801			002117		SN=SN+1
  8802			040000			ZZ=ZZ+ZZ
  8803						IFE	ZZ,<ZZ=1>
  8804	034415	204 00 0 00 035556 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8805									;AND MOVE RESULT INTO AC
  8806	034416	312 00 0 00 035556 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8807						STOP		^
  8808	034417	254 04 0 00 034420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8809	034420	324 00 0 00 034421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8810									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8811									;IN THE SUBTEST) TO LOOP ON ERROR^
  8812
  8813					;**********
  8814
  8815
  8816					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8817					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8818					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8819					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8820
  8821			002120		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 27-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0202

  8822			100000			ZZ=ZZ+ZZ
  8823						IFE	ZZ,<ZZ=1>
  8824	034421	204 00 0 00 035557 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8825									;AND MOVE RESULT INTO AC
  8826	034422	312 00 0 00 035557 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8827						STOP		^
  8828	034423	254 04 0 00 034424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8829	034424	324 00 0 00 034425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8830									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8831									;IN THE SUBTEST) TO LOOP ON ERROR^
  8832
  8833					;**********
  8834
  8835
  8836					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8837					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8838					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8839					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8840
  8841			002121		SN=SN+1
  8842			200000			ZZ=ZZ+ZZ
  8843						IFE	ZZ,<ZZ=1>
  8844	034425	204 00 0 00 035560 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8845									;AND MOVE RESULT INTO AC
  8846	034426	312 00 0 00 035560 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8847						STOP		^
  8848	034427	254 04 0 00 034430 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8849	034430	324 00 0 00 034431 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8850									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8851									;IN THE SUBTEST) TO LOOP ON ERROR^
  8852
  8853					;**********
  8854
  8855
  8856					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8857					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
  8858					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
  8859					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
  8860
  8861			002122		SN=SN+1
  8862			400000			ZZ=ZZ+ZZ
  8863						IFE	ZZ,<ZZ=1>
  8864	034431	204 00 0 00 035561 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8865									;AND MOVE RESULT INTO AC
  8866	034432	312 00 0 00 035561 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
  8867						STOP		^
  8868	034433	254 04 0 00 034434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8869	034434	324 00 0 00 034435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8871									;IN THE SUBTEST) TO LOOP ON ERROR^
  8872
  8873					;**********
  8874
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 28
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0203

  8875			002200		SN=2200
  8876			000000			ZZ=0
  8877
  8878					B2200:	REPEAT	^D18,<
  8879					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8880					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  8881					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  8882					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  8883
  8884					SN=SN+1
  8885						ZZ=ZZ+ZZ+1
  8886						IFE	<ZZ-1>,<ZZ=-2>
  8887						MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8888									;AND MOVE RESULT INTO AC
  8889						CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  8890						STOP
  8891
  8892					;**********
  8893					>
  8894
  8895					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8896					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  8897					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  8898					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  8899
  8900			002201		SN=SN+1
  8901			000001			ZZ=ZZ+ZZ+1
  8902		777777	777776			IFE	<ZZ-1>,<ZZ=-2>
  8903	034435	204 00 0 00 035562 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8904									;AND MOVE RESULT INTO AC
  8905	034436	312 00 0 00 035562 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  8906						STOP		^
  8907	034437	254 04 0 00 034440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8908	034440	324 00 0 00 034441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8909									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8910									;IN THE SUBTEST) TO LOOP ON ERROR^
  8911
  8912					;**********
  8913
  8914
  8915					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8916					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  8917					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  8918					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  8919
  8920			002202		SN=SN+1
  8921		777777	777775			ZZ=ZZ+ZZ+1
  8922						IFE	<ZZ-1>,<ZZ=-2>
  8923	034441	204 00 0 00 035563 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8924									;AND MOVE RESULT INTO AC
  8925	034442	312 00 0 00 035563 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  8926						STOP		^
  8927	034443	254 04 0 00 034444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8928	034444	324 00 0 00 034445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8929									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 28-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0204

  8930									;IN THE SUBTEST) TO LOOP ON ERROR^
  8931
  8932					;**********
  8933
  8934
  8935					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8936					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  8937					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  8938					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  8939
  8940			002203		SN=SN+1
  8941		777777	777773			ZZ=ZZ+ZZ+1
  8942						IFE	<ZZ-1>,<ZZ=-2>
  8943	034445	204 00 0 00 035564 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8944									;AND MOVE RESULT INTO AC
  8945	034446	312 00 0 00 035564 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  8946						STOP		^
  8947	034447	254 04 0 00 034450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8948	034450	324 00 0 00 034451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8949									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8950									;IN THE SUBTEST) TO LOOP ON ERROR^
  8951
  8952					;**********
  8953
  8954
  8955					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8956					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  8957					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  8958					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  8959
  8960			002204		SN=SN+1
  8961		777777	777767			ZZ=ZZ+ZZ+1
  8962						IFE	<ZZ-1>,<ZZ=-2>
  8963	034451	204 00 0 00 035565 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8964									;AND MOVE RESULT INTO AC
  8965	034452	312 00 0 00 035565 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  8966						STOP		^
  8967	034453	254 04 0 00 034454 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8968	034454	324 00 0 00 034455 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8969									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8970									;IN THE SUBTEST) TO LOOP ON ERROR^
  8971
  8972					;**********
  8973
  8974
  8975					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8976					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  8977					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  8978					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  8979
  8980			002205		SN=SN+1
  8981		777777	777757			ZZ=ZZ+ZZ+1
  8982						IFE	<ZZ-1>,<ZZ=-2>
  8983	034455	204 00 0 00 035566 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  8984									;AND MOVE RESULT INTO AC
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 28-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0205

  8985	034456	312 00 0 00 035566 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  8986						STOP		^
  8987	034457	254 04 0 00 034460 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8988	034460	324 00 0 00 034461 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8989									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8990									;IN THE SUBTEST) TO LOOP ON ERROR^
  8991
  8992					;**********
  8993
  8994
  8995					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  8996					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  8997					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  8998					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  8999
  9000			002206		SN=SN+1
  9001		777777	777737			ZZ=ZZ+ZZ+1
  9002						IFE	<ZZ-1>,<ZZ=-2>
  9003	034461	204 00 0 00 035567 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9004									;AND MOVE RESULT INTO AC
  9005	034462	312 00 0 00 035567 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9006						STOP		^
  9007	034463	254 04 0 00 034464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9008	034464	324 00 0 00 034465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9009									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9010									;IN THE SUBTEST) TO LOOP ON ERROR^
  9011
  9012					;**********
  9013
  9014
  9015					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9016					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9017					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9018					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9019
  9020			002207		SN=SN+1
  9021		777777	777677			ZZ=ZZ+ZZ+1
  9022						IFE	<ZZ-1>,<ZZ=-2>
  9023	034465	204 00 0 00 035570 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9024									;AND MOVE RESULT INTO AC
  9025	034466	312 00 0 00 035570 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9026						STOP		^
  9027	034467	254 04 0 00 034470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9028	034470	324 00 0 00 034471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9029									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9030									;IN THE SUBTEST) TO LOOP ON ERROR^
  9031
  9032					;**********
  9033
  9034
  9035					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9036					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9037					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9038					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9039
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 28-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0206

  9040			002210		SN=SN+1
  9041		777777	777577			ZZ=ZZ+ZZ+1
  9042						IFE	<ZZ-1>,<ZZ=-2>
  9043	034471	204 00 0 00 035571 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9044									;AND MOVE RESULT INTO AC
  9045	034472	312 00 0 00 035571 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9046						STOP		^
  9047	034473	254 04 0 00 034474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9048	034474	324 00 0 00 034475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9049									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9050									;IN THE SUBTEST) TO LOOP ON ERROR^
  9051
  9052					;**********
  9053
  9054
  9055					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9056					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9057					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9058					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9059
  9060			002211		SN=SN+1
  9061		777777	777377			ZZ=ZZ+ZZ+1
  9062						IFE	<ZZ-1>,<ZZ=-2>
  9063	034475	204 00 0 00 035572 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9064									;AND MOVE RESULT INTO AC
  9065	034476	312 00 0 00 035572 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9066						STOP		^
  9067	034477	254 04 0 00 034500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9068	034500	324 00 0 00 034501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9069									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9070									;IN THE SUBTEST) TO LOOP ON ERROR^
  9071
  9072					;**********
  9073
  9074
  9075					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9076					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9077					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9078					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9079
  9080			002212		SN=SN+1
  9081		777777	776777			ZZ=ZZ+ZZ+1
  9082						IFE	<ZZ-1>,<ZZ=-2>
  9083	034501	204 00 0 00 035573 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9084									;AND MOVE RESULT INTO AC
  9085	034502	312 00 0 00 035573 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9086						STOP		^
  9087	034503	254 04 0 00 034504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9088	034504	324 00 0 00 034505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9089									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9090									;IN THE SUBTEST) TO LOOP ON ERROR^
  9091
  9092					;**********
  9093
  9094
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 28-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0207

  9095					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9096					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9097					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9098					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9099
  9100			002213		SN=SN+1
  9101		777777	775777			ZZ=ZZ+ZZ+1
  9102						IFE	<ZZ-1>,<ZZ=-2>
  9103	034505	204 00 0 00 035574 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9104									;AND MOVE RESULT INTO AC
  9105	034506	312 00 0 00 035574 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9106						STOP		^
  9107	034507	254 04 0 00 034510 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9108	034510	324 00 0 00 034511 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9109									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9110									;IN THE SUBTEST) TO LOOP ON ERROR^
  9111
  9112					;**********
  9113
  9114
  9115					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9116					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9117					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9118					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9119
  9120			002214		SN=SN+1
  9121		777777	773777			ZZ=ZZ+ZZ+1
  9122						IFE	<ZZ-1>,<ZZ=-2>
  9123	034511	204 00 0 00 035575 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9124									;AND MOVE RESULT INTO AC
  9125	034512	312 00 0 00 035575 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9126						STOP		^
  9127	034513	254 04 0 00 034514 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9128	034514	324 00 0 00 034515 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9129									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9130									;IN THE SUBTEST) TO LOOP ON ERROR^
  9131
  9132					;**********
  9133
  9134
  9135					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9136					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9137					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9138					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9139
  9140			002215		SN=SN+1
  9141		777777	767777			ZZ=ZZ+ZZ+1
  9142						IFE	<ZZ-1>,<ZZ=-2>
  9143	034515	204 00 0 00 035576 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9144									;AND MOVE RESULT INTO AC
  9145	034516	312 00 0 00 035576 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9146						STOP		^
  9147	034517	254 04 0 00 034520 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9148	034520	324 00 0 00 034521 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9149									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 28-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0208

  9150									;IN THE SUBTEST) TO LOOP ON ERROR^
  9151
  9152					;**********
  9153
  9154
  9155					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9156					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9157					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9158					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9159
  9160			002216		SN=SN+1
  9161		777777	757777			ZZ=ZZ+ZZ+1
  9162						IFE	<ZZ-1>,<ZZ=-2>
  9163	034521	204 00 0 00 035577 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9164									;AND MOVE RESULT INTO AC
  9165	034522	312 00 0 00 035577 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9166						STOP		^
  9167	034523	254 04 0 00 034524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9168	034524	324 00 0 00 034525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9169									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9170									;IN THE SUBTEST) TO LOOP ON ERROR^
  9171
  9172					;**********
  9173
  9174
  9175					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9176					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9177					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9178					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9179
  9180			002217		SN=SN+1
  9181		777777	737777			ZZ=ZZ+ZZ+1
  9182						IFE	<ZZ-1>,<ZZ=-2>
  9183	034525	204 00 0 00 035600 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9184									;AND MOVE RESULT INTO AC
  9185	034526	312 00 0 00 035600 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9186						STOP		^
  9187	034527	254 04 0 00 034530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9188	034530	324 00 0 00 034531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9189									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9190									;IN THE SUBTEST) TO LOOP ON ERROR^
  9191
  9192					;**********
  9193
  9194
  9195					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9196					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9197					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9198					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9199
  9200			002220		SN=SN+1
  9201		777777	677777			ZZ=ZZ+ZZ+1
  9202						IFE	<ZZ-1>,<ZZ=-2>
  9203	034531	204 00 0 00 035601 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9204									;AND MOVE RESULT INTO AC
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 28-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0209

  9205	034532	312 00 0 00 035601 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9206						STOP		^
  9207	034533	254 04 0 00 034534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9208	034534	324 00 0 00 034535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9209									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9210									;IN THE SUBTEST) TO LOOP ON ERROR^
  9211
  9212					;**********
  9213
  9214
  9215					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9216					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9217					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9218					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9219
  9220			002221		SN=SN+1
  9221		777777	577777			ZZ=ZZ+ZZ+1
  9222						IFE	<ZZ-1>,<ZZ=-2>
  9223	034535	204 00 0 00 035602 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9224									;AND MOVE RESULT INTO AC
  9225	034536	312 00 0 00 035602 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9226						STOP		^
  9227	034537	254 04 0 00 034540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9228	034540	324 00 0 00 034541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9229									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9230									;IN THE SUBTEST) TO LOOP ON ERROR^
  9231
  9232					;**********
  9233
  9234
  9235					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9236					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
  9237					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
  9238					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
  9239
  9240			002222		SN=SN+1
  9241		777777	377777			ZZ=ZZ+ZZ+1
  9242						IFE	<ZZ-1>,<ZZ=-2>
  9243	034541	204 00 0 00 035603 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9244									;AND MOVE RESULT INTO AC
  9245	034542	312 00 0 00 035603 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
  9246						STOP		^
  9247	034543	254 04 0 00 034544 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9248	034544	324 00 0 00 034545 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9249									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9250									;IN THE SUBTEST) TO LOOP ON ERROR^
  9251
  9252					;**********
  9253
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 29
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0210

  9254			002300		SN=2300
  9255			000000			ZZ=0
  9256			000000			YY=0
  9257
  9258					B2300:	REPEAT	^D18,<
  9259					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9260					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9261					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9262					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9263					;THEN, C(AC) IS CHECKED.
  9264					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9265					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9266
  9267					SN=SN+1
  9268						ZZ=ZZ+ZZ
  9269						YY=YY+YY+1
  9270						IFE	ZZ,<ZZ=1>
  9271						IFE	<YY-1>,<YY=-2>
  9272						MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9273									;AND MOVE RESULT INTO AC
  9274						CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9275						STOP
  9276
  9277					;**********
  9278					>
  9279
  9280					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9281					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9282					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9283					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9284					;THEN, C(AC) IS CHECKED.
  9285					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9286					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9287
  9288			002301		SN=SN+1
  9289			000000			ZZ=ZZ+ZZ
  9290			000001			YY=YY+YY+1
  9291			000001			IFE	ZZ,<ZZ=1>
  9292		777777	777776			IFE	<YY-1>,<YY=-2>
  9293	034545	204 00 0 00 035604 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9294									;AND MOVE RESULT INTO AC
  9295	034546	312 00 0 00 035605 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9296						STOP		^
  9297	034547	254 04 0 00 034550 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9298	034550	324 00 0 00 034551 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9299									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9300									;IN THE SUBTEST) TO LOOP ON ERROR^
  9301
  9302					;**********
  9303
  9304
  9305					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9306					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9307					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9308					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 29-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0211

  9309					;THEN, C(AC) IS CHECKED.
  9310					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9311					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9312
  9313			002302		SN=SN+1
  9314			000002			ZZ=ZZ+ZZ
  9315		777777	777775			YY=YY+YY+1
  9316						IFE	ZZ,<ZZ=1>
  9317						IFE	<YY-1>,<YY=-2>
  9318	034551	204 00 0 00 035606 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9319									;AND MOVE RESULT INTO AC
  9320	034552	312 00 0 00 035607 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9321						STOP		^
  9322	034553	254 04 0 00 034554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9323	034554	324 00 0 00 034555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9324									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9325									;IN THE SUBTEST) TO LOOP ON ERROR^
  9326
  9327					;**********
  9328
  9329
  9330					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9331					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9332					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9333					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9334					;THEN, C(AC) IS CHECKED.
  9335					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9336					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9337
  9338			002303		SN=SN+1
  9339			000004			ZZ=ZZ+ZZ
  9340		777777	777773			YY=YY+YY+1
  9341						IFE	ZZ,<ZZ=1>
  9342						IFE	<YY-1>,<YY=-2>
  9343	034555	204 00 0 00 035610 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9344									;AND MOVE RESULT INTO AC
  9345	034556	312 00 0 00 035611 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9346						STOP		^
  9347	034557	254 04 0 00 034560 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9348	034560	324 00 0 00 034561 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9349									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9350									;IN THE SUBTEST) TO LOOP ON ERROR^
  9351
  9352					;**********
  9353
  9354
  9355					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9356					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9357					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9358					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9359					;THEN, C(AC) IS CHECKED.
  9360					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9361					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9362
  9363			002304		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 29-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0212

  9364			000010			ZZ=ZZ+ZZ
  9365		777777	777767			YY=YY+YY+1
  9366						IFE	ZZ,<ZZ=1>
  9367						IFE	<YY-1>,<YY=-2>
  9368	034561	204 00 0 00 035612 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9369									;AND MOVE RESULT INTO AC
  9370	034562	312 00 0 00 035613 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9371						STOP		^
  9372	034563	254 04 0 00 034564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9373	034564	324 00 0 00 034565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9374									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9375									;IN THE SUBTEST) TO LOOP ON ERROR^
  9376
  9377					;**********
  9378
  9379
  9380					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9381					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9382					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9383					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9384					;THEN, C(AC) IS CHECKED.
  9385					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9386					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9387
  9388			002305		SN=SN+1
  9389			000020			ZZ=ZZ+ZZ
  9390		777777	777757			YY=YY+YY+1
  9391						IFE	ZZ,<ZZ=1>
  9392						IFE	<YY-1>,<YY=-2>
  9393	034565	204 00 0 00 035614 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9394									;AND MOVE RESULT INTO AC
  9395	034566	312 00 0 00 035615 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9396						STOP		^
  9397	034567	254 04 0 00 034570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9398	034570	324 00 0 00 034571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9399									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9400									;IN THE SUBTEST) TO LOOP ON ERROR^
  9401
  9402					;**********
  9403
  9404
  9405					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9406					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9407					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9408					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9409					;THEN, C(AC) IS CHECKED.
  9410					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9411					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9412
  9413			002306		SN=SN+1
  9414			000040			ZZ=ZZ+ZZ
  9415		777777	777737			YY=YY+YY+1
  9416						IFE	ZZ,<ZZ=1>
  9417						IFE	<YY-1>,<YY=-2>
  9418	034571	204 00 0 00 035616 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 29-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0213

  9419									;AND MOVE RESULT INTO AC
  9420	034572	312 00 0 00 035617 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9421						STOP		^
  9422	034573	254 04 0 00 034574 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9423	034574	324 00 0 00 034575 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9424									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9425									;IN THE SUBTEST) TO LOOP ON ERROR^
  9426
  9427					;**********
  9428
  9429
  9430					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9431					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9432					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9433					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9434					;THEN, C(AC) IS CHECKED.
  9435					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9436					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9437
  9438			002307		SN=SN+1
  9439			000100			ZZ=ZZ+ZZ
  9440		777777	777677			YY=YY+YY+1
  9441						IFE	ZZ,<ZZ=1>
  9442						IFE	<YY-1>,<YY=-2>
  9443	034575	204 00 0 00 035620 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9444									;AND MOVE RESULT INTO AC
  9445	034576	312 00 0 00 035621 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9446						STOP		^
  9447	034577	254 04 0 00 034600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9448	034600	324 00 0 00 034601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9449									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9450									;IN THE SUBTEST) TO LOOP ON ERROR^
  9451
  9452					;**********
  9453
  9454
  9455					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9456					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9457					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9458					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9459					;THEN, C(AC) IS CHECKED.
  9460					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9461					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9462
  9463			002310		SN=SN+1
  9464			000200			ZZ=ZZ+ZZ
  9465		777777	777577			YY=YY+YY+1
  9466						IFE	ZZ,<ZZ=1>
  9467						IFE	<YY-1>,<YY=-2>
  9468	034601	204 00 0 00 035622 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9469									;AND MOVE RESULT INTO AC
  9470	034602	312 00 0 00 035623 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9471						STOP		^
  9472	034603	254 04 0 00 034604 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9473	034604	324 00 0 00 034605 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 29-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0214

  9474									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9475									;IN THE SUBTEST) TO LOOP ON ERROR^
  9476
  9477					;**********
  9478
  9479
  9480					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9481					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9482					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9483					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9484					;THEN, C(AC) IS CHECKED.
  9485					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9486					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9487
  9488			002311		SN=SN+1
  9489			000400			ZZ=ZZ+ZZ
  9490		777777	777377			YY=YY+YY+1
  9491						IFE	ZZ,<ZZ=1>
  9492						IFE	<YY-1>,<YY=-2>
  9493	034605	204 00 0 00 035624 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9494									;AND MOVE RESULT INTO AC
  9495	034606	312 00 0 00 035625 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9496						STOP		^
  9497	034607	254 04 0 00 034610 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9498	034610	324 00 0 00 034611 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9499									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9500									;IN THE SUBTEST) TO LOOP ON ERROR^
  9501
  9502					;**********
  9503
  9504
  9505					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9506					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9507					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9508					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9509					;THEN, C(AC) IS CHECKED.
  9510					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9511					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9512
  9513			002312		SN=SN+1
  9514			001000			ZZ=ZZ+ZZ
  9515		777777	776777			YY=YY+YY+1
  9516						IFE	ZZ,<ZZ=1>
  9517						IFE	<YY-1>,<YY=-2>
  9518	034611	204 00 0 00 035626 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9519									;AND MOVE RESULT INTO AC
  9520	034612	312 00 0 00 035627 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9521						STOP		^
  9522	034613	254 04 0 00 034614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9523	034614	324 00 0 00 034615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9524									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9525									;IN THE SUBTEST) TO LOOP ON ERROR^
  9526
  9527					;**********
  9528
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 29-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0215

  9529
  9530					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9531					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9532					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9533					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9534					;THEN, C(AC) IS CHECKED.
  9535					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9536					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9537
  9538			002313		SN=SN+1
  9539			002000			ZZ=ZZ+ZZ
  9540		777777	775777			YY=YY+YY+1
  9541						IFE	ZZ,<ZZ=1>
  9542						IFE	<YY-1>,<YY=-2>
  9543	034615	204 00 0 00 035630 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9544									;AND MOVE RESULT INTO AC
  9545	034616	312 00 0 00 035631 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9546						STOP		^
  9547	034617	254 04 0 00 034620 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9548	034620	324 00 0 00 034621 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9549									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9550									;IN THE SUBTEST) TO LOOP ON ERROR^
  9551
  9552					;**********
  9553
  9554
  9555					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9556					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9557					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9558					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9559					;THEN, C(AC) IS CHECKED.
  9560					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9561					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9562
  9563			002314		SN=SN+1
  9564			004000			ZZ=ZZ+ZZ
  9565		777777	773777			YY=YY+YY+1
  9566						IFE	ZZ,<ZZ=1>
  9567						IFE	<YY-1>,<YY=-2>
  9568	034621	204 00 0 00 035632 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9569									;AND MOVE RESULT INTO AC
  9570	034622	312 00 0 00 035633 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9571						STOP		^
  9572	034623	254 04 0 00 034624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9573	034624	324 00 0 00 034625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9574									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9575									;IN THE SUBTEST) TO LOOP ON ERROR^
  9576
  9577					;**********
  9578
  9579
  9580					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9581					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9582					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9583					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 29-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0216

  9584					;THEN, C(AC) IS CHECKED.
  9585					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9586					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9587
  9588			002315		SN=SN+1
  9589			010000			ZZ=ZZ+ZZ
  9590		777777	767777			YY=YY+YY+1
  9591						IFE	ZZ,<ZZ=1>
  9592						IFE	<YY-1>,<YY=-2>
  9593	034625	204 00 0 00 035634 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9594									;AND MOVE RESULT INTO AC
  9595	034626	312 00 0 00 035635 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9596						STOP		^
  9597	034627	254 04 0 00 034630 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9598	034630	324 00 0 00 034631 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9599									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9600									;IN THE SUBTEST) TO LOOP ON ERROR^
  9601
  9602					;**********
  9603
  9604
  9605					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9606					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9607					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9608					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9609					;THEN, C(AC) IS CHECKED.
  9610					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9611					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9612
  9613			002316		SN=SN+1
  9614			020000			ZZ=ZZ+ZZ
  9615		777777	757777			YY=YY+YY+1
  9616						IFE	ZZ,<ZZ=1>
  9617						IFE	<YY-1>,<YY=-2>
  9618	034631	204 00 0 00 035636 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9619									;AND MOVE RESULT INTO AC
  9620	034632	312 00 0 00 035637 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9621						STOP		^
  9622	034633	254 04 0 00 034634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9623	034634	324 00 0 00 034635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9624									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9625									;IN THE SUBTEST) TO LOOP ON ERROR^
  9626
  9627					;**********
  9628
  9629
  9630					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9631					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9632					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9633					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9634					;THEN, C(AC) IS CHECKED.
  9635					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9636					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9637
  9638			002317		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 29-7
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0217

  9639			040000			ZZ=ZZ+ZZ
  9640		777777	737777			YY=YY+YY+1
  9641						IFE	ZZ,<ZZ=1>
  9642						IFE	<YY-1>,<YY=-2>
  9643	034635	204 00 0 00 035640 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9644									;AND MOVE RESULT INTO AC
  9645	034636	312 00 0 00 035641 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9646						STOP		^
  9647	034637	254 04 0 00 034640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9648	034640	324 00 0 00 034641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9649									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9650									;IN THE SUBTEST) TO LOOP ON ERROR^
  9651
  9652					;**********
  9653
  9654
  9655					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9656					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9657					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9658					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9659					;THEN, C(AC) IS CHECKED.
  9660					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9661					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9662
  9663			002320		SN=SN+1
  9664			100000			ZZ=ZZ+ZZ
  9665		777777	677777			YY=YY+YY+1
  9666						IFE	ZZ,<ZZ=1>
  9667						IFE	<YY-1>,<YY=-2>
  9668	034641	204 00 0 00 035642 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9669									;AND MOVE RESULT INTO AC
  9670	034642	312 00 0 00 035643 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9671						STOP		^
  9672	034643	254 04 0 00 034644 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9673	034644	324 00 0 00 034645 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9674									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9675									;IN THE SUBTEST) TO LOOP ON ERROR^
  9676
  9677					;**********
  9678
  9679
  9680					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9681					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9682					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9683					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9684					;THEN, C(AC) IS CHECKED.
  9685					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9686					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9687
  9688			002321		SN=SN+1
  9689			200000			ZZ=ZZ+ZZ
  9690		777777	577777			YY=YY+YY+1
  9691						IFE	ZZ,<ZZ=1>
  9692						IFE	<YY-1>,<YY=-2>
  9693	034645	204 00 0 00 035644 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 29-8
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0218

  9694									;AND MOVE RESULT INTO AC
  9695	034646	312 00 0 00 035645 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9696						STOP		^
  9697	034647	254 04 0 00 034650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9698	034650	324 00 0 00 034651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9699									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9700									;IN THE SUBTEST) TO LOOP ON ERROR^
  9701
  9702					;**********
  9703
  9704
  9705					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9706					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
  9707					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
  9708					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9709					;THEN, C(AC) IS CHECKED.
  9710					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9711					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9712
  9713			002322		SN=SN+1
  9714			400000			ZZ=ZZ+ZZ
  9715		777777	377777			YY=YY+YY+1
  9716						IFE	ZZ,<ZZ=1>
  9717						IFE	<YY-1>,<YY=-2>
  9718	034651	204 00 0 00 035646 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9719									;AND MOVE RESULT INTO AC
  9720	034652	312 00 0 00 035647 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
  9721						STOP		^
  9722	034653	254 04 0 00 034654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9723	034654	324 00 0 00 034655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9724									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9725									;IN THE SUBTEST) TO LOOP ON ERROR^
  9726
  9727					;**********
  9728
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 30
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0219

  9729			002400		SN=2400
  9730			000000			ZZ=0
  9731			000000			YY=0
  9732
  9733					B2400:	REPEAT	 ^D18,<
  9734					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9735					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9736					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9737					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9738					;THEN, C(AC) IS CHECKED.
  9739					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9740					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9741
  9742					SN=SN+1
  9743						ZZ=ZZ+ZZ
  9744						YY=YY+YY+1
  9745						IFE	ZZ,<ZZ=1>
  9746						IFE	<YY-1>,<YY=-2>
  9747						MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9748									;AND MOVE RESULT INTO AC
  9749						CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9750						STOP
  9751
  9752					;**********
  9753					>
  9754
  9755					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9756					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9757					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9758					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9759					;THEN, C(AC) IS CHECKED.
  9760					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9761					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9762
  9763			002401		SN=SN+1
  9764			000000			ZZ=ZZ+ZZ
  9765			000001			YY=YY+YY+1
  9766			000001			IFE	ZZ,<ZZ=1>
  9767		777777	777776			IFE	<YY-1>,<YY=-2>
  9768	034655	204 00 0 00 035605 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9769									;AND MOVE RESULT INTO AC
  9770	034656	312 00 0 00 035604 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9771						STOP		^
  9772	034657	254 04 0 00 034660 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9773	034660	324 00 0 00 034661 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9774									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9775									;IN THE SUBTEST) TO LOOP ON ERROR^
  9776
  9777					;**********
  9778
  9779
  9780					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9781					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9782					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9783					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 30-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0220

  9784					;THEN, C(AC) IS CHECKED.
  9785					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9786					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9787
  9788			002402		SN=SN+1
  9789			000002			ZZ=ZZ+ZZ
  9790		777777	777775			YY=YY+YY+1
  9791						IFE	ZZ,<ZZ=1>
  9792						IFE	<YY-1>,<YY=-2>
  9793	034661	204 00 0 00 035607 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9794									;AND MOVE RESULT INTO AC
  9795	034662	312 00 0 00 035606 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9796						STOP		^
  9797	034663	254 04 0 00 034664 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9798	034664	324 00 0 00 034665 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9799									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9800									;IN THE SUBTEST) TO LOOP ON ERROR^
  9801
  9802					;**********
  9803
  9804
  9805					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9806					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9807					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9808					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9809					;THEN, C(AC) IS CHECKED.
  9810					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9811					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9812
  9813			002403		SN=SN+1
  9814			000004			ZZ=ZZ+ZZ
  9815		777777	777773			YY=YY+YY+1
  9816						IFE	ZZ,<ZZ=1>
  9817						IFE	<YY-1>,<YY=-2>
  9818	034665	204 00 0 00 035611 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9819									;AND MOVE RESULT INTO AC
  9820	034666	312 00 0 00 035610 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9821						STOP		^
  9822	034667	254 04 0 00 034670 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9823	034670	324 00 0 00 034671 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9824									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9825									;IN THE SUBTEST) TO LOOP ON ERROR^
  9826
  9827					;**********
  9828
  9829
  9830					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9831					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9832					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9833					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9834					;THEN, C(AC) IS CHECKED.
  9835					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9836					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9837
  9838			002404		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 30-2
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0221

  9839			000010			ZZ=ZZ+ZZ
  9840		777777	777767			YY=YY+YY+1
  9841						IFE	ZZ,<ZZ=1>
  9842						IFE	<YY-1>,<YY=-2>
  9843	034671	204 00 0 00 035613 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9844									;AND MOVE RESULT INTO AC
  9845	034672	312 00 0 00 035612 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9846						STOP		^
  9847	034673	254 04 0 00 034674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9848	034674	324 00 0 00 034675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9849									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9850									;IN THE SUBTEST) TO LOOP ON ERROR^
  9851
  9852					;**********
  9853
  9854
  9855					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9856					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9857					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9858					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9859					;THEN, C(AC) IS CHECKED.
  9860					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9861					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9862
  9863			002405		SN=SN+1
  9864			000020			ZZ=ZZ+ZZ
  9865		777777	777757			YY=YY+YY+1
  9866						IFE	ZZ,<ZZ=1>
  9867						IFE	<YY-1>,<YY=-2>
  9868	034675	204 00 0 00 035615 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9869									;AND MOVE RESULT INTO AC
  9870	034676	312 00 0 00 035614 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9871						STOP		^
  9872	034677	254 04 0 00 034700 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9873	034700	324 00 0 00 034701 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9874									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9875									;IN THE SUBTEST) TO LOOP ON ERROR^
  9876
  9877					;**********
  9878
  9879
  9880					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9881					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9882					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9883					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9884					;THEN, C(AC) IS CHECKED.
  9885					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9886					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9887
  9888			002406		SN=SN+1
  9889			000040			ZZ=ZZ+ZZ
  9890		777777	777737			YY=YY+YY+1
  9891						IFE	ZZ,<ZZ=1>
  9892						IFE	<YY-1>,<YY=-2>
  9893	034701	204 00 0 00 035617 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 30-3
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0222

  9894									;AND MOVE RESULT INTO AC
  9895	034702	312 00 0 00 035616 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9896						STOP		^
  9897	034703	254 04 0 00 034704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9898	034704	324 00 0 00 034705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9899									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9900									;IN THE SUBTEST) TO LOOP ON ERROR^
  9901
  9902					;**********
  9903
  9904
  9905					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9906					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9907					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9908					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9909					;THEN, C(AC) IS CHECKED.
  9910					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9911					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9912
  9913			002407		SN=SN+1
  9914			000100			ZZ=ZZ+ZZ
  9915		777777	777677			YY=YY+YY+1
  9916						IFE	ZZ,<ZZ=1>
  9917						IFE	<YY-1>,<YY=-2>
  9918	034705	204 00 0 00 035621 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9919									;AND MOVE RESULT INTO AC
  9920	034706	312 00 0 00 035620 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9921						STOP		^
  9922	034707	254 04 0 00 034710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9923	034710	324 00 0 00 034711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9924									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9925									;IN THE SUBTEST) TO LOOP ON ERROR^
  9926
  9927					;**********
  9928
  9929
  9930					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9931					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9932					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9933					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9934					;THEN, C(AC) IS CHECKED.
  9935					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9936					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9937
  9938			002410		SN=SN+1
  9939			000200			ZZ=ZZ+ZZ
  9940		777777	777577			YY=YY+YY+1
  9941						IFE	ZZ,<ZZ=1>
  9942						IFE	<YY-1>,<YY=-2>
  9943	034711	204 00 0 00 035623 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9944									;AND MOVE RESULT INTO AC
  9945	034712	312 00 0 00 035622 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9946						STOP		^
  9947	034713	254 04 0 00 034714 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9948	034714	324 00 0 00 034715 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 30-4
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0223

  9949									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9950									;IN THE SUBTEST) TO LOOP ON ERROR^
  9951
  9952					;**********
  9953
  9954
  9955					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9956					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9957					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9958					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9959					;THEN, C(AC) IS CHECKED.
  9960					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9961					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9962
  9963			002411		SN=SN+1
  9964			000400			ZZ=ZZ+ZZ
  9965		777777	777377			YY=YY+YY+1
  9966						IFE	ZZ,<ZZ=1>
  9967						IFE	<YY-1>,<YY=-2>
  9968	034715	204 00 0 00 035625 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9969									;AND MOVE RESULT INTO AC
  9970	034716	312 00 0 00 035624 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9971						STOP		^
  9972	034717	254 04 0 00 034720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9973	034720	324 00 0 00 034721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9974									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9975									;IN THE SUBTEST) TO LOOP ON ERROR^
  9976
  9977					;**********
  9978
  9979
  9980					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
  9981					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
  9982					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
  9983					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
  9984					;THEN, C(AC) IS CHECKED.
  9985					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
  9986					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
  9987
  9988			002412		SN=SN+1
  9989			001000			ZZ=ZZ+ZZ
  9990		777777	776777			YY=YY+YY+1
  9991						IFE	ZZ,<ZZ=1>
  9992						IFE	<YY-1>,<YY=-2>
  9993	034721	204 00 0 00 035627 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
  9994									;AND MOVE RESULT INTO AC
  9995	034722	312 00 0 00 035626 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
  9996						STOP		^
  9997	034723	254 04 0 00 034724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9998	034724	324 00 0 00 034725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9999									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10000									;IN THE SUBTEST) TO LOOP ON ERROR^
 10001
 10002					;**********
 10003
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 30-5
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0224

 10004
 10005					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 10006					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 10007					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 10008					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 10009					;THEN, C(AC) IS CHECKED.
 10010					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 10011					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 10012
 10013			002413		SN=SN+1
 10014			002000			ZZ=ZZ+ZZ
 10015		777777	775777			YY=YY+YY+1
 10016						IFE	ZZ,<ZZ=1>
 10017						IFE	<YY-1>,<YY=-2>
 10018	034725	204 00 0 00 035631 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 10019									;AND MOVE RESULT INTO AC
 10020	034726	312 00 0 00 035630 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 10021						STOP		^
 10022	034727	254 04 0 00 034730 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10023	034730	324 00 0 00 034731 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10024									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10025									;IN THE SUBTEST) TO LOOP ON ERROR^
 10026
 10027					;**********
 10028
 10029
 10030					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 10031					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 10032					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 10033					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 10034					;THEN, C(AC) IS CHECKED.
 10035					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 10036					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 10037
 10038			002414		SN=SN+1
 10039			004000			ZZ=ZZ+ZZ
 10040		777777	773777			YY=YY+YY+1
 10041						IFE	ZZ,<ZZ=1>
 10042						IFE	<YY-1>,<YY=-2>
 10043	034731	204 00 0 00 035633 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 10044									;AND MOVE RESULT INTO AC
 10045	034732	312 00 0 00 035632 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 10046						STOP		^
 10047	034733	254 04 0 00 034734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10048	034734	324 00 0 00 034735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10049									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10050									;IN THE SUBTEST) TO LOOP ON ERROR^
 10051
 10052					;**********
 10053
 10054
 10055					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 10056					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 10057					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 10058					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 30-6
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0225

 10059					;THEN, C(AC) IS CHECKED.
 10060					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 10061					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 10062
 10063			002415		SN=SN+1
 10064			010000			ZZ=ZZ+ZZ
 10065		777777	767777			YY=YY+YY+1
 10066						IFE	ZZ,<ZZ=1>
 10067						IFE	<YY-1>,<YY=-2>
 10068	034735	204 00 0 00 035635 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 10069									;AND MOVE RESULT INTO AC
 10070	034736	312 00 0 00 035634 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 10071						STOP		^
 10072	034737	254 04 0 00 034740 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10073	034740	324 00 0 00 034741 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10074									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10075									;IN THE SUBTEST) TO LOOP ON ERROR^
 10076
 10077					;**********
 10078
 10079
 10080					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 10081					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 10082					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 10083					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 10084					;THEN, C(AC) IS CHECKED.
 10085					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 10086					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 10087
 10088			002416		SN=SN+1
 10089			020000			ZZ=ZZ+ZZ
 10090		777777	757777			YY=YY+YY+1
 10091						IFE	ZZ,<ZZ=1>
 10092						IFE	<YY-1>,<YY=-2>
 10093	034741	204 00 0 00 035637 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 10094									;AND MOVE RESULT INTO AC
 10095	034742	312 00 0 00 035636 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 10096						STOP		^
 10097	034743	254 04 0 00 034744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10098	034744	324 00 0 00 034745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10099									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10100									;IN THE SUBTEST) TO LOOP ON ERROR^
 10101
 10102					;**********
 10103
 10104
 10105					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 10106					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 10107					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 10108					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 10109					;THEN, C(AC) IS CHECKED.
 10110					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 10111					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 10112
 10113			002417		SN=SN+1
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 30-7
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0226

 10114			040000			ZZ=ZZ+ZZ
 10115		777777	737777			YY=YY+YY+1
 10116						IFE	ZZ,<ZZ=1>
 10117						IFE	<YY-1>,<YY=-2>
 10118	034745	204 00 0 00 035641 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 10119									;AND MOVE RESULT INTO AC
 10120	034746	312 00 0 00 035640 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 10121						STOP		^
 10122	034747	254 04 0 00 034750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10123	034750	324 00 0 00 034751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10124									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10125									;IN THE SUBTEST) TO LOOP ON ERROR^
 10126
 10127					;**********
 10128
 10129
 10130					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 10131					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 10132					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 10133					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 10134					;THEN, C(AC) IS CHECKED.
 10135					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 10136					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 10137
 10138			002420		SN=SN+1
 10139			100000			ZZ=ZZ+ZZ
 10140		777777	677777			YY=YY+YY+1
 10141						IFE	ZZ,<ZZ=1>
 10142						IFE	<YY-1>,<YY=-2>
 10143	034751	204 00 0 00 035643 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 10144									;AND MOVE RESULT INTO AC
 10145	034752	312 00 0 00 035642 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 10146						STOP		^
 10147	034753	254 04 0 00 034754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10148	034754	324 00 0 00 034755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10149									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10150									;IN THE SUBTEST) TO LOOP ON ERROR^
 10151
 10152					;**********
 10153
 10154
 10155					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 10156					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 10157					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 10158					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 10159					;THEN, C(AC) IS CHECKED.
 10160					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 10161					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 10162
 10163			002421		SN=SN+1
 10164			200000			ZZ=ZZ+ZZ
 10165		777777	577777			YY=YY+YY+1
 10166						IFE	ZZ,<ZZ=1>
 10167						IFE	<YY-1>,<YY=-2>
 10168	034755	204 00 0 00 035645 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 30-8
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVS INSTRUCTION                                                           SEQ 0227

 10169									;AND MOVE RESULT INTO AC
 10170	034756	312 00 0 00 035644 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 10171						STOP		^
 10172	034757	254 04 0 00 034760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10173	034760	324 00 0 00 034761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10174									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10175									;IN THE SUBTEST) TO LOOP ON ERROR^
 10176
 10177					;**********
 10178
 10179
 10180					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 10181					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 10182					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 10183					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 10184					;THEN, C(AC) IS CHECKED.
 10185					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 10186					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 10187
 10188			002422		SN=SN+1
 10189			400000			ZZ=ZZ+ZZ
 10190		777777	377777			YY=YY+YY+1
 10191						IFE	ZZ,<ZZ=1>
 10192						IFE	<YY-1>,<YY=-2>
 10193	034761	204 00 0 00 035647 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 10194									;AND MOVE RESULT INTO AC
 10195	034762	312 00 0 00 035646 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 10196						STOP		^
 10197	034763	254 04 0 00 034764 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10198	034764	324 00 0 00 034765 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10199									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10200									;IN THE SUBTEST) TO LOOP ON ERROR^
 10201
 10202					;**********
 10203
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 31
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAXX) INSTRUCTIONS                                                SEQ 0228

 10204					SUBTTL	TEST OF COMPARE (CAXX) INSTRUCTIONS
 10205
 10206					;**********
 10207
 10208					;THIS TEST VERIFIES THAT CAIE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 10209					;AND ONLY WHEN C(AC)=E
 10210					;IN THIS CASE C(AC)=E=0;  HENCE, CAIE SHOULD SKIP
 10211					;OTHERWISE THE PROGRAM HALTS
 10212
 10213	034765	400 00 0 00 000000 	B2500:	SETZ			;PRELOAD AC TO 0
 10214	034766	302 00 0 00 000000 		CAIE			;*CAIE SHOULD SKIP BECAUSE C(AC)=E
 10215						STOP^
 10216	034767	254 04 0 00 034770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10217	034770	324 00 0 00 034771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10218									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10219									;IN THE SUBTEST) TO LOOP ON ERROR^
 10220
 10221					;*****     FAILURE ANALYSIS     *****
 10222					;C(AC0)		C(AC1)		FAILING SIGNAL
 10223
 10224					;				SW: PC CHANGE
 10225					;				FC: AD FM ; EN
 10226					;				FC: AD CRY 36
 10227					;				FC: AB PC EN
 10228					;				ET0: COND P: PC CLK EN
 10229
 10230					;**********
 10231
 10232					;THIS TEST VERIFIES THAT CAIE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 10233					;AND ONLY WHEN C(AC)=E
 10234					;IN THIS CASE C(AC)=E=1.  HENCE, CAIE SHOULD SKIP
 10235					;OTHERWISE THE PROGRAM HALTS
 10236
 10237	034771	200 00 0 00 035416 	B2600:	MOVE	[1]		;PRELOAD AC TO 1
 10238	034772	302 00 0 00 000001 		CAIE	1		;*CAIE SHOULD SKIP BECAUSE C(AC)=E
 10239						STOP^
 10240	034773	254 04 0 00 034774 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10241	034774	324 00 0 00 034775 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10242									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10243									;IN THE SUBTEST) TO LOOP ON ERROR^
 10244
 10245					;*****     FAILURE ANALYSIS     *****
 10246					;C(AC0)		C(AC1)		FAILING SIGNAL
 10247
 10248					;				FC: AD AR - EN
 10249
 10250					;**********
 10251
 10252					;THIS TEST VERIFIES THAT CAME SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 10253					;AND ONLY WHEN C(AC)=C(E)
 10254					;IN THIS CASE C(AC)=C(E)=1;  HENCE, CAME SHOULD SKIP
 10255					;OTHERWISE THE PROGRAM HALTS
 10256
 10257	034775	201 00 0 00 000001 	B2700:	MOVEI	1		;PRELOAD AC TO 1
 10258	034776	312 00 0 00 035416 		CAME	[1]		;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 31-1
DAKABM	MAC	19-JAN-77 13:39		TEST OF COMPARE (CAXX) INSTRUCTIONS                                                SEQ 0229

 10259						STOP^
 10260	034777	254 04 0 00 035000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10261	035000	324 00 0 00 035001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10262									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10263									;IN THE SUBTEST) TO LOOP ON ERROR^
 10264
 10265					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 32
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0230

 10266					SUBTTL	TEST OF BOOLEAN INSTRUCTIONS
 10267
 10268					;**********
 10269
 10270					;THIS TEST VERIFIES THAT SETCA IGNORES THE ADDRESS FIELD OF THE INSTUCTION WORD.
 10271					;IN THIS CASE C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 10272					;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES.
 10273
 10274	035001	201 00 0 00 777777 	B3000:	MOVEI	-1		;PRELOAD AC TO 0,,-1
 10275	035002	450 00 0 00 035524 		SETCA	[-1]		;*SETCA SHOULD PUT -1,,0 INTO THE AC
 10276	035003	312 00 0 00 035502 		CAME	[-1,,0]		;PASS TEST IF C(AC)=-1,,0
 10277						STOP^
 10278	035004	254 04 0 00 035005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10279	035005	324 00 0 00 035006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10280									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10281									;IN THE SUBTEST) TO LOOP ON ERROR^
 10282
 10283					;**********
 10284
 10285					;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
 10286					;RESULT IN THE AC.
 10287					;IN THIS CASE C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 10288					;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES
 10289
 10290	035006	201 00 0 00 777777 	B3100:	MOVEI	-1		;PRELOAD AC TO 0,,-1
 10291	035007	450 00 0 00 000000 		SETCA			;*SETCA SHOULD PUT -1,,0 INTO THE AC
 10292	035010	312 00 0 00 035502 		CAME	[-1,,0]		;PASS TEST IF C(AC) =-1,,0
 10293						STOP^
 10294	035011	254 04 0 00 035012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10295	035012	324 00 0 00 035013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10296									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10297									;IN THE SUBTEST) TO LOOP ON ERROR^
 10298
 10299					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 33
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0231

 10300					;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
 10301					;RESULT IN THE AC,
 10302					;IN THIS CASE C(AC)=0,,0  HENCE, THE RESULT IN THE AC SHOULD BE,-1
 10303					;IF THE RESULT IN THE AC IS -1,,-1, THE TEST PASSES
 10304
 10305	035013	201 00 0 00 000000 	B3200:	MOVEI	0		;PRELOAD AC TO 0,,0
 10306	035014	450 00 0 00 000000 		SETCA			;*SETCA SHOULD PUT -1,,-1 INTO THE AC
 10307	035015	312 00 0 00 035524 		CAME	[-1]		;PASS TEST IF C(AC) =-1,,-1
 10308						STOP^
 10309	035016	254 04 0 00 035017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10310	035017	324 00 0 00 035020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10311									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10312									;IN THE SUBTEST) TO LOOP ON ERROR^
 10313
 10314					;*****     FAILURE ANALYSIS     *****
 10315					;C(AC0)		C(AC1)		FAILING SIGNAL
 10316
 10317					;0				ET2: AR AD EN
 10318
 10319					;**********
 10320
 10321					;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
 10322					;RESULT IN THE AC,
 10323					;IN THIS CASE C(AC)=-1,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE 0,,0
 10324					;IF THE RESULT IN THE AC IS ZERO, THE TEST PASSES
 10325
 10326	035020	200 00 0 00 035524 	B3300:	MOVE	[-1]		;PRELOAD AC TO -1,,-1
 10327	035021	450 00 0 00 000000 		SETCA			;*SETCA SHOULD PUT 0,,0 INTO THE AC
 10328	035022	312 00 0 00 035412 		CAME	[0]		;PASS TEST IF C(AC) IS ZERO
 10329						STOP^
 10330	035023	254 04 0 00 035024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10331	035024	324 00 0 00 035025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10333									;IN THE SUBTEST) TO LOOP ON ERROR^
 10334
 10335					;*****     FAILURE ANALYSIS     *****
 10336					;C(AC0)		C(AC1)		FAILING SIGNAL
 10337
 10338					;-1,,-1				FC: AD FM - EN
 10339
 10340					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 34
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0232

 10341					;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
 10342					;RESULT IN THE AC.
 10343					;IN THIS CASE AC=E AND C(E)=C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 10344					;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES
 10345
 10346	035025	201 00 0 00 777777 	B3500:	MOVEI	-1		;PRELOAD AC TO 0,,-1
 10347	035026	460 00 0 00 000000 		SETCM			;*SETCM SHOULD PUT -1,,0 INTO THE AC
 10348	035027	312 00 0 00 035502 		CAME	[-1,,0]		;PASS TEST IF C(AC) =-1,,0
 10349						STOP^
 10350	035030	254 04 0 00 035031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10351	035031	324 00 0 00 035032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10352									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10353									;IN THE SUBTEST) TO LOOP ON ERROR^
 10354
 10355					;*****     FAILURE ANALYSIS     *****
 10356					;C(AC0)		C(AC1)		FAILING SIGNAL
 10357
 10358					;-1,,-1				SW: FCE
 10359					;-1,,-1				FC: AD AR - EN
 10360					;0,,-1				ET2: AR AD EN
 10361
 10362					;**********
 10363
 10364					;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
 10365					;RESULT IN THE AC.
 10366					;IN THIS CASE C(E)=-1,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE 0,,0
 10367					;IF THE RESULT IN THE AC IS ZERO,THE TEST PASSES
 10368
 10369	035032	460 00 0 00 035524 	B3600:	SETCM	[-1]		;*SETCM SHOULD PUT 0 INTO THE AC
 10370	035033	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC0)=0
 10371						STOP^
 10372	035034	254 04 0 00 035035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10373	035035	324 00 0 00 035036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10374									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10375									;IN THE SUBTEST) TO LOOP ON ERROR^
 10376
 10377					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 35
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0233

 10378					;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
 10379					;RESULT IN THE AC.
 10380					;IN THIS CASE C(E)=0,,0;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1
 10381					;IF THE RESULT IN THE AC IS -1,,-1,THE TEST PASSES
 10382
 10383	035036	460 00 0 00 035412 	B3700:	SETCM	[0]		;*SETCM SHOULD PUT -1,,-1 INTO THE AC
 10384	035037	312 00 0 00 035524 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 10385						STOP^
 10386	035040	254 04 0 00 035041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10387	035041	324 00 0 00 035042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10388									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10389									;IN THE SUBTEST) TO LOOP ON ERROR^
 10390
 10391					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 36
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0234

 10392					;THIS TEST VERIFIES THAT SETO SETS C(AC) TO -1,,-1.  SETO IGNORES
 10393					;THE ADDRESS FIELD OF THE INSTRUCTION WORD.
 10394					;FIRST C(AC) IS SET TO 0,,0; THEN SETO IS EXECUTED.
 10395					;THE AC IS THEN CHECKED FOR ALL ONES.  IF C(AC) IS ALL ONES,
 10396					;THE TEST PASSES
 10397
 10398	035042	201 00 0 00 000000 	B4300:	MOVEI	0		;PRELOAD AC WITH 0,,0
 10399	035043	474 00 0 00 000000 		SETO			;*SETO SHOULD LOAD THE AC WITH -1,,-1
 10400	035044	312 00 0 00 035524 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 10401						STOP^
 10402	035045	254 04 0 00 035046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10403	035046	324 00 0 00 035047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10404									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10405									;IN THE SUBTEST) TO LOOP ON ERROR^
 10406
 10407					;*****     FAILURE ANALYSIS     *****
 10408					;C(AC0)		C(AC1)		FAILING SIGNAL
 10409
 10410					;0				ET2: AR AD EN
 10411
 10412					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 37
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0235

 10413					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 10414					;INCLUSIVE OR OF C(AC) WITH THE COMPLEMENT OF C(MEMORY).
 10415					;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=0.
 10416					;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
 10417					;THE AC IS CHECKED FOR ITS FINAL CONTENTS NON-ZERO.
 10418					;IF C(AC) IS NOT=0, THE TEST PASSES
 10419
 10420	035047	201 00 0 00 000000 	B4400:	MOVEI	0		;PRELOAD AC,E WITH 0
 10421	035050	464 00 0 00 000000 		ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
 10422	035051	336 00 0 00 000000 		SKIPN			;PASS IF C(AC) IS NON-ZERO
 10423						STOP^
 10424	035052	254 04 0 00 035053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10425	035053	324 00 0 00 035054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10426									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10427									;IN THE SUBTEST) TO LOOP ON ERROR^
 10428
 10429					;**********
 10430
 10431					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 10432					;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
 10433					;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=0
 10434					;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
 10435					;THE AC IS CHECKED FOR ITS FINAL CONTENTS EQUAL TO -1,,-1
 10436					;IF C(AC0)=-1,,-1, THE TEST PASSES
 10437
 10438	035054	201 00 0 00 000000 	B4500:	MOVEI	0		;PRELOAD AC,E WITH 0
 10439	035055	464 00 0 00 000000 		ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
 10440	035056	312 00 0 00 035524 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 10441						STOP^
 10442	035057	254 04 0 00 035060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10443	035060	324 00 0 00 035061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10444									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10445									;IN THE SUBTEST) TO LOOP ON ERROR^
 10446
 10447					;*****     FAILURE ANALYSIS     *****
 10448					;C(AC0)		C(AC1)		FAILING SIGNAL
 10449
 10450					;0				SW: ET0
 10451					;0				FC: AD AR + EN
 10452					;0				ET2: AR AD EN
 10453
 10454					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 38
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0236

 10455					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 10456					;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
 10457					;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=-1,,-1
 10458					;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
 10459					;THE AC IS CHECKED FOR ITS FINAL CONTENTS EQUAL TO -1,,-1
 10460					;IF C(AC0)=-1,,-1, THE TEST PASSES
 10461
 10462	035061	200 00 0 00 035524 	B4600:	MOVE	[-1]		;PRELOAD AC,E WITH -1,,-1
 10463	035062	464 00 0 00 000000 		ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
 10464	035063	312 00 0 00 035524 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 10465						STOP^
 10466	035064	254 04 0 00 035065 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10467	035065	324 00 0 00 035066 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10468									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10469									;IN THE SUBTEST) TO LOOP ON ERROR^
 10470
 10471					;*****     FAILURE ANALYSIS     *****
 10472					;C(AC0)		C(AC1)		FAILING SIGNAL
 10473
 10474					;0				FC: AD FM - EN
 10475					;0				ET0: AR AD EN
 10476
 10477					;**********
 10478
 10479					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 10480					;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
 10481					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1; HENCE, THE RESULT
 10482					;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR ITS INAL CONTENTS=0.
 10483					;IF C(AC)=0, THE TEST PASSES
 10484
 10485	035066	201 00 0 00 000000 	B4700:	MOVEI	0		;PRELOAD AC WITH 0
 10486	035067	464 00 0 00 035524 		ORCM	[-1]		;*ORCM SHOULD PLACE ALL ZEROS INTO THE AC
 10487	035070	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0,,0
 10488						STOP^
 10489	035071	254 04 0 00 035072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10490	035072	324 00 0 00 035073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10491									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10492									;IN THE SUBTEST) TO LOOP ON ERROR^
 10493
 10494					;*****     FAILURE ANALYSIS     *****
 10495					;C(AC0)		C(AC1)		FAILING SIGNAL
 10496
 10497					;-E				SW: FCE
 10498
 10499					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 39
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0237

 10500					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 10501					;INCLUSIVE OR OF C(AC) WITH C(E).
 10502					;IN THIS CASE AC=E AND C(AC)=C(E)=0,,0.  HENCE THE
 10503					;RESULT IN THE AC SHOULD BE 0,,0.
 10504					;THE AC IS CHECKED FOR 0,,0.  IF C(AC)=0,,0, THIS TEST PASSES
 10505
 10506	035073	201 00 0 00 000000 	B5000:	MOVEI	0		;PRELOAD AC,E WITH 0,,0
 10507	035074	434 00 0 00 000000 		IOR			;*IOR SHOULD PUT 0 INTO AC
 10508	035075	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0,,0
 10509						STOP^
 10510	035076	254 04 0 00 035077 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10511	035077	324 00 0 00 035100 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10512									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10513									;IN THE SUBTEST) TO LOOP ON ERROR^
 10514
 10515					;*****     FAILURE ANALYSIS     *****
 10516					;C(AC0)		C(AC1)		FAILING SIGNAL
 10517
 10518					;-1,,-1				SW: ET0
 10519					;-1,,-1				ET0: AR AD EN
 10520					;-1,,-1				ET0: AD AR - EN
 10521					;-1,,-1				ET2: AR AD EN
 10522
 10523					;**********
 10524
 10525					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 10526					;INCLUSIVE OR OF C(AC) WITH C(E).
 10527					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
 10528					;RESULT IN THE AC SHOULD BE -1,,-1.
 10529					;THE AC IS CHECKED FOR -1,,-1
 10530					;IF C(AC) =-1,,-1 THE TEST PASSES.
 10531
 10532	035100	201 00 0 00 000000 	B5100:	MOVEI	0		;PRELOAD AC WITH 0
 10533	035101	434 00 0 00 035524 		IOR	[-1]		;*IOR SHOULD PUT -1,,-1 INTO AC
 10534	035102	312 00 0 00 035524 		CAME	[-1]		;PASS TEST IF C(AC)  =-1,,-1
 10535						STOP^
 10536	035103	254 04 0 00 035104 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10537	035104	324 00 0 00 035105 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10538									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10539									;IN THE SUBTEST) TO LOOP ON ERROR^
 10540
 10541					;*****     FAILURE ANALYSIS     *****
 10542					;C(AC0)		C(AC1)		FAILING SIGNAL
 10543
 10544					;E				SW: FCE
 10545					;0				FC: AD AR - EN
 10546
 10547					;*****     FAILURE ANALYSIS     *****
 10548					;C(AC0)		C(AC1)		FAILING SIGNAL
 10549
 10550					;0				FC: AD FM - EN
 10551
 10552	035105				NB5300:;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 40
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0238

 10553					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 10554					;INCLUSIVE OR OF C(AC) WITH C(E).
 10555					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
 10556					;RESULT IN THE AC SHOULD BE -1,,-1
 10557					;THE AC IS CHECKED FOR ITS CONTENTS = ALL ONES
 10558					;IF C(AC)=-1, THE TEST PASSES
 10559
 10560	035105	474 00 0 00 000000 	B5200:	SETO			;PRELOAD AC WITH -1,,-1
 10561	035106	434 00 0 00 035524 		IOR	[-1]		;*IOR SHOULD PUT -1,,-1 INTO AC
 10562	035107	312 00 0 00 035524 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 10563						STOP^
 10564	035110	254 04 0 00 035111 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10565	035111	324 00 0 00 035112 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10566									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10567									;IN THE SUBTEST) TO LOOP ON ERROR^
 10568
 10569					;**********
 10570
 10571					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 10572					;INCLUSIVE OR OF C(AC) WITH C(E).
 10573					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
 10574					;RESULT IN THE AC SHOULD BE -1,,-1
 10575					;THE AC IS CHECKED FOR ITS CONTENTS = ALL ONES
 10576					;IF C(AC)=-1,,-1, THE TEST PASSES
 10577
 10578	035112	474 00 0 00 000000 	B5300:	SETO			;PRELOAD AC WITH -1,,-1
 10579	035113	434 00 0 00 035412 		IOR	[0]		;*IOR SHOULD PUT -1,,-1 INTO AC
 10580	035114	312 00 0 00 035524 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 10581						STOP^
 10582	035115	254 04 0 00 035116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10583	035116	324 00 0 00 035117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10584									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10585									;IN THE SUBTEST) TO LOOP ON ERROR^
 10586
 10587					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 41
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0239

 10588					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 10589					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 10590					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT
 10591					;IN THE AC SHOULD BE 0,,-1
 10592					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THE TEST PASSES
 10593
 10594	035117	474 00 0 00 000000 	B5500:	SETO			;PRELOAD AC WITH ALL ONES
 10595	035120	420 00 0 00 035502 		ANDCM	[XWD -1,0]	;*ANDCM SHOULD PLACE 0,,-1 IN THE AC
 10596	035121	312 00 0 00 035537 		CAME	[0,,-1]		;IF C(AC)=0,,-1, THE TEST PASSES
 10597						STOP^
 10598	035122	254 04 0 00 035123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10599	035123	324 00 0 00 035124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10600									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10601									;IN THE SUBTEST) TO LOOP ON ERROR^
 10602
 10603					;*****     FAILURE ANALYSIS     *****
 10604					;C(AC0)		C(AC1)		FAILING SIGNAL
 10605
 10606					;-E				SW: FCE
 10607					;-1,,-1				FC: AD AR - EN
 10608					;-1,,0				ET2: AR AD EN
 10609
 10610					;**********
 10611
 10612					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 10613					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 10614					;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=0.  HENCE,
 10615					;THE RESULT IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.
 10616					;IF C(AC)=0, THE TEST PASSES.
 10617
 10618	035124	474 00 0 00 000000 	B5600:	SETO			;PRELOAD AC WITH ALL ONES
 10619	035125	420 00 0 00 000000 		ANDCM			;*ANDCM SHOULD PLACE 0 IN THE AC
 10620	035126	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 10621						STOP^
 10622	035127	254 04 0 00 035130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10623	035130	324 00 0 00 035131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10624									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10625									;IN THE SUBTEST) TO LOOP ON ERROR^
 10626
 10627					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 42
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0240

 10628					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 10629					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 10630					;IN THIS CASE C(AC)=-1,,-1, AND C(E)=0.  HENCE, THE RESULT IN THE AC
 10631					;SHOULD BE ALL ONES.  THE AC IS CHECKED FOR -1,,-1.
 10632					;IF C(AC)=-1,,-1, THE TEST PASSES
 10633
 10634	035131	474 00 0 00 000000 	B5700:	SETO			;PRELOAD AC WITH 0
 10635	035132	420 00 0 00 035412 		ANDCM	[0]		;*ANDCM SHOULD PLACE -1,,-1 IN THE AC
 10636	035133	312 00 0 00 035524 		CAME	[-1]		;IF C(AC)=-1,,-1, THE TEST PASSES
 10637						STOP^
 10638	035134	254 04 0 00 035135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10639	035135	324 00 0 00 035136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10640									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10641									;IN THE SUBTEST) TO LOOP ON ERROR^
 10642
 10643					;**********
 10644
 10645					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 10646					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 10647					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 10648					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.
 10649					;IF C(AC)=0, THE TEST PASSES
 10650
 10651	035136	201 00 0 00 000000 	B6000:	MOVEI	0		;PRELOAD AC WITH 0
 10652	035137	420 00 0 00 000000 		ANDCM			;*ANDCM SHOULD PLACE 0 IN THE AC
 10653	035140	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 10654						STOP^
 10655	035141	254 04 0 00 035142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10656	035142	324 00 0 00 035143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10657									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10658									;IN THE SUBTEST) TO LOOP ON ERROR^
 10659
 10660					;*****     FAILURE ANALYSIS     *****
 10661					;C(AC0)		C(AC1)		FAILING SIGNAL
 10662
 10663					;-1,,-1				FC: AD FM + EN
 10664
 10665					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 43
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0241

 10666					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 10667					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 10668					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1. HENCE, THE RESULT IN THE AC
 10669					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.
 10670					;IF C(AC)=0, THE TEST PASSES
 10671
 10672	035143	400 00 0 00 000000 	B6100:	SETZ			;PRELOAD AC WITH 0
 10673	035144	420 00 0 00 035524 		ANDCM	[-1]		;*ANDCM SHOULD PLACE 0 IN THE AC
 10674	035145	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES
 10675						STOP^
 10676	035146	254 04 0 00 035147 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10677	035147	324 00 0 00 035150 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10678									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10679									;IN THE SUBTEST) TO LOOP ON ERROR^
 10680
 10681					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 44
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0242

 10682					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 10683					;OF THE COMPLEMENT OF C(AC) AND C(E).
 10684					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 10685					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO.  IF C(AC) IS
 10686					;EQUAL TO ZERO, THE TEST PASSES.
 10687
 10688	035150	200 00 0 00 035502 	B6200:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 10689	035151	410 00 0 00 035412 		ANDCA	[0]		;*ANDCA SHOULD PLACE 0 IN THE AC
 10690	035152	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 10691						STOP^
 10692	035153	254 04 0 00 035154 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10693	035154	324 00 0 00 035155 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10694									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10695									;IN THE SUBTEST) TO LOOP ON ERROR^
 10696
 10697					;*****     FAILURE ANALYSIS     *****
 10698					;C(AC0)		C(AC1)		FAILING SIGNAL
 10699
 10700					;E				SW: FCE
 10701					;0,,-1				FC: AD AR + EN
 10702
 10703					;**********
 10704
 10705					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 10706					;OF THE COMPLEMENT OF C(AC) AND C(E).
 10707					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE, THE
 10708					;RESULT IN THE AC SHOULD BE 0,,707070.  THE AC IS CHECKED
 10709					;FOR 0,,707070.  IF C(AC)=0,,707070, THE TEST PASSES.
 10710
 10711	035155	200 00 0 00 035502 	B6300:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 10712	035156	410 00 0 00 035650 		ANDCA	[707070707070]	;*ANDCA SHOULD PLACE 0,,707070 IN THE AC
 10713	035157	312 00 0 00 035651 		CAME	[XWD 0,707070]	;IF C(AC)=0,,707070, THE TEST PASSES
 10714						STOP^
 10715	035160	254 04 0 00 035161 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10716	035161	324 00 0 00 035162 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10717									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10718									;IN THE SUBTEST) TO LOOP ON ERROR^
 10719
 10720					;*****     FAILURE ANALYSIS     *****
 10721					;C(AC0)		C(AC1)		FAILING SIGNAL
 10722
 10723					;707070,,707070			FC: AD FM - EN
 10724					;707070,,707070			ET2: AR AD EN
 10725
 10726					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 45
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0243

 10727					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 10728					;OF THE COMPLEMENT OF C(AC) AND C(E).
 10729					;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=0. HENCE, THE RESULT
 10730					;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC=0,
 10731					;THE TEST PASSES.
 10732
 10733	035162	400 00 0 00 000000 	B6400:	SETZ			;CLEAR THE AC AND E
 10734	035163	410 00 0 00 000000 		ANDCA			;*ANDCA SHOULD PLACE 0 IN THE AC
 10735	035164	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES
 10736						STOP^
 10737	035165	254 04 0 00 035166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10738	035166	324 00 0 00 035167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10739									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10740									;IN THE SUBTEST) TO LOOP ON ERROR^
 10741
 10742					;**********
 10743
 10744					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 10745					;OF THE COMPLEMENT OF C(AC) AND C(E).
 10746					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 10747					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR ALL ONES.
 10748					;IF C(AC)=-1,,-1, THE TEST PASSES.
 10749
 10750	035167	400 00 0 00 000000 	B6500:	SETZ			;CLEAR THE AC
 10751	035170	410 00 0 00 035524 		ANDCA	[-1]		;*ANDCA SHOULD PLACE ALL ONES IN THE AC
 10752	035171	312 00 0 00 035524 		CAME	[-1]		;IF C(AC)=ALL ONES, THE TEST PASSES.
 10753						STOP^
 10754	035172	254 04 0 00 035173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10755	035173	324 00 0 00 035174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10756									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10757									;IN THE SUBTEST) TO LOOP ON ERROR^
 10758
 10759					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 46
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0244

 10760					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 10761					;OF THE COMPLEMENT OF C(AC) AND C(E).
 10762					;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=-1,,-1. HENCE, THE RESULT
 10763					;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
 10764					;THE TEST PASSES.
 10765
 10766	035174	474 00 0 00 000000 	B6600:	SETO			;PRESET AC TO ALL ONES
 10767	035175	410 00 0 00 000000 		ANDCA			;*ANDCA SHOULD PLACE 0 IN THE AC
 10768	035176	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES
 10769						STOP^
 10770	035177	254 04 0 00 035200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10771	035200	324 00 0 00 035201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10773									;IN THE SUBTEST) TO LOOP ON ERROR^
 10774
 10775					;**********
 10776
 10777					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 10778					;OF THE COMPLEMENT OF C(AC) AND C(E).
 10779					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 10780					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
 10781					;THE TEST PASSES.
 10782
 10783	035201	474 00 0 00 000000 	B6700:	SETO			;PRESET AC TO ALL ONES
 10784	035202	410 00 0 00 035412 		ANDCA	[0]		;*ANDCA SHOULD PLACE 0 IN THE AC
 10785	035203	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 10786						STOP^
 10787	035204	254 04 0 00 035205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10788	035205	324 00 0 00 035206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10789									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10790									;IN THE SUBTEST) TO LOOP ON ERROR^
 10791
 10792					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 47
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0245

 10793					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 10794					;OF THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 10795					;IN THIS CASE C(AC)=-1,,0 AND C(E)=0; HENCE, THE RESULT IN THE AC
 10796					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
 10797					;THIS TEST PASSES.
 10798
 10799	035206	200 00 0 00 035502 	B7000:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 10800	035207	440 00 0 00 035412 		ANDCB	[0]		;*ANDCB SHOULD PLACE 0,,-1 IN THE AC
 10801	035210	312 00 0 00 035537 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 10802						STOP^
 10803	035211	254 04 0 00 035212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10804	035212	324 00 0 00 035213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10805									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10806									;IN THE SUBTEST) TO LOOP ON ERROR^
 10807
 10808					;*****     FAILURE ANALYSIS     *****
 10809					;C(AC0)		C(AC1)		FAILING SIGNAL
 10810
 10811					;0,,-E				SW: FCE
 10812					;-1,,-1				FC: AD FM - EN
 10813					;0				ET2: AR AD EN
 10814
 10815					;**********
 10816
 10817					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 10818					;OF THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 10819					;IN THIS CASE C(AC)=-1,,0 AND C(E)=-1,,-1; HENCE, THE RESULT IN THE AC
 10820					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
 10821					;THIS TEST PASSES.
 10822
 10823	035213	200 00 0 00 035502 	B7100:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 10824	035214	440 00 0 00 035524 		ANDCB	[-1]		;*ANDCB SHOULD PLACE 0 IN AC
 10825	035215	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 10826						STOP^
 10827	035216	254 04 0 00 035217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10828	035217	324 00 0 00 035220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10829									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10830									;IN THE SUBTEST) TO LOOP ON ERROR^
 10831
 10832					;*****     FAILURE ANALYSIS     *****
 10833					;C(AC0)		C(AC1)		FAILING SIGNAL
 10834
 10835					;0,,-1				FC: AD AR - EN
 10836
 10837					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 48
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0246

 10838
 10839					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 10840					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 10841					;IN THIS CASE AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 10842					;SHOULD BE ALL ONES.  THE AC IS CHECKED FOR ALL ONES.  IF C(AC)=-1,,-1,
 10843					;THE TEST PASSES.
 10844
 10845	035220	400 00 0 00 000000 	B7200:	SETZ			;PRELOAD AC,E WITH ZEROES
 10846	035221	440 00 0 00 000000 		ANDCB			;*ANDCB SHOULD PLACE ALL ONES IN THE AC
 10847	035222	312 00 0 00 035524 		CAME	[-1]		;PASS IF C(AC) IS ALL ONES
 10848						STOP^
 10849	035223	254 04 0 00 035224 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10850	035224	324 00 0 00 035225 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10851									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10852									;IN THE SUBTEST) TO LOOP ON ERROR^
 10853
 10854					;**********
 10855
 10856					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 10857					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 10858					;IN THIS CASE AC=E AND C(AC)=C(E)=-1,,-1.  HENCE THE RESULT IN THE AC
 10859					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 10860
 10861	035225	474 00 0 00 000000 	B7300:	SETO			;PRELOAD AC,E WITH ONES
 10862	035226	440 00 0 00 000000 		ANDCB			;*ANDCB SHOULD PLACE ALL ZEROS IN THE AC
 10863	035227	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 10864						STOP^
 10865	035230	254 04 0 00 035231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10866	035231	324 00 0 00 035232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10867									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10868									;IN THE SUBTEST) TO LOOP ON ERROR^
 10869
 10870					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 49
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0247

 10871					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 10872					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 10873					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 10874					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 10875
 10876	035232	400 00 0 00 000000 	B7400:	SETZ			;PRELOAD AC WITH 0
 10877	035233	440 00 0 00 035524 		ANDCB	[-1]		;*ANDCB SHOULD PLACE 0 IN THE AC
 10878	035234	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 10879						STOP^
 10880	035235	254 04 0 00 035236 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10881	035236	324 00 0 00 035237 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10882									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10883									;IN THE SUBTEST) TO LOOP ON ERROR^
 10884
 10885					;**********
 10886
 10887					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 10888					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 10889					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 10890					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 10891
 10892	035237	474 00 0 00 000000 	B7500:	SETO			;PRELOAD AC WITH -1,,-1
 10893	035240	440 00 0 00 035412 		ANDCB	[0]		;*ANDCB SHOULD PLACE 0 IN THE AC
 10894	035241	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 10895						STOP^
 10896	035242	254 04 0 00 035243 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10897	035243	324 00 0 00 035244 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10898									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10899									;IN THE SUBTEST) TO LOOP ON ERROR^
 10900
 10901					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 50
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0248

 10902					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 10903					;THE COMPLEMENT OF C(AC) AND C(E).
 10904					;IN THIS CASE C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 10905					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
 10906					;THIS TEST FAILS.
 10907
 10908	035244	200 00 0 00 035502 	B7600:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 10909	035245	454 00 0 00 035412 		ORCA	[0]		;*ORCA SHOULD PLACE 0,,-1 IN THE AC
 10910	035246	312 00 0 00 035537 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 10911						STOP^
 10912	035247	254 04 0 00 035250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10913	035250	324 00 0 00 035251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10914									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10915									;IN THE SUBTEST) TO LOOP ON ERROR^
 10916
 10917					;*****     FAILURE ANALYSIS     *****
 10918					;C(AC0)		C(AC1)		FAILING SIGNAL
 10919
 10920					;-1,,0				SW: ET0
 10921					;-1,,0				FC: AD AR - EN
 10922					;0				FC: AD FM + EN
 10923					;-1,,-1				ET0: AR AD EN
 10924					;-1,,-1				ET0: AD AR - EN
 10925					;-1,,0				ET2: AR AD EN
 10926
 10927					;**********
 10928
 10929					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 10930					;THE COMPLEMENT OF C(AC) AND C(E).
 10931					;IN THIS CASE C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE, THE RESULT IN THE AC
 10932					;SHOULD BE 707070,,-1.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
 10933					;THIS TEST FAILS.
 10934
 10935	035251	200 00 0 00 035502 	B10000:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 10936	035252	454 00 0 00 035650 		ORCA	[707070707070]	;*ORCA SHOULD PLACE 707070,,-1 IN THE AC
 10937	035253	312 00 0 00 035652 		CAME	[XWD 707070,-1]	;PASS IF C(AC)=707070,,-1
 10938						STOP^
 10939	035254	254 04 0 00 035255 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10940	035255	324 00 0 00 035256 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10941									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10942									;IN THE SUBTEST) TO LOOP ON ERROR^
 10943
 10944					;*****     FAILURE ANALYSIS     *****
 10945					;C(AC0)		C(AC1)		FAILING SIGNAL
 10946
 10947					;0,,-1				SW: FCE
 10948
 10949					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 51
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0249

 10950					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 10951					;THE COMPLEMENT OF C(AC) AND C(E).
 10952					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 10953					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 10954
 10955	035256	400 00 0 00 000000 	B10100:	SETZ			;PRELOAD AC,E WITH 0
 10956	035257	454 00 0 00 000000 		ORCA			;*ORCA SHOULD PLACE -1,,-1 IN THE AC
 10957	035260	312 00 0 00 035524 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 10958						STOP^
 10959	035261	254 04 0 00 035262 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10960	035262	324 00 0 00 035263 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10961									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10962									;IN THE SUBTEST) TO LOOP ON ERROR^
 10963
 10964					;**********
 10965
 10966					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OF FUNCTION OF
 10967					;THE COMPLEMENT OF C(AC) AND C(E).
 10968					;IN THIS CASE, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 10969					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 10970
 10971	035263	474 00 0 00 000000 	B10200:	SETO			;PRELOAD AC,E WITH 0
 10972	035264	454 00 0 00 000000 		ORCA			;*ORCA SHOULD PLACE -1,,-1 IN THE AC
 10973	035265	312 00 0 00 035524 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 10974						STOP^
 10975	035266	254 04 0 00 035267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10976	035267	324 00 0 00 035270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10977									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10978									;IN THE SUBTEST) TO LOOP ON ERROR^
 10979
 10980					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 52
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0250

 10981					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 10982					;THE COMPLEMENT OF C(AC) AND C(E).
 10983					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESUTL IN THE AC
 10984					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 10985
 10986	035270	400 00 0 00 000000 	B10300:	SETZ			;PRELOAD AC WITH 0
 10987	035271	454 00 0 00 035524 		ORCA	[-1]		;*ORCA SHOULD PLACE -1,,-1 IN THE AC
 10988	035272	312 00 0 00 035524 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 10989						STOP^
 10990	035273	254 04 0 00 035274 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10991	035274	324 00 0 00 035275 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10992									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10993									;IN THE SUBTEST) TO LOOP ON ERROR^
 10994
 10995					;**********
 10996
 10997					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 10998					;THE COMPLEMENT OF C(AC) AND C(E).
 10999					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 11000					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 11001
 11002	035275	474 00 0 00 000000 	B10400:	SETO			;PRELOAD AC WITH -1,,-1
 11003	035276	454 00 0 00 035412 		ORCA	[0]		;*ORCA SHOULD PLACE 0 IN THE AC
 11004	035277	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 11005						STOP^
 11006	035300	254 04 0 00 035301 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11007	035301	324 00 0 00 035302 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11008									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11009									;IN THE SUBTEST) TO LOOP ON ERROR^
 11010
 11011					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 53
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0251

 11012					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 11013					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
 11014					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE THE RESULT
 11015					;IN THE AC 070707,,-1.  THE AC IS CHECKED FOR 070707,,-1.  IF C(AC)=070707,,-1,
 11016					;THIS TEST PASSES
 11017
 11018	035302	200 00 0 00 035502 	B10500:	MOVE	[XWD -1,0]	;PRELOAD THE AC WITH -1,,0
 11019	035303	470 00 0 00 035650 		ORCB	[707070707070]	;*ORCB SHOULD PLACE 070707,,-1 IN THE AC
 11020	035304	312 00 0 00 035653 		CAME	[XWD 070707,-1]	;PASS IF C(AC)=070707,,-1
 11021						STOP^
 11022	035305	254 04 0 00 035306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11023	035306	324 00 0 00 035307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11024									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11025									;IN THE SUBTEST) TO LOOP ON ERROR^
 11026
 11027					;*****     FAILURE ANALYSIS     *****
 11028					;C(AC0)		C(AC1)		FAILING SIGNAL
 11029
 11030					;-1,,-1				SW: FCE
 11031					;707070,,0			SW: ET0
 11032					;0,,-1				FC: AD AR + EN
 11033					;070707,,070707			FC: AD FM + EN
 11034					;070707,,070707			ET0: AR AD EN
 11035					;-1,,-1				ET0: AD AR - EN
 11036					;707070,,0			ET2: AR AD EN
 11037
 11038					;**********
 11039
 11040					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 11041					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
 11042					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE THE RESULT
 11043					;IN THE AC -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
 11044					;THIS TEST PASSES
 11045
 11046	035307	200 00 0 00 035537 	B10700:	MOVE	[XWD 0,-1]	;PRELOAD THE AC WITH 0,,-1
 11047	035310	470 00 0 00 035524 		ORCB	[-1]		;*ORCB SHOULD PLACE -1,,0 IN THE AC
 11048	035311	312 00 0 00 035502 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 11049						STOP^
 11050	035312	254 04 0 00 035313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11051	035313	324 00 0 00 035314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11052									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11053									;IN THE SUBTEST) TO LOOP ON ERROR^
 11054
 11055					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 54
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0252

 11056					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 11057					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 11058					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 11059					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)-1,,-1, THE TEST PASSES
 11060
 11061	035314	400 00 0 00 000000 	B11000:	SETZ			;PRELOAD AC WITH 0
 11062	035315	470 00 0 00 035412 		ORCB	[0]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
 11063	035316	312 00 0 00 035524 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 11064						STOP^
 11065	035317	254 04 0 00 035320 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11066	035320	324 00 0 00 035321 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11067									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11068									;IN THE SUBTEST) TO LOOP ON ERROR^
 11069
 11070					;**********
 11071
 11072					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 11073					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 11074					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 11075					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES
 11076
 11077	035321	474 00 0 00 000000 	B11100:	SETO			;PRELOAD AC WITH -1,,-1
 11078	035322	470 00 0 00 035524 		ORCB	[-1]		;*ORCB SHOULD PLACE 0 IN THE AC
 11079	035323	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 11080						STOP^
 11081	035324	254 04 0 00 035325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11082	035325	324 00 0 00 035326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11084									;IN THE SUBTEST) TO LOOP ON ERROR^
 11085
 11086					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 55
DAKABM	MAC	19-JAN-77 13:39		TEST OF BOOLEAN INSTRUCTIONS                                                       SEQ 0253

 11087					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 11088					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
 11089					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 11090					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES
 11091
 11092	035326	400 00 0 00 000000 	B11200:	SETZ			;PRELOAD AC WITH 0
 11093	035327	470 00 0 00 035524 		ORCB	[-1]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
 11094	035330	312 00 0 00 035524 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 11095						STOP^
 11096	035331	254 04 0 00 035332 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11097	035332	324 00 0 00 035333 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11098									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11099									;IN THE SUBTEST) TO LOOP ON ERROR^
 11100
 11101					;**********
 11102
 11103					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 11104					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 11105					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 11106					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES
 11107
 11108	035333	474 00 0 00 000000 	B11300:	SETO			;PRELOAD AC WITH -1,,-1
 11109	035334	470 00 0 00 035412 		ORCB	[0]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
 11110	035335	312 00 0 00 035524 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 11111						STOP^
 11112	035336	254 04 0 00 035337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11113	035337	324 00 0 00 035340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11114									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11115									;IN THE SUBTEST) TO LOOP ON ERROR^
 11116
 11117					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 56
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVN INSTRUCTION                                                           SEQ 0254

 11118					SUBTTL	TEST OF MOVN INSTRUCTION
 11119
 11120					;**********
 11121
 11122					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC
 11123					;IN THIS CASE C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 11124					;THE AC IS CHECKED FOR 0, THE NEGATIVE OF 0.  IF C(AC)=0, THIS TEST PASSES
 11125
 11126	035340	474 00 0 00 000000 	B11500:	SETO			;PRELOAD AC WITH -1,,-1
 11127	035341	210 00 0 00 035412 		MOVN	[0]		;*MOVN SHOULD PLACE 0 INTO THE AC
 11128	035342	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 11129						STOP^
 11130	035343	254 04 0 00 035344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11131	035344	324 00 0 00 035345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11132									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11133									;IN THE SUBTEST) TO LOOP ON ERROR^
 11134
 11135					;*****     FAILURE ANALYSIS     *****
 11136					;C(AC0)		C(AC1)		FAILING SIGNAL
 11137
 11138					;E				SW: FCE
 11139					;-1,,-1				FC: AD FM + EN
 11140					;-1,,-1				FC: AD CRY 36
 11141
 11142					;**********
 11143
 11144					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC.
 11145					;IN THIS CASE C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE 1,,0
 11146					;THE AC IS CHECKED FOR 1,,0.  IF C(AC)=1,,0, THE TEST PASSES
 11147
 11148	035345	200 00 0 00 035502 	B11600:	MOVE	[XWD -1,0]	;PRELOAD AC,E WITH -1,,0
 11149	035346	210 00 0 00 000000 		MOVN			;*MOVN SHOULD PLACE 1,,0 INTO THE AC
 11150	035347	312 00 0 00 035440 		CAME	[XWD 1,0]	;PASS IF C(AC)=1,,0
 11151						STOP^
 11152	035350	254 04 0 00 035351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11153	035351	324 00 0 00 035352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11154									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11155									;IN THE SUBTEST) TO LOOP ON ERROR^
 11156
 11157					;*****     FAILURE ANALYSIS     *****
 11158					;C(AC0)		C(AC1)		FAILING SIGNAL
 11159
 11160					;0				FC: AD ADD
 11161					;0				FC: AD FM - EN
 11162					;0				FC: AD AR - EN
 11163					;-1,,0				ET2: AR AD EN
 11164
 11165					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 57
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVN INSTRUCTION                                                           SEQ 0255

 11166					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC.
 11167					;IN THIS CASE C(E) =707070,,707070.  HENCE, THE RESULT IN THE AC SHOULD BE
 11168					;070707,,070710.  THE AC IS CHECKED FOR 070707,,070710.  IF C(AC)=
 11169					;070707,,070710, THE TEST PASSES
 11170
 11171	035352	400 00 0 00 000000 	B11700:	SETZ			;PRELOAD AC WITH 0
 11172	035353	210 00 0 00 035650 		MOVN	[707070707070]	;*MOVN SHOULD PLACE 070707,,070710 INTO THE AC
 11173	035354	312 00 0 00 035654 		CAME	[070707070710]	;PASS IF C(AC) 070707,,070710
 11174						STOP^
 11175	035355	254 04 0 00 035356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11176	035356	324 00 0 00 035357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11177									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11178									;IN THE SUBTEST) TO LOOP ON ERROR^
 11179
 11180					;**********
 11181
 11182					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC
 11183					;IN THIS CASE C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0,,1.
 11184					;THE AC IS CHECKED FOR 0,,1, THE NEGATIVE OF -1,,-1.  IF C(AC)=1, THIS TEST PASSES
 11185
 11186	035357	210 00 0 00 035524 	B12100:	MOVN	[-1]		;*MOVN SHOULD PLACE 0,,1 INTO THE AC
 11187	035360	302 00 0 00 000001 		CAIE	1		;PASS OF C(AC)=0,,1
 11188						STOP^
 11189	035361	254 04 0 00 035362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11190	035362	324 00 0 00 035363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11191									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11192									;IN THE SUBTEST) TO LOOP ON ERROR^
 11193
 11194					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 58
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVM INSTRUCTION                                                           SEQ 0256

 11195					SUBTTL	TEST OF MOVM INSTRUCTION
 11196
 11197					;**********
 11198
 11199					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC.
 11200					;IN THIS CASE, C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 11201					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 11202
 11203	035363	474 00 0 00 000000 	B12200:	SETO			;PRELOAD AC WITH -1,,-1
 11204	035364	214 00 0 00 035412 		MOVM	[0]		;*MOVM SHOULD PLACE 0 INTO THE AC
 11205	035365	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 11206						STOP^
 11207	035366	254 04 0 00 035367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11208	035367	324 00 0 00 035370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11209									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11210									;IN THE SUBTEST) TO LOOP ON ERROR^
 11211
 11212					;*****     FAILURE ANALYSIS     *****
 11213					;C(AC0)		C(AC1)		FAILING SIGNAL
 11214
 11215					;E				SW: FCE
 11216
 11217					;**********
 11218
 11219					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
 11220					;IN THIS CASE, C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0,,1.
 11221					;THE AC IS CHECKED FOR 0,,1.  IF C(AC)=0,,1, THIS TEST PASSES
 11222
 11223	035370	400 00 0 00 000000 	B12300:	SETZ			;PRELOAD AC WITH 0
 11224	035371	214 00 0 00 035524 		MOVM	[-1]		;*MOVM SHOULD PLACE 0,,1 INTO THE AC
 11225	035372	302 00 0 00 000001 		CAIE	1		;PASS IF C(AC)=0,,1
 11226						STOP^
 11227	035373	254 04 0 00 035374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11228	035374	324 00 0 00 035375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11229									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11230									;IN THE SUBTEST) TO LOOP ON ERROR^
 11231
 11232					;*****     FAILURE ANALYSIS     *****
 11233					;C(AC0)		C(AC1)		FAILING SIGNAL
 11234
 11235					;0				FC: AD FM + EN
 11236					;0				FC: AD ADD
 11237					;0				FC: AD CRY 36
 11238					;0				FC: AD AR - EN
 11239					;-1,,-1				ET2: AR AD EN
 11240
 11241					;**********
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 59
DAKABM	MAC	19-JAN-77 13:39		TEST OF MOVM INSTRUCTION                                                           SEQ 0257

 11242					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
 11243					;IN THIS CASE, C(E)=400000,,0.  HENCE, THE RESULT IN THE AC SHOULD BE
 11244					;400000,,0.  THE AC IS CHECKED FOR 400000,,0.
 11245					;IF C(AC)=400000,,0, THIS TEST PASSES.
 11246
 11247	035375	400 00 0 00 000000 	B12400:	SETZ
 11248	035376	214 00 0 00 035461 		MOVM	[XWD 400000,0]	;*MOVM SHOULD PLACE 400000,,0 INTO THE AC
 11249	035377	312 00 0 00 035461 		CAME	[XWD 400000,0]	;PASS IF C(AC)=400000,,0
 11250						STOP^
 11251	035400	254 04 0 00 035401 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11252	035401	324 00 0 00 035402 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11253									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11254									;IN THE SUBTEST) TO LOOP ON ERROR^
 11255
 11256					;**********
 11257
 11258					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
 11259					;IN THIS CASE, C(E)=377777,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE
 11260					;377777,,-1.  THE AC IS CHECKED FOR 377777,,-1.
 11261					;IF C(AC)=377777,,-1, THIS TEST PASSES.
 11262
 11263	035402	400 00 0 00 000000 	B12500:	SETZ			;PRELOAD AC WITH 0
 11264	035403	214 00 0 00 035540 		MOVM	[XWD 377777,-1]	;*MOVM SHOULD PLACE 377777,,-1 INTO THE AC
 11265	035404	312 00 0 00 035540 		CAME	[XWD 377777,-1]	;PASS IF C(AC)=377777,,-1
 11266						STOP^
 11267	035405	254 04 0 00 035406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11268	035406	324 00 0 00 035407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11269									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11270									;IN THE SUBTEST) TO LOOP ON ERROR^
 11271
 11272					;**********
 11273	035407	254 00 0 00 030057 		JRST	BEGEND
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 1
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 0258

 11274					SUBTTL	*STOR* RESERVED STORAGE, JAN 18,1977
 11275
 11276					;PROGRAM LITERALS
 11277
 11278						XLIST
 11279					IFNDEF	$LPAPER,<LIST>
 11280	035410					LIT
 11281	035410	000001	000001
 11282	035411	254 00 0 00 030741
 11283	035412	000000	000000
 11284	035413	123456	765432
 11285	035414	123456	000000
 11286	035415	000000	123456
 11287	035416	000000	000001
 11288	035417	000000	000002
 11289	035420	000000	000004
 11290	035421	000000	000010
 11291	035422	000000	000020
 11292	035423	000000	000040
 11293	035424	000000	000100
 11294	035425	000000	000200
 11295	035426	000000	000400
 11296	035427	000000	001000
 11297	035430	000000	002000
 11298	035431	000000	004000
 11299	035432	000000	010000
 11300	035433	000000	020000
 11301	035434	000000	040000
 11302	035435	000000	100000
 11303	035436	000000	200000
 11304	035437	000000	400000
 11305	035440	000001	000000
 11306	035441	000002	000000
 11307	035442	000004	000000
 11308	035443	000010	000000
 11309	035444	000020	000000
 11310	035445	000040	000000
 11311	035446	000100	000000
 11312	035447	000200	000000
 11313	035450	000400	000000
 11314	035451	001000	000000
 11315	035452	002000	000000
 11316	035453	004000	000000
 11317	035454	010000	000000
 11318	035455	020000	000000
 11319	035456	040000	000000
 11320	035457	100000	000000
 11321	035460	200000	000000
 11322	035461	400000	000000
 11323	035462	600000	000000
 11324	035463	700000	000000
 11325	035464	740000	000000
 11326	035465	760000	000000
 11327	035466	770000	000000
 11328	035467	774000	000000
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 1-1
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 0259

 11329	035470	776000	000000
 11330	035471	777000	000000
 11331	035472	777400	000000
 11332	035473	777600	000000
 11333	035474	777700	000000
 11334	035475	777740	000000
 11335	035476	777760	000000
 11336	035477	777770	000000
 11337	035500	777774	000000
 11338	035501	777776	000000
 11339	035502	777777	000000
 11340	035503	777777	400000
 11341	035504	777777	600000
 11342	035505	777777	700000
 11343	035506	777777	740000
 11344	035507	777777	760000
 11345	035510	777777	770000
 11346	035511	777777	774000
 11347	035512	777777	776000
 11348	035513	777777	777000
 11349	035514	777777	777400
 11350	035515	777777	777600
 11351	035516	777777	777700
 11352	035517	777777	777740
 11353	035520	777777	777760
 11354	035521	777777	777770
 11355	035522	777777	777774
 11356	035523	777777	777776
 11357	035524	777777	777777
 11358	035525	777777	777773
 11359	035526	777777	777677
 11360	035527	777777	775777
 11361	035530	777777	737777
 11362	035531	777777	377777
 11363	035532	777767	777777
 11364	035533	777577	777777
 11365	035534	773777	777777
 11366	035535	677777	777777
 11367	035536	577777	777777
 11368	035537	000000	777777
 11369	035540	377777	777777
 11370	035541	000002	000002
 11371	035542	000004	000004
 11372	035543	000010	000010
 11373	035544	000020	000020
 11374	035545	000040	000040
 11375	035546	000100	000100
 11376	035547	000200	000200
 11377	035550	000400	000400
 11378	035551	001000	001000
 11379	035552	002000	002000
 11380	035553	004000	004000
 11381	035554	010000	010000
 11382	035555	020000	020000
 11383	035556	040000	040000
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 1-2
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 0260

 11384	035557	100000	100000
 11385	035560	200000	200000
 11386	035561	400000	400000
 11387	035562	777776	777776
 11388	035563	777775	777775
 11389	035564	777773	777773
 11390	035565	777767	777767
 11391	035566	777757	777757
 11392	035567	777737	777737
 11393	035570	777677	777677
 11394	035571	777577	777577
 11395	035572	777377	777377
 11396	035573	776777	776777
 11397	035574	775777	775777
 11398	035575	773777	773777
 11399	035576	767777	767777
 11400	035577	757777	757777
 11401	035600	737777	737777
 11402	035601	677777	677777
 11403	035602	577777	577777
 11404	035603	377777	377777
 11405	035604	000001	777776
 11406	035605	777776	000001
 11407	035606	000002	777775
 11408	035607	777775	000002
 11409	035610	000004	777773
 11410	035611	777773	000004
 11411	035612	000010	777767
 11412	035613	777767	000010
 11413	035614	000020	777757
 11414	035615	777757	000020
 11415	035616	000040	777737
 11416	035617	777737	000040
 11417	035620	000100	777677
 11418	035621	777677	000100
 11419	035622	000200	777577
 11420	035623	777577	000200
 11421	035624	000400	777377
 11422	035625	777377	000400
 11423	035626	001000	776777
 11424	035627	776777	001000
 11425	035630	002000	775777
 11426	035631	775777	002000
 11427	035632	004000	773777
 11428	035633	773777	004000
 11429	035634	010000	767777
 11430	035635	767777	010000
 11431	035636	020000	757777
 11432	035637	757777	020000
 11433	035640	040000	737777
 11434	035641	737777	040000
 11435	035642	100000	677777
 11436	035643	677777	100000
 11437	035644	200000	577777
 11438	035645	577777	200000
DAKAB PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2) 0,2	MACRO %52(537) 14:08 19-JAN-77 PAGE 1-3
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 0261

 11439	035646	400000	377777
 11440	035647	377777	400000
 11441	035650	707070	707070
 11442	035651	000000	707070
 11443	035652	707070	777777
 11444	035653	070707	777777
 11445	035654	070707	070710
 11446						LIST
 11447	035655	000000	000000		ENDSLD:	0
 11448
 11449					IFDEF	DEBUG,<
 11450					PATCH:	BLOCK DEBUG		;PATCHING AREA
 11451					>
 11452
 11453					;PROGRAM VARIABLES
 11454	035656					VAR
 11455
 11456					IFDEF	PGMEND,<
 11457	035656	000000	000000		END:	0
 11458			030000			END	BEGIN	>

NO ERRORS DETECTED

PROGRAM BREAK IS 000000
ABSLUTE BREAK IS 035657
CPU TIME USED 00:41.977

11K CORE USED
