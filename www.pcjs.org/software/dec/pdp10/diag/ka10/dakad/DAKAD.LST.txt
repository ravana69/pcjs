DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 1
DAKADT	MAC	19-JAN-77 13:37		DIAGNOSTIC PARAMETERS                                                              SEQ 0007

     1					;DAKAD
     2
     3
     4
     5			000002			DECVER==2
     6			000000			MCNVER==0
     7
     8						XLIST
     9						LIST
    10						LALL
    11						NAME	\MCNVER,\DECVER^
    12
    13					TITLE	DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2
    14					^
    15
    16					;TEST DESIGNED FOR INITIAL DEBUGGING OF PROCESSOR HARDWARE
    17					;AND TO DETECT (SOLID) FAILURES IN THE FIELD.
    18
    19					;COPYRIGHT 1972,1977
    20					;DIGITAL EQUIPMENT CORPORATION
    21					;MARLBORO, MASS. 01752
    22
    23					;JOHN R. KIRCHOFF
    24					;DICK MALISKA
    25
    26	000137					LOC	137
    27	000137	000000	000002			MCNVER,,DECVER
    28
    29						NOSYM
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 2
DAKADT	MAC	19-JAN-77 13:37		DIAGNOSTIC PARAMETERS                                                              SEQ 0008

    30					SUBTTL	DIAGNOSTIC PARAMETERS
    31
    32					;PARAMETER DEFINITIONS
    33			000001		EXCASB==1
    34			000001		USRASB==1
    35			000001		PGMEND==1
    36			000100		DEBUG==100
    37
    38					;FLAG DEFINITIONS
    39			010000		USERF=10000		;USER MODE FLAG
    40
    41
    42					;MACROS
    43
    44					;SPECIAL FEATURE PARAMETERS
    45
    46			030712		SADR1=START
    47			030712		SADR2=START
    48			030712		SADR3=START
    49			030712		SADR4=START
    50		254000	030712		SADR5=JRST START
    51		254000	030712		SADR6=JRST START
    52		254000	030712		SADR7=JRST START
    53		254000	030712		SADR8=JRST START
    54		254000	030712		SADR9=JRST START
    55		254000	030712		SADR10=JRST START
    56		254000	030712		SADR11=JRST START
    57
    58			000000		PAREA0=0
    59			000000		PAREA1=0
    60			000000		PAREA2=0
    61		444253	414400		PAREA3=SIXBIT/DBKAD/
    62		645560	000000		PAREA4=SIXBIT/TMP/
    63			000000		PAREA5=0
    64			000000		PAREA6=0
    65			001000		ITERAT==1000
    66			000001		PGMEND=1
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 1
PARAM	KLM	18-JAN-77 11:38		*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, JAN 18,1977                               SEQ 0009

    67					SUBTTL	*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, JAN 18,1977
    68
    69					DEFINE	S,<;*********************************************************************>
    70
    71					S^;*********************************************************************^
    72					;*DATA SWITCHES (READ FROM CONSOLE IN EXEC MODE OR TYPED IN IN USER MODE)
    73					;*LEFT HALF SWITCHES ARE PRE-ASSIGNED FOR SUBROUTINE PACKAGE USE
    74					;*AND CONTROL LOOPING, PRINTING (TTY OR OTHER DEVICE) AND MISC. FUNCTIONS
    75					S^;*********************************************************************^
    76
    77			400000		ABORT==	400000			;ABORT PROGRAM ON PASS COMPLETION
    78			200000		RSTART==200000			;RESTART TEST, PRINT TOTALS
    79			100000		TOTALS==100000			;PRINT TOTALS, CONTINUE
    80
    81			040000		NOPNT==	040000			;INHIBIT ALL PRINT/TYPE OUT (EXCEPT FORCED)
    82			020000		PNTLPT==020000			;PRINT ALL DATA ON LPT (LOGICAL DEVICE, USER MODE)
    83			010000		DING==	010000			;RING BELL ON ERROR
    84
    85			004000		LOOPER==004000			;ENTER EXERCISE/CHECK LOOP ON ERROR
    86			002000		ERSTOP==002000			;HALT ON TEST ERROR
    87			001000		PALERS==001000			;PRINT ALL ERRORS
    88
    89			000400		RELIAB==000400			;RELIABILITY MODE
    90			000200		TXTINH==000200			;INHIBIT ERROR TEXT
    91			000100		INHPAG==000100			;INHIBIT PAGING
    92
    93			000040		MODDVC==000040			;MODIFY DEVICE CODE
    94			000020		INHCSH==000020			;INHIBIT CACHE
    95			000010		OPRSEL==000010			;OPERATOR SELECTION
    96
    97			000004		CHAIN==	000004			;CHAIN CONTROL SWITCH
    98
    99			000002		KAHZ50==000002			;KA10 50 HERTZ POWER
   100
   101									;SWITCH 17 RESERVED !!!
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 2
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0010

   102					SUBTTL	*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977
   103
   104					S^;*********************************************************************^
   105					;*SPECIAL SUBPROGRAM LINKAGES
   106					S^;*********************************************************************^
   107
   108			027772		FSELNK=	27772	;FILE SELECT LINK
   109			027773		FRDLNK=	27773	;FILE READ LINK
   110			027774		LDLNK=	27774	;LOAD LINKAGE ADDRESS
   111			027775		DDTLNK=	27775	;DDT LINKAGE ADDRESS
   112			027776		MODLNK=	27776	;OPERATIONAL MODE CHECK LINKAGE ADDRESS
   113			027777		SUBLNK=	27777	;SUBROUTINE LINKAGE ADDRESS
   114
   115					S^;*********************************************************************^
   116					;*SPECIAL SUBROUTINE FATAL HALTS
   117					;*USED TO REPORT ERRORS THAT CAUSE THE SUBROUTINES TO BE UNUSABLE
   118					S^;*********************************************************************^
   119
   120					;ADDRESS   TAG	REASON
   121					;---------------------
   122
   123					; 1010 	NOEXEC	;PROGRAM NOT CODED FOR EXEC MODE OPERATION
   124					; 1011  PLERR	;FATAL PUSH LIST POINTER ERROR
   125					; 1012  PLERR1	;INITIAL PUSH LIST POINTER ERROR
   126					; 1013  MUOERR	;MUUO WITH LUUO HANDLER WIPED OUT
   127					; 1014  DTEBER	;DTE20 INTERRUPT WITHOUT DOORBELL
   128					; 1015  DTECER	;DTE20 CLOCK INTERRUPT WITHOUT FLAG SET
   129					; 1016  CPIERR	;CPU INITIALIZATION ERROR
   130					; 1017  EOPERR	;END OF PROGRAM ERROR
   131					; 1020  LUOERR	;INTERRUPT WITH LUUO HANDLER WIPED OUT
   132
   133					S^;*********************************************************************^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 3
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0011

   134					S^;*********************************************************************^
   135					;OPERATOR DEFINITIONS (NON-UUO'S)
   136					S^;*********************************************************************^
   137
   138		260740	000000		OPDEF	GO	[PUSHJ	P,]	;SUBROUTINE CALL
   139		263740	000000		OPDEF	RTN	[POPJ	P,]	;SUBROUTINE RETURN
   140		261740	000000		OPDEF	PUT	[PUSH	P,]	;PUT DATA ON PUSH LIST
   141		262740	000000		OPDEF	GET	[POP	P,]	;GET DATA FROM PUSH LIST
   142		254000	000000		OPDEF	PJRST	[JRST	]	;JRST TO ROUTINE THAT RTN'S
   143		254200	000000		OPDEF	HALT	[JRST	4,]	;DEFINITION FOR DDT
   144		254100	000000		OPDEF	JRSTF	[JRST	2,]	;DEFINITION FOR DDT
   145		254500	000000		OPDEF	JEN	[JRST	12,]	;DEFINITION FOR DDT
   146
   147					S^;*********************************************************************^
   148					;*SUBROUTINE INITIALIZATION CALL
   149					S^;*********************************************************************^
   150
   151		265000	030011		OPDEF	PGMINT	[JSP	0,SBINIT]	;SUBROUTINE INITIALIZATION
   152
   153					S^;*********************************************************************^
   154					;*HALTING UUO'S (A MORE GRACEFUL HALT THAN SIMPLY USING THE HALT INSTRUCTION).
   155					S^;*********************************************************************^
   156
   157		037640	000004		OPDEF	FATAL	[37B8!15B12!4]	;FATAL PROGRAMMING HALT
   158		037600	000004		OPDEF	ERRHLT	[37B8!14B12!4]	;PROGRAM ERROR HALT
   159
   160					S^;*********************************************************************^
   161					;*TERMINAL INPUT UUO'S
   162					;*ALWAYS COME FROM THE CONSOLE TERMINAL IN EXEC MODE OR THE
   163					;*CONTROLLING TERMINAL (REAL TERMINAL OR PTY) IN USER MODE.
   164					S^;*********************************************************************^
   165
   166		037000	000003		OPDEF	TTICHR 	[37B8!0B12!3]	;TTY, INPUT ANY CHARACTER
   167		037040	000003		OPDEF	TTIYES	[37B8!1B12!3]	;TTY, NORMAL RETURN Y
   168		037100	000003		OPDEF	TTINO	[37B8!2B12!3]	;TTY, NORMAL RETURN N
   169		037140	000003		OPDEF	TTIOCT	[37B8!3B12!3]	;TTY, INPUT OCTAL WORD
   170		037200	000003		OPDEF	TTIDEC	[37B8!4B12!3]	;TTY, INPUT DECIMAL WORD
   171		037240	000003		OPDEF	TTICNV	[37B8!5B12!3]	;TTY, INPUT CONVERTABLE WORD
   172		037300	000003		OPDEF	TTLOOK	[37B8!6B12!3]	;TTY, KEYBOARD CHECK
   173		037340	000003		OPDEF	TTALTM	[37B8!7B12!3]	;TTY, ALT-MODE CHECK
   174		037400	000003		OPDEF	TTSIXB	[37B8!10B12!3]	;TTY, INPUT SIXBIT WORD
   175		037440	000003		OPDEF	TTYINP	[37B8!11B12!3]	;TTY, IMAGE MODE INPUT
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 4
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0012

   176					;*TERMINAL OUTPUT UUO'S.
   177
   178		037000	000000		OPDEF	PNTA	[37B8!0B12!0]	;PRINT ASCII WORD
   179		037000	000001		OPDEF	PNTAF	[37B8!0B12!1]	;PRINT ASCII WORD FORCED
   180		037740	000000		OPDEF	PNTAL	[37B8!17B12!0]	;PRINT ASCIZ LINE
   181		037740	000001		OPDEF	PNTALF	[37B8!17B12!1]	;PRINT ASCIZ LINE FORCED
   182		037600	000003		OPDEF	PSIXL	[37B8!14B12!3]	;PRINT SIXBIT'Z LINE
   183		037640	000003		OPDEF	PSIXLF	[37B8!15B12!3]	;PRINT SIXBIT'Z LINE FORCED
   184		037000	000000		OPDEF	PNTMSG	[37B8!0B12!0]	;PRINT MESSAGE IMMEDIATE
   185		037040	000000		OPDEF	PNTMSF	[37B8!1B12!0]	;PRINT MESSAGE IMMEDIATE FORCED
   186		037100	000000		OPDEF	PSIXM	[37B8!2B12!0]	;PRINT SIXBIT'Z MSG IMMEDIATE
   187		037200	000000		OPDEF	PSIXMF	[37B8!4B12!0]	;PRINT SIXBIT'Z MSG IMM FORCED
   188		037000	000000		OPDEF	PNTCI	[37B8!0B12!0]	;PRINT CHARACTER IMMEDIATE
   189		037040	000000		OPDEF	PNTCIF	[37B8!1B12!0]	;PRINT CHARACTER IMMEDIATE FORCED
   190		037500	000000		OPDEF	PNTCHR	[37B8!12B12!0]	;PRINT CHARACTER
   191		037500	000001		OPDEF	PNTCHF	[37B8!12B12!1]	;PRINT CHARACTER FORCED
   192		037040	000000		OPDEF	PNT1	[37B8!1B12!0]	;PRINT ONE OCTAL DIGIT
   193		037040	000001		OPDEF	PNT1F	[37B8!1B12!1]	;PRINT 1 OCTAL DIGIT FORCED
   194		037100	000000		OPDEF	PNT2	[37B8!2B12!0]	;PRINT TWO OCTAL DIGITS
   195		037100	000001		OPDEF	PNT2F	[37B8!2B12!1]	;PRINT 2 OCTAL DIGITS FORCED
   196		037140	000000		OPDEF	PNT3	[37B8!3B12!0]	;PRINT THREE OCTAL DIGITS
   197		037140	000001		OPDEF	PNT3F	[37B8!3B12!1]	;PRINT THREE OCTAL DIGITS FORCED
   198		037200	000000		OPDEF	PNT4	[37B8!4B12!0]	;PRINT FOUR OCTAL DIGITS
   199		037200	000001		OPDEF	PNT4F	[37B8!4B12!1]	;PRINT FOUR OCTAL DIGITS FORCED
   200		037240	000000		OPDEF	PNT5	[37B8!5B12!0]	;PRINT FIVE OCTAL DIGITS
   201		037240	000001		OPDEF	PNT5F	[37B8!5B12!1]	;PRINT FIVE OCTAL DIGITS FORCED
   202		037300	000000		OPDEF	PNT6	[37B8!6B12!0]	;PRINT SIX OCTAL DIGITS
   203		037300	000001		OPDEF	PNT6F	[37B8!6B12!1]	;PRINT SIX OCTAL DIGITS FORCED
   204		037340	000000		OPDEF	PNT7	[37B8!7B12!0]	;PRINT 7 OCTAL DIGITS
   205		037340	000001		OPDEF	PNT7F	[37B8!7B12!1]	;PRINT 7 OCTAL DIGITS FORCED
   206		037440	000000		OPDEF	PNT11	[37B8!11B12!0]	;PRINT 11 OCTAL DIGITS
   207		037440	000001		OPDEF	PNT11F	[37B8!11B12!1]	;PRINT 11 OCTAL DIGITS FORCED.
   208		037400	000000		OPDEF	PNTADR	[37B8!10B12!0]	;PRINT PHYSICAL ADDRESS
   209		037400	000001		OPDEF	PNTADF	[37B8!10B12!1]	;PRINT PHYSICAL ADDRESS FORCED
   210		037600	000000		OPDEF	PNTOCT  [37B8!14B12!0]	;PRINT FULL WORD OCTAL
   211		037600	000001		OPDEF	PNTOTF	[37B8!14B12!1]	;PRINT FULL WORD OCTAL FORCED
   212		037540	000000		OPDEF	PNTHW	[37B8!13B12!0]	;PRINT OCTAL HALF WORDS, 6 SP 6
   213		037540	000001		OPDEF	PNTHWF	[37B8!13B12!1]	;PRINT OCTAL HALF WORDS, 6 SP 6 FORCED
   214		037700	000003		OPDEF	PNTOCS	[37B8!16B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S
   215		037740	000003		OPDEF	PNTOCF	[37B8!17B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S FORCED
   216		037640	000000		OPDEF	PNTDEC	[37B8!15B12!0]	;PRINT DECIMAL, SUPRESS LEADING 0'S
   217		037640	000001		OPDEF	PNTDCF	[37B8!15B12!1]	;PRINT DECIMAL, SUPRESS LEADING 0'S FORCED
   218		037700	000000		OPDEF	PNTDS	[37B8!16B12!0]	;PRINT DECIMAL, SPACES FOR LD 0'S
   219		037700	000001		OPDEF	PNTDSF	[37B8!16B12!1]	;PRINT DECIMAL, SPACES FOR LD 0'S FORCED
   220		037200	000002		OPDEF	PNTNM	[37B8!4B12!2]	;PRINT PROGRAM NAME
   221		037000	000002		OPDEF	PNTSIX	[37B8!0B12!2]	;PRINT SIXBIT WORD
   222		037040	000002		OPDEF	PNTSXF	[37B8!1B12!2]	;PRINT SIXBIT WORD FORCED
   223		037240	000002		OPDEF	DROPDV	[37B8!5B12!2]	;CLOSE LOGICAL FILE, USER MODE
   224		037100	000002		OPDEF	PNTCW	[37B8!2B12!2]	;PRINT DF10 CONTROL WORD
   225		037140	000002		OPDEF	PNTCWF	[37B8!3B12!2]	;PRINT DF10 CONTROL WORD FORCED
   226		037000	030242		OPDEF	PCRL	[37B8!0B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED
   227		037040	030242		OPDEF	PCRLF	[37B8!1B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED FORCED
   228		037000	000040		OPDEF	PSP	[37B8!0B12!40]	;PRINT SPACE
   229		037040	000040		OPDEF	PSPF	[37B8!1B12!40]	;PRINT SPACE FORCED
   230		037000	030243		OPDEF	PCRL2	[37B8!0B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE)
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 4-1
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0013

   231		037040	030243		OPDEF	PCRL2F	[37B8!1B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE) FORCED
   232		037040	000007		OPDEF	PBELL	[37B8!1B12!7]	;PRINT TTY BELL
   233
   234		037040	000026		OPDEF	PFORCE	[37B8!1B12!26]	;PRINT FORCE, CONTROL O OVERRIDE
   235
   236					DEFINE	PMSG	(ARG),<
   237						PSIXM	[SIXBIT\ARG'_\]>
   238
   239					DEFINE	PMSGF	(ARG),<
   240						PSIXMF	[SIXBIT\ARG'_\]>
   241
   242					;*SIXBTZ -- MACRO TO GENERATE SIXBIT DATA FOR PRINTING
   243					;*	CONSERVES CORE OVER ASCIZ
   244
   245					DEFINE	SIXBTZ	(ARG),<	[SIXBIT\ARG'_\]>
   246
   247					;*CONSOLE SWITCH INPUT UUO.
   248					;*READS CONSOLE SWITCHES IF IN EXEC MODE OR ASKS FOR THEM IF
   249					;* USER MODE.
   250
   251		037400	000002		OPDEF	SWITCH	[37B8!10B12!2]	;INPUT CONSOLE SWITCHES
   252
   253					;*CLOCK INITIALIZATION UUO - TO SET DESIRED CLOCK OPERATION
   254					;*EITHER IGNORE CLOCK, ONLY LET IT TICK OR CAUSE INTERRUPT TO OCCUR.
   255
   256		037540	000004		OPDEF	CLOKOP	[37B8!13B12!4]	;CLOCK OPERATION UUO - PDP-11 CLOCK
   257		037200	000004		OPDEF	MTROP	[37B8!4B12!4]	;CLOCK OPERATION UUO - DK20 METER
   258
   259					;*KL10 ONLY CACHE OPERATION UUO'S
   260
   261		037040	000004		OPDEF	CINVAL	[37B8!1B12!4]	;CACHE INVALIDATE
   262		037100	000004		OPDEF	CFLUSH	[37B8!2B12!4]	;CACHE FLUSH
   263		037140	000004		OPDEF	CWRTBI	[37B8!3B12!4]	;CACHE WRITE-BACK & INVALIDATE
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 5
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0014

   264					;*END OF PASS/PROGRAM UUOS
   265
   266					;PERFORMS THE END OF PASS FUNCTIONS. INCREMENT PASS COUNT,
   267					;*DECREMENT ITERATION COUNT, CHECK IF FINISHED WITH THIS PROGRAM ETC.
   268
   269		037500	000004		OPDEF	ENDUUO	[37B8!12B12!4]	;UUO TO DISPLAY LIGHTS
   270		037700	000004		OPDEF	EOPUUO	[37B8!16B12!4]	;END OF PROGRAM UUO
   271
   272					;*MEMORY MANAGEMENT UUO'S
   273					;*UUO'S TO PERFORM VARIOUS MEMORY FUNCTIONS. MAPPING, ZEROING, PAGING,
   274					;*ADDRESS CONVERSION, ETC...
   275
   276		037000	000004		OPDEF	MAPMEM	[37B8!0B12!4]	;MAP MEMORY
   277		037500	000002		OPDEF	MEMZRO	[37B8!12B12!2]	;ZERO MEMORY
   278		037440	000002		OPDEF	MEMSEG	[37B8!11B12!2]	;SETUP MEMORY SEGMENT
   279		037540	000002		OPDEF	MAPADR	[37B8!13B12!2]	;VIRTUAL TO PHYSICAL ADR CONVERT
   280		037640	000002		OPDEF	MAPCNK	[37B8!15B12!2]	;MAP MEMORY CHUNK
   281		037600	000002		OPDEF	MAPSET	[37B8!14B12!2]	;SET KI10 EXEC PAGE MAP
   282		037740	000002		OPDEF	MAPPNT	[37B8!17B12!2]	;PRINT MEMORY MAP
   283
   284					;*DEVICE CODE MODIFICATION UUO
   285					;*ALLOWS THE MODIFICATION OF IOT'S TO ONE DEVICE TO BE CHANGED TO
   286					;*IOT'S TO A DIFFERENT DEVICE CODE.
   287
   288		037340	000002		OPDEF	MODPCU	[37B8!7B12!2]	;MODIFY PERHIPERAL CODE, USER
   289		037300	000002		OPDEF	MODPCP	[37B8!6B12!2]	;MODIFY PERHIPERAL CODE, PROGRAM
   290
   291			030000			IFNDEF	MODDVL,<MODDVL==BEGIN>
   292			030000			IFNDEF	MODDVU,<MODDVU==BEGIN>
   293
   294					;*"DIAMON" FILE SELECTION AND READ UUOS
   295
   296		037240	000004		OPDEF	FSELECT	[37B8!5B12!4]	;FILE SELECTION
   297		037300	000004		OPDEF	FREAD	[37B8!6B12!4]	;FILE READ - ASCII DATA
   298		037340	000004		OPDEF	FRD36	[37B8!7B12!4]	;FILE READ - 36 BIT DATA
   299		037400	000004		OPDEF	FRD8	[37B8!10B12!4]	;FILE READ - 8 BIT DATA
   300
   301					;*KI10 ONLY UUO FOR PRINTING MARGIN VALUES
   302
   303		037700	000002		OPDEF	PNTMGN	[37B8!16B12!2]	;PRINT MARGIN VALUE
   304
   305						XLIST
   306					IFNDEF	KLOLD,<LIST
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 6
PARAM	KLM	18-JAN-77 11:38		ERROR HANDLING UUO DEFINITIONS, JAN 18,1977                                        SEQ 0015

   307					SUBTTL	ERROR HANDLING UUO DEFINITIONS, JAN 18,1977
   308
   309					S^;*********************************************************************^
   310					;*ERROR HANDLER PARAMETERS
   311					S^;*********************************************************************^
   312
   313		036000	000000		OPDEF	ERUUO	[36B8]		;ERROR CALL UUO
   314		035000	000000		OPDEF	ERLOOP	[35B8]		;ERROR LOOP, CHECKS PC,REPT,REPT1,ERROR
   315		035040	000000		OPDEF	ERLP1	[35B8!1B12]	;ERROR LOOP IF PC'S MATCH
   316		035100	000000		OPDEF	ERLP2	[35B8!2B12]	;ERROR LOOP IF ANY ERROR
   317		034000	000000		OPDEF	REPTUO	[34B8]		;REPEAT LOOP UUO
   318
   319					;*THE ERROR HANDLER MACROS
   320
   321					;*A MACRO TO REPORT AN ERROR AND LOOP
   322
   323						DEFINE	ERROR	(ADR,FORMAT,CORECT,ACTUAL,F,D,ERR)<
   324						SALL
   325						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   326							   CORECT,,ACTUAL
   327							   [SIXBIT\D'_\],,ERR]
   328						XALL
   329
   330						ERLOOP	ADR		;IF ERROR, LOOP TO ADR
   331					>
   332
   333					;*A MACRO TO REPORT AN ERROR AND NOT LOOP
   334
   335						DEFINE	ERROR1	(FORMAT,CORECT,ACTUAL,F,D,ERR)<
   336						SALL
   337						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   338							   CORECT,,ACTUAL
   339							   [SIXBIT\D'_\],,ERR]
   340						XALL	>
   341
   342					>;END OF KLOLD CONDITIONAL
   343
   344						XLIST
   345						LIST
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 1
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0016

   346					SUBTTL	*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977
   347
   348	030000					LOC	30000
   349
   350					S^;*********************************************************************^
   351					;*PROGRAM STARTING ADDRESSES
   352					;*THESE ADDRESSES CALL VARIOUS SPECIAL START ROUTINES AND OR OPTIONS
   353					;*NORMAL START ADDRESS IS 30000 ALL OTHERS ARE SPECIAL. INVOKED BECAUSE
   354					;*OF END OF PASS, POWER FAILURE, DDT START, RE-ENTERING(TYPICALLY USER
   355					;*MODE), OR ANY NUMBER OF SPECIAL FEATURE TESTS.
   356					S^;*********************************************************************^
   357
   358	030000	254 00 1 00 027776 	BEGIN:	JRST	@MODLNK		;STAND-ALONE START
   359	030001	254 00 0 00 030712 	$START:	JRST	START		;MODE CHECK STARTING ADDRESS
   360
   361	030002	254 00 1 00 027774 	DIAGMN:	JRST	@LDLNK		;DIAGNOSTIC MONITOR START
   362
   363	030003	254 00 1 00 027774 	SYSEXR:	JRST	@LDLNK		;SYSTEM EXERCISER START
   364
   365	030004	254 00 0 00 030712 	SFSTRT:	JRST	SADR1		;SPECIAL FEATURE START
   366
   367	030005	254 00 0 00 030712 	PFSTRT:	JRST	SADR2		;POWER FAIL RESTART
   368
   369	030006	254 00 0 00 030712 	REENTR:	JRST	SADR3		;REENTER START(USUALLY USER MODE ONLY)
   370
   371	030007				SRTDDT:				;COMMONLY MISTAKEN NAME FOR "DDTSRT"
   372	030007	254 00 1 00 027775 	DDTSRT:	JRST	@DDTLNK		;DDT START
   373
   374	030010	254 00 0 00 030741 	BEGIN1:	JRST	STARTA		;LOOP START(END OF PASS COMES HERE)
   375	030011	254 00 1 00 027777 	SBINIT:	JRST	@SUBLNK		;PMGINT LINKAGE
   376	030012	000000	000000		RETURN:	0			;RETURN ADDRESS STORAGE
   377
   378	030013	254000	030712		START1:	SADR7			;OPTIONAL STARTING ADR/INSTRUCTIONS
   379	030014	254000	030712		START2:	SADR8			; "
   380	030015	254000	030712		START3:	SADR9			; "
   381	030016	254000	030712		START4:	SADR10			; "
   382	030017	254000	030712		START5:	SADR11			; "
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 2
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0017

   383					S^;*********************************************************************^
   384					;*PROGRAM FIXED PARAMETER AREA
   385					S^;*********************************************************************^
   386
   387	030020	444253	414400		PNTNAM:	PAREA3		;SIXBIT PROGRAM NAME
   388	030021	645560	000000		PNTEXT:	PAREA4		;SIXBIT PROGRAM EXTENSION
   389	030022	000000	000000		RANDBS:	PAREA1		;RANDOM BASE NUMBER
   390	030023	000000	000000		SWTEXR:	PAREA2		;SYSTEM EXERCISER SWITCHES
   391	030024	000000	001000		ITRCNT:	ITERAT		;PROGRAM ITERATIONS
   392	030025	000000	030725		$PNAME:	PGMNAM		;POINTER TO PROGRAMS NAME
   393	030026	000000	000002		$PVER:	MCNVER,,DECVER	;MCN & DEC VERSION LEVEL
   394	030027	000000	030000		$MODVL:	MODDVL		;DEVICE CODE CHANGE LOWER LIMIT
   395	030030	000000	030000		$MODVU:	MODDVU		;DEVICE CODE CHANGE UPPER LIMIT
   396	030031	777777	777777		$EMODE:	IFNDEF EXCASB,<0> IFDEF EXCASB,<-1>	;EXEC ALLOWED
   397	030032	777777	777777		$UMODE:	IFNDEF USRASB,<0> IFDEF USRASB,<-1>	;USER ALLOWED
   398	030033	000000	000000		$DSKUP:	IFNDEF DSKUPD,<0> IFDEF DSKUPD,<-1>	;DISK UPDATE MODE
   399	030034	000000	000000		$MMAP:	IFNDEF MEMMAP,<0> IFDEF MEMMAP,<-1>	;ALLOW MEMORY RTNS
   400	030035	000000	000000		PAREA7:	PAREA5		;OPTIONAL PARAMETER
   401	030036	000000	000000		PAREA8:	PAREA6		;OPTIONAL PARAMETER
   402
   403					S^;*********************************************************************^
   404					;*PROGRAM VARIABLE PARAMETER AREA
   405					S^;*********************************************************************^
   406
   407	030037	000000	000000		USER:	0		; 0 = EXEC, -1 = USER MODE FLAG
   408	030040	000000	000000		KAIFLG:	0		;PROCESSOR TYPE, 0 = KA10, -1 = KI10
   409	030041	000000	000000		KLFLG:	0		;PROCESSOR TYPE, 0 = KA/KI, -1 = KL10
   410	030042	777777	777777		MONFLG:	-1		;DIAG MONITOR SPECIAL USER FLAG
   411	030043	000000	000000		MONCTL:	0		;DIAG MON/SYS EXR FLAG
   412	030044	000000	000000		MONTEN:	0		;-1= LOADED BY 10
   413	030045	000000	000000		CLOCKF:	0		;CLOCK TICKED FLAG
   414	030046	000000	000000		CONSW:	0		;CONSOLE SWITCH SETTINGS
   415	030047	000000	000000		PASCNT:	0		;PROGRAM PASS COUNT
   416	030050	000000	000000		RUNFLG:	0		;PROGRAM RUN FLAG
   417	030051	000000	000000		TESTPC:	0		;SUBTEST PC
   418	030052	000000	000000		ERRPC:	0		;ERROR PC
   419	030053	000000	000000		ERRTLS:	0		;ERROR TOTALS
   420	030054	000000	000000		TICKS:	0		;PROGRAM RUNNING TIME
   421	030055	000000	000000		MARGIN:	0		;KI10 MARGIN WORD VALUE
   422	030056	000000	000000		$ONETM:	0		;SUBROUTINE INITIALIZATION FLAG
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 3
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0018

   423					S^;*********************************************************************^
   424					;*SPECIAL PROGRAM DISPATCH ADDRESSES
   425					S^;*********************************************************************^
   426
   427	030057	037 12 0 00 000004 	BEGEND:	ENDUUO		;END OF PASS
   428	030060	254 00 0 00 030010 	$BEND1:	JRST	BEGIN1	;KEEP RUNNING PROGRAM
   429	030061	037 16 0 00 000004 	$BEND2:	EOPUUO		;END OF PROGRAM - NO RETURN
   430	030062	254000	030712		CNTLC:	SADR5		;CONTROL C XFER ADDRESS
   431	030063	254000	030712		ALTMGO:	SADR6		;ALTMODE XFER ADDRESS
   432	030064				CPOPJ1:			;SKIP RETURN
   433	030064	350 00 0 17 000000 	UUOSKP:	AOS	(P)	;SKIP RETURN FROM UUO
   434	030065				CPOPJ:			;NON-SKIP REGULAR RETURN
   435	030065	263 17 0 00 000000 	UUOEXT:	RTN		;UUO RETURN
   436	030066	255 00 0 00 000000 	UUORTN:	JFCL		;ADDITIONAL USERS UUO ROUTINE
   437	030067	255 00 0 00 000000 	$UORTX:	JFCL		;ADDITIONAL UUO LINKAGE
   438	030070	255 00 0 00 000000 	$UUOER:	JFCL		;INITED AS (JRST $UOERX)
   439	030071	255 00 0 00 000000 	$ITRHL:	JFCL		;ADDITIONAL INTERRUPT LINKAGE
   440	030072	255 00 0 00 000000 	$ITRX1:	JFCL		; "
   441	030073	255 00 0 00 000000 	$USRHL:	JFCL		; "
   442	030074	255 00 0 00 000000 	$RSRTX:	JFCL		;ADDITIONAL POWER FAIL LINKAGE
   443	030075	255 00 0 00 000000 	$RSRTY:	JFCL		; "
   444	030076	255 00 0 00 000000 	RESRT1:	JFCL		; INITED AS (JRST RESRTX)
   445	030077	255 00 0 00 000000 	RESRT2:	JFCL		; "
   446	030100	255 00 0 00 000000 	$PARER:	JFCL		;ADDITIONAL PARITY ERROR LINKAGE
   447	030101	255 00 0 00 000000 	ERMORE:	JFCL		;ADDITIONAL ERROR HANDLER LINKAGE
   448	030102	254 04 0 00 030102 		HALT	.	;IMPROPER TRANSFER HALT
   449
   450	030103	000000	000000		$PSHER:	0		;INITED AS (JRST PSHERR)
   451	030104	000000	000000		ITRCH1:	0		;PC & FLAGS OF CURRENT INTERRUPT
   452	030105	000000	000000			0		;INITED AS (JRST $ITRC1)
   453
   454					S^;*********************************************************************^
   455					;*PROCESSOR CONTROL STORAGE
   456					S^;*********************************************************************^
   457
   458	030106	000000	000000		$ACC0:	0		;INTERRUPT SAVED AC0
   459	030107	000000	000000		$SVPI:	0		;INTERRUPT SAVED PI
   460	030110	000000	000000		$SVAPR:	0		;INTERRUPT SAVED APR
   461	030111	000000	000000		$SVPAG:	0		;INTERRUPT SAVED PAG (DATAI)
   462	030112	000000	000000		$SPAG1:	0		;INTERRUPT SAVED PAG (CONI)
   463
   464	030113	000000	000000		$SVUUO:	0		;CURRENT USERS UUO
   465	030114	000000	000000		$SVUPC:	0		;PC OF CURRENT USERS UUO
   466
   467	030115	000000	000000		REPTU:	0		;REPEAT UUO ITERATIONS
   468	030116	000000	000000		SCOPE:	0		;ERROR HANDLER SCOPE LOOP FLAG
   469	030117	000000	000000		%CORFLG:0		; " CORRECT FLAG
   470	030120	000000	000000		%COREC:	0		; " CORRECT DATA
   471	030121	000000	000000		%ACTFL:	0		; " ACTUAL FLAG
   472	030122	000000	000000		%ACTUL:	0		; " ACTUAL DATA
   473	030123	000000	000000		%DISCR:	0		; " DISCREPENCY DATA
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 4
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0019

   474					S^;*********************************************************************^
   475					;*UUO DISPATCH TABLE
   476					S^;*********************************************************************^
   477						XLIST
   478						LIST
   479	030124	030070	030070		UUODIS:	LUUO1,,$UUOER
   480	030125	030070	030070			LUUO3,,LUUO2
   481	030126	030070	030070			LUUO5,,LUUO4
   482	030127	030070	030070			LUUO7,,LUUO6
   483	030130	030070	030070			LUUO11,,LUUO10
   484	030131	030070	030070			LUUO13,,LUUO12
   485	030132	030070	030070			LUUO15,,LUUO14
   486	030133	030070	030070			LUUO17,,LUUO16
   487	030134	030070	030070			LUUO21,,LUUO20
   488	030135	030070	030070			LUUO23,,LUUO22
   489	030136	030070	030070			LUUO25,,LUUO24
   490	030137	030070	030070			LUUO27,,LUUO26
   491	030140	030070	030070			LUUO31,,LUUO30
   492	030141	030070	030070			LUUO33,,LUUO32
   493
   494					S^;*********************************************************************^
   495					;*MEMORY MANAGMENT STORAGE
   496					S^;*********************************************************************^
   497
   498	030142	000000	000000		DF22F:	0		;DF10 CONTROL FLAG, 0 = 18, -1 = 22 BIT
   499	030143	000000	000000		MAPNEW:	0		;MEMORY MAPPING CONTROL FLAG, -1 = 4096K MAPPING
   500	030144	000000	000000		MEMTOT:	0		;TOTAL MEMORY SIZE IN K (1024.)
   501	030145	000000	000000		MEMLOW:	0		;LOWEST USABLE MEMORY
   502	030146				MEMSIZ:	BLOCK ^D41	;MEMORY SEGMENT POINTER TABLE
   503
   504					S^;*********************************************************************^
   505					;*PRINT CONTROL STORAGE
   506					S^;*********************************************************************^
   507
   508	030217	000000	000000		PNTFLG:	0		;PRINT FLAG, -1 WHILE IN PRINT ROUTINE
   509	030220	000000	000000		PNTENB:	0		;PRINT ENABLE
   510	030221	000000	000000		PDISF:	0		;PRINT DISABLED FLAG
   511	030222	000000	000000		PNTINH:	0		;INHIBIT PRINT INPUT CHECKS
   512	030223	000000	000000		PNTSPC:	0		;PRINT SPACE CONTROL
   513	030224	000000	000000		OPTIME:	0		;TYPE-IN WAIT TIME
   514	030225	000000	000000		$TWCNT:	0		;TIME WAITED
   515	030226	000000	000000		$DVOFF:	0		;LOGICAL DEVICE INITED FLAG
   516	030227	000000	000000		TTYFIL:	0		;TTY EXEC FILLERS FLAG
   517	030230	000000	000000		TTYSPD:	0		;TTY EXEC BAUD RATE
   518	030231	000000	000000		$TTCHR:	0		;ACTUAL TYPED IN CHAR
   519	030232	000000	000000		$CHRIN:	0		;UPPER CASED & PARITY STRIPPED CHAR
   520	030233	000000	000000		$TYPNB:	0		;TYPED IN NUMBER
   521	030234	000000	000000		$CRLF:	0		;FREE CR/LF FLAG
   522	030235	000000	000000		$TABF:	0		;TAB CONVERSION FLAG
   523	030236	000000	000000		$FFF:	0		;FORM FEED CONVERSION FLAG
   524	030237	000000	000000		$VTF:	0		;VERTICAL TAB CONVERSION FLAG
   525	030240	000000	000000		USRLFF:	0		;USER LF FILLERS
   526	030241	000000	000000		USRCRF:	0		;USER CR FILLERS
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 5
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0020

   527					S^;*********************************************************************^
   528					;*THE FOLLOWING MISCELLANEOUS PRINT CHARACTERS ARE INCLUDED
   529					;*TO FACILITATE PRINTING AND ARE CALLED AS FOLLOWS:
   530					;*	MOVEI	NAME
   531					;*	PNTA		;OR PNTAF
   532					S^;*********************************************************************^
   533
   534	030242				CRLF:	ASCII/
   535	030242	015 012 000 000 000 	/
   536	030243				CRLF2:	ASCII/
   537
   538	030243	015 012 015 012 000 	/
   539	030244	054 000 000 000 000 	COMMA:	ASCII/,/
   540	030245	056 000 000 000 000 	PERIOD:	ASCII/./
   541	030246	040 000 000 000 000 	SPACE:	ASCII/ /
   542	030247	011 000 000 000 000 	TAB:	ASCII/	/
   543	030250				MINUS:
   544	030250	055 000 000 000 000 	HYPEN:	ASCII/-/
   545	030251	053 000 000 000 000 	PLUS:	ASCII/+/
   546	030252	052 000 000 000 000 	AST:	ASCII/*/
   547	030253	100 000 000 000 000 	ATSIN:	ASCII/@/
   548	030254	050 000 000 000 000 	LFP:	ASCII/(/
   549	030255	051 000 000 000 000 	RTP:	ASCII/)/
   550	030256	007 0000000000 		BELL:	BYTE (7) 007
   551	030257	077 000 000 000 000 	QUEST:	ASCII/?/
   552	030260	057 000 000 000 000 	SLASH:	ASCII!/!
   553	030261	044 000 000 000 000 	DOLLAR:	ASCII/$/
   554	030262	000000	000012		RADIX:	^D10			;DECIMAL PRINT RADIX
   555	030263	000000	000040		RADLSP:	40			;DECIMAL PRINT LEADING CHAR
   556	030264	000000	000012		RADLSC:	^D10			;DECIMAL PRINT LEADING CHAR COUNT
   557
   558					S^;*********************************************************************^
   559					;*USER MODE OUTPUT FILE INFORMATION
   560					S^;*********************************************************************^
   561
   562	030265				$OBUF:	BLOCK	3		;LOGICAL FILE OUTPUT BUFFER HEADER
   563	030270	60 62 51 56 64 00 	$OUTNM:	SIXBIT	/PRINT/		;FILE NAME
   564	030271	60 56 64 00 00 00 	$OUTEX:	SIXBIT	/PNT/		;FILE NAME EXTENSION
   565	030272					BLOCK	2
   566
   567					S^;*********************************************************************^
   568					;*DISK UPDATE MODE FILE INFORMATION
   569					S^;*********************************************************************^
   570
   571	030274				$IBUF:	BLOCK	3
   572	030277	60 62 51 56 64 00 	$INNM:	SIXBIT	/PRINT/
   573	030300	60 56 64 00 00 00 	$INEXT:	SIXBIT	/PNT/
   574	030301					BLOCK	2
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 6
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0021

   575					S^;*********************************************************************^
   576					;*PUSHDOWN LIST CONTROL INFORMATION
   577					S^;*********************************************************************^
   578
   579	030303	777577	030303		PLIST:	PLIST-PLISTE,,PLIST
   580	030304				PLISTS:	BLOCK	200
   581	030504	000000	000000		PLISTE:	0		;END OF PUSHDOWN LIST
   582
   583					S^;*********************************************************************^
   584					;*POWER LINE CLOCK FREQUENCY FLAG
   585					S^;*********************************************************************^
   586
   587	030505	000000	000000		CYCL60:	0	;0 = 60, -1 = 50 CYCLE
   588
   589					S^;*********************************************************************^
   590					;*KL10 CACHE CONTROL FLAGS
   591					S^;*********************************************************************^
   592
   593	030506	000000	000000		CSHFLG:	0	;ALLOW CACHE IF 0
   594	030507	000000	000000		CSHMEM:	0	;CACHE MEMORY SEGMENTS IF 0
   595
   596					S^;*********************************************************************^
   597					;*NUMBER INPUT DIGIT FLAG
   598					S^;*********************************************************************^
   599
   600	030510	000000	000000		TTNBRF:	0	;-1 IF ANY DIGIT TYPED
   601
   602					S^;*********************************************************************^
   603					;*KL10 & KI10 "INHPAG" SWITCH PAGING PREVENTION
   604					S^;*********************************************************************^
   605
   606	030511	000000	000000		PVPAGI:	0	;IF NON-ZERO, OVERRIDE "INHPAG" SWITCH ACTION
   607
   608					S^;*********************************************************************^
   609					;*ERROR REPORTING ROUTINE ADDITIONAL USERS CONTROL INSTRUCTIONS
   610					S^;*********************************************************************^
   611
   612	030512	000000	000000		%ERHI1:	0	;IF NON-ZERO, XCT'D AT START OF %ERUUO
   613	030513	000000	000000		%ERHI2:	0	;IF NON-ZERO, XCT'D AT END OF %ERUUO
   614	030514	000000	000000		%ERHI3:	0	;IF NON-ZERO, XCT'D AFTER "PC" OF %ERUUO
   615
   616					S^;*********************************************************************^
   617					;*SPECIAL USERS UUO INTERCEPT INSTRUCTION
   618					S^;*********************************************************************^
   619
   620	030515	000000	000000		$$UUO:	0	;IF NON-ZERO, XCT'D AT START OF $UORTN
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 7
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0022

   621					S^;*********************************************************************^
   622					;*KL10 PROCESSOR TYPE FLAG, 0=P0, 1=BBD NEW, 2=BBD OLD
   623					S^;*********************************************************************^
   624
   625	030516	000000	000000		KLTYP:	0
   626
   627					S^;*********************************************************************^
   628					;*SPECIAL USERS MUUO INTERCEPT INSTRUCTION
   629					S^;*********************************************************************^
   630
   631	030517	000000	000000		$$MUUO:	0	;IF NON-ZERO, XCT'D AT START OF MUUOER
   632
   633					S^;*********************************************************************^
   634					;*SPECIAL USERS USER MODE OUTPUT ERROR INTERCEPT INSTUCTION
   635					S^;*********************************************************************^
   636
   637	030520	000000	000000		$$OUTER:0	;IF NON-ZERO, XCT'D AT END OF USER MODE ERROR
   638
   639					S^;*********************************************************************^
   640					;*"SWITCH" CALL USAGE CONTROL
   641					S^;*********************************************************************^
   642
   643	030521	000000	000000		$$TOGGLE:0	;IF NON-ZERO, USE C(CONSW) FOR SWITCHES
   644
   645					S^;*********************************************************************^
   646					;*SPECIAL USERS ALTMODE SWITCH CALL INTERCEPT INSTRUCTIONS
   647					S^;*********************************************************************^
   648
   649	030522	000000	000000		$$TAX1:	0	;IF NON-ZERO, XCT'D AT START OF ALTMODE SWITCH CALL
   650	030523	000000	000000		$$TAX2:	0	;IF NON-ZERO, XCT'D AT END OF ALTMODE SWITCH CALL
   651
   652					S^;*********************************************************************^
   653					;*SPECIAL FUTURE EXPANSION ROOM
   654					;*IF ANY FIXED AREA TAGS ARE ADDED, REDUCE THE SIZE OF
   655					;*THIS BLOCK STATEMENT ACCORDINGLY.  THIS MUST BE DONE
   656					;*SO THAT PREVIOUS FIXED ASSIGNMENTS DO NOT CHANGE.
   657					S^;*********************************************************************^
   658
   659	030524					BLOCK	53	;HOPEFULLY THIS IS ENOUGH FOREVER
   660
   661					S^;*********************************************************************^
   662					;*END OF FIXED STORAGE
   663					S^;*********************************************************************^
   664
   665			030577			$ENDFX=<PLISTE+100>&<777700>-1
   666	030577					LOC	$ENDFX
   667	030577	000000	000000		ENDFIX:	0		;END OF FIXED STORAGE
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 1
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0023

   668					SUBTTL	*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76
   669
   670					;NEW DEFINITIONS USED BY THE KL10 SUBROUTINE PACKAGE
   671
   672			000000		AC0=	0
   673			030000		DIAGNOS=30000		;PDP-10 DIAGNOSTIC START ADDRESS
   674			010000		DDT=	10000		;PDP-10 DDT START ADDRESS
   675			020000		DIAMON=	20000		;PDP-10 DIAMON LOADER START ADDRESS
   676			020000		DONG11=	1B22		;11 DOORBELL (FROM THE 10)
   677
   678					;DTE20 DEVICE CODES
   679
   680			000200		DTE==	200		;DTE0
   681			000204		DTE0==	204
   682			000204		DTE1==	204
   683			000210		DTE2==	210
   684			000214		DTE3==	214
   685
   686					;KL10 EPT COMMUNICATION AREA
   687
   688			000440		$STD=	440		;PDP-10 DIAGNOSTIC START ADDRESS
   689			000441		$DDT=	441		;PDP-10 DDT START ADDRESS
   690			000442		$STL=	442		;PDP-10 LOADER START ADDRESS
   691			000443		$STM=	443		;PDP-10 MONITOR START ADDRESS
   692
   693			000444		$DTFLG=	444		;DTE20 OPERATION COMPLETE FLAG
   694			000445		$DTCLK=	445		;DTE20 CLOCK INTERRUPT FLAG
   695			000446		$DTCI=	446		;DTE20 CLOCK INTERRUPT INSTRUCTION
   696			000447		$DTT11=	447		;DTE20 10 TO 11 ARGUMENT
   697			000450		$DTF11=	450		;DTE20 11 TO 10 ARGUMENT
   698			000451		$DTCMD=	451		;DTE20 TO 11 COMMAND WORD
   699			000452		$DTSEQ=	452		;DTE20 OPERATION SEQUENCE NUMBER
   700			000453		$DTOPR=	453		;DTE20 OPERATIONAL DTE #
   701			000454		$DTCHR=	454		;DTE20 LAST TYPED CHARACTER
   702			000455		$DTMTD=	455		;DTE20 MONITOR TTY OUTPUT COMPLETE FLAG
   703			000456		$DTMTI=	456		;DTE20 MONITOR TTY INPUT FLAG
   704
   705			000457		$DTSWR=	457		;DTE20 CONSOLE SWITCH REGISTER
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 2
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0024

   706					;SPECIAL "FIXED" REASSIGNMENTS
   707
   708			030600			$$LOC=.			;SAVE CURRENT LOCATION
   709
   710	030000					LOC	30000
   711	030000	254 00 0 00 030600 	$$BEGIN:JRST	$$START		;SETUP SPECIAL START
   712	030001	254 00 0 00 030600 		JRST	$$START		;"DIAMON" CHAIN START ADDRESS
   713
   714	000440					LOC	440
   715	000440	254 00 0 00 030000 	$STD:	JRST	BEGIN		;SETUP FOR "STD"
   716	000443					LOC	443
   717	000443	254 00 0 00 030636 	$STM:	JRST	$SPEC		;SIMPLE RUN CONTROL
   718
   719	030057					LOC	30057
   720	030057	254 00 0 00 030641 	$BEGEND:JRST	$SPBEND		;SETUP SPECIAL "BEGEND"
   721
   722					;SPECIAL MUUO, TRAP & PAGE FAIL SETUP
   723
   724	000420					LOC	420
   725	000420	254 04 0 00 000420 	$$420:	HALT	.		;KI10 PAGE FAIL
   726	000421	255 00 0 00 000000 	$$421:	JFCL			;OVERFLOW
   727	000422	254 04 0 00 000422 	$$422:	HALT	.		;PUSHDOWN OVERFLOW
   728	000423	254 04 0 00 000423 	$$423:	HALT	.		;TRAP 3
   729	000424	000000	000000		$$424:	0			;MMUO
   730	000425	000000	000000		$$425:	0			;MMUO PC
   731	000426	000000	000000		$$426:	0			;KI10-PAGE FAIL, KL10-PROCESS CONTEXT
   732	000427	254 04 0 00 000427 	$$427:	HALT	.
   733	000430	000000	000427		$$430:	427			;MMUO NEW PC'S
   734	000431	000000	000427		$$431:	427
   735	000432	000000	000427		$$432:	427
   736	000433	000000	000427		$$433:	427
   737	000434	000000	000427		$$434:	427
   738	000435	000000	000427		$$435:	427
   739	000436	000000	000427		$$436:	427
   740	000437	000000	000427		$$437:	427
   741
   742	000500					LOC	500
   743	000500	000000	000000		$$500:	0			;KL10 PAGE FAIL WORD
   744	000501	000000	000000		$$501:	0			;KL10 PAGE FAIL PC
   745	000502	000000	000503		$$502:	503			;KL10 PAGE FAIL NEW PC
   746	000503	254 04 0 00 000503 	$$503:	HALT	.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 3
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0025

   747	030600					LOC	$$LOC		;RESET CURRENT LOCATION
   748
   749					;SPECIAL STARTUP SEQUENCE
   750
   751	030600	402 00 0 00 030037 	$$START:SETZM	USER
   752	030601	265 00 0 00 030602 		JSP	0,.+1		;IN USER MODE ?
   753	030602	603 00 0 00 010000 		TLNE	0,USERF
   754	030603	476 00 0 00 030037 		SETOM	USER		;YES, SET CONTROL WORD
   755	030604	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE ?
   756	030605	402 00 0 00 030037 		SETZM	USER		;YES, RUN AS EXEC
   757	030606	332 00 0 00 030037 		SKIPE	USER
   758	030607	254 00 0 00 030712 		JRST	START		;USER MODE, DON'T NEED CPU TYPE
   759
   760	030610	336 00 0 00 030044 	$STKIL:	SKIPN	MONTEN		;LOADED BY "DIAMON" ?
   761	030611	476 00 0 00 030024 		SETOM	ITRCNT		;NO, RUN FOREVER
   762	030612	402 00 0 00 030516 		SETZM	KLTYP
   763	030613	402 00 0 00 030041 		SETZM	KLFLG		;ASSUME KI10
   764	030614	200 01 0 00 034442 		MOVE	1,[1,,1]
   765	030615	251 01 0 00 000001 		BLT	1,1		;HOPE THIS WORKS
   766	030616	316 01 0 00 034442 		CAMN	1,[1,,1]	;IF AC NE 1,,1 AFTER BLT, KL10
   767	030617	254 00 0 00 030712 		JRST	START		;KI10, NO ADDITIONAL SETUP
   768
   769	030620	7 000 20 0 00 010040 	$STKL:	CONO	APR,10040	;SET BBD NOT BIT
   770	030621	7 000 24 0 00 000000 		CONI	APR,0
   771	030622	7 000 20 0 00 020040 		CONO	APR,20040	;CLEAR BBD NOT BIT
   772	030623	606 00 0 00 000040 		TRNN	0,40		;IF SET, KL10
   773	030624	350 00 0 00 030516 		AOS	KLTYP		;IF NOT, BBD
   774	030625	402 00 0 00 000444 		SETZM	$DTFLG
   775	030626	402 00 0 00 000445 		SETZM	$DTCLK
   776	030627	200 00 0 00 000453 		MOVE	$DTOPR		;GET DTE #
   777	030630	436 00 0 00 030670 		ORM	$$DTE0		;INSERT IN DTE I/O INSTS
   778	030631	436 00 0 00 030672 		ORM	$$DTE1
   779	030632	436 00 0 00 030704 		ORM	$$DTE2
   780	030633	436 00 0 00 030706 		ORM	$$DTE3
   781	030634	476 00 0 00 030041 		SETOM	KLFLG		;SET KL10 CONTROL FLAG
   782	030635	254 00 0 00 030712 		JRST	START
   783
   784	030636	200 00 0 00 034443 	$SPEC:	MOVE	[JRST STARTA]	;SIMPLE RUN CONTROL
   785	030637	202 00 0 00 030643 		MOVEM	$SPB1
   786	030640	254 00 0 00 030712 		JRST	START
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 4
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0026

   787					;SPECIAL "BEGEND" ROUTINE
   788
   789	030641	350 00 0 00 030047 	$SPBEND:AOS	PASCNT		;INCREMENT PASS COUNT
   790	030642	370 00 0 00 030024 		SOS	ITRCNT		;DECREMENT ITERATION COUNT
   791	030643	336 00 0 00 030037 	$SPB1:	SKIPN	USER
   792	030644	254 00 0 00 030652 		JRST	$SPBEX		;EXEC MODE
   793
   794	030645	332 00 0 00 030024 	$SPBUS:	SKIPE	ITRCNT		;USER MODE, COMPLETED ?
   795	030646	254 00 0 00 030741 		JRST	STARTA		;NO, KEEP RUNNING
   796	030647	336 00 0 00 030044 		SKIPN	MONTEN		;DONE, LOADED BY "DIAMON" ?
   797	030650	047 00 0 00 000012 		EXIT			;NO, RETURN TO MONITOR
   798	030651	254 00 1 00 030012 		JRST	@RETURN		;YES, RETURN TO "DIAMON"
   799
   800	030652	332 00 0 00 030041 	$SPBEX:	SKIPE	KLFLG
   801	030653	254 00 0 00 030660 		JRST	$SPBKL		;KL10 & EXEC
   802	030654	7 004 14 0 00 030024 		DATAO	PI,ITRCNT	;KI10 & EXEC, DISPLAY ITER COUNT
   803	030655	332 00 0 00 030024 		SKIPE	ITRCNT
   804	030656	254 00 0 00 030741 		JRST	STARTA		;NOT COMPLETED YET
   805	030657	254 00 1 00 030012 		JRST	@RETURN		;DONE
   806
   807	030660	336 00 0 00 030024 	$SPBKL:	SKIPN	ITRCNT
   808	030661	254 00 0 00 030676 		JRST	$SPKLD		;KL10, EXEC & COMPLETED
   809
   810	030662	335 00 0 00 030043 		SKIPGE	MONCTL
   811	030663	254 00 0 00 030741 		JRST	STARTA		;"DIAMON" CONTROL
   812	030664	201 00 0 00 000404 		MOVEI	0,404		;NOTIFY PDP-11 OF END OF PASS
   813	030665	202 00 0 00 000451 		MOVEM	0,$DTCMD
   814	030666	402 00 0 00 000444 		SETZM	$DTFLG
   815	030667	336 00 0 00 030516 		SKIPN	KLTYP
   816	030670	7 200 20 0 00 020000 	$$DTE0:	CONO	DTE,DONG11
   817	030671	332 00 0 00 030516 		SKIPE	KLTYP
   818	030672	7 200 20 0 00 010000 	$$DTE1:	CONO	DTE,10000
   819	030673	336 00 0 00 000444 		SKIPN	$DTFLG		;WAIT TILL 11 RESPONDS
   820	030674	254 00 0 00 030673 		JRST	.-1
   821	030675	254 00 0 00 030741 		JRST	STARTA		;KEEP RUNNING
   822
   823					;SPECIAL KL10 COMPLETED ROUTINE
   824
   825	030676	332 00 0 00 030044 	$SPKLD:	SKIPE	MONTEN
   826	030677	254 00 1 00 030012 		JRST	@RETURN		;LOADED BY "DIAMON"
   827
   828	030700	201 00 0 00 000403 		MOVEI	0,403		;NOTIFY PDP-11 OF COMPLETION
   829	030701	202 00 0 00 000451 		MOVEM	0,$DTCMD
   830	030702	402 00 0 00 000444 		SETZM	$DTFLG
   831	030703	336 00 0 00 030516 		SKIPN	KLTYP
   832	030704	7 200 20 0 00 020000 	$$DTE2:	CONO	DTE,DONG11
   833	030705	332 00 0 00 030516 		SKIPE	KLTYP
   834	030706	7 200 20 0 00 010000 	$$DTE3:	CONO	DTE,10000
   835	030707	336 00 0 00 000444 		SKIPN	$DTFLG		;SHOULD NEVER HAPPEN
   836	030710	254 00 0 00 030707 		JRST	.-1		;11 NEVER RETURNS ON END OF PROGRAM
   837	030711	254 04 0 00 030000 		HALT	BEGIN		;IF IT DOES, HALT.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 1
DAKADM	MAC	19-JAN-77 13:41		DIAGNOSTIC PARAMETERS                                                              SEQ 0027

   838					SUBTTL	DIAGNOSTIC PARAMETERS
   839
   840					;ACCUMULATOR ASSIGNMENTS
   841
   842					;CONTROL WORDS
   843
   844			400000		AROV=400000		;ARITHMETIC OVERFLOW
   845			200000		CRY0=200000		;CARRY 0
   846			100000		CRY1=100000		;CARRY 1
   847			040000		FOV=40000		;FLOATING OVERFLOW
   848			020000		BIS=20000		;BYTE INTERRUPT
   849			010000		USERF=10000		;USER MODE FLAG
   850			004000		EXIOT=4000		;USER PRIV I/O FLAG
   851			000100		FXU=100			;FLOATING UNDERFLOW
   852			000040		DCK=40			;DIVIDE CHECK
   853
   854
   855					;MACROS
   856
   857					; STOP - USED FOR SCOPE LOOP, IF INSTRUCTION FAILS, CHANGE (JUMPA .+1)
   858					;	 TO A (JUMPA X) TO CYCLE ON FAILING INSTRUCTION
   859
   860					DEFINE	STOP	(A)<
   861						HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   862						JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   863									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   864									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
   865									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1>
   866
   867					; SFLAG - USED TO CLEAR ALL FLAGS THEN TO SET REQUESTED FLAG
   868
   869					DEFINE	SFLAG	(A)<
   870						MOVSI	1,A
   871						JFCL	17,.+1		;RESET ALL FLAGS
   872						JRST	2,.+1(1)	;SET A FLAG>
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 2
DAKADM	MAC	19-JAN-77 13:41		DIAGNOSTIC SECTION                                                                 SEQ 0028

   873					SUBTTL	DIAGNOSTIC SECTION
   874
   875	030712	402 00 0 00 030037 	START:	SETZM	USER#		;CLEAR USER CONTROL WORD
   876	030713	265 00 0 00 030714 		JSP	0,.+1		;GET FLAGS
   877	030714	603 00 0 00 010000 		TLNE	USERF		;IN USER MODE?
   878	030715	476 00 0 00 030037 		SETOM	USER		;YES, SET USER CONTROL WORD
   879	030716	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE?
   880	030717	402 00 0 00 030037 		SETZM	USER		;YES, CLEAR USER CONTROL WORD
   881	030720	336 00 0 00 030037 		SKIPN	USER
   882	030721	254 00 0 00 030742 		JRST	C00
   883	030722	331 00 0 00 030043 		SKIPL	MONCTL
   884	030723	051 03 0 00 030725 		TTCALL	3,PGMNAM	;MENTION OUR NAME
   885	030724	254 00 0 00 030741 		JRST	STARTA
   886
   887	030725				PGMNAM:	ASCIZ/
   888	030725	015 012 120 104 120 	PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) [DAKAD]
   889	030726	055 061 060 040 113
   890	030727	101 061 060 040 102
   891	030730	101 123 111 103 040
   892	030731	111 116 123 124 122
   893	030732	125 103 124 111 117
   894	030733	116 040 104 111 101
   895	030734	107 116 117 123 124
   896	030735	111 103 040 050 064
   897	030736	051 040 133 104 101
   898	030737	113 101 104 135 015
   899	030740	012 000 000 000 000 	/
   900
   901					;BASIC INSTRUCTION TEST (3)
   902					;THE TEST IS DESIGNED FOR INITIAL DEBUGGING OF
   903					;PROCESSOR HARDWARE AND TO DETECT (SOLID) FAILURES
   904					;IN THE FIELD.
   905
   906	030741	254 00 0 00 030742 	STARTA:	JRST	.+1
   907	030742				C00:
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 3
DAKADM	MAC	19-JAN-77 13:41		DIAGNOSTIC SECTION                                                                 SEQ 0029

   908					;TESTING BEGINS HERE
   909
   910					;IF ANY LOADING PROBLEMS OCCUR, START PROGRAM HERE.
   911
   912					;NOTE:	AN "*" IN THE COMMENT FIELD OF AN INSTRUCTION INDICATES THAT
   913					;	IT IS THE TESTED INSTRUCTION.
   914
   915					SUBTTL	TEST OF AC HARDWARE AND INDEX REGISTERS
   916
   917					;**********
   918
   919					;THIS TEST VERIFIES THAT AC1 IS ACCESSABLE
   920					;IN THIS CASE, AC1 IS PRELOADED WITH 1.
   921					;C(AC1) IS THEN CHECKED FOR A1.  THIS TEST PASSES IF C(AC1)=1.
   922					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
   923
   924	030742	400 00 0 00 000000 	C100:	SETZ			;CLEAR AC0
   925	030743	201 01 0 00 000001 		MOVEI	1,1		;PRELOAD AC1 WITH 1
   926	030744	302 01 0 00 000001 		CAIE	1,1		;PASS IF C(AC1)=1
   927						STOP^
   928	030745	254 04 0 00 030746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   929	030746	324 00 0 00 030747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   930									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   931									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
   932									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
   933
   934					;**********
   935
   936					;THIS TEST VERIFIES THAT AC2 IS ACCESSABLE.
   937					;IN THIS CASE, AC2 IS PRELOADED WITH 2.
   938					;C(AC2) IS THEN CHECKED FOR 2.  THIS TEST PASSES IF C(AC2)=2.
   939					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
   940
   941	030747	201 02 0 00 000002 	C200:	MOVEI	2,2		;PRELOAD AC2 WITH 2
   942	030750	302 02 0 00 000002 		CAIE	2,2		;PASS IF C(AC2)=2
   943						STOP^
   944	030751	254 04 0 00 030752 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   945	030752	324 00 0 00 030753 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   946									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   947									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
   948									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
   949
   950					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 4
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0030

   951					;THIS TEST VERIFIES THAT AC4 IS ACCESSABLE.
   952					;IN THIS CASE, AC4 IS PRELOADED WITH 4.
   953					;C(AC4) IS THEN CHECKED FOR 4.  THIS TEST PASSES IF C(AC4)=4.
   954					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
   955
   956	030753	201 04 0 00 000004 	C300:	MOVEI	4,4		;PRELOAD AC4 WITH 4
   957	030754	302 04 0 00 000004 		CAIE	4,4		;PASS IF C(AC4)=4
   958						STOP^
   959	030755	254 04 0 00 030756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   960	030756	324 00 0 00 030757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   961									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   962									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
   963									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
   964
   965					;**********
   966
   967					;THIS TEST VERIFIES THAT AC10 IS ACCESSABLE.
   968					;IN THIS CASE, AC10 IS PRELOADED WITH 10.
   969					;C(AC10) IS THEN CHECKED FOR 10.  THIS TEST PASSES IF C(AC10)=10.
   970					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
   971
   972	030757	201 10 0 00 000010 	C400:	MOVEI	10,10		;PRELOAD AC10 WITH 10
   973	030760	302 10 0 00 000010 		CAIE	10,10		;PASS IF C(AC10)=10
   974						STOP^
   975	030761	254 04 0 00 030762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   976	030762	324 00 0 00 030763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   977									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   978									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
   979									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
   980
   981					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 5
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0031

   982			000500		SN=500
   983		777777	777777			ZZ=-1
   984
   985					;THIS TEST VERIFIES THAT ALL ACS EXIST
   986					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
   987					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
   988					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
   989
   990					C500:	REPEAT	^D16,
   991					<	ZZ=ZZ+1
   992						MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR>
   993			000000			ZZ=ZZ+1
   994	030763	201 00 0 00 000000 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
   995			000001			ZZ=ZZ+1
   996	030764	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
   997			000002			ZZ=ZZ+1
   998	030765	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
   999			000003			ZZ=ZZ+1
  1000	030766	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1001			000004			ZZ=ZZ+1
  1002	030767	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1003			000005			ZZ=ZZ+1
  1004	030770	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1005			000006			ZZ=ZZ+1
  1006	030771	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1007			000007			ZZ=ZZ+1
  1008	030772	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1009			000010			ZZ=ZZ+1
  1010	030773	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1011			000011			ZZ=ZZ+1
  1012	030774	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1013			000012			ZZ=ZZ+1
  1014	030775	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1015			000013			ZZ=ZZ+1
  1016	030776	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1017			000014			ZZ=ZZ+1
  1018	030777	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1019			000015			ZZ=ZZ+1
  1020	031000	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1021			000016			ZZ=ZZ+1
  1022	031001	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1023			000017			ZZ=ZZ+1
  1024	031002	201 17 0 00 000017 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
  1025					PAGE
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 5-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0032

  1026			000020			ZZ=20
  1027
  1028						REPEAT	^D16,<
  1029					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1030					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1031					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1032					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1033
  1034					SN=SN+1
  1035						ZZ=ZZ-1
  1036						CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1037						STOP
  1038									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1039
  1040					;**********
  1041					>
  1042
  1043					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1044					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1045					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1046					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1047
  1048			000501		SN=SN+1
  1049			000017			ZZ=ZZ-1
  1050	031003	302 17 0 00 000017 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1051						STOP^
  1052	031004	254 04 0 00 031005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1053	031005	324 00 0 00 031006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1054									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1055									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1056									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1057									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1058
  1059					;**********
  1060
  1061
  1062					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1063					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1064					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1065					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1066
  1067			000502		SN=SN+1
  1068			000016			ZZ=ZZ-1
  1069	031006	302 16 0 00 000016 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1070						STOP^
  1071	031007	254 04 0 00 031010 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1072	031010	324 00 0 00 031011 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1073									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1074									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1075									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1076									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1077
  1078					;**********
  1079
  1080
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 5-2
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0033

  1081					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1082					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1083					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1084					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1085
  1086			000503		SN=SN+1
  1087			000015			ZZ=ZZ-1
  1088	031011	302 15 0 00 000015 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1089						STOP^
  1090	031012	254 04 0 00 031013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1091	031013	324 00 0 00 031014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1092									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1093									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1094									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1095									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1096
  1097					;**********
  1098
  1099
  1100					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1101					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1102					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1103					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1104
  1105			000504		SN=SN+1
  1106			000014			ZZ=ZZ-1
  1107	031014	302 14 0 00 000014 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1108						STOP^
  1109	031015	254 04 0 00 031016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1110	031016	324 00 0 00 031017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1111									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1112									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1113									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1114									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1115
  1116					;**********
  1117
  1118
  1119					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1120					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1121					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1122					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1123
  1124			000505		SN=SN+1
  1125			000013			ZZ=ZZ-1
  1126	031017	302 13 0 00 000013 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1127						STOP^
  1128	031020	254 04 0 00 031021 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1129	031021	324 00 0 00 031022 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1130									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1131									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1132									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1133									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1134
  1135					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 5-3
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0034

  1136
  1137
  1138					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1139					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1140					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1141					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1142
  1143			000506		SN=SN+1
  1144			000012			ZZ=ZZ-1
  1145	031022	302 12 0 00 000012 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1146						STOP^
  1147	031023	254 04 0 00 031024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1148	031024	324 00 0 00 031025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1149									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1150									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1151									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1152									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1153
  1154					;**********
  1155
  1156
  1157					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1158					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1159					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1160					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1161
  1162			000507		SN=SN+1
  1163			000011			ZZ=ZZ-1
  1164	031025	302 11 0 00 000011 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1165						STOP^
  1166	031026	254 04 0 00 031027 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1167	031027	324 00 0 00 031030 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1168									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1169									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1170									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1171									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1172
  1173					;**********
  1174
  1175
  1176					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1177					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1178					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1179					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1180
  1181			000510		SN=SN+1
  1182			000010			ZZ=ZZ-1
  1183	031030	302 10 0 00 000010 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1184						STOP^
  1185	031031	254 04 0 00 031032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1186	031032	324 00 0 00 031033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1187									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1188									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1189									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1190									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 5-4
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0035

  1191
  1192					;**********
  1193
  1194
  1195					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1196					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1197					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1198					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1199
  1200			000511		SN=SN+1
  1201			000007			ZZ=ZZ-1
  1202	031033	302 07 0 00 000007 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1203						STOP^
  1204	031034	254 04 0 00 031035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1205	031035	324 00 0 00 031036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1206									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1207									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1208									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1209									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1210
  1211					;**********
  1212
  1213
  1214					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1215					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1216					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1217					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1218
  1219			000512		SN=SN+1
  1220			000006			ZZ=ZZ-1
  1221	031036	302 06 0 00 000006 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1222						STOP^
  1223	031037	254 04 0 00 031040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1224	031040	324 00 0 00 031041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1225									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1226									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1227									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1228									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1229
  1230					;**********
  1231
  1232
  1233					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1234					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1235					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1236					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1237
  1238			000513		SN=SN+1
  1239			000005			ZZ=ZZ-1
  1240	031041	302 05 0 00 000005 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1241						STOP^
  1242	031042	254 04 0 00 031043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1243	031043	324 00 0 00 031044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1244									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1245									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 5-5
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0036

  1246									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1247									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1248
  1249					;**********
  1250
  1251
  1252					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1253					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1254					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1255					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1256
  1257			000514		SN=SN+1
  1258			000004			ZZ=ZZ-1
  1259	031044	302 04 0 00 000004 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1260						STOP^
  1261	031045	254 04 0 00 031046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1262	031046	324 00 0 00 031047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1263									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1264									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1265									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1266									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1267
  1268					;**********
  1269
  1270
  1271					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1272					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1273					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1274					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1275
  1276			000515		SN=SN+1
  1277			000003			ZZ=ZZ-1
  1278	031047	302 03 0 00 000003 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1279						STOP^
  1280	031050	254 04 0 00 031051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1281	031051	324 00 0 00 031052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1282									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1283									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1284									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1285									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1286
  1287					;**********
  1288
  1289
  1290					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1291					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1292					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1293					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1294
  1295			000516		SN=SN+1
  1296			000002			ZZ=ZZ-1
  1297	031052	302 02 0 00 000002 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1298						STOP^
  1299	031053	254 04 0 00 031054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1300	031054	324 00 0 00 031055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 5-6
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0037

  1301									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1302									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1303									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1304									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1305
  1306					;**********
  1307
  1308
  1309					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1310					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1311					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1312					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1313
  1314			000517		SN=SN+1
  1315			000001			ZZ=ZZ-1
  1316	031055	302 01 0 00 000001 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1317						STOP^
  1318	031056	254 04 0 00 031057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1319	031057	324 00 0 00 031060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1320									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1321									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1322									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1323									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1324
  1325					;**********
  1326
  1327
  1328					;THIS TEST VERIFIES THAT ALL ACS EXIST.
  1329					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
  1330					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1331					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
  1332
  1333			000520		SN=SN+1
  1334			000000			ZZ=ZZ-1
  1335	031060	302 00 0 00 000000 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1336						STOP^
  1337	031061	254 04 0 00 031062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1338	031062	324 00 0 00 031063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1339									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1340									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1341									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1342									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
  1343
  1344					;**********
  1345
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 6
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0038

  1346			000600		SN=600
  1347			000000			ZZ=0
  1348
  1349					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1350					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1351					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS; THEN THE CONTENTS OF EACH
  1352					;AC IS CHECKED FOR ITS ADDRESS.  IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1353
  1354					C600:	REPEAT	^D15,
  1355					<	ZZ=ZZ+1
  1356						MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1357						MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.>
  1358			000001			ZZ=ZZ+1
  1359	031063	201 00 0 00 000001 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1360	031064	202 00 0 00 000001 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1361			000002			ZZ=ZZ+1
  1362	031065	201 00 0 00 000002 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1363	031066	202 00 0 00 000002 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1364			000003			ZZ=ZZ+1
  1365	031067	201 00 0 00 000003 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1366	031070	202 00 0 00 000003 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1367			000004			ZZ=ZZ+1
  1368	031071	201 00 0 00 000004 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1369	031072	202 00 0 00 000004 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1370			000005			ZZ=ZZ+1
  1371	031073	201 00 0 00 000005 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1372	031074	202 00 0 00 000005 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1373			000006			ZZ=ZZ+1
  1374	031075	201 00 0 00 000006 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1375	031076	202 00 0 00 000006 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1376			000007			ZZ=ZZ+1
  1377	031077	201 00 0 00 000007 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1378	031100	202 00 0 00 000007 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1379			000010			ZZ=ZZ+1
  1380	031101	201 00 0 00 000010 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1381	031102	202 00 0 00 000010 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1382			000011			ZZ=ZZ+1
  1383	031103	201 00 0 00 000011 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1384	031104	202 00 0 00 000011 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1385			000012			ZZ=ZZ+1
  1386	031105	201 00 0 00 000012 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1387	031106	202 00 0 00 000012 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1388			000013			ZZ=ZZ+1
  1389	031107	201 00 0 00 000013 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1390	031110	202 00 0 00 000013 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1391			000014			ZZ=ZZ+1
  1392	031111	201 00 0 00 000014 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1393	031112	202 00 0 00 000014 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1394			000015			ZZ=ZZ+1
  1395	031113	201 00 0 00 000015 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1396	031114	202 00 0 00 000015 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1397			000016			ZZ=ZZ+1
  1398	031115	201 00 0 00 000016 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1399	031116	202 00 0 00 000016 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1400			000017			ZZ=ZZ+1
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 6-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0039

  1401	031117	201 00 0 00 000017 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
  1402	031120	202 00 0 00 000017 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
  1403
  1404			000020			ZZ=20
  1405
  1406						REPEAT	^D15,<
  1407					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1408					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1409					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1410					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1411					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1412
  1413					SN=SN+1
  1414						ZZ=ZZ-1
  1415						CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1416						STOP
  1417									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1418
  1419					;**********
  1420					>
  1421
  1422					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1423					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1424					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1425					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1426					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1427
  1428			000601		SN=SN+1
  1429			000017			ZZ=ZZ-1
  1430	031121	302 17 0 00 000017 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1431						STOP^
  1432	031122	254 04 0 00 031123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1433	031123	324 00 0 00 031124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1434									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1435									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1436									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1437									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1438
  1439					;**********
  1440
  1441
  1442					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1443					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1444					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1445					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1446					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1447
  1448			000602		SN=SN+1
  1449			000016			ZZ=ZZ-1
  1450	031124	302 16 0 00 000016 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1451						STOP^
  1452	031125	254 04 0 00 031126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1453	031126	324 00 0 00 031127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1454									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1455									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 6-2
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0040

  1456									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1457									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1458
  1459					;**********
  1460
  1461
  1462					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1463					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1464					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1465					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1466					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1467
  1468			000603		SN=SN+1
  1469			000015			ZZ=ZZ-1
  1470	031127	302 15 0 00 000015 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1471						STOP^
  1472	031130	254 04 0 00 031131 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1473	031131	324 00 0 00 031132 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1474									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1475									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1476									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1477									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1478
  1479					;**********
  1480
  1481
  1482					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1483					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1484					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1485					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1486					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1487
  1488			000604		SN=SN+1
  1489			000014			ZZ=ZZ-1
  1490	031132	302 14 0 00 000014 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1491						STOP^
  1492	031133	254 04 0 00 031134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1493	031134	324 00 0 00 031135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1494									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1495									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1496									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1497									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1498
  1499					;**********
  1500
  1501
  1502					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1503					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1504					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1505					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1506					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1507
  1508			000605		SN=SN+1
  1509			000013			ZZ=ZZ-1
  1510	031135	302 13 0 00 000013 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 6-3
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0041

  1511						STOP^
  1512	031136	254 04 0 00 031137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1513	031137	324 00 0 00 031140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1514									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1515									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1516									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1517									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1518
  1519					;**********
  1520
  1521
  1522					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1523					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1524					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1525					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1526					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1527
  1528			000606		SN=SN+1
  1529			000012			ZZ=ZZ-1
  1530	031140	302 12 0 00 000012 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1531						STOP^
  1532	031141	254 04 0 00 031142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1533	031142	324 00 0 00 031143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1534									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1535									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1536									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1537									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1538
  1539					;**********
  1540
  1541
  1542					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1543					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1544					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1545					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1546					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1547
  1548			000607		SN=SN+1
  1549			000011			ZZ=ZZ-1
  1550	031143	302 11 0 00 000011 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1551						STOP^
  1552	031144	254 04 0 00 031145 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1553	031145	324 00 0 00 031146 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1554									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1555									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1556									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1557									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1558
  1559					;**********
  1560
  1561
  1562					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1563					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1564					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1565					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 6-4
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0042

  1566					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1567
  1568			000610		SN=SN+1
  1569			000010			ZZ=ZZ-1
  1570	031146	302 10 0 00 000010 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1571						STOP^
  1572	031147	254 04 0 00 031150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1573	031150	324 00 0 00 031151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1574									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1575									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1576									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1577									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1578
  1579					;**********
  1580
  1581
  1582					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1583					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1584					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1585					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1586					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1587
  1588			000611		SN=SN+1
  1589			000007			ZZ=ZZ-1
  1590	031151	302 07 0 00 000007 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1591						STOP^
  1592	031152	254 04 0 00 031153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1593	031153	324 00 0 00 031154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1594									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1595									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1596									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1597									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1598
  1599					;**********
  1600
  1601
  1602					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1603					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1604					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1605					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1606					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1607
  1608			000612		SN=SN+1
  1609			000006			ZZ=ZZ-1
  1610	031154	302 06 0 00 000006 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1611						STOP^
  1612	031155	254 04 0 00 031156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1613	031156	324 00 0 00 031157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1614									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1615									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1616									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1617									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1618
  1619					;**********
  1620
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 6-5
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0043

  1621
  1622					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1623					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1624					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1625					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1626					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1627
  1628			000613		SN=SN+1
  1629			000005			ZZ=ZZ-1
  1630	031157	302 05 0 00 000005 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1631						STOP^
  1632	031160	254 04 0 00 031161 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1633	031161	324 00 0 00 031162 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1634									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1635									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1636									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1637									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1638
  1639					;**********
  1640
  1641
  1642					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1643					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1644					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1645					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1646					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1647
  1648			000614		SN=SN+1
  1649			000004			ZZ=ZZ-1
  1650	031162	302 04 0 00 000004 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1651						STOP^
  1652	031163	254 04 0 00 031164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1653	031164	324 00 0 00 031165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1654									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1655									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1656									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1657									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1658
  1659					;**********
  1660
  1661
  1662					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1663					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1664					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1665					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1666					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1667
  1668			000615		SN=SN+1
  1669			000003			ZZ=ZZ-1
  1670	031165	302 03 0 00 000003 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1671						STOP^
  1672	031166	254 04 0 00 031167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1673	031167	324 00 0 00 031170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1674									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1675									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 6-6
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0044

  1676									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1677									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1678
  1679					;**********
  1680
  1681
  1682					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1683					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1684					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1685					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1686					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1687
  1688			000616		SN=SN+1
  1689			000002			ZZ=ZZ-1
  1690	031170	302 02 0 00 000002 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1691						STOP^
  1692	031171	254 04 0 00 031172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1693	031172	324 00 0 00 031173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1694									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1695									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1696									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1697									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1698
  1699					;**********
  1700
  1701
  1702					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
  1703					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
  1704					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
  1705					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
  1706					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
  1707
  1708			000617		SN=SN+1
  1709			000001			ZZ=ZZ-1
  1710	031173	302 01 0 00 000001 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
  1711						STOP^
  1712	031174	254 04 0 00 031175 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1713	031175	324 00 0 00 031176 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1714									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1715									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1716									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1717									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
  1718
  1719					;**********
  1720
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 7
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0045

  1721			000700		SN=700
  1722			000000			ZZ=0
  1723
  1724					C700:	REPEAT	^D15,<
  1725					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1726					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1727					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1728					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1729
  1730					SN=SN+1
  1731						ZZ=ZZ+1
  1732						MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1733						CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1734						STOP
  1735
  1736					;**********
  1737					>
  1738
  1739					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1740					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1741					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1742					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1743
  1744			000701		SN=SN+1
  1745			000001			ZZ=ZZ+1
  1746	031176	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1747	031177	302 01 0 01 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1748						STOP^
  1749	031200	254 04 0 00 031201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1750	031201	324 00 0 00 031202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1751									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1752									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1753									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1754
  1755					;**********
  1756
  1757
  1758					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1759					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1760					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1761					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1762
  1763			000702		SN=SN+1
  1764			000002			ZZ=ZZ+1
  1765	031202	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1766	031203	302 02 0 02 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1767						STOP^
  1768	031204	254 04 0 00 031205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1769	031205	324 00 0 00 031206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1770									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1771									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1772									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1773
  1774					;**********
  1775
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 7-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0046

  1776
  1777					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1778					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1779					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1780					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1781
  1782			000703		SN=SN+1
  1783			000003			ZZ=ZZ+1
  1784	031206	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1785	031207	302 03 0 03 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1786						STOP^
  1787	031210	254 04 0 00 031211 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1788	031211	324 00 0 00 031212 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1789									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1790									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1791									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1792
  1793					;**********
  1794
  1795
  1796					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1797					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1798					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1799					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1800
  1801			000704		SN=SN+1
  1802			000004			ZZ=ZZ+1
  1803	031212	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1804	031213	302 04 0 04 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1805						STOP^
  1806	031214	254 04 0 00 031215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1807	031215	324 00 0 00 031216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1808									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1809									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1810									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1811
  1812					;**********
  1813
  1814
  1815					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1816					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1817					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1818					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1819
  1820			000705		SN=SN+1
  1821			000005			ZZ=ZZ+1
  1822	031216	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1823	031217	302 05 0 05 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1824						STOP^
  1825	031220	254 04 0 00 031221 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1826	031221	324 00 0 00 031222 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1827									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1828									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1829									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1830
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 7-2
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0047

  1831					;**********
  1832
  1833
  1834					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1835					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1836					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1837					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1838
  1839			000706		SN=SN+1
  1840			000006			ZZ=ZZ+1
  1841	031222	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1842	031223	302 06 0 06 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1843						STOP^
  1844	031224	254 04 0 00 031225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1845	031225	324 00 0 00 031226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1846									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1847									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1848									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1849
  1850					;**********
  1851
  1852
  1853					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1854					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1855					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1856					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1857
  1858			000707		SN=SN+1
  1859			000007			ZZ=ZZ+1
  1860	031226	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1861	031227	302 07 0 07 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1862						STOP^
  1863	031230	254 04 0 00 031231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1864	031231	324 00 0 00 031232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1865									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1866									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1867									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1868
  1869					;**********
  1870
  1871
  1872					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1873					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1874					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1875					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1876
  1877			000710		SN=SN+1
  1878			000010			ZZ=ZZ+1
  1879	031232	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1880	031233	302 10 0 10 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1881						STOP^
  1882	031234	254 04 0 00 031235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1883	031235	324 00 0 00 031236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1884									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1885									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 7-3
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0048

  1886									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1887
  1888					;**********
  1889
  1890
  1891					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1892					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1893					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1894					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1895
  1896			000711		SN=SN+1
  1897			000011			ZZ=ZZ+1
  1898	031236	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1899	031237	302 11 0 11 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1900						STOP^
  1901	031240	254 04 0 00 031241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1902	031241	324 00 0 00 031242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1903									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1904									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1905									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1906
  1907					;**********
  1908
  1909
  1910					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1911					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1912					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1913					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1914
  1915			000712		SN=SN+1
  1916			000012			ZZ=ZZ+1
  1917	031242	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1918	031243	302 12 0 12 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1919						STOP^
  1920	031244	254 04 0 00 031245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1921	031245	324 00 0 00 031246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1922									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1923									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1924									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1925
  1926					;**********
  1927
  1928
  1929					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1930					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1931					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1932					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1933
  1934			000713		SN=SN+1
  1935			000013			ZZ=ZZ+1
  1936	031246	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1937	031247	302 13 0 13 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1938						STOP^
  1939	031250	254 04 0 00 031251 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1940	031251	324 00 0 00 031252 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 7-4
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0049

  1941									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1942									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1943									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1944
  1945					;**********
  1946
  1947
  1948					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1949					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1950					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1951					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1952
  1953			000714		SN=SN+1
  1954			000014			ZZ=ZZ+1
  1955	031252	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1956	031253	302 14 0 14 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1957						STOP^
  1958	031254	254 04 0 00 031255 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1959	031255	324 00 0 00 031256 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1960									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1961									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1962									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1963
  1964					;**********
  1965
  1966
  1967					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1968					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1969					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1970					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1971
  1972			000715		SN=SN+1
  1973			000015			ZZ=ZZ+1
  1974	031256	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1975	031257	302 15 0 15 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1976						STOP^
  1977	031260	254 04 0 00 031261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1978	031261	324 00 0 00 031262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1979									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1980									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1981									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1982
  1983					;**********
  1984
  1985
  1986					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  1987					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  1988					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  1989					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  1990
  1991			000716		SN=SN+1
  1992			000016			ZZ=ZZ+1
  1993	031262	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  1994	031263	302 16 0 16 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  1995						STOP^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 7-5
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0050

  1996	031264	254 04 0 00 031265 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1997	031265	324 00 0 00 031266 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1998									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1999									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2000									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2001
  2002					;**********
  2003
  2004
  2005					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
  2006					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
  2007					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
  2008					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
  2009
  2010			000717		SN=SN+1
  2011			000017			ZZ=ZZ+1
  2012	031266	201 17 0 00 000017 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
  2013	031267	302 17 0 17 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2014						STOP^
  2015	031270	254 04 0 00 031271 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2016	031271	324 00 0 00 031272 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2017									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2018									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2019									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2020
  2021					;**********
  2022
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 8
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0051

  2023			001000		SN=1000
  2024			000000			ZZ=0
  2025
  2026					C1000:	REPEAT	^D15,<
  2027					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2028					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2029					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2030					.
  2031					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2032					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2033
  2034					SN=SN+1
  2035						ZZ=ZZ+1
  2036						MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2037						HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2038						CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2039						STOP
  2040
  2041					;**********
  2042					>
  2043
  2044					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2045					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2046					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2047					.
  2048					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2049					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2050
  2051			001001		SN=SN+1
  2052			000001			ZZ=ZZ+1
  2053	031272	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2054	031273	505 01 0 00 000001 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2055	031274	312 01 0 01 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2056						STOP^
  2057	031275	254 04 0 00 031276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2058	031276	324 00 0 00 031277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2059									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2060									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2061									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2062
  2063					;**********
  2064
  2065
  2066					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2067					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2068					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2069					.
  2070					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2071					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2072
  2073			001002		SN=SN+1
  2074			000002			ZZ=ZZ+1
  2075	031277	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2076	031300	505 02 0 00 000002 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2077	031301	312 02 0 02 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 8-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0052

  2078						STOP^
  2079	031302	254 04 0 00 031303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2080	031303	324 00 0 00 031304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2081									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2082									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2083									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2084
  2085					;**********
  2086
  2087
  2088					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2089					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2090					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2091					.
  2092					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2093					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2094
  2095			001003		SN=SN+1
  2096			000003			ZZ=ZZ+1
  2097	031304	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2098	031305	505 03 0 00 000003 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2099	031306	312 03 0 03 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2100						STOP^
  2101	031307	254 04 0 00 031310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2102	031310	324 00 0 00 031311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2103									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2104									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2105									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2106
  2107					;**********
  2108
  2109
  2110					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2111					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2112					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2113					.
  2114					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2115					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2116
  2117			001004		SN=SN+1
  2118			000004			ZZ=ZZ+1
  2119	031311	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2120	031312	505 04 0 00 000004 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2121	031313	312 04 0 04 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2122						STOP^
  2123	031314	254 04 0 00 031315 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2124	031315	324 00 0 00 031316 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2125									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2126									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2127									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2128
  2129					;**********
  2130
  2131
  2132					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 8-2
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0053

  2133					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2134					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2135					.
  2136					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2137					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2138
  2139			001005		SN=SN+1
  2140			000005			ZZ=ZZ+1
  2141	031316	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2142	031317	505 05 0 00 000005 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2143	031320	312 05 0 05 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2144						STOP^
  2145	031321	254 04 0 00 031322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2146	031322	324 00 0 00 031323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2147									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2148									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2149									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2150
  2151					;**********
  2152
  2153
  2154					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2155					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2156					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2157					.
  2158					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2159					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2160
  2161			001006		SN=SN+1
  2162			000006			ZZ=ZZ+1
  2163	031323	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2164	031324	505 06 0 00 000006 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2165	031325	312 06 0 06 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2166						STOP^
  2167	031326	254 04 0 00 031327 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2168	031327	324 00 0 00 031330 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2169									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2170									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2171									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2172
  2173					;**********
  2174
  2175
  2176					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2177					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2178					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2179					.
  2180					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2181					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2182
  2183			001007		SN=SN+1
  2184			000007			ZZ=ZZ+1
  2185	031330	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2186	031331	505 07 0 00 000007 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2187	031332	312 07 0 07 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 8-3
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0054

  2188						STOP^
  2189	031333	254 04 0 00 031334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2190	031334	324 00 0 00 031335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2191									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2192									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2193									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2194
  2195					;**********
  2196
  2197
  2198					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2199					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2200					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2201					.
  2202					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2203					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2204
  2205			001010		SN=SN+1
  2206			000010			ZZ=ZZ+1
  2207	031335	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2208	031336	505 10 0 00 000010 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2209	031337	312 10 0 10 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2210						STOP^
  2211	031340	254 04 0 00 031341 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2212	031341	324 00 0 00 031342 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2213									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2214									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2215									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2216
  2217					;**********
  2218
  2219
  2220					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2221					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2222					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2223					.
  2224					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2225					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2226
  2227			001011		SN=SN+1
  2228			000011			ZZ=ZZ+1
  2229	031342	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2230	031343	505 11 0 00 000011 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2231	031344	312 11 0 11 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2232						STOP^
  2233	031345	254 04 0 00 031346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2234	031346	324 00 0 00 031347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2235									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2236									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2237									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2238
  2239					;**********
  2240
  2241
  2242					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 8-4
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0055

  2243					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2244					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2245					.
  2246					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2247					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2248
  2249			001012		SN=SN+1
  2250			000012			ZZ=ZZ+1
  2251	031347	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2252	031350	505 12 0 00 000012 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2253	031351	312 12 0 12 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2254						STOP^
  2255	031352	254 04 0 00 031353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2256	031353	324 00 0 00 031354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2257									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2258									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2259									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2260
  2261					;**********
  2262
  2263
  2264					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2265					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2266					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2267					.
  2268					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2269					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2270
  2271			001013		SN=SN+1
  2272			000013			ZZ=ZZ+1
  2273	031354	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2274	031355	505 13 0 00 000013 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2275	031356	312 13 0 13 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2276						STOP^
  2277	031357	254 04 0 00 031360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2278	031360	324 00 0 00 031361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2279									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2280									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2281									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2282
  2283					;**********
  2284
  2285
  2286					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2287					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2288					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2289					.
  2290					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2291					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2292
  2293			001014		SN=SN+1
  2294			000014			ZZ=ZZ+1
  2295	031361	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2296	031362	505 14 0 00 000014 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2297	031363	312 14 0 14 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 8-5
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0056

  2298						STOP^
  2299	031364	254 04 0 00 031365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2300	031365	324 00 0 00 031366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2301									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2302									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2303									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2304
  2305					;**********
  2306
  2307
  2308					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2309					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2310					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2311					.
  2312					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2313					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2314
  2315			001015		SN=SN+1
  2316			000015			ZZ=ZZ+1
  2317	031366	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2318	031367	505 15 0 00 000015 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2319	031370	312 15 0 15 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2320						STOP^
  2321	031371	254 04 0 00 031372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2322	031372	324 00 0 00 031373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2323									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2324									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2325									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2326
  2327					;**********
  2328
  2329
  2330					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
  2331					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2332					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2333					.
  2334					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2335					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2336
  2337			001016		SN=SN+1
  2338			000016			ZZ=ZZ+1
  2339	031373	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2340	031374	505 16 0 00 000016 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2341	031375	312 16 0 16 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2342						STOP^
  2343	031376	254 04 0 00 031377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2344	031377	324 00 0 00 031400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2345									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2346									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2347									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2348
  2349					;**********
  2350
  2351
  2352					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 8-6
DAKADM	MAC	19-JAN-77 13:41		TEST OF AC HARDWARE AND INDEX REGISTERS                                            SEQ 0057

  2353					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
  2354					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES
  2355					.
  2356					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
  2357					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
  2358
  2359			001017		SN=SN+1
  2360			000017			ZZ=ZZ+1
  2361	031400	201 17 0 00 000017 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
  2362	031401	505 17 0 00 000017 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
  2363	031402	312 17 0 17 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
  2364						STOP^
  2365	031403	254 04 0 00 031404 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2366	031404	324 00 0 00 031405 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2367									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2368									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2369									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2370
  2371					;**********
  2372
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 9
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0058

  2373					SUBTTL	TEST OF INDEX REGISTER ADDRESSING
  2374
  2375					;**********
  2376
  2377					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2378					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2379					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2380					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A 0,
  2381					;THE FINAL RESULT IN AC3 SHOULD BE 0.  IF C(AC3)=0, THIS TEST PASSES.
  2382
  2383	031405	476 00 0 00 000003 	C1100:	SETOM	3		;PRELOAD AC3 WITH -1,,1
  2384	031406	402 00 0 00 000001 		SETZM	1		;PRELOAD AC1 WITH 0
  2385	031407	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER 2 WITH 1
  2386	031410	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2387	031411	332 00 0 00 000003 		SKIPE	3		;TEST INDEXING
  2388						STOP^
  2389	031412	254 04 0 00 031413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2390	031413	324 00 0 00 031414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2391									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2392									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2393									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2394
  2395					;**********
  2396
  2397			001200		SN=1200
  2398			000000			ZZ=0
  2399
  2400					C1200:	REPEAT	^D18,<
  2401					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2402					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2403					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2404					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2405					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2406					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2407
  2408					SN=SN+1
  2409						ZZ=ZZ+ZZ
  2410						IFE	ZZ,<ZZ=1>
  2411						SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2412						MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2413						MOVEI	2,1		;SETUP INDEX REGISTER
  2414						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2415						CAIE	3,ZZ		;TEST INDEXING
  2416						STOP
  2417
  2418					;**********
  2419					>
  2420
  2421					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2422					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2423					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2424					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2425					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2426					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2427
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 9-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0059

  2428			001201		SN=SN+1
  2429			000000			ZZ=ZZ+ZZ
  2430			000001			IFE	ZZ,<ZZ=1>
  2431	031414	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2432	031415	201 01 0 00 000001 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2433	031416	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2434	031417	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2435	031420	302 03 0 00 000001 		CAIE	3,ZZ		;TEST INDEXING
  2436						STOP^
  2437	031421	254 04 0 00 031422 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2438	031422	324 00 0 00 031423 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2439									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2440									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2441									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2442
  2443					;**********
  2444
  2445
  2446					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2447					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2448					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2449					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2450					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2451					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2452
  2453			001202		SN=SN+1
  2454			000002			ZZ=ZZ+ZZ
  2455						IFE	ZZ,<ZZ=1>
  2456	031423	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2457	031424	201 01 0 00 000002 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2458	031425	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2459	031426	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2460	031427	302 03 0 00 000002 		CAIE	3,ZZ		;TEST INDEXING
  2461						STOP^
  2462	031430	254 04 0 00 031431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2463	031431	324 00 0 00 031432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2464									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2465									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2466									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2467
  2468					;**********
  2469
  2470
  2471					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2472					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2473					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2474					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2475					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2476					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2477
  2478			001203		SN=SN+1
  2479			000004			ZZ=ZZ+ZZ
  2480						IFE	ZZ,<ZZ=1>
  2481	031432	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2482	031433	201 01 0 00 000004 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 9-2
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0060

  2483	031434	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2484	031435	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2485	031436	302 03 0 00 000004 		CAIE	3,ZZ		;TEST INDEXING
  2486						STOP^
  2487	031437	254 04 0 00 031440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2488	031440	324 00 0 00 031441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2489									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2490									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2491									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2492
  2493					;**********
  2494
  2495
  2496					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2497					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2498					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2499					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2500					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2501					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2502
  2503			001204		SN=SN+1
  2504			000010			ZZ=ZZ+ZZ
  2505						IFE	ZZ,<ZZ=1>
  2506	031441	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2507	031442	201 01 0 00 000010 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2508	031443	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2509	031444	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2510	031445	302 03 0 00 000010 		CAIE	3,ZZ		;TEST INDEXING
  2511						STOP^
  2512	031446	254 04 0 00 031447 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2513	031447	324 00 0 00 031450 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2514									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2515									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2516									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2517
  2518					;**********
  2519
  2520
  2521					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2522					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2523					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2524					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2525					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2526					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2527
  2528			001205		SN=SN+1
  2529			000020			ZZ=ZZ+ZZ
  2530						IFE	ZZ,<ZZ=1>
  2531	031450	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2532	031451	201 01 0 00 000020 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2533	031452	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2534	031453	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2535	031454	302 03 0 00 000020 		CAIE	3,ZZ		;TEST INDEXING
  2536						STOP^
  2537	031455	254 04 0 00 031456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 9-3
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0061

  2538	031456	324 00 0 00 031457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2539									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2540									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2541									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2542
  2543					;**********
  2544
  2545
  2546					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2547					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2548					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2549					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2550					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2551					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2552
  2553			001206		SN=SN+1
  2554			000040			ZZ=ZZ+ZZ
  2555						IFE	ZZ,<ZZ=1>
  2556	031457	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2557	031460	201 01 0 00 000040 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2558	031461	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2559	031462	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2560	031463	302 03 0 00 000040 		CAIE	3,ZZ		;TEST INDEXING
  2561						STOP^
  2562	031464	254 04 0 00 031465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2563	031465	324 00 0 00 031466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2564									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2565									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2566									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2567
  2568					;**********
  2569
  2570
  2571					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2572					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2573					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2574					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2575					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2576					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2577
  2578			001207		SN=SN+1
  2579			000100			ZZ=ZZ+ZZ
  2580						IFE	ZZ,<ZZ=1>
  2581	031466	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2582	031467	201 01 0 00 000100 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2583	031470	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2584	031471	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2585	031472	302 03 0 00 000100 		CAIE	3,ZZ		;TEST INDEXING
  2586						STOP^
  2587	031473	254 04 0 00 031474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2588	031474	324 00 0 00 031475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2589									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2590									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2591									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2592
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 9-4
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0062

  2593					;**********
  2594
  2595
  2596					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2597					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2598					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2599					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2600					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2601					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2602
  2603			001210		SN=SN+1
  2604			000200			ZZ=ZZ+ZZ
  2605						IFE	ZZ,<ZZ=1>
  2606	031475	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2607	031476	201 01 0 00 000200 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2608	031477	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2609	031500	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2610	031501	302 03 0 00 000200 		CAIE	3,ZZ		;TEST INDEXING
  2611						STOP^
  2612	031502	254 04 0 00 031503 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2613	031503	324 00 0 00 031504 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2614									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2615									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2616									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2617
  2618					;**********
  2619
  2620
  2621					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2622					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2623					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2624					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2625					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2626					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2627
  2628			001211		SN=SN+1
  2629			000400			ZZ=ZZ+ZZ
  2630						IFE	ZZ,<ZZ=1>
  2631	031504	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2632	031505	201 01 0 00 000400 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2633	031506	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2634	031507	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2635	031510	302 03 0 00 000400 		CAIE	3,ZZ		;TEST INDEXING
  2636						STOP^
  2637	031511	254 04 0 00 031512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2638	031512	324 00 0 00 031513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2639									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2640									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2641									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2642
  2643					;**********
  2644
  2645
  2646					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2647					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 9-5
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0063

  2648					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2649					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2650					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2651					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2652
  2653			001212		SN=SN+1
  2654			001000			ZZ=ZZ+ZZ
  2655						IFE	ZZ,<ZZ=1>
  2656	031513	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2657	031514	201 01 0 00 001000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2658	031515	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2659	031516	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2660	031517	302 03 0 00 001000 		CAIE	3,ZZ		;TEST INDEXING
  2661						STOP^
  2662	031520	254 04 0 00 031521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2663	031521	324 00 0 00 031522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2664									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2665									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2666									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2667
  2668					;**********
  2669
  2670
  2671					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2672					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2673					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2674					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2675					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2676					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2677
  2678			001213		SN=SN+1
  2679			002000			ZZ=ZZ+ZZ
  2680						IFE	ZZ,<ZZ=1>
  2681	031522	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2682	031523	201 01 0 00 002000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2683	031524	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2684	031525	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2685	031526	302 03 0 00 002000 		CAIE	3,ZZ		;TEST INDEXING
  2686						STOP^
  2687	031527	254 04 0 00 031530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2688	031530	324 00 0 00 031531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2689									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2690									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2691									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2692
  2693					;**********
  2694
  2695
  2696					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2697					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2698					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2699					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2700					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2701					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2702
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 9-6
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0064

  2703			001214		SN=SN+1
  2704			004000			ZZ=ZZ+ZZ
  2705						IFE	ZZ,<ZZ=1>
  2706	031531	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2707	031532	201 01 0 00 004000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2708	031533	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2709	031534	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2710	031535	302 03 0 00 004000 		CAIE	3,ZZ		;TEST INDEXING
  2711						STOP^
  2712	031536	254 04 0 00 031537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2713	031537	324 00 0 00 031540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2714									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2715									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2716									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2717
  2718					;**********
  2719
  2720
  2721					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2722					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2723					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2724					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2725					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2726					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2727
  2728			001215		SN=SN+1
  2729			010000			ZZ=ZZ+ZZ
  2730						IFE	ZZ,<ZZ=1>
  2731	031540	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2732	031541	201 01 0 00 010000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2733	031542	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2734	031543	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2735	031544	302 03 0 00 010000 		CAIE	3,ZZ		;TEST INDEXING
  2736						STOP^
  2737	031545	254 04 0 00 031546 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2738	031546	324 00 0 00 031547 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2739									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2740									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2741									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2742
  2743					;**********
  2744
  2745
  2746					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2747					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2748					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2749					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2750					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2751					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2752
  2753			001216		SN=SN+1
  2754			020000			ZZ=ZZ+ZZ
  2755						IFE	ZZ,<ZZ=1>
  2756	031547	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2757	031550	201 01 0 00 020000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 9-7
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0065

  2758	031551	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2759	031552	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2760	031553	302 03 0 00 020000 		CAIE	3,ZZ		;TEST INDEXING
  2761						STOP^
  2762	031554	254 04 0 00 031555 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2763	031555	324 00 0 00 031556 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2764									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2765									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2766									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2767
  2768					;**********
  2769
  2770
  2771					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2772					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2773					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2774					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2775					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2776					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2777
  2778			001217		SN=SN+1
  2779			040000			ZZ=ZZ+ZZ
  2780						IFE	ZZ,<ZZ=1>
  2781	031556	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2782	031557	201 01 0 00 040000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2783	031560	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2784	031561	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2785	031562	302 03 0 00 040000 		CAIE	3,ZZ		;TEST INDEXING
  2786						STOP^
  2787	031563	254 04 0 00 031564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2788	031564	324 00 0 00 031565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2789									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2790									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2791									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2792
  2793					;**********
  2794
  2795
  2796					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2797					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2798					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2799					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2800					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2801					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2802
  2803			001220		SN=SN+1
  2804			100000			ZZ=ZZ+ZZ
  2805						IFE	ZZ,<ZZ=1>
  2806	031565	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2807	031566	201 01 0 00 100000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2808	031567	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2809	031570	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2810	031571	302 03 0 00 100000 		CAIE	3,ZZ		;TEST INDEXING
  2811						STOP^
  2812	031572	254 04 0 00 031573 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 9-8
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0066

  2813	031573	324 00 0 00 031574 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2814									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2815									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2816									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2817
  2818					;**********
  2819
  2820
  2821					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2822					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2823					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2824					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2825					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2826					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2827
  2828			001221		SN=SN+1
  2829			200000			ZZ=ZZ+ZZ
  2830						IFE	ZZ,<ZZ=1>
  2831	031574	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2832	031575	201 01 0 00 200000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2833	031576	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2834	031577	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2835	031600	302 03 0 00 200000 		CAIE	3,ZZ		;TEST INDEXING
  2836						STOP^
  2837	031601	254 04 0 00 031602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2838	031602	324 00 0 00 031603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2839									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2840									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2841									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2842
  2843					;**********
  2844
  2845
  2846					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2847					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2848					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2849					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2850					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2851					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2852
  2853			001222		SN=SN+1
  2854			400000			ZZ=ZZ+ZZ
  2855						IFE	ZZ,<ZZ=1>
  2856	031603	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2857	031604	201 01 0 00 400000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2858	031605	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2859	031606	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2860	031607	302 03 0 00 400000 		CAIE	3,ZZ		;TEST INDEXING
  2861						STOP^
  2862	031610	254 04 0 00 031611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2863	031611	324 00 0 00 031612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2864									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2865									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2866									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2867
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 9-9
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0067

  2868					;**********
  2869
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 10
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0068

  2870			001300		SN=1300
  2871			000000			ZZ=0
  2872
  2873					C1300:	REPEAT	^D18,<
  2874					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2875					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2876					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2877					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2878					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2879					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2880
  2881					SN=SN+1
  2882						ZZ=ZZ+ZZ
  2883						IFE	ZZ,<ZZ=1>
  2884						SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2885						MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2886						MOVEI	2,1		;SETUP INDEX REGISTER
  2887						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2888						CAME	3,[ZZ,,0]	;TEST INDEXING
  2889						STOP
  2890
  2891					;**********
  2892					>
  2893
  2894					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2895					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2896					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2897					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2898					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2899					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2900
  2901			001301		SN=SN+1
  2902			000000			ZZ=ZZ+ZZ
  2903			000001			IFE	ZZ,<ZZ=1>
  2904	031612	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2905	031613	205 01 0 00 000001 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2906	031614	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2907	031615	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2908	031616	312 03 0 00 034444 		CAME	3,[ZZ,,0]	;TEST INDEXING
  2909						STOP^
  2910	031617	254 04 0 00 031620 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2911	031620	324 00 0 00 031621 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2912									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2913									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2914									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2915
  2916					;**********
  2917
  2918
  2919					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2920					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2921					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2922					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2923					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2924					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 10-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0069

  2925
  2926			001302		SN=SN+1
  2927			000002			ZZ=ZZ+ZZ
  2928						IFE	ZZ,<ZZ=1>
  2929	031621	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2930	031622	205 01 0 00 000002 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2931	031623	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2932	031624	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2933	031625	312 03 0 00 034445 		CAME	3,[ZZ,,0]	;TEST INDEXING
  2934						STOP^
  2935	031626	254 04 0 00 031627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2936	031627	324 00 0 00 031630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2937									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2938									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2939									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2940
  2941					;**********
  2942
  2943
  2944					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2945					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2946					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2947					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2948					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2949					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2950
  2951			001303		SN=SN+1
  2952			000004			ZZ=ZZ+ZZ
  2953						IFE	ZZ,<ZZ=1>
  2954	031630	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  2955	031631	205 01 0 00 000004 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2956	031632	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2957	031633	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2958	031634	312 03 0 00 034446 		CAME	3,[ZZ,,0]	;TEST INDEXING
  2959						STOP^
  2960	031635	254 04 0 00 031636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2961	031636	324 00 0 00 031637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2962									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2963									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2964									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2965
  2966					;**********
  2967
  2968
  2969					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2970					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2971					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2972					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2973					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2974					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  2975
  2976			001304		SN=SN+1
  2977			000010			ZZ=ZZ+ZZ
  2978						IFE	ZZ,<ZZ=1>
  2979	031637	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 10-2
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0070

  2980	031640	205 01 0 00 000010 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  2981	031641	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  2982	031642	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  2983	031643	312 03 0 00 034447 		CAME	3,[ZZ,,0]	;TEST INDEXING
  2984						STOP^
  2985	031644	254 04 0 00 031645 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2986	031645	324 00 0 00 031646 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2987									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2988									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2989									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2990
  2991					;**********
  2992
  2993
  2994					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  2995					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  2996					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  2997					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  2998					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  2999					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3000
  3001			001305		SN=SN+1
  3002			000020			ZZ=ZZ+ZZ
  3003						IFE	ZZ,<ZZ=1>
  3004	031646	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3005	031647	205 01 0 00 000020 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3006	031650	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3007	031651	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3008	031652	312 03 0 00 034450 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3009						STOP^
  3010	031653	254 04 0 00 031654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3011	031654	324 00 0 00 031655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3012									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3013									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3014									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3015
  3016					;**********
  3017
  3018
  3019					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3020					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3021					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3022					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3023					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3024					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3025
  3026			001306		SN=SN+1
  3027			000040			ZZ=ZZ+ZZ
  3028						IFE	ZZ,<ZZ=1>
  3029	031655	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3030	031656	205 01 0 00 000040 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3031	031657	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3032	031660	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3033	031661	312 03 0 00 034451 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3034						STOP^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 10-3
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0071

  3035	031662	254 04 0 00 031663 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3036	031663	324 00 0 00 031664 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3037									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3038									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3039									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3040
  3041					;**********
  3042
  3043
  3044					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3045					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3046					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3047					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3048					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3049					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3050
  3051			001307		SN=SN+1
  3052			000100			ZZ=ZZ+ZZ
  3053						IFE	ZZ,<ZZ=1>
  3054	031664	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3055	031665	205 01 0 00 000100 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3056	031666	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3057	031667	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3058	031670	312 03 0 00 034452 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3059						STOP^
  3060	031671	254 04 0 00 031672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3061	031672	324 00 0 00 031673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3062									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3063									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3064									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3065
  3066					;**********
  3067
  3068
  3069					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3070					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3071					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3072					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3073					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3074					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3075
  3076			001310		SN=SN+1
  3077			000200			ZZ=ZZ+ZZ
  3078						IFE	ZZ,<ZZ=1>
  3079	031673	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3080	031674	205 01 0 00 000200 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3081	031675	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3082	031676	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3083	031677	312 03 0 00 034453 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3084						STOP^
  3085	031700	254 04 0 00 031701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3086	031701	324 00 0 00 031702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3087									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3088									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3089									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 10-4
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0072

  3090
  3091					;**********
  3092
  3093
  3094					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3095					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3096					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3097					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3098					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3099					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3100
  3101			001311		SN=SN+1
  3102			000400			ZZ=ZZ+ZZ
  3103						IFE	ZZ,<ZZ=1>
  3104	031702	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3105	031703	205 01 0 00 000400 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3106	031704	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3107	031705	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3108	031706	312 03 0 00 034454 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3109						STOP^
  3110	031707	254 04 0 00 031710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3111	031710	324 00 0 00 031711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3112									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3113									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3114									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3115
  3116					;**********
  3117
  3118
  3119					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3120					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3121					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3122					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3123					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3124					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3125
  3126			001312		SN=SN+1
  3127			001000			ZZ=ZZ+ZZ
  3128						IFE	ZZ,<ZZ=1>
  3129	031711	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3130	031712	205 01 0 00 001000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3131	031713	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3132	031714	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3133	031715	312 03 0 00 034455 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3134						STOP^
  3135	031716	254 04 0 00 031717 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3136	031717	324 00 0 00 031720 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3137									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3138									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3139									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3140
  3141					;**********
  3142
  3143
  3144					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 10-5
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0073

  3145					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3146					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3147					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3148					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3149					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3150
  3151			001313		SN=SN+1
  3152			002000			ZZ=ZZ+ZZ
  3153						IFE	ZZ,<ZZ=1>
  3154	031720	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3155	031721	205 01 0 00 002000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3156	031722	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3157	031723	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3158	031724	312 03 0 00 034456 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3159						STOP^
  3160	031725	254 04 0 00 031726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3161	031726	324 00 0 00 031727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3162									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3163									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3164									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3165
  3166					;**********
  3167
  3168
  3169					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3170					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3171					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3172					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3173					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3174					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3175
  3176			001314		SN=SN+1
  3177			004000			ZZ=ZZ+ZZ
  3178						IFE	ZZ,<ZZ=1>
  3179	031727	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3180	031730	205 01 0 00 004000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3181	031731	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3182	031732	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3183	031733	312 03 0 00 034457 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3184						STOP^
  3185	031734	254 04 0 00 031735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3186	031735	324 00 0 00 031736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3187									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3188									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3189									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3190
  3191					;**********
  3192
  3193
  3194					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3195					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3196					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3197					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3198					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3199					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 10-6
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0074

  3200
  3201			001315		SN=SN+1
  3202			010000			ZZ=ZZ+ZZ
  3203						IFE	ZZ,<ZZ=1>
  3204	031736	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3205	031737	205 01 0 00 010000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3206	031740	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3207	031741	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3208	031742	312 03 0 00 034460 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3209						STOP^
  3210	031743	254 04 0 00 031744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3211	031744	324 00 0 00 031745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3212									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3213									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3214									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3215
  3216					;**********
  3217
  3218
  3219					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3220					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3221					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3222					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3223					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3224					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3225
  3226			001316		SN=SN+1
  3227			020000			ZZ=ZZ+ZZ
  3228						IFE	ZZ,<ZZ=1>
  3229	031745	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3230	031746	205 01 0 00 020000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3231	031747	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3232	031750	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3233	031751	312 03 0 00 034461 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3234						STOP^
  3235	031752	254 04 0 00 031753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3236	031753	324 00 0 00 031754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3237									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3238									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3239									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3240
  3241					;**********
  3242
  3243
  3244					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3245					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3246					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3247					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3248					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3249					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3250
  3251			001317		SN=SN+1
  3252			040000			ZZ=ZZ+ZZ
  3253						IFE	ZZ,<ZZ=1>
  3254	031754	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 10-7
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0075

  3255	031755	205 01 0 00 040000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3256	031756	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3257	031757	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3258	031760	312 03 0 00 034462 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3259						STOP^
  3260	031761	254 04 0 00 031762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3261	031762	324 00 0 00 031763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3262									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3263									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3264									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3265
  3266					;**********
  3267
  3268
  3269					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3270					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3271					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3272					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3273					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3274					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3275
  3276			001320		SN=SN+1
  3277			100000			ZZ=ZZ+ZZ
  3278						IFE	ZZ,<ZZ=1>
  3279	031763	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3280	031764	205 01 0 00 100000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3281	031765	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3282	031766	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3283	031767	312 03 0 00 034463 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3284						STOP^
  3285	031770	254 04 0 00 031771 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3286	031771	324 00 0 00 031772 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3287									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3288									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3289									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3290
  3291					;**********
  3292
  3293
  3294					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3295					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3296					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3297					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3298					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3299					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3300
  3301			001321		SN=SN+1
  3302			200000			ZZ=ZZ+ZZ
  3303						IFE	ZZ,<ZZ=1>
  3304	031772	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3305	031773	205 01 0 00 200000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3306	031774	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3307	031775	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3308	031776	312 03 0 00 034464 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3309						STOP^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 10-8
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0076

  3310	031777	254 04 0 00 032000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3311	032000	324 00 0 00 032001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3312									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3313									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3314									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3315
  3316					;**********
  3317
  3318
  3319					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3320					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3321					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3322					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3323					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
  3324					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
  3325
  3326			001322		SN=SN+1
  3327			400000			ZZ=ZZ+ZZ
  3328						IFE	ZZ,<ZZ=1>
  3329	032001	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
  3330	032002	205 01 0 00 400000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
  3331	032003	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3332	032004	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3333	032005	312 03 0 00 034465 		CAME	3,[ZZ,,0]	;TEST INDEXING
  3334						STOP^
  3335	032006	254 04 0 00 032007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3336	032007	324 00 0 00 032010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3337									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3338									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3339									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3340
  3341					;**********
  3342
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 11
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0077

  3343					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3344					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3345					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3346					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH -1,,-1,
  3347					;THE FINAL RESULT IN AC3 SHOULD BE -1,,-1.  IF C(AC3)=-1,,-1, THIS TEST PASSES.
  3348
  3349	032010	402 00 0 00 000003 	C1400:	SETZM	3		;PRELOAD AC3 WITH 0
  3350	032011	476 00 0 00 000001 		SETOM	1		;PRELOAD AC1 WITH -1,,-1
  3351	032012	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3352	032013	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3353	032014	312 03 0 00 034466 		CAME	3,[-1,,-1]	;TEST INDEXING
  3354						STOP^
  3355	032015	254 04 0 00 032016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3356	032016	324 00 0 00 032017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3357									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3358									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3359									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3360
  3361					;**********
  3362
  3363			001500		SN=1500
  3364			000000			ZZ=0
  3365
  3366					C1500:	REPEAT	^D18,<
  3367					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3368					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3369					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3370					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3371					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3372					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3373
  3374					SN=SN+1
  3375						ZZ=<ZZ+ZZ+1>&777777
  3376						IFE	<ZZ-1>,<ZZ=777776>
  3377						SETZM	3		;PRELOAD AC3 WITH 0
  3378						HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3379						MOVEI	2,1		;SETUP INDEX REGISTER
  3380						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3381						CAME	3,[-1,,ZZ]	;TEST INDEXING
  3382						STOP
  3383
  3384					;**********
  3385					>
  3386
  3387					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3388					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3389					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3390					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3391					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3392					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3393
  3394			001501		SN=SN+1
  3395			000001			ZZ=<ZZ+ZZ+1>&777777
  3396			777776			IFE	<ZZ-1>,<ZZ=777776>
  3397	032017	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 11-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0078

  3398	032020	561 01 0 00 777776 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3399	032021	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3400	032022	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3401	032023	312 03 0 00 034467 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3402						STOP^
  3403	032024	254 04 0 00 032025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3404	032025	324 00 0 00 032026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3405									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3406									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3407									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3408
  3409					;**********
  3410
  3411
  3412					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3413					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3414					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3415					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3416					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3417					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3418
  3419			001502		SN=SN+1
  3420			777775			ZZ=<ZZ+ZZ+1>&777777
  3421						IFE	<ZZ-1>,<ZZ=777776>
  3422	032026	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3423	032027	561 01 0 00 777775 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3424	032030	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3425	032031	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3426	032032	312 03 0 00 034470 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3427						STOP^
  3428	032033	254 04 0 00 032034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3429	032034	324 00 0 00 032035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3430									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3431									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3432									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3433
  3434					;**********
  3435
  3436
  3437					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3438					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3439					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3440					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3441					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3442					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3443
  3444			001503		SN=SN+1
  3445			777773			ZZ=<ZZ+ZZ+1>&777777
  3446						IFE	<ZZ-1>,<ZZ=777776>
  3447	032035	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3448	032036	561 01 0 00 777773 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3449	032037	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3450	032040	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3451	032041	312 03 0 00 034471 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3452						STOP^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 11-2
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0079

  3453	032042	254 04 0 00 032043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3454	032043	324 00 0 00 032044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3455									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3456									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3457									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3458
  3459					;**********
  3460
  3461
  3462					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3463					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3464					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3465					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3466					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3467					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3468
  3469			001504		SN=SN+1
  3470			777767			ZZ=<ZZ+ZZ+1>&777777
  3471						IFE	<ZZ-1>,<ZZ=777776>
  3472	032044	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3473	032045	561 01 0 00 777767 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3474	032046	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3475	032047	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3476	032050	312 03 0 00 034472 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3477						STOP^
  3478	032051	254 04 0 00 032052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3479	032052	324 00 0 00 032053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3480									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3481									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3482									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3483
  3484					;**********
  3485
  3486
  3487					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3488					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3489					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3490					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3491					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3492					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3493
  3494			001505		SN=SN+1
  3495			777757			ZZ=<ZZ+ZZ+1>&777777
  3496						IFE	<ZZ-1>,<ZZ=777776>
  3497	032053	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3498	032054	561 01 0 00 777757 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3499	032055	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3500	032056	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3501	032057	312 03 0 00 034473 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3502						STOP^
  3503	032060	254 04 0 00 032061 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3504	032061	324 00 0 00 032062 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3505									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3506									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3507									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 11-3
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0080

  3508
  3509					;**********
  3510
  3511
  3512					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3513					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3514					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3515					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3516					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3517					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3518
  3519			001506		SN=SN+1
  3520			777737			ZZ=<ZZ+ZZ+1>&777777
  3521						IFE	<ZZ-1>,<ZZ=777776>
  3522	032062	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3523	032063	561 01 0 00 777737 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3524	032064	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3525	032065	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3526	032066	312 03 0 00 034474 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3527						STOP^
  3528	032067	254 04 0 00 032070 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3529	032070	324 00 0 00 032071 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3530									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3531									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3532									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3533
  3534					;**********
  3535
  3536
  3537					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3538					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3539					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3540					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3541					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3542					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3543
  3544			001507		SN=SN+1
  3545			777677			ZZ=<ZZ+ZZ+1>&777777
  3546						IFE	<ZZ-1>,<ZZ=777776>
  3547	032071	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3548	032072	561 01 0 00 777677 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3549	032073	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3550	032074	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3551	032075	312 03 0 00 034475 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3552						STOP^
  3553	032076	254 04 0 00 032077 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3554	032077	324 00 0 00 032100 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3555									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3556									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3557									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3558
  3559					;**********
  3560
  3561
  3562					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 11-4
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0081

  3563					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3564					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3565					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3566					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3567					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3568
  3569			001510		SN=SN+1
  3570			777577			ZZ=<ZZ+ZZ+1>&777777
  3571						IFE	<ZZ-1>,<ZZ=777776>
  3572	032100	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3573	032101	561 01 0 00 777577 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3574	032102	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3575	032103	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3576	032104	312 03 0 00 034476 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3577						STOP^
  3578	032105	254 04 0 00 032106 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3579	032106	324 00 0 00 032107 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3580									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3581									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3582									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3583
  3584					;**********
  3585
  3586
  3587					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3588					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3589					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3590					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3591					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3592					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3593
  3594			001511		SN=SN+1
  3595			777377			ZZ=<ZZ+ZZ+1>&777777
  3596						IFE	<ZZ-1>,<ZZ=777776>
  3597	032107	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3598	032110	561 01 0 00 777377 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3599	032111	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3600	032112	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3601	032113	312 03 0 00 034477 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3602						STOP^
  3603	032114	254 04 0 00 032115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3604	032115	324 00 0 00 032116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3605									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3606									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3607									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3608
  3609					;**********
  3610
  3611
  3612					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3613					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3614					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3615					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3616					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3617					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 11-5
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0082

  3618
  3619			001512		SN=SN+1
  3620			776777			ZZ=<ZZ+ZZ+1>&777777
  3621						IFE	<ZZ-1>,<ZZ=777776>
  3622	032116	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3623	032117	561 01 0 00 776777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3624	032120	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3625	032121	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3626	032122	312 03 0 00 034500 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3627						STOP^
  3628	032123	254 04 0 00 032124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3629	032124	324 00 0 00 032125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3630									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3631									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3632									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3633
  3634					;**********
  3635
  3636
  3637					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3638					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3639					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3640					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3641					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3642					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3643
  3644			001513		SN=SN+1
  3645			775777			ZZ=<ZZ+ZZ+1>&777777
  3646						IFE	<ZZ-1>,<ZZ=777776>
  3647	032125	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3648	032126	561 01 0 00 775777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3649	032127	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3650	032130	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3651	032131	312 03 0 00 034501 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3652						STOP^
  3653	032132	254 04 0 00 032133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3654	032133	324 00 0 00 032134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3655									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3656									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3657									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3658
  3659					;**********
  3660
  3661
  3662					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3663					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3664					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3665					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3666					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3667					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3668
  3669			001514		SN=SN+1
  3670			773777			ZZ=<ZZ+ZZ+1>&777777
  3671						IFE	<ZZ-1>,<ZZ=777776>
  3672	032134	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 11-6
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0083

  3673	032135	561 01 0 00 773777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3674	032136	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3675	032137	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3676	032140	312 03 0 00 034502 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3677						STOP^
  3678	032141	254 04 0 00 032142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3679	032142	324 00 0 00 032143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3680									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3681									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3682									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3683
  3684					;**********
  3685
  3686
  3687					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3688					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3689					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3690					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3691					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3692					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3693
  3694			001515		SN=SN+1
  3695			767777			ZZ=<ZZ+ZZ+1>&777777
  3696						IFE	<ZZ-1>,<ZZ=777776>
  3697	032143	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3698	032144	561 01 0 00 767777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3699	032145	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3700	032146	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3701	032147	312 03 0 00 034503 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3702						STOP^
  3703	032150	254 04 0 00 032151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3704	032151	324 00 0 00 032152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3705									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3706									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3707									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3708
  3709					;**********
  3710
  3711
  3712					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3713					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3714					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3715					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3716					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3717					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3718
  3719			001516		SN=SN+1
  3720			757777			ZZ=<ZZ+ZZ+1>&777777
  3721						IFE	<ZZ-1>,<ZZ=777776>
  3722	032152	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3723	032153	561 01 0 00 757777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3724	032154	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3725	032155	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3726	032156	312 03 0 00 034504 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3727						STOP^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 11-7
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0084

  3728	032157	254 04 0 00 032160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3729	032160	324 00 0 00 032161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3730									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3731									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3732									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3733
  3734					;**********
  3735
  3736
  3737					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3738					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3739					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3740					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3741					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3742					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3743
  3744			001517		SN=SN+1
  3745			737777			ZZ=<ZZ+ZZ+1>&777777
  3746						IFE	<ZZ-1>,<ZZ=777776>
  3747	032161	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3748	032162	561 01 0 00 737777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3749	032163	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3750	032164	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3751	032165	312 03 0 00 034505 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3752						STOP^
  3753	032166	254 04 0 00 032167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3754	032167	324 00 0 00 032170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3755									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3756									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3757									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3758
  3759					;**********
  3760
  3761
  3762					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3763					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3764					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3765					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3766					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3767					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3768
  3769			001520		SN=SN+1
  3770			677777			ZZ=<ZZ+ZZ+1>&777777
  3771						IFE	<ZZ-1>,<ZZ=777776>
  3772	032170	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3773	032171	561 01 0 00 677777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3774	032172	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3775	032173	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3776	032174	312 03 0 00 034506 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3777						STOP^
  3778	032175	254 04 0 00 032176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3779	032176	324 00 0 00 032177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3780									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3781									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3782									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 11-8
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0085

  3783
  3784					;**********
  3785
  3786
  3787					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3788					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3789					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3790					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3791					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3792					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3793
  3794			001521		SN=SN+1
  3795			577777			ZZ=<ZZ+ZZ+1>&777777
  3796						IFE	<ZZ-1>,<ZZ=777776>
  3797	032177	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3798	032200	561 01 0 00 577777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3799	032201	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3800	032202	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3801	032203	312 03 0 00 034507 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3802						STOP^
  3803	032204	254 04 0 00 032205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3804	032205	324 00 0 00 032206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3805									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3806									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3807									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3808
  3809					;**********
  3810
  3811
  3812					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3813					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3814					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3815					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3816					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3817					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3818
  3819			001522		SN=SN+1
  3820			377777			ZZ=<ZZ+ZZ+1>&777777
  3821						IFE	<ZZ-1>,<ZZ=777776>
  3822	032206	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3823	032207	561 01 0 00 377777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3824	032210	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3825	032211	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3826	032212	312 03 0 00 034510 		CAME	3,[-1,,ZZ]	;TEST INDEXING
  3827						STOP^
  3828	032213	254 04 0 00 032214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3829	032214	324 00 0 00 032215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3830									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3831									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3832									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3833
  3834					;**********
  3835
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 12
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0086

  3836			001600		SN=1600
  3837			000000			ZZ=0
  3838
  3839					C1600:	REPEAT	^D18,<
  3840					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3841					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3842					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3843					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3844					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3845					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3846
  3847					SN=SN+1
  3848						ZZ=<ZZ+ZZ+1>&777777
  3849						IFE	<ZZ-1>,<ZZ=777776>
  3850						SETZM	3		;PRELOAD AC3 WITH 0
  3851						HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3852						MOVEI	2,1		;SETUP INDEX REGISTER
  3853						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3854						CAME	3,[ZZ,,-1]	;TEST INDEXING
  3855						STOP
  3856
  3857					;**********
  3858					>
  3859
  3860					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3861					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3862					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3863					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3864					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3865					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3866
  3867			001601		SN=SN+1
  3868			000001			ZZ=<ZZ+ZZ+1>&777777
  3869			777776			IFE	<ZZ-1>,<ZZ=777776>
  3870	032215	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3871	032216	525 01 0 00 777776 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3872	032217	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3873	032220	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3874	032221	312 03 0 00 034511 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  3875						STOP^
  3876	032222	254 04 0 00 032223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3877	032223	324 00 0 00 032224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3878									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3879									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3880									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3881
  3882					;**********
  3883
  3884
  3885					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3886					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3887					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3888					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3889					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3890					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 12-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0087

  3891
  3892			001602		SN=SN+1
  3893			777775			ZZ=<ZZ+ZZ+1>&777777
  3894						IFE	<ZZ-1>,<ZZ=777776>
  3895	032224	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3896	032225	525 01 0 00 777775 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3897	032226	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3898	032227	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3899	032230	312 03 0 00 034512 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  3900						STOP^
  3901	032231	254 04 0 00 032232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3902	032232	324 00 0 00 032233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3903									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3904									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3905									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3906
  3907					;**********
  3908
  3909
  3910					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3911					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3912					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3913					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3914					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3915					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3916
  3917			001603		SN=SN+1
  3918			777773			ZZ=<ZZ+ZZ+1>&777777
  3919						IFE	<ZZ-1>,<ZZ=777776>
  3920	032233	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3921	032234	525 01 0 00 777773 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3922	032235	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3923	032236	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3924	032237	312 03 0 00 034513 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  3925						STOP^
  3926	032240	254 04 0 00 032241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3927	032241	324 00 0 00 032242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3928									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3929									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3930									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3931
  3932					;**********
  3933
  3934
  3935					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3936					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3937					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3938					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3939					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3940					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3941
  3942			001604		SN=SN+1
  3943			777767			ZZ=<ZZ+ZZ+1>&777777
  3944						IFE	<ZZ-1>,<ZZ=777776>
  3945	032242	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 12-2
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0088

  3946	032243	525 01 0 00 777767 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3947	032244	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3948	032245	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3949	032246	312 03 0 00 034514 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  3950						STOP^
  3951	032247	254 04 0 00 032250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3952	032250	324 00 0 00 032251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3953									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3954									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3955									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3956
  3957					;**********
  3958
  3959
  3960					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3961					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3962					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3963					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3964					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3965					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3966
  3967			001605		SN=SN+1
  3968			777757			ZZ=<ZZ+ZZ+1>&777777
  3969						IFE	<ZZ-1>,<ZZ=777776>
  3970	032251	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3971	032252	525 01 0 00 777757 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3972	032253	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3973	032254	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3974	032255	312 03 0 00 034515 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  3975						STOP^
  3976	032256	254 04 0 00 032257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3977	032257	324 00 0 00 032260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  3978									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  3979									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  3980									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  3981
  3982					;**********
  3983
  3984
  3985					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  3986					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  3987					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  3988					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  3989					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  3990					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  3991
  3992			001606		SN=SN+1
  3993			777737			ZZ=<ZZ+ZZ+1>&777777
  3994						IFE	<ZZ-1>,<ZZ=777776>
  3995	032260	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  3996	032261	525 01 0 00 777737 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  3997	032262	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  3998	032263	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  3999	032264	312 03 0 00 034516 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4000						STOP^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 12-3
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0089

  4001	032265	254 04 0 00 032266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4002	032266	324 00 0 00 032267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4003									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4004									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4005									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4006
  4007					;**********
  4008
  4009
  4010					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4011					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4012					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4013					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4014					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4015					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4016
  4017			001607		SN=SN+1
  4018			777677			ZZ=<ZZ+ZZ+1>&777777
  4019						IFE	<ZZ-1>,<ZZ=777776>
  4020	032267	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4021	032270	525 01 0 00 777677 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4022	032271	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4023	032272	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4024	032273	312 03 0 00 034517 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4025						STOP^
  4026	032274	254 04 0 00 032275 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4027	032275	324 00 0 00 032276 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4028									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4029									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4030									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4031
  4032					;**********
  4033
  4034
  4035					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4036					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4037					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4038					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4039					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4040					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4041
  4042			001610		SN=SN+1
  4043			777577			ZZ=<ZZ+ZZ+1>&777777
  4044						IFE	<ZZ-1>,<ZZ=777776>
  4045	032276	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4046	032277	525 01 0 00 777577 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4047	032300	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4048	032301	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4049	032302	312 03 0 00 034520 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4050						STOP^
  4051	032303	254 04 0 00 032304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4052	032304	324 00 0 00 032305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4053									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4054									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4055									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 12-4
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0090

  4056
  4057					;**********
  4058
  4059
  4060					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4061					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4062					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4063					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4064					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4065					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4066
  4067			001611		SN=SN+1
  4068			777377			ZZ=<ZZ+ZZ+1>&777777
  4069						IFE	<ZZ-1>,<ZZ=777776>
  4070	032305	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4071	032306	525 01 0 00 777377 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4072	032307	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4073	032310	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4074	032311	312 03 0 00 034521 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4075						STOP^
  4076	032312	254 04 0 00 032313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4077	032313	324 00 0 00 032314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4078									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4079									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4080									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4081
  4082					;**********
  4083
  4084
  4085					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4086					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4087					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4088					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4089					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4090					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4091
  4092			001612		SN=SN+1
  4093			776777			ZZ=<ZZ+ZZ+1>&777777
  4094						IFE	<ZZ-1>,<ZZ=777776>
  4095	032314	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4096	032315	525 01 0 00 776777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4097	032316	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4098	032317	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4099	032320	312 03 0 00 034522 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4100						STOP^
  4101	032321	254 04 0 00 032322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4102	032322	324 00 0 00 032323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4103									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4104									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4105									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4106
  4107					;**********
  4108
  4109
  4110					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 12-5
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0091

  4111					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4112					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4113					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4114					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4115					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4116
  4117			001613		SN=SN+1
  4118			775777			ZZ=<ZZ+ZZ+1>&777777
  4119						IFE	<ZZ-1>,<ZZ=777776>
  4120	032323	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4121	032324	525 01 0 00 775777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4122	032325	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4123	032326	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4124	032327	312 03 0 00 034523 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4125						STOP^
  4126	032330	254 04 0 00 032331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4127	032331	324 00 0 00 032332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4128									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4129									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4130									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4131
  4132					;**********
  4133
  4134
  4135					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4136					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4137					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4138					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4139					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4140					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4141
  4142			001614		SN=SN+1
  4143			773777			ZZ=<ZZ+ZZ+1>&777777
  4144						IFE	<ZZ-1>,<ZZ=777776>
  4145	032332	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4146	032333	525 01 0 00 773777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4147	032334	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4148	032335	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4149	032336	312 03 0 00 034524 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4150						STOP^
  4151	032337	254 04 0 00 032340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4152	032340	324 00 0 00 032341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4153									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4154									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4155									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4156
  4157					;**********
  4158
  4159
  4160					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4161					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4162					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4163					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4164					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4165					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 12-6
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0092

  4166
  4167			001615		SN=SN+1
  4168			767777			ZZ=<ZZ+ZZ+1>&777777
  4169						IFE	<ZZ-1>,<ZZ=777776>
  4170	032341	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4171	032342	525 01 0 00 767777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4172	032343	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4173	032344	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4174	032345	312 03 0 00 034525 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4175						STOP^
  4176	032346	254 04 0 00 032347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4177	032347	324 00 0 00 032350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4178									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4179									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4180									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4181
  4182					;**********
  4183
  4184
  4185					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4186					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4187					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4188					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4189					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4190					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4191
  4192			001616		SN=SN+1
  4193			757777			ZZ=<ZZ+ZZ+1>&777777
  4194						IFE	<ZZ-1>,<ZZ=777776>
  4195	032350	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4196	032351	525 01 0 00 757777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4197	032352	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4198	032353	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4199	032354	312 03 0 00 034526 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4200						STOP^
  4201	032355	254 04 0 00 032356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4202	032356	324 00 0 00 032357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4203									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4204									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4205									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4206
  4207					;**********
  4208
  4209
  4210					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4211					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4212					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4213					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4214					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4215					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4216
  4217			001617		SN=SN+1
  4218			737777			ZZ=<ZZ+ZZ+1>&777777
  4219						IFE	<ZZ-1>,<ZZ=777776>
  4220	032357	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 12-7
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0093

  4221	032360	525 01 0 00 737777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4222	032361	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4223	032362	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4224	032363	312 03 0 00 034527 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4225						STOP^
  4226	032364	254 04 0 00 032365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4227	032365	324 00 0 00 032366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4228									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4229									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4230									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4231
  4232					;**********
  4233
  4234
  4235					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4236					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4237					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4238					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4239					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4240					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4241
  4242			001620		SN=SN+1
  4243			677777			ZZ=<ZZ+ZZ+1>&777777
  4244						IFE	<ZZ-1>,<ZZ=777776>
  4245	032366	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4246	032367	525 01 0 00 677777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4247	032370	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4248	032371	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4249	032372	312 03 0 00 034530 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4250						STOP^
  4251	032373	254 04 0 00 032374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4252	032374	324 00 0 00 032375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4253									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4254									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4255									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4256
  4257					;**********
  4258
  4259
  4260					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4261					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4262					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4263					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4264					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4265					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4266
  4267			001621		SN=SN+1
  4268			577777			ZZ=<ZZ+ZZ+1>&777777
  4269						IFE	<ZZ-1>,<ZZ=777776>
  4270	032375	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4271	032376	525 01 0 00 577777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4272	032377	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4273	032400	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4274	032401	312 03 0 00 034531 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4275						STOP^
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 12-8
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0094

  4276	032402	254 04 0 00 032403 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4277	032403	324 00 0 00 032404 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4278									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4279									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4280									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4281
  4282					;**********
  4283
  4284
  4285					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4286					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
  4287					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
  4288					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
  4289					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
  4290					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
  4291
  4292			001622		SN=SN+1
  4293			377777			ZZ=<ZZ+ZZ+1>&777777
  4294						IFE	<ZZ-1>,<ZZ=777776>
  4295	032404	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
  4296	032405	525 01 0 00 377777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
  4297	032406	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
  4298	032407	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
  4299	032410	312 03 0 00 034532 		CAME	3,[ZZ,,-1]	;TEST INDEXING
  4300						STOP^
  4301	032411	254 04 0 00 032412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4302	032412	324 00 0 00 032413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4303									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4304									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4305									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4306
  4307					;**********
  4308
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 13
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0095

  4309					;VERIFY INDEXING WHERE 'E' IS NON-ZERO
  4310
  4311			001700		SN=1700
  4312		777777	777777			ZZ=-1
  4313		777777	777770			XX=-10
  4314
  4315					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4316					;IN THIS TEST, THE INDEX REG IS SET-UP WITH MOVEI ZZ+1,ZZ-XX,
  4317					;WHERE ZZ+1 IS THE INDEX REG.  THE AC IS PRELOADED WITH ITS OWN ADDRESS, 0,,ZZ.
  4318					;CAIE IS USED TO TEST THE INDEXING OPERATION.
  4319					;IF THE RESULT IN C(AC)=XX+C(ZZ+1 - RIGHT), THIS TEST PASSES.
  4320					;XX+C(ZZ+1 - RIGHT) SHOULD = ZZ.
  4321
  4322					C1700:	REPEAT	^D15,
  4323					<SN=SN+1
  4324						ZZ=ZZ+1
  4325						XX=XX+3
  4326						MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4327						MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4328						CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4329						STOP
  4330
  4331					;**********
  4332					>
  4333			001701		SN=SN+1
  4334			000000			ZZ=ZZ+1
  4335		777777	777773			XX=XX+3
  4336	032413	201 01 0 00 000005 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4337	032414	201 00 0 00 000000 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4338	032415	302 00 0 01 777773 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4339						STOP^
  4340	032416	254 04 0 00 032417 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4341	032417	324 00 0 00 032420 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4342									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4343									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4344									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4345
  4346					;**********
  4347
  4348			001702		SN=SN+1
  4349			000001			ZZ=ZZ+1
  4350		777777	777776			XX=XX+3
  4351	032420	201 02 0 00 000003 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4352	032421	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4353	032422	302 01 0 02 777776 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4354						STOP^
  4355	032423	254 04 0 00 032424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4356	032424	324 00 0 00 032425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4357									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4358									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4359									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4360
  4361					;**********
  4362
  4363			001703		SN=SN+1
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 13-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0096

  4364			000002			ZZ=ZZ+1
  4365			000001			XX=XX+3
  4366	032425	201 03 0 00 000001 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4367	032426	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4368	032427	302 02 0 03 000001 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4369						STOP^
  4370	032430	254 04 0 00 032431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4371	032431	324 00 0 00 032432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4372									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4373									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4374									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4375
  4376					;**********
  4377
  4378			001704		SN=SN+1
  4379			000003			ZZ=ZZ+1
  4380			000004			XX=XX+3
  4381	032432	201 04 0 00 777777 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4382	032433	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4383	032434	302 03 0 04 000004 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4384						STOP^
  4385	032435	254 04 0 00 032436 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4386	032436	324 00 0 00 032437 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4387									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4388									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4389									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4390
  4391					;**********
  4392
  4393			001705		SN=SN+1
  4394			000004			ZZ=ZZ+1
  4395			000007			XX=XX+3
  4396	032437	201 05 0 00 777775 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4397	032440	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4398	032441	302 04 0 05 000007 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4399						STOP^
  4400	032442	254 04 0 00 032443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4401	032443	324 00 0 00 032444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4402									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4403									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4404									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4405
  4406					;**********
  4407
  4408			001706		SN=SN+1
  4409			000005			ZZ=ZZ+1
  4410			000012			XX=XX+3
  4411	032444	201 06 0 00 777773 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4412	032445	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4413	032446	302 05 0 06 000012 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4414						STOP^
  4415	032447	254 04 0 00 032450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4416	032450	324 00 0 00 032451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4417									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4418									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 13-2
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0097

  4419									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4420
  4421					;**********
  4422
  4423			001707		SN=SN+1
  4424			000006			ZZ=ZZ+1
  4425			000015			XX=XX+3
  4426	032451	201 07 0 00 777771 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4427	032452	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4428	032453	302 06 0 07 000015 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4429						STOP^
  4430	032454	254 04 0 00 032455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4431	032455	324 00 0 00 032456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4432									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4433									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4434									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4435
  4436					;**********
  4437
  4438			001710		SN=SN+1
  4439			000007			ZZ=ZZ+1
  4440			000020			XX=XX+3
  4441	032456	201 10 0 00 777767 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4442	032457	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4443	032460	302 07 0 10 000020 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4444						STOP^
  4445	032461	254 04 0 00 032462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4446	032462	324 00 0 00 032463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4447									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4448									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4449									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4450
  4451					;**********
  4452
  4453			001711		SN=SN+1
  4454			000010			ZZ=ZZ+1
  4455			000023			XX=XX+3
  4456	032463	201 11 0 00 777765 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4457	032464	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4458	032465	302 10 0 11 000023 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4459						STOP^
  4460	032466	254 04 0 00 032467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4461	032467	324 00 0 00 032470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4462									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4463									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4464									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4465
  4466					;**********
  4467
  4468			001712		SN=SN+1
  4469			000011			ZZ=ZZ+1
  4470			000026			XX=XX+3
  4471	032470	201 12 0 00 777763 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4472	032471	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4473	032472	302 11 0 12 000026 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 13-3
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0098

  4474						STOP^
  4475	032473	254 04 0 00 032474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4476	032474	324 00 0 00 032475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4477									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4478									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4479									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4480
  4481					;**********
  4482
  4483			001713		SN=SN+1
  4484			000012			ZZ=ZZ+1
  4485			000031			XX=XX+3
  4486	032475	201 13 0 00 777761 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4487	032476	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4488	032477	302 12 0 13 000031 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4489						STOP^
  4490	032500	254 04 0 00 032501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4491	032501	324 00 0 00 032502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4492									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4493									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4494									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4495
  4496					;**********
  4497
  4498			001714		SN=SN+1
  4499			000013			ZZ=ZZ+1
  4500			000034			XX=XX+3
  4501	032502	201 14 0 00 777757 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4502	032503	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4503	032504	302 13 0 14 000034 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4504						STOP^
  4505	032505	254 04 0 00 032506 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4506	032506	324 00 0 00 032507 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4507									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4508									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4509									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4510
  4511					;**********
  4512
  4513			001715		SN=SN+1
  4514			000014			ZZ=ZZ+1
  4515			000037			XX=XX+3
  4516	032507	201 15 0 00 777755 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4517	032510	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4518	032511	302 14 0 15 000037 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4519						STOP^
  4520	032512	254 04 0 00 032513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4521	032513	324 00 0 00 032514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4522									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4523									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4524									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4525
  4526					;**********
  4527
  4528			001716		SN=SN+1
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 13-4
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0099

  4529			000015			ZZ=ZZ+1
  4530			000042			XX=XX+3
  4531	032514	201 16 0 00 777753 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4532	032515	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4533	032516	302 15 0 16 000042 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4534						STOP^
  4535	032517	254 04 0 00 032520 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4536	032520	324 00 0 00 032521 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4537									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4538									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4539									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4540
  4541					;**********
  4542
  4543			001717		SN=SN+1
  4544			000016			ZZ=ZZ+1
  4545			000045			XX=XX+3
  4546	032521	201 17 0 00 777751 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4547	032522	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
  4548	032523	302 16 0 17 000045 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4549						STOP^
  4550	032524	254 04 0 00 032525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4551	032525	324 00 0 00 032526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4552									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4553									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4554									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4555
  4556					;**********
  4557
  4558					PAGE
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 13-5
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0100

  4559			002000		SN=2000
  4560		777777	777777			ZZ=-1
  4561		777777	777760			XX=-20
  4562
  4563					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
  4564					;IN THIS TEST, THE INDEX REG IS SET-UP WITH MOVEI ZZ+1,ZZ-XX,
  4565					;WHERE ZZ+1 IS THE INDEX REG.  INDEXING IS TESTED BY LOADING
  4566					;THE AC VIA MOVEI ZZ,XX(ZZ+1), WHERE XX+C(ZZ+1)=ZZ.
  4567					;IF THE RESULT IN THE AC EQUALS 0,,ZZ, THIS TEST PASSES.
  4568
  4569					C2000:	REPEAT	^D15,
  4570					<SN=SN+1
  4571						ZZ=ZZ+1
  4572						XX=XX+5
  4573						MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4574						MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4575						CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4576						STOP
  4577
  4578					;**********
  4579					>
  4580			002001		SN=SN+1
  4581			000000			ZZ=ZZ+1
  4582		777777	777765			XX=XX+5
  4583	032526	201 01 0 00 000013 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4584	032527	201 00 0 01 777765 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4585	032530	302 00 0 00 000000 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4586						STOP^
  4587	032531	254 04 0 00 032532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4588	032532	324 00 0 00 032533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4589									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4590									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4591									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4592
  4593					;**********
  4594
  4595			002002		SN=SN+1
  4596			000001			ZZ=ZZ+1
  4597		777777	777772			XX=XX+5
  4598	032533	201 02 0 00 000007 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4599	032534	201 01 0 02 777772 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4600	032535	302 01 0 00 000001 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4601						STOP^
  4602	032536	254 04 0 00 032537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4603	032537	324 00 0 00 032540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4604									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4605									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4606									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4607
  4608					;**********
  4609
  4610			002003		SN=SN+1
  4611			000002			ZZ=ZZ+1
  4612		777777	777777			XX=XX+5
  4613	032540	201 03 0 00 000003 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 13-6
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0101

  4614	032541	201 02 0 03 777777 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4615	032542	302 02 0 00 000002 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4616						STOP^
  4617	032543	254 04 0 00 032544 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4618	032544	324 00 0 00 032545 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4619									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4620									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4621									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4622
  4623					;**********
  4624
  4625			002004		SN=SN+1
  4626			000003			ZZ=ZZ+1
  4627			000004			XX=XX+5
  4628	032545	201 04 0 00 777777 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4629	032546	201 03 0 04 000004 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4630	032547	302 03 0 00 000003 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4631						STOP^
  4632	032550	254 04 0 00 032551 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4633	032551	324 00 0 00 032552 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4634									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4635									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4636									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4637
  4638					;**********
  4639
  4640			002005		SN=SN+1
  4641			000004			ZZ=ZZ+1
  4642			000011			XX=XX+5
  4643	032552	201 05 0 00 777773 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4644	032553	201 04 0 05 000011 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4645	032554	302 04 0 00 000004 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4646						STOP^
  4647	032555	254 04 0 00 032556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4648	032556	324 00 0 00 032557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4649									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4650									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4651									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4652
  4653					;**********
  4654
  4655			002006		SN=SN+1
  4656			000005			ZZ=ZZ+1
  4657			000016			XX=XX+5
  4658	032557	201 06 0 00 777767 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4659	032560	201 05 0 06 000016 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4660	032561	302 05 0 00 000005 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4661						STOP^
  4662	032562	254 04 0 00 032563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4663	032563	324 00 0 00 032564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4664									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4665									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4666									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4667
  4668					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 13-7
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0102

  4669
  4670			002007		SN=SN+1
  4671			000006			ZZ=ZZ+1
  4672			000023			XX=XX+5
  4673	032564	201 07 0 00 777763 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4674	032565	201 06 0 07 000023 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4675	032566	302 06 0 00 000006 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4676						STOP^
  4677	032567	254 04 0 00 032570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4678	032570	324 00 0 00 032571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4679									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4680									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4681									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4682
  4683					;**********
  4684
  4685			002010		SN=SN+1
  4686			000007			ZZ=ZZ+1
  4687			000030			XX=XX+5
  4688	032571	201 10 0 00 777757 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4689	032572	201 07 0 10 000030 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4690	032573	302 07 0 00 000007 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4691						STOP^
  4692	032574	254 04 0 00 032575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4693	032575	324 00 0 00 032576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4694									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4695									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4696									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4697
  4698					;**********
  4699
  4700			002011		SN=SN+1
  4701			000010			ZZ=ZZ+1
  4702			000035			XX=XX+5
  4703	032576	201 11 0 00 777753 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4704	032577	201 10 0 11 000035 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4705	032600	302 10 0 00 000010 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4706						STOP^
  4707	032601	254 04 0 00 032602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4708	032602	324 00 0 00 032603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4709									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4710									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4711									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4712
  4713					;**********
  4714
  4715			002012		SN=SN+1
  4716			000011			ZZ=ZZ+1
  4717			000042			XX=XX+5
  4718	032603	201 12 0 00 777747 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4719	032604	201 11 0 12 000042 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4720	032605	302 11 0 00 000011 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4721						STOP^
  4722	032606	254 04 0 00 032607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4723	032607	324 00 0 00 032610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 13-8
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0103

  4724									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4725									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4726									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4727
  4728					;**********
  4729
  4730			002013		SN=SN+1
  4731			000012			ZZ=ZZ+1
  4732			000047			XX=XX+5
  4733	032610	201 13 0 00 777743 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4734	032611	201 12 0 13 000047 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4735	032612	302 12 0 00 000012 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4736						STOP^
  4737	032613	254 04 0 00 032614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4738	032614	324 00 0 00 032615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4739									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4740									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4741									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4742
  4743					;**********
  4744
  4745			002014		SN=SN+1
  4746			000013			ZZ=ZZ+1
  4747			000054			XX=XX+5
  4748	032615	201 14 0 00 777737 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4749	032616	201 13 0 14 000054 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4750	032617	302 13 0 00 000013 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4751						STOP^
  4752	032620	254 04 0 00 032621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4753	032621	324 00 0 00 032622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4754									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4755									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4756									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4757
  4758					;**********
  4759
  4760			002015		SN=SN+1
  4761			000014			ZZ=ZZ+1
  4762			000061			XX=XX+5
  4763	032622	201 15 0 00 777733 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4764	032623	201 14 0 15 000061 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4765	032624	302 14 0 00 000014 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4766						STOP^
  4767	032625	254 04 0 00 032626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4768	032626	324 00 0 00 032627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4769									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4770									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4771									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4772
  4773					;**********
  4774
  4775			002016		SN=SN+1
  4776			000015			ZZ=ZZ+1
  4777			000066			XX=XX+5
  4778	032627	201 16 0 00 777727 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 13-9
DAKADM	MAC	19-JAN-77 13:41		TEST OF INDEX REGISTER ADDRESSING                                                  SEQ 0104

  4779	032630	201 15 0 16 000066 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4780	032631	302 15 0 00 000015 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4781						STOP^
  4782	032632	254 04 0 00 032633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4783	032633	324 00 0 00 032634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4784									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4785									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4786									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4787
  4788					;**********
  4789
  4790			002017		SN=SN+1
  4791			000016			ZZ=ZZ+1
  4792			000073			XX=XX+5
  4793	032634	201 17 0 00 777723 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
  4794	032635	201 16 0 17 000073 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
  4795	032636	302 16 0 00 000016 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
  4796						STOP^
  4797	032637	254 04 0 00 032640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4798	032640	324 00 0 00 032641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4799									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4800									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4801									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4802
  4803					;**********
  4804
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 14
DAKADM	MAC	19-JAN-77 13:41		TEST OF EXCH INSTRUCTION                                                           SEQ 0105

  4805					SUBTTL	TEST OF EXCH INSTRUCTION
  4806
  4807					;**********
  4808
  4809					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
  4810					;MOVES C(AC) INTO E.
  4811					;IN THIS CASE, AC=E=0 AND C(AC)=C(E).  HENCE, THE FINAL RESULT
  4812					;IN AC0 SHOULD BE 0.  IF C(AC)=0, THE TEST PASSES.
  4813
  4814	032641	400 00 0 00 000000 	C2100:	SETZ			;PRELOAD AC,E WITH 0
  4815	032642	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 0 INTO AC0
  4816	032643	332 00 0 00 000000 		SKIPE			;PASS IF C(AC0)=0
  4817						STOP^
  4818	032644	254 04 0 00 032645 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4819	032645	324 00 0 00 032646 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4820									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4821									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4822									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4823
  4824					;**********
  4825
  4826					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
  4827					;MOVES C(AC) INTO E.
  4828					;IN THIS CASE, AC=E=-1,,-1 AND C(AC)=C(E).  HENCE, THE FINAL RESULT
  4829					;IN AC0 SHOULD BE -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
  4830
  4831	032646	474 00 0 00 000000 	C2200:	SETO			;PRELOAD AC,E WITH -1,,-1
  4832	032647	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE -1,,-1 INTO AC0
  4833	032650	312 00 0 00 034466 		CAME	[-1]		;PASS IF C(AC0)=-1,,-1
  4834						STOP^
  4835	032651	254 04 0 00 032652 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4836	032652	324 00 0 00 032653 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4837									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4838									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4839									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4840
  4841					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 15
DAKADM	MAC	19-JAN-77 13:41		TEST OF EXCH INSTRUCTION                                                           SEQ 0106

  4842					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
  4843					;MOVES C(AC) INTO E.
  4844					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0,,-1.  HENCE, THE FINAL RESULT
  4845					;IN THE AC SHOULD BE 0,,-1 AND THE RESULT IN E SHOULD BE -1,,0,
  4846					;IF THESE RESULTS OCCUR, THE TEST PASSES.
  4847
  4848	032653	205 00 0 00 777777 	C2400:	MOVSI	-1		;PRELOAD AC WITH -1,,0
  4849	032654	201 01 0 00 777777 		MOVEI	1,-1		;PRELOAD E WITH 0,,-1
  4850	032655	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD PLACE 0,,-1 INTO THE AC AND -1,,0 INTO E
  4851	032656	312 01 0 00 034533 		CAME	1,[-1,,0]	;PASS IF C(E)=-1,,0
  4852						STOP^
  4853	032657	254 04 0 00 032660 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4854	032660	324 00 0 00 032661 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4855									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4856									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4857									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4858	032661	312 00 0 00 034534 	C2410:	CAME	0,[0,,-1]	;PASS IF C(AC)=0,,-1
  4859						STOP^
  4860	032662	254 04 0 00 032663 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4861	032663	324 00 0 00 032664 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4862									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4863									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4864									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4865
  4866					;**********
  4867
  4868					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
  4869					;MOVES C(AC) INTO E.
  4870					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,0.  HENCE, THE FINAL RESULT
  4871					;IN THE AC SHOULD BE -1,,0 AND THE RESULT IN E SHOULD BE 0,,-1.
  4872					;IF THESE RESULTS OCCUR, THE TEST PASSES.
  4873
  4874	032664	201 00 0 00 777777 	C2700:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
  4875	032665	205 01 0 00 777777 		MOVSI	1,-1		;PRELOAD E WITH -1,,0
  4876	032666	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD PLACE -1,,0 INTO THE AC AND 0,,-1 INTO E
  4877	032667	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
  4878						STOP^
  4879	032670	254 04 0 00 032671 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4880	032671	324 00 0 00 032672 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4881									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4882									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4883									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4884	032672	312 00 0 00 034533 	C2710:	CAME	,[XWD -1,0]	;PASS IF C(AC)=-1,,0
  4885						STOP^
  4886	032673	254 04 0 00 032674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4887	032674	324 00 0 00 032675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4888									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4889									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4890									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4891
  4892					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 16
DAKADM	MAC	19-JAN-77 13:41		TEST OF EXCH INSTRUCTION                                                           SEQ 0107

  4893					;THIS TEST IS A RELIABILITY CHECK OF EXCH.
  4894					;FIRST, AC, E ARE PRELOADED WITH 252525,,252525.  THERE, EXCH IS
  4895					;EXECUTED 7 TIMES.  THE AC IS THEN CHECKED FOR 252525,,252525.
  4896					;IF C(AC)=C(E)=252525,,252525, THIS TEST PASSES.
  4897					;IN THIS TEST AC=E=AC0
  4898
  4899	032675	200 00 0 00 034535 	C3000:	MOVE	[252525252525]	;PRELOAD AC,E WITH 252525,,252525
  4900						REPEAT	7,
  4901					<	EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0>
  4902	032676	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
  4903	032677	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
  4904	032700	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
  4905	032701	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
  4906	032702	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
  4907	032703	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
  4908	032704	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
  4909	032705	312 00 0 00 034535 		CAME	[252525252525]	;PASS IF C(AC0)=252525,,252525
  4910						STOP^
  4911	032706	254 04 0 00 032707 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4912	032707	324 00 0 00 032710 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4913									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4914									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4915									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4916
  4917					;**********
  4918					PAGE
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 16-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF EXCH INSTRUCTION                                                           SEQ 0108

  4919					;THIS TEST VERIFIES THAT EXCH MOVES C(AC) INTO E AND C(E) INTO THE AC.
  4920					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  EXCH IS EXECUTED 7 TIMES; THEN,
  4921					;THE AC IS CHECKED FOR -1,,-1 AND E IS CHECKED FOR 0.  IF EITHER OF THESE
  4922					;RESULTS ARE NOT FOUND, THIS TEST FAILS.
  4923
  4924	032710	400 00 0 00 000000 	C3100:	SETZ			;PRELOAD AC WITH 0
  4925	032711	474 01 0 00 000000 		SETO	1,0		;PRELOAD E WITH -1,,-1
  4926						REPEAT	7,
  4927					<	EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)>
  4928	032712	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
  4929	032713	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
  4930	032714	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
  4931	032715	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
  4932	032716	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
  4933	032717	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
  4934	032720	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
  4935	032721	312 00 0 00 034466 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
  4936						STOP^
  4937	032722	254 04 0 00 032723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4938	032723	324 00 0 00 032724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4939									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4940									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4941									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4942	032724	312 01 0 00 034536 	C3110:	CAME	1,[0]		;PASS IF C(E)=0
  4943						STOP^
  4944	032725	254 04 0 00 032726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4945	032726	324 00 0 00 032727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4946									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4947									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4948									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4949
  4950					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 17
DAKADM	MAC	19-JAN-77 13:41		TEST OF MOVEM INSTRUCTION                                                          SEQ 0109

  4951					SUBTTL	TEST OF MOVEM INSTRUCTION
  4952
  4953					;THIS TEST VERIFIES THAT MOVEM PLACES C(AC) INTO E AND DOES NOT MODIFY C(AC)
  4954					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN AC AND E SHOULD
  4955					;BE -1,,-1.  IF C(AC) AND C(E)=-1,,-1, THIS TEST PASSES
  4956
  4957	032727	474 00 0 00 000000 	C3200:	SETO			;PRELOAD AC WITH -1,,-1
  4958	032730	400 01 0 00 000000 		SETZ	1,0		;PRELOAD E WITH 0
  4959	032731	202 00 0 00 000001 		MOVEM	1		;*MOVEM SHOULD PLACE -1,,-1 INTO E
  4960	032732	312 01 0 00 034466 		CAME	1,[-1]		;PASS IF C(E)=-1,,-1
  4961						STOP^
  4962	032733	254 04 0 00 032734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4963	032734	324 00 0 00 032735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4964									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4965									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4966									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4967	032735	312 00 0 00 034466 	C3210:	CAME	0,[-1]		;PASS IF C(AC)=-1,,-1
  4968						STOP^
  4969	032736	254 04 0 00 032737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4970	032737	324 00 0 00 032740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4971									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4972									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4973									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4974
  4975					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 18
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0110

  4976					SUBTTL	TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS
  4977
  4978					;**********
  4979
  4980					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION
  4981					;IF JFCL SKIPS THE NEXT INSTRUCTION, THIS TEST FAILS
  4982
  4983	032740	200 00 0 00 034537 	C3300:	MOVE	[HALT .+3]	;THIS INSTRUCTION SHOULD NOT AFFECT THE TEST
  4984	032741	255 17 0 00 032742 		JFCL	17,.+1		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
  4985	032742	304 00 0 00 000000 		CAIA			;SKIP HALT INSTRUCTION IF JFCL PASSES
  4986						STOP^
  4987	032743	254 04 0 00 032744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4988	032744	324 00 0 00 032745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  4989									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  4990									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  4991									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  4992
  4993					;**********
  4994
  4995					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE CRY0 FLAG.
  4996					;ADDI IS USED TO SET CRY0.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR CRY0.
  4997					;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER CRY0 WAS RESET BY THE PREVIOUS JFCL.
  4998					;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR CRY0
  4999
  5000	032745	200 00 0 00 034466 	C3400:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
  5001	032746	271 00 0 00 000001 		ADDI	1		;SET CRY0 FLAG
  5002	032747	255 17 0 00 032750 		JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
  5003	032750	255 04 0 00 032752 		JFCL	4,.+2		;PASS IF CRY0 WAS RESET BY PREVIOUS INSTRUCTION
  5004	032751	334 00 0 00 000000 		SKIPA			;SKIP HALT IF CRY0 WAS CLEARED
  5005						STOP^
  5006	032752	254 04 0 00 032753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5007	032753	324 00 0 00 032754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5008									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5009									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5010									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5011
  5012					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 19
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0111

  5013					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE CRY1 FLAG.
  5014					;ADDI IS USED TO SET CRY1.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR CRY1.
  5015					;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER CRY1 WAS RESET BY THE PREVIOUS JFCL.
  5016					;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR CRY1
  5017
  5018	032754	200 00 0 00 034466 	C3500:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
  5019	032755	271 00 0 00 000001 		ADDI	1		;SET CRY1 FLAG
  5020	032756	255 17 0 00 032757 		JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
  5021	032757	255 02 0 00 032761 		JFCL	2,.+2		;PASS IF CRY1 WAS RESET BY PREVIOUS INSTRUCTION
  5022	032760	334 00 0 00 000000 		SKIPA			;SKIP HALT IF CRY1 WAS CLEARED
  5023						STOP^
  5024	032761	254 04 0 00 032762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5025	032762	324 00 0 00 032763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5026									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5027									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5028									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5029
  5030					;**********
  5031
  5032					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE AROV FLAG.
  5033					;ADDI IS USED TO SET AROV.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR AROV.
  5034					;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER AROV WAS RESET BY THE PREVIOUS JFCL.
  5035					;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR AROV
  5036
  5037	032763	205 00 0 00 400000 	C3600:	MOVSI	400000		;PRELOAD AC WITH -1,,-1
  5038	032764	270 00 0 00 034465 		ADD	[XWD 400000,0]	;SET AROV FLAG
  5039	032765	255 17 0 00 032766 		JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
  5040	032766	255 10 0 00 032770 		JFCL	10,.+2		;PASS IF AROV WAS RESET BY PREVIOUS INSTRUCTION
  5041	032767	334 00 0 00 000000 		SKIPA			;SKIP HALT IF AROV WAS CLEARED
  5042						STOP^
  5043	032770	254 04 0 00 032771 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5044	032771	324 00 0 00 032772 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5045									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5046									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5047									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5048
  5049					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 20
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0112

  5050					;THIS TEST VERIFIES THAT JFCL 0, IS A NO-OP.
  5051					;IN THIS TEST, ADD IS USED TO SET CRY0.  THEN JFCL 0,.+2 IS EXECUTED.
  5052					;IF JFCL 0,.+2 DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
  5053
  5054	032772	205 00 0 00 400000 	C3700:	MOVSI	400000		;PRELOAD AC WITH MOST NEGATIVE NUMBER
  5055	032773	270 00 0 00 034466 		ADD	[-1]		;SET CRY0 FLAG
  5056	032774	255 00 0 00 032776 		JFCL	.+2		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
  5057	032775	334 00 0 00 000000 		SKIPA			;PASS IF JFCL DID NOT SKIP
  5058						STOP^
  5059	032776	254 04 0 00 032777 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5060	032777	324 00 0 00 033000 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5061									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5062									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5063									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5064
  5065					;**********
  5066
  5067					;THIS TEST VERIFIES THAT JFCL 0, IS A NO-OP.
  5068					;IN THIS TEST, ADD IS USED TO SET CRY1.  THEN JFCL 0,.+2 IS EXECUTED.
  5069					;IF JFCL 0,.+2 DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
  5070
  5071	033000	205 00 0 00 200000 	C4000:	MOVSI	200000		;PRELOAD AC WITH MOST NEGATIVE NUMBER
  5072	033001	270 00 0 00 034464 		ADD	[XWD 200000,0]	;SET CRY1 FLAG
  5073	033002	255 00 0 00 033004 		JFCL	.+2		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
  5074	033003	334 00 0 00 000000 		SKIPA			;PASS IF JFCL DID NOT SKIP
  5075						STOP^
  5076	033004	254 04 0 00 033005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5077	033005	324 00 0 00 033006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5078									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5079									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5080									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5081
  5082					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 21
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0113

  5083					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
  5084					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
  5085					;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN, JFCL SHOULD SKIP
  5086					;BECAUSE A FLAG WAS SET BY ADDI
  5087					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
  5088					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
  5089
  5090	033006	200 00 0 00 034466 	C4100:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
  5091	033007	271 00 0 00 000001 		ADDI	1		;*ADDI SHOULD SET CRY0/1 FLAGS
  5092	033010	255 17 0 00 033012 		JFCL	17,.+2		;*JFCL SHOULD JUMP BECAUSE FLAGS ARE SET
  5093						STOP^
  5094	033011	254 04 0 00 033012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5095	033012	324 00 0 00 033013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5096									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5097									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5098									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5099
  5100					;**********
  5101
  5102					;THIS TEST VERIFIES THAT CAI DOES NOT CLEAR ANY ARITHMETIC FLAGS.
  5103					;FIRST, CRY0 AND CRY1 ARE SET BY ADDI; THEN CAI IS EXECUTED.
  5104					;JFCL SHOULD JUMP BECAUSE FLAGS ARE SET.  IF JFCL DOES NOT JUMP,
  5105					;THE FLAGS WERE CLEARED BY CAI.  HENCE, CAI FAILED
  5106
  5107	033013	200 00 0 00 034466 	C4200:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
  5108	033014	271 00 0 00 000001 		ADDI	1		;SET CYR0/1 FLAGS
  5109	033015	300 17 0 00 000017 		CAI	17,17		;*CAI SHOULD NOT CLEAR FLAGS
  5110	033016	255 17 0 00 033020 		JFCL	17,.+2		;PASS IF CAI CLEARED FLAGS
  5111						STOP^
  5112	033017	254 04 0 00 033020 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5113	033020	324 00 0 00 033021 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5114									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5115									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5116									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5117
  5118					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 22
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0114

  5119					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
  5120					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
  5121					;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN JFCL SHOULD SKIP
  5122					;BECAUSE A FLAG WAS SET BY ADDI
  5123					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
  5124					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
  5125
  5126	033021	200 00 0 00 034466 	C4300:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
  5127	033022	271 00 0 00 000001 		ADDI	1		;*ADDI SHOULD SET CRY1 FLAGS
  5128	033023	255 02 0 00 033025 		JFCL	2,.+2		;*JFCL SHOULD JUMP BECAUSE CRY1 FLAG IS SET
  5129						STOP^
  5130	033024	254 04 0 00 033025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5131	033025	324 00 0 00 033026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5132									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5133									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5134									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5135
  5136					;**********
  5137
  5138					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
  5139					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
  5140					;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN, JFCL SHOULD SKIP
  5141					;BECAUSE A FLAG WAS SET BY ADDI
  5142					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
  5143					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
  5144
  5145	033026	200 00 0 00 034466 	C4400:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
  5146	033027	271 00 0 00 000001 		ADDI	1		;*ADDI SHOULD SET CRY0 FLAG
  5147	033030	255 04 0 00 033032 		JFCL	4,.+2		;*JFCL SHOULD JUMP BECAUSE CRY0 FLAG IS SET
  5148						STOP^
  5149	033031	254 04 0 00 033032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5150	033032	324 00 0 00 033033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5151									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5152									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5153									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5154
  5155					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 23
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0115

  5156					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
  5157					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
  5158					;BECAUSE A FLAG WAS SET BY ADD
  5159					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
  5160					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
  5161
  5162	033033	205 00 0 00 400000 	C4500:	MOVSI	400000		;PRELOAD AC WITH ALL ONES
  5163	033034	270 00 0 00 034465 		ADD	[XWD 400000,0]	;*ADD SHOULD SET AROV FLAG
  5164	033035	255 10 0 00 033037 		JFCL	10,.+2		;*JFCL SHOULD JUMP BECAUSE AROV FLAG IS SET
  5165						STOP^
  5166	033036	254 04 0 00 033037 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5167	033037	324 00 0 00 033040 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5168									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5169									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5170									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5171
  5172					;**********
  5173
  5174					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE FLOATING OVERFLOW FLAG (FOV).
  5175					;FIRST JFCL 17,.+1 IS EXECUTED TO CLEAR FOV.  THEN, JFCL 1,.+2 IS EXECUTED TO DETERMINE
  5176					;WHETHER FOV WAS CLEARED.  IF FOV WAS CLEAR, THIS TEST PASSES
  5177
  5178	033040	255 17 0 00 033041 	C4600:	JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
  5179	033041	255 01 0 00 033043 		JFCL	1,.+2		;PASS IF FOV WAS CLEARED
  5180	033042	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TEST PASSED
  5181						STOP^
  5182	033043	254 04 0 00 033044 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5183	033044	324 00 0 00 033045 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5184									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5185									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5186									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5187
  5188					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 24
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0116

  5189					;THIS TEST VERIFIES THAT JFCL 13, DOES NOT RESET CRY0.
  5190					;FIRST CRY0 AND CRY1 ARE SET BY ADDI; THEN, JFCL 13,.+2 IS EXECUTED
  5191					;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT CRY0.
  5192					;THIS TEST PASSES IF JFCL 13,.+1 DID NOT RESET CRY0.
  5193
  5194	033045	200 00 0 00 034466 	C4700:	MOVE	[-1]		;RELOAD AC WITH -1,,-1
  5195	033046	271 00 0 00 000001 		ADDI	1		;SET CRY0/1
  5196	033047	255 13 0 00 033050 		JFCL	13,.+1		;*JFCL 13, SHOULD NOT RESET CRY0
  5197	033050	255 04 0 00 033052 		JFCL	4,.+2		;FAIL IF CRY 0 WAS RESET
  5198						STOP^
  5199	033051	254 04 0 00 033052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5200	033052	324 00 0 00 033053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5201									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5202									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5203									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5204
  5205					;**********
  5206
  5207					;THIS TEST VERIFIES THAT JFCL 15, DOES NOT RESET CRY1.
  5208					;FIRST CRY0 AND CRY1 ARE SET BY ADDI; THEN, JFCL15,.+2 IS EXECUTED
  5209					;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT CRY1.
  5210					;THIS TEST PASSES IF JFCL 15,.+1 DID NOT RESET CRY1.
  5211
  5212	033053	200 00 0 00 034466 	C5000:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
  5213	033054	271 00 0 00 000001 		ADDI	1		;SET CRY0/1
  5214	033055	255 15 0 00 033056 		JFCL	15,.+1		;*JFCL15, SHOULD NOT RESET CRY0
  5215	033056	255 02 0 00 033060 		JFCL	2,.+2		;FAIL IF CRY1 WAS RESET
  5216						STOP^
  5217	033057	254 04 0 00 033060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5218	033060	324 00 0 00 033061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5219									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5220									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5221									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5222
  5223					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 25
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0117

  5224					;THIS TEST VERIFIES THAT JFCL 17, DOES NOT RESET AROV.
  5225					;FIRST AROV IS SET BY ADD; THEN, JFCL 17,.+2 IS EXECUTED
  5226					;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT AROV.
  5227					;THIS TEST PASSES IF JFCL 17,.+1 DID NOT RESET AROV.
  5228
  5229	033061	205 00 0 00 400000 	C5100:	MOVSI	400000		;PRELOAD AC WITH -1,,-1
  5230	033062	270 00 0 00 034465 		ADD	[XWD 400000,0]	;SET AROV
  5231	033063	255 07 0 00 033064 		JFCL	7,.+1		;*JFCL 17, SHOULD NOT RESET AROV
  5232	033064	255 10 0 00 033066 		JFCL	10,.+2		;FAIL IF AROV WAS RESET
  5233						STOP^
  5234	033065	254 04 0 00 033066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5235	033066	324 00 0 00 033067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5236									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5237									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5238									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5239
  5240					;**********
  5241
  5242					;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET AROV.
  5243					;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
  5244					;AROV IS THEN CHECKED.  IF AROV IS SET, THIS TEST FAILS.
  5245
  5246	033067	255 17 0 00 033070 	C5200:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
  5247	033070	400 00 0 00 000000 		SETZ			;PRELOAD AC,E WITH 0
  5248	033071	270 00 0 00 000000 		ADD			;*ADD SHOULD NOT SET AROV
  5249	033072	255 10 0 00 033074 		JFCL	10,.+2		;PASS IF AROV WAS RESET
  5250	033073	334 00 0 00 000000 		SKIPA			;SKIP HALT IF ADD PASSED
  5251						STOP^
  5252	033074	254 04 0 00 033075 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5253	033075	324 00 0 00 033076 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5254									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5255									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5256									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5257
  5258					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 26
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0118

  5259					;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET CRY0.
  5260					;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
  5261					;CRY0 IS THEN CHECKED.  IF CRY0 IS SET, THIS TEST FAILS.
  5262
  5263
  5264	033076	400 00 0 00 000000 	C5300:	SETZ			;RESET ARITHMETIC FLAGS
  5265	033077	255 17 0 00 033100 		JFCL	17,.+1		;PRELOAD AC,E WITH 0
  5266	033100	270 00 0 00 000000 		ADD			;*ADD SHOULD NOT SET CRY0
  5267	033101	255 04 0 00 033103 		JFCL	4,.+2		;PASS IF CRY0 WAS RESET
  5268	033102	334 00 0 00 000000 		SKIPA			;SKIP HALT IF ADD PASSED
  5269						STOP^
  5270	033103	254 04 0 00 033104 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5271	033104	324 00 0 00 033105 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5272									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5273									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5274									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5275
  5276					;**********
  5277
  5278					;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET CRY1.
  5279					;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
  5280					;CRY1 IS THEN CHECKED.  IF CRY1 IS SET, THIS TEST FAILS.
  5281
  5282	033105	400 00 0 00 000000 	C5400:	SETZ			;RESET ARITHMETIC FLAGS
  5283	033106	255 17 0 00 033107 		JFCL	17,.+1		;PRELOAD AC,E WITH 0
  5284	033107	270 00 0 00 000000 		ADD			;*ADD SHOULD NOT SET CRY1
  5285	033110	255 02 0 00 033112 		JFCL	2,.+2		;PASS IF CRY1 WAS RESET
  5286	033111	334 00 0 00 000000 		SKIPA			;SKIP HALT IF ADD PASSED
  5287						STOP^
  5288	033112	254 04 0 00 033113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5289	033113	324 00 0 00 033114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5290									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5291									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5292									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5293
  5294					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 27
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0119

  5295					;THIS TEST VERIFIES THAT THE 30X AND THE 31X INSTRUCTION GROUPS DO NOT AFFECT
  5296					;THE ARITHMETIC FLAGS.  FIRST, THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, CAI
  5297					;AND CAM ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
  5298					;THIS TEST FAILS AND CAI OR CAM IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS
  5299
  5300	033114	255 17 0 00 033115 	C5500:	JFCL	17,.+1		;CLEAR ALL FLAGS
  5301	033115	400 00 0 00 000000 		SETZ			;CLEAR AC,0
  5302	033116	300 00 0 00 000000 		CAI			;*CAI SHOULD NOT SET ANY ARITHMETIC FLAG
  5303	033117	310 00 0 00 034466 		CAM	[-1]		;*CAM SHOULD NOT SET ANY ARITHMETIC FLAG
  5304	033120	255 17 0 00 033122 		JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
  5305	033121	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TEST PASSED
  5306						STOP^
  5307	033122	254 04 0 00 033123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5308	033123	324 00 0 00 033124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5309									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5310									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5311									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5312
  5313					;**********
  5314
  5315					;THIS TEST VERIFIES THAT THE BOOLEAN INSTRUCTION GROUPS DO NOT AFFECT
  5316					;THE ARITHMETIC FLAGS.  FIRST THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, XOR [0]
  5317					;AND XOR [-1] ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
  5318					;THIS TEST FAILS AND XOR IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS
  5319
  5320	033124	255 17 0 00 033125 	C5600:	JFCL	17,.+1		;CLEAR ALL FLAGS
  5321	033125	474 00 0 00 000000 		SETO			;CLEAR AC,0
  5322	033126	430 00 0 00 034536 		XOR	[0]		;*XOR SHOULD NOT SET ANY ARITHMETIC FLAG
  5323	033127	430 00 0 00 034466 		XOR	[-1]		;*XOR SHOULD NOT SET ANY ARITHMETIC FLAG
  5324	033130	255 17 0 00 033132 		JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
  5325	033131	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TEST PASSED
  5326						STOP^
  5327	033132	254 04 0 00 033133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5328	033133	324 00 0 00 033134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5329									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5330									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5331									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5332
  5333					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 28
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0120

  5334					;THIS TEST VERIFIES THAT THE AOBJX INSTRUCTION GROUP DOES DO NOT AFFECT
  5335					;THE ARITHMETIC FLAGS.  FIRST THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, AOBJN
  5336					;AND AOBJP ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
  5337					;THIS TEST FAILS AND AOBJN OR AOBJP IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS
  5338
  5339	033134	474 00 0 00 000000 	C5700:	SETO			;CLEAR ALL FLAGS
  5340	033135	255 17 0 00 033136 		JFCL	17,.+1		;CLEAR AC,0
  5341	033136	253 00 0 00 033137 		AOBJN	.+1		;*AOBJN SHOULD NOT SET ANY ARITHMETIC ARITHMETIC
  5342	033137	252 00 0 00 033140 		AOBJP	.+1		;*AOBJP SHOULD NOT SET ANY ARITHMETIC FLAG
  5343	033140	255 17 0 00 033142 		JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
  5344	033141	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TST PASSED
  5345						STOP^
  5346	033142	254 04 0 00 033143 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5347	033143	324 00 0 00 033144 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5348									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5349									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5350									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5351
  5352					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 29
DAKADM	MAC	19-JAN-77 13:41		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0121

  5353					;THIS TEST VERIFIES THAT SKIP DOES NOT AFFECT THE FLAGS.
  5354					;FIRST, THE ARITHMETIC FLAGS ARE CLEARED; THEN, SKIP IS EXECUTED.
  5355					;IF SKIP SETS AROV, CRYO, CRY1 OR FOV, THIS TEST FAILS.
  5356
  5357	033144	255 17 0 00 033145 	C5701:	JFCL	17,.+1		;CLEAR ALL FLAGS
  5358	033145	330 00 0 00 034466 		SKIP	0,[-1]		;*SKIP SHOULD NOT SET ANY FLAGS
  5359	033146	255 17 0 00 033150 		JFCL	17,.+2		;FAIL IF ANY FLAG IS SET
  5360	033147	334 00 0 00 000000 		SKIPA			;PASS IF NO FLAG IS SET
  5361						STOP^
  5362	033150	254 04 0 00 033151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5363	033151	324 00 0 00 033152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5364									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5365									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5366									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5367
  5368					;**********
  5369
  5370					;THIS TEST VERIFIES THAT JUMP DOES NOT AFFECT THE FLAGS.
  5371					;FIRST, THE ARITHMETIC FLAGS ARE CLEARED; THEN, JUMP IS EXECUTED.
  5372					;IF JUMP SETS AROV, CRYO, CRY1 OR FOV, THIS TEST FAILS.
  5373
  5374	033152	255 17 0 00 033153 	C5702:	JFCL	17,.+1		;CLEAR ALL FLAGS
  5375	033153	320 00 0 00 034466 		JUMP	0,[-1]		;*JUMP SHOULD NOT SET ANY FLAGS
  5376	033154	255 17 0 00 033156 		JFCL	17,.+2		;FAIL IF ANY FLAG IS SET
  5377	033155	334 00 0 00 000000 		SKIPA			;PASS IF NO FLAG IS SET
  5378						STOP^
  5379	033156	254 04 0 00 033157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5380	033157	324 00 0 00 033160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5381									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5382									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5383									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5384
  5385					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 30
DAKADM	MAC	19-JAN-77 13:41		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0122

  5386					SUBTTL	TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS
  5387
  5388					;**********
  5389
  5390					;THIS TEST VERIFIES THAT 'JRST, 0' DOES NOT SET ANY FLAGS.
  5391					;FIRST THE ARITHMETIC FLAGS ARE RESET; THEN, 'JRST 0,.+1' IS EXECUTED
  5392					;THE AROV,CRY0 AND CRY1 FLAGS ARE THEN CHECKED. IF ANY
  5393					;OF THESE FLAGS ARE SET, THIS TEST FAILS
  5394
  5395	033160	255 17 0 00 033161 	C6000:	JFCL	17,.+1		;RESET ALL FLAGS
  5396	033161	254 00 0 00 033162 		JRST	.+1		;*JRST SHOULD NOT SET ANY FLAGS
  5397	033162	255 16 0 00 033164 		JFCL	16,.+2		;PASS IF NO FLAGS ARE SET
  5398	033163	334 00 0 00 000000 		SKIPA			;SKIP HALT IF JRST PASSES
  5399						STOP^
  5400	033164	254 04 0 00 033165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5401	033165	324 00 0 00 033166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5402									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5403									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5404									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5405
  5406					;**********
  5407
  5408					;THIS TEST VERIFIES THAT 'MOVE 2,2' DOES NOT SET ANY FLAGS.
  5409					;FIRST, THE ARITHMETIC FLAGS ARE RESET; THEN, 'MOVE 2,2' IS EXECUTED.
  5410					;THE FOV,AROV,CRY0 AND CRY1 FLAGS ARE THEN CHECKED.  IF ANY
  5411					;OF THESE FLAGS ARE SET, THIS TEST FAILS
  5412
  5413	033166	255 17 0 00 033167 	C6100:	JFCL	17,.+1		;RESET ALL FLAGS
  5414	033167	200 02 0 00 000002 		MOVE	2,2		;*MOVE SHOULD NOT SET ANY FLAGS
  5415	033170	255 17 0 00 033172 		JFCL	17,.+2		;PASS IF NO FLAGS ARE SET
  5416	033171	334 00 0 00 000000 		SKIPA			;SKIP HALT IF MOVE PASSED
  5417						STOP^
  5418	033172	254 04 0 00 033173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5419	033173	324 00 0 00 033174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5420									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5421									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5422									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5423
  5424					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 31
DAKADM	MAC	19-JAN-77 13:41		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0123

  5425					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
  5426					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE CRY0 FLAG.
  5427					;FIRST, ALL FLAGS ARE RESET; THEN AC1 IS SET TO SPECIFY CRY0.
  5428					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET CRY0.  CRY0 IS THEN CHECKED.  IF
  5429					;CRY0 IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
  5430
  5431	033174	255 17 0 00 033175 	C6200:	JFCL	17,.+1		;CLEAR ALL FLAGS
  5432						SFLAG	CRY0		^;SET CRY0 FLAG
  5433
  5434	033175	205 01 0 00 200000 		MOVSI	1,CRY0
  5435	033176	255 17 0 00 033177 		JFCL	17,.+1		;RESET ALL FLAGS
  5436	033177	254 02 0 01 033200 		JRST	2,.+1(1)	;SET CRY0 FLAG
  5437	033200	255 04 0 00 033202 		JFCL	4,.+2		;PASS IF CRY0 IS SET
  5438						STOP^
  5439	033201	254 04 0 00 033202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5440	033202	324 00 0 00 033203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5441									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5442									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5443									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5444
  5445					;**********
  5446
  5447					;THIS TEST VERIFIES THAT JRST 2,.+(1) WILL SET THE ARITHMETIC FLAG
  5448					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAIN 0.  HENCE, JRST 2,.+1(1)
  5449					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0/1, FLAGS ARE SET BY ADDI;
  5450					;THEN THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.  IF CRY1 WAS CLEARED, THE
  5451					;TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
  5452
  5453	033203	200 00 0 00 034466 	C6300:	MOVE	[-1]		;PRELOAD AC0 WITH -1,,-1
  5454	033204	271 00 0 00 000001 		ADDI	1		;SET CRY0/1 FLAGS
  5455						SFLAG	0		^;RESET ALL ARITHMETIC FLAGS
  5456
  5457	033205	205 01 0 00 000000 		MOVSI	1,0
  5458	033206	255 17 0 00 033207 		JFCL	17,.+1		;RESET ALL FLAGS
  5459	033207	254 02 0 01 033210 		JRST	2,.+1(1)	;SET 0 FLAG
  5460	033210	255 02 0 00 033212 		JFCL	2,.+2		;PASS IF CRY1 IS RESET
  5461	033211	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
  5462						STOP^
  5463	033212	254 04 0 00 033213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5464	033213	324 00 0 00 033214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5465									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5466									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5467									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5468
  5469					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 32
DAKADM	MAC	19-JAN-77 13:41		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0124

  5470
  5471					;THIS TEST VERIFIES THAT JRST 2,.+(1) WILL SET THE ARITHMETIC FLAG
  5472					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAIN 0.  HENCE, JRST 2,.+1(1)
  5473					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0/1, FLAGS ARE SET BY ADD
  5474					;THEN THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.  IF AROV WAS CLEARED, THE
  5475					;TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
  5476
  5477	033214	205 00 0 00 400000 	C6400:	MOVSI	400000		;PRELOAD AC0 WITH -1,,-1
  5478	033215	270 00 0 00 034466 		ADD	[-1]		;SET CRY0 AND AROV FLAGS
  5479						SFLAG	0		^;RESET ALL ARITHMETIC FLAGS
  5480
  5481	033216	205 01 0 00 000000 		MOVSI	1,0
  5482	033217	255 17 0 00 033220 		JFCL	17,.+1		;RESET ALL FLAGS
  5483	033220	254 02 0 01 033221 		JRST	2,.+1(1)	;SET 0 FLAG
  5484	033221	255 10 0 00 033223 		JFCL	10,.+2		;PASS IF AROV IS RESET
  5485	033222	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
  5486						STOP^
  5487	033223	254 04 0 00 033224 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5488	033224	324 00 0 00 033225 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5489									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5490									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5491									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5492
  5493					;**********
  5494
  5495					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
  5496					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE AROV FLAG.
  5497					;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY AROV.
  5498					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET AROV.  AROV IS THEN CHECKED.  IF
  5499					;AROV IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
  5500
  5501	033225				C6500:	SFLAG	AROV		^;SET AROV FLAG
  5502
  5503	033225	205 01 0 00 400000 		MOVSI	1,AROV
  5504	033226	255 17 0 00 033227 		JFCL	17,.+1		;RESET ALL FLAGS
  5505	033227	254 02 0 01 033230 		JRST	2,.+1(1)	;SET AROV FLAG
  5506	033230	255 10 0 00 033232 		JFCL	10,.+2		;PASS IF AROV WAS SET
  5507						STOP^
  5508	033231	254 04 0 00 033232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5509	033232	324 00 0 00 033233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5510									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5511									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5512									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5513
  5514					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 33
DAKADM	MAC	19-JAN-77 13:41		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0125

  5515					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
  5516					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE CRY1 FLAG.
  5517					;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY CRY1.
  5518					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET CRY1.  CRY1 IS THEN CHECKED.  IF
  5519					;CRY1 IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
  5520
  5521	033233				C6600:	SFLAG	CRY1		^;SET CRY1 FLAG
  5522
  5523	033233	205 01 0 00 100000 		MOVSI	1,CRY1
  5524	033234	255 17 0 00 033235 		JFCL	17,.+1		;RESET ALL FLAGS
  5525	033235	254 02 0 01 033236 		JRST	2,.+1(1)	;SET CRY1 FLAG
  5526	033236	255 02 0 00 033240 		JFCL	2,.+2		;PASS IF CRY1 WAS SET
  5527						STOP^
  5528	033237	254 04 0 00 033240 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5529	033240	324 00 0 00 033241 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5530									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5531									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5532									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5533
  5534					;**********
  5535
  5536					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
  5537					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE FOV FLAG.
  5538					;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY FOV.
  5539					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET FOV.  FOV IS THEN CHECKED.  IF
  5540					;FOV IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
  5541
  5542	033241				C6700:	SFLAG	FOV		^;SET FOV FLAG
  5543
  5544	033241	205 01 0 00 040000 		MOVSI	1,FOV
  5545	033242	255 17 0 00 033243 		JFCL	17,.+1		;RESET ALL FLAGS
  5546	033243	254 02 0 01 033244 		JRST	2,.+1(1)	;SET FOV FLAG
  5547	033244	255 01 0 00 033246 		JFCL	1,.+2		;PASS IF FOV WAS SET
  5548						STOP^
  5549	033245	254 04 0 00 033246 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5550	033246	324 00 0 00 033247 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5551									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5552									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5553									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5554
  5555					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 34
DAKADM	MAC	19-JAN-77 13:41		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0126

  5556					;THIS TEST VERIFIES THAT JFCL 0, SHOULD NEVER JUMP.
  5557					;FIRST, FOV IS SET VIA JRST2, ;THEN JFCL 0,
  5558					;IS EXECUTED.  IF JFCL 0, DOES NOT SKIP, THIS TEST PASSES
  5559
  5560	033247				C7000:	SFLAG	FOV		^;SET FOV FLAG
  5561
  5562	033247	205 01 0 00 040000 		MOVSI	1,FOV
  5563	033250	255 17 0 00 033251 		JFCL	17,.+1		;RESET ALL FLAGS
  5564	033251	254 02 0 01 033252 		JRST	2,.+1(1)	;SET FOV FLAG
  5565	033252	255 00 0 00 033254 		JFCL	,.+2		;*JFCL SHOULD NOT JUMP
  5566	033253	334 00 0 00 000000 		SKIPA			;PASS IF JFCL DID NOT JUMP
  5567						STOP^
  5568	033254	254 04 0 00 033255 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5569	033255	324 00 0 00 033256 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5570									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5571									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5572									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5573
  5574					;**********
  5575
  5576					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
  5577					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
  5578					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0, FLAG IS SET BY JRST 2,.+1(1)
  5579					;WITH C(AC1)=CRY0.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1 WITH C(AC1)=0.
  5580					;IF CRY0 WAS CLEARED, THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
  5581
  5582	033256				C7100:	SFLAG	CRY0		^;SET CRY0 FLAGS
  5583
  5584	033256	205 01 0 00 200000 		MOVSI	1,CRY0
  5585	033257	255 17 0 00 033260 		JFCL	17,.+1		;RESET ALL FLAGS
  5586	033260	254 02 0 01 033261 		JRST	2,.+1(1)	;SET CRY0 FLAG
  5587	033261	400 01 0 00 000000 		SETZ	1,		;SETUP MASK TO CLEAR ARITHMETIC FLAGS
  5588	033262	254 02 0 01 033263 		JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
  5589	033263	255 04 0 00 033265 		JFCL	4,.+2		;PASS IF CRY0 FLAG WAS RESET
  5590	033264	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PSSED
  5591						STOP^
  5592	033265	254 04 0 00 033266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5593	033266	324 00 0 00 033267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5594									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5595									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5596									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5597
  5598					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 35
DAKADM	MAC	19-JAN-77 13:41		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS                                      SEQ 0127

  5599					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
  5600					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
  5601					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE FOV, FLAG IS SET BY JRST 2,.+1(1)
  5602					;WITH C(AC1)=FOV.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1 WITH C(AC1)=0.
  5603					;IF FOV WAS CLEARED, THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
  5604
  5605	033267				C7200:	SFLAG	FOV		^;SET FOV FLAG
  5606
  5607	033267	205 01 0 00 040000 		MOVSI	1,FOV
  5608	033270	255 17 0 00 033271 		JFCL	17,.+1		;RESET ALL FLAGS
  5609	033271	254 02 0 01 033272 		JRST	2,.+1(1)	;SET FOV FLAG
  5610	033272	400 01 0 00 000000 		SETZ	1,		;SETUP MASK TO CLEAR ARITHMETIC FLAGS,
  5611	033273	254 02 0 01 033274 		JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
  5612	033274	255 01 0 00 033276 		JFCL	1,.+2		;PASS IF FOV FLAG WAS RESET
  5613	033275	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PSSED
  5614						STOP^
  5615	033276	254 04 0 00 033277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5616	033277	324 00 0 00 033300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5617									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5618									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5619									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5620
  5621					;**********
  5622
  5623					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
  5624					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
  5625					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE ARITHMETIC FLAGS ARE RESET BY
  5626					;JFCL 17,.+1.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.
  5627					;IF ALL THE ARITHMETIC FLAGS WERE CLEARED,
  5628					;THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
  5629
  5630	033300	255 17 0 00 033301 	C7300:	JFCL	17,.+1		;CLEAR FLAGS
  5631	033301	400 01 0 00 000000 		SETZ	1,		;SETUP MASK TO CLEAR ARITMETIC FLAGS
  5632	033302	254 02 0 01 033303 		JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
  5633	033303	255 17 0 00 033305 		JFCL	17,.+2		;PASS IF ALL FLAGS ARE RESET
  5634	033304	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
  5635						STOP^
  5636	033305	254 04 0 00 033306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5637	033306	324 00 0 00 033307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5638									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5639									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5640									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5641
  5642					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 36
DAKADM	MAC	19-JAN-77 13:41		TEST OF JSP INSTRUCTION                                                            SEQ 0128

  5643					SUBTTL	TEST OF JSP INSTRUCTION
  5644
  5645					;**********
  5646
  5647					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS AND PC IN THE AC.
  5648					;IN THIS CASE, THE FLAGS ARE RESET; THEN, JSP IS EXECUTED.  THE AC IS THEN
  5649					;CHECKED FOR ITS CONTENTS NON-ZERO.  IF C(AC)=0, IT INDICATES
  5650					;THAT NEITHER THE FLAGS NOR THE PC WAS SAVED.  HENCE, THIS TEST FAILS.
  5651
  5652	033307	403 00 0 00 000001 	C7400:	SETZB	1		;CLEAR AC AND SETUP MASK TO RESET FLAGS
  5653	033310	254 02 0 01 033311 		JRST	2,.+1(1)	;RESET FLAGS
  5654	033311	265 00 0 00 033312 		JSP	.+1		;*JSP SHOULD STORE FLAGS AND PC IN THE AC
  5655	033312	336 00 0 00 000000 		SKIPN			;PASS IF C(AC) IS NON-ZERO
  5656						STOP			^;IT DID NOT STORE ANY FLAGS OR PC
  5657
  5658	033313	254 04 0 00 033314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5659	033314	324 00 0 00 033315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5660									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5661									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5662									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1
  5663
  5664					;**********
  5665
  5666					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE PC IN THE RIGHT HALF OF THE AC.
  5667					;IN THIS CASE, THE AC IS CLEARED, THEN, JSP IS EXECUTED.  THE RIGHT HALF OF
  5668					;THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO.  IF C(AC RIGHT HALF)
  5669					;IS NON-ZERO, IT INDICATED THAT THE PC WAS SAVED; AND THIS TEST PASSES.
  5670
  5671	033315	400 00 0 00 000000 	C7500:	SETZ			;CLEAN AC
  5672	033316	265 00 0 00 033317 		JSP	.+1		;*JSP SHOULD STORE THE PC IN THE AC
  5673	033317	606 00 0 00 777777 		TRNN	-1		;PASS IF C(AC) IN NON-ZERO
  5674						STOP^
  5675	033320	254 04 0 00 033321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5676	033321	324 00 0 00 033322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5677									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5678									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5679									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5680
  5681					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 37
DAKADM	MAC	19-JAN-77 13:41		TEST OF JSP INSTRUCTION                                                            SEQ 0129

  5682					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
  5683					;FIST, THE AC IS CLEARED; THEN, SOME FLAGS ARE SET AND JSP IS EXECUTED.
  5684					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
  5685					;WHETHER THE FLAGS WERE SAVED.  IF C(AC-LEFT) IS NON-ZERO, THIS TEST PASSES
  5686
  5687	033322	402 00 0 00 000000 	C7600:	SETZM	0		;CLEAR AC
  5688	033323	205 01 0 00 740000 		MOVSI	1,740000	;SET UP MASK TO SET FLAGS
  5689	033324	254 02 0 01 033325 		JRST	2,.+1(1)	;SET SOME ARITHMETIC FLAGS
  5690	033325	265 00 0 00 033326 		JSP	.+1		;*JSP SHOULD STORE FLAGS IN THE AC
  5691	033326	607 00 0 00 777777 		TLNN	-1		;PASS IF C(AC) IS NON-ZERO
  5692						STOP^
  5693	033327	254 04 0 00 033330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5694	033330	324 00 0 00 033331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5695									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5696									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5697									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5698
  5699					;**********
  5700
  5701					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
  5702					;FIRST, THE AC IS CLEARED; THEN, THE AROV FLAG IS SET AND JSP IS EXECUTED.
  5703					;THEN, THE AROV FLAG BIT OF
  5704					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
  5705					;WHETHER THE AROV FLAG WAS SAVED.  IF THE AROV FLAG BIT OF THE AC IS SET, THIS TEST PASSES
  5706
  5707	033331	402 00 0 00 000000 	C7700:	SETZM	0		;CLEAR THE AC
  5708						SFLAG	AROV		^;SET AROV FLAG
  5709
  5710	033332	205 01 0 00 400000 		MOVSI	1,AROV
  5711	033333	255 17 0 00 033334 		JFCL	17,.+1		;RESET ALL FLAGS
  5712	033334	254 02 0 01 033335 		JRST	2,.+1(1)	;SET AROV FLAG
  5713	033335	265 00 0 00 033336 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
  5714	033336	607 00 0 00 400000 		TLNN	AROV		;PASS IF AROV WAS SAVED
  5715						STOP^
  5716	033337	254 04 0 00 033340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5717	033340	324 00 0 00 033341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5718									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5719									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5720									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5721
  5722					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 38
DAKADM	MAC	19-JAN-77 13:41		TEST OF JSP INSTRUCTION                                                            SEQ 0130

  5723					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
  5724					;FIRST, THE AC IS CLEARED; THEN, THE CRY0 FLAG IS SET AND JSP IS EXECUTED.
  5725					;THEN, THE CRY0 FLAG BIT OF
  5726					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
  5727					;WHETHER THE CRY0 FLAG WAS SAVED.  IF THE CRY0 FLAG BIT OF THE AC IS SET, THIS TEST PASSES
  5728
  5729	033341	402 00 0 00 000000 	C10000:	SETZM	0		;CLEAR THE AC
  5730						SFLAG	CRY0		^;SET CRY0 FLAG
  5731
  5732	033342	205 01 0 00 200000 		MOVSI	1,CRY0
  5733	033343	255 17 0 00 033344 		JFCL	17,.+1		;RESET ALL FLAGS
  5734	033344	254 02 0 01 033345 		JRST	2,.+1(1)	;SET CRY0 FLAG
  5735	033345	265 00 0 00 033346 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
  5736	033346	607 00 0 00 200000 		TLNN	CRY0		;PASS IF CRY0 WAS SAVED
  5737						STOP^
  5738	033347	254 04 0 00 033350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5739	033350	324 00 0 00 033351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5740									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5741									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5742									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5743
  5744					;**********
  5745
  5746					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
  5747					;FIRST, THE AC IS CLEARED; THEN, THE CRY1 FLAG IS SET AND JSP IS EXECUTED.
  5748					;THEN, THE CRY1 FLAG BIT OF
  5749					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
  5750					;WHETHER THE FLAG WAS SAVED.  IF THE CRY1 FLAG BIT OF THE AC IS SET, THIS TEST PASSES
  5751
  5752	033351	400 00 0 00 000000 	C10100:	SETZ			;CLEAR AC
  5753						SFLAG	CRY1		^;SET CRY1 FLAG
  5754
  5755	033352	205 01 0 00 100000 		MOVSI	1,CRY1
  5756	033353	255 17 0 00 033354 		JFCL	17,.+1		;RESET ALL FLAGS
  5757	033354	254 02 0 01 033355 		JRST	2,.+1(1)	;SET CRY1 FLAG
  5758	033355	265 00 0 00 033356 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
  5759	033356	607 00 0 00 100000 		TLNN	CRY1		;PASS IF AROV WAS SAVED
  5760						STOP^
  5761	033357	254 04 0 00 033360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5762	033360	324 00 0 00 033361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5763									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5764									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5765									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5766
  5767					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 39
DAKADM	MAC	19-JAN-77 13:41		TEST OF JSP INSTRUCTION                                                            SEQ 0131

  5768					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
  5769					;FRIST, THE AC IS CLEARED; THEN, THE FOV FLAG IS SET AND JSP IS EXECUTED.
  5770					;THEN, THE FOV FLAG BIT OF THE LEFT HALF OF THE AC IS CHECKED FOR
  5771					;ITS CONTENTS NON-ZERO TO DETERMINE WHETHER THE FOV FLAG WAS SAVED.
  5772					;IF THE FOV FLAG BIT OF THE AC IS SET, THIS TEST PASSES
  5773
  5774	033361	400 00 0 00 000000 	C10200:	SETZ			;CLEAR THE AC
  5775						SFLAG	FOV		^;SET FOV FLAG
  5776
  5777	033362	205 01 0 00 040000 		MOVSI	1,FOV
  5778	033363	255 17 0 00 033364 		JFCL	17,.+1		;RESET ALL FLAGS
  5779	033364	254 02 0 01 033365 		JRST	2,.+1(1)	;SET FOV FLAG
  5780	033365	265 00 0 00 033366 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
  5781	033366	607 00 0 00 040000 		TLNN	FOV		;PASS IF FOV WAS SAVED
  5782						STOP^
  5783	033367	254 04 0 00 033370 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5784	033370	324 00 0 00 033371 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5785									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5786									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5787									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5788
  5789					;**********
  5790
  5791					;THIS TEST VERIFIES THAT JSP WILL STORE ONLY FLAGS THAT EXIST.
  5792					;I.E. RESET FLAGS WILL NOT BE SET IN THE AC.  ONLY FLAGS THAT ARE
  5793					;CLEARABLE BY JRSTF WILL BE CHECKED HERE.  FIRST ALL CLEARABLE
  5794					;FLAGS ARE RESET BY JRSTF;  THEN JSP IS EXECUTED.  THE AC IS THEN CHECKED.
  5795					;IF ANY CLEARABLE FLAGS ARE SET IN THE AC, THIS TEST FAILS.
  5796
  5797	033371				C10300:	SFLAG	0		^;CLEAR ALL CLEARABLE FLAGS
  5798
  5799	033371	205 01 0 00 000000 		MOVSI	1,0
  5800	033372	255 17 0 00 033373 		JFCL	17,.+1		;RESET ALL FLAGS
  5801	033373	254 02 0 01 033374 		JRST	2,.+1(1)	;SET 0 FLAG
  5802	033374	265 00 0 00 033375 		JSP	.+1		;*JSP SHOULD NOT STORE CLEARABLE FALGS
  5803	033375	603 00 0 00 761777 		TLNE	761777		;FAIL IF ANY CLEARABLE FLAG IS SET
  5804						STOP^
  5805	033376	254 04 0 00 033377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5806	033377	324 00 0 00 033400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5807									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5808									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5809									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5810
  5811					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 40
DAKADM	MAC	19-JAN-77 13:41		TEST OF JSP INSTRUCTION                                                            SEQ 0132

  5812					;THIS TEST VERIFIES THAT JSP ALWAYS JUMPS.
  5813					;IN THIS TEST, JSP .+2 IS EXECUTED.  IF JSP JUMPS, THE TEST PASSES;
  5814					;OTHERWISE, THIS TEST HALTS
  5815
  5816	033400	265 00 0 00 033402 	C10400:	JSP	.+2		;*JSP SHOULD ALWAYS JUMP
  5817						STOP^
  5818	033401	254 04 0 00 033402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5819	033402	324 00 0 00 033403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5820									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5821									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5822									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5823
  5824					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 41
DAKADM	MAC	19-JAN-77 13:41		TEST JRST INSTRUCTION                                                              SEQ 0133

  5825					SUBTTL	TEST JRST INSTRUCTION
  5826
  5827					;**********
  5828
  5829					;THIS TEST VERIFIES THAT JRST ALWAYS JUMPS.
  5830					;IN THIS TEST, JRST .+2 IS EXECUTED.  IF JRST JUMPS, THE TEST PASSES;
  5831					;OTHERWISE, THIS TEST HALTS
  5832
  5833	033403	254 00 0 00 033405 	C10500:	JRST	.+2		;*JRST 0, SHOULD ALWAYS JUMP
  5834						STOP^
  5835	033404	254 04 0 00 033405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5836	033405	324 00 0 00 033406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5837									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5838									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5839									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5840
  5841					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 42
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOBJX INSTRUCTIONS                                                         SEQ 0134

  5842					SUBTTL	TEST OF AOBJX INSTRUCTIONS
  5843
  5844					;**********
  5845
  5846					;THIS TEST VERIFIES THAT AOBJN ALWAYS ADDS 1 TO BOTH HALVES OF THE AC.
  5847					;FIRST, THE AC IS CLEARED; THEN, AOBJN IS EXECUTED AND THE AC IS CHECKED
  5848					;FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
  5849
  5850	033406	400 00 0 00 000000 	C11200:	SETZ			;CLEAR THE AC
  5851	033407	253 00 0 00 033410 		AOBJN	.+1		;*AOBJN SHOULD ADD 1 TO BOTH HALVES OF THE AC
  5852	033410	312 00 0 00 034442 		CAME	[XWD 1,1]	;PASS IF C(AC)=1,,1
  5853						STOP^
  5854	033411	254 04 0 00 033412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5855	033412	324 00 0 00 033413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5856									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5857									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5858									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5859
  5860					;**********
  5861
  5862					;THIS TEST VERIFIES THAT AOBJP ALWAYS ADDS 1 TO BOTH HALVES OF THE AC.
  5863					;FIRST, THE AC IS CLEARED; THEN AOBJP IS EXECUTED AND THE AC IS CHECKED
  5864					;FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
  5865
  5866	033413	200 00 0 00 034540 	C11300:	MOVE	[XWD 377777,377777]	;PRELOAD AC WITH 377777,,377777
  5867	033414	252 00 0 00 033415 		AOBJP	.+1			;*AOBJP SHOULD ADD, TO BOTH HALVES OF THE AC
  5868	033415	312 00 0 00 034541 		CAME	[XWD 400000,400000]	;PASS IF C(AC)=400000,400000
  5869						STOP^
  5870	033416	254 04 0 00 033417 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5871	033417	324 00 0 00 033420 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5872									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5873									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5874									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5875
  5876					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 43
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOBJX INSTRUCTIONS                                                         SEQ 0135

  5877					;THIS TEST VERIFIES THAT AOBJN WILL NOT JUMP WHEN C(AC) IS POSITIVE
  5878					;FIRST, THE AC IS CLEARED; AND AOBJN IS EXECUTED.  AOBJN SHOULD NOT JUMP
  5879					;BECAUSE C(AC) IS POSITIVE.  IF AOBJN JUMPS, THIS TEST FAILS
  5880
  5881	033420	400 00 0 00 000000 	C11400:	SETZ			;CLEAR THE AC
  5882	033421	253 00 0 00 033423 		AOBJN	.+2		;*AOBJN SHOULD NOT JUMP WHEN C(AC) IS POSITIVE
  5883	033422	334 00 0 00 000000 		SKIPA			;PASS IF AOBJN DOES NOT JUMP
  5884						STOP^
  5885	033423	254 04 0 00 033424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5886	033424	324 00 0 00 033425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5887									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5888									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5889									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5890
  5891					;**********
  5892
  5893					;THIS TEST VERIFIES THAT AOBJP WILL JUMP WHEN C(AC) IS POSITIVE
  5894					;FIRST, THE AC IS CLEARED; AND AOBJP IS EXECUTED.  AOBJP SHOULD JUMP
  5895					;BECAUSE C(AC) IS POSITIVE.  IF AOBJP DOES NOT JUMP, THIS TEST FAILS
  5896
  5897	033425	400 00 0 00 000000 	C11500:	SETZ			;CLEAR THE AC
  5898	033426	252 00 0 00 033430 		AOBJP 	.+2		;*AOBJP SHOULD JUMP BECAUSE C(AC) IS POSITIVE
  5899						STOP^
  5900	033427	254 04 0 00 033430 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5901	033430	324 00 0 00 033431 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5902									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5903									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5904									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5905
  5906					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 44
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOBJX INSTRUCTIONS                                                         SEQ 0136

  5907					;THIS TEST VERIFIES THAT AOBJN WILL JUMP WHEN C(AC) IS NEGATIVE
  5908					;FIRST, THE AC IS PRELOADED WITH 400000,,0; AND AOBJN IS EXECUTED.  AOBJN SHOULD JUMP
  5909					;BECAUSE C(AC) IS NEGATIVE.  IF AOBJN DOES NOT JUMP, THIS TEST FAILS
  5910
  5911	033431	200 00 0 00 034541 	C11600:	MOVE	[XWD 400000,400000]	;PRELOAD AC WITH 400000,,400000
  5912	033432	253 00 0 00 033434 		AOBJN	.+2		;*AOBJN SHOULD JUMP BECAUSE C(AC) IS NEGATIVE
  5913						STOP^
  5914	033433	254 04 0 00 033434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5915	033434	324 00 0 00 033435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5916									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5917									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5918									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5919
  5920					;**********
  5921
  5922					;THIS TEST VERIFIES THAT AOBJP WILL NOT JUMP WHEN C(AC) IS NEGATIVE.  FIRST,
  5923					;THE AC IS PRELOADED WITH 400000,,0; AND AOBJP IS EXECUTED.  AOBJP SHOULD NOT JUMP
  5924					;BECAUSE C(AC) IS NEGATIVE.  IF AOBJP JUMPS, THIS TEST FAILS
  5925
  5926	033435	200 00 0 00 034541 	C11700:	MOVE	[XWD 400000,400000]	;PRELOAD AC WITH 400000,,400000
  5927	033436	252 00 0 00 033440 		AOBJP	.+2		;*AOBJP SHOULD NOT JUMP BECAUSE C(AC) IS NEGATIVE
  5928	033437	334 00 0 00 000000 		SKIPA			;PASS IF AOBJP DOES NOT JUMP
  5929						STOP^
  5930	033440	254 04 0 00 033441 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5931	033441	324 00 0 00 033442 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5932									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5933									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5934									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5935
  5936					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 45
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOBJX INSTRUCTIONS                                                         SEQ 0137

  5937					;THIS TEST VERIFIES THAT THERE IS A CARRY FROM BIT 18 TO BIT 17 OF THE AC ON AOBJN.
  5938					;THE AC IS PRELOADED WITH -1,,-1; THEN AOBJN IS EXECUTED. AOBJN SHOULD ADD ONE
  5939					;TO BOTH HALVES OF THE AC, GENERATING A CARRY FROM BIT 18 TO BIT 17. IF A
  5940					;CARRY WAS GENERATED, THIS TEST PASSES
  5941
  5942	033442	474 00 0 00 000000 	C12000:	SETO			;PRELOAD AC WITH -1,, -1
  5943	033443	253 00 0 00 033444 		AOBJN	.+1		;*AOBJN SHOULD GENERATE A CARRY FROM BIT 18 TO 17
  5944	033444	312 00 0 00 034444 		CAME	[1,,0]		;PASS IF C(AC)=1,,0 (CARRY WAS GENERATED)
  5945						STOP^
  5946	033445	254 04 0 00 033446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5947	033446	324 00 0 00 033447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5948									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5949									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5950									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5951
  5952					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 46
DAKADM	MAC	19-JAN-77 13:41		TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX                               SEQ 0138

  5953					SUBTTL	TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX
  5954
  5955					;THIS TEST VERIFIES THAT MOVNI SETS CRY0 AND CRY1 FLAGS ONLY WHEN THE DATA IS 0.
  5956					;FIRST, THE ARITHMETIC FLAGS ARE RESET; THEN, MOVNI IS EXECUTED WITH DATA OF ZEROS.
  5957					;THE ARITHMETIC FLAGS ARE CHECKED.
  5958					; CRY0/1 ARE SET AND AROV AND FOV RESET, THIS TEST PASSES.
  5959
  5960	033447	255 17 0 00 033450 	C12100:	JFCL	17,.+1		;CLEAR FLAGS
  5961	033450	211 00 0 00 000000 		MOVNI	0		;* MOVNI 0 SHOULD SET CRY0/1
  5962	033451	255 04 0 00 033453 		JCRY0	.+2		;PASS IF CRY0 IS SET
  5963						STOP^
  5964	033452	254 04 0 00 033453 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5965	033453	324 00 0 00 033454 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5966									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5967									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5968									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5969	033454	255 02 0 00 033456 		JCRY1	.+2		;PASS IF CRY1 IS SET
  5970						STOP^
  5971	033455	254 04 0 00 033456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5972	033456	324 00 0 00 033457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5973									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5974									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5975									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5976	033457	255 10 0 00 033461 		JOV	.+2		;PASS IF AROV RESET
  5977	033460	334 00 0 00 000000 		SKIPA
  5978						STOP^
  5979	033461	254 04 0 00 033462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5980	033462	324 00 0 00 033463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5981									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5982									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5983									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5984	033463	255 01 0 00 033465 		JFOV	.+2		;PASS IF FOV RESET
  5985	033464	334 00 0 00 000000 		SKIPA
  5986						STOP^
  5987	033465	254 04 0 00 033466 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5988	033466	324 00 0 00 033467 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  5989									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  5990									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  5991									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  5992
  5993					;**********
  5994
  5995					;THIS TEST VERIFIES THAT MOVN WILL NOT SET ARITHMETIC FLAGS WHEN THE DATA IS -1,,-1.
  5996					;FIRST, THE FLAGS ARE RESET; THEN, MOVN [-1,,-1] IS EXECUTED.
  5997					;THE ARITHMETIC FLAGS ARE CHECKED.
  5998					;IF ANY ARITHMETIC FLAG IS SET, THIS TEST FAILS.
  5999
  6000	033467	255 17 0 00 033470 	C12200:	JFCL	17,.+1		;CLEAR FLAGS
  6001	033470	210 00 0 00 034466 		MOVN	[-1]		;*MOVN [-1,,-1] SHOULD SET ARITHMETIC FLAGS
  6002	033471	255 17 0 00 033473 		JFCL	17,.+2		;FAIL IF AN ARITHMETIC FLAG IS SET
  6003	033472	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF MOVN PASSED.
  6004						STOP^
  6005	033473	254 04 0 00 033474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6006	033474	324 00 0 00 033475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6007									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 46-1
DAKADM	MAC	19-JAN-77 13:41		TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX                               SEQ 0139

  6008									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6009									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6010
  6011					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 47
DAKADM	MAC	19-JAN-77 13:41		TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX                               SEQ 0140

  6012					;THIS TEST VERIFIES THAT MOVN WILL SET THE AROV AND
  6013					;CRY1 FLAGS ONLY WHEN THE DATA IS 400000,,0
  6014					;FIRST, THE FLAGS ARE RESET; THEN, MOVN [400000,,0] IS EXECUTED.
  6015					;THE ARITHMETIC FLAGS ARE CHECKED.
  6016					;IF AROV AND CRY1 ARE SET AND CRY0 AND FOV ARE RESET, THIS TEST PASSES.
  6017
  6018	033475	255 17 0 00 033476 	C12300:	JFCL	17,.+1		;CLEAR ARITHMETIC FLAGS
  6019	033476	210 00 0 00 034465 		MOVN	[XWD 400000,0]	;*MOVN [400000,,0] SHOULD SET AROV AND CRY1 ONLY
  6020	033477	255 10 0 00 033501 		JOV	.+2		;PASS IF AROV IS SET
  6021						STOP^
  6022	033500	254 04 0 00 033501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6023	033501	324 00 0 00 033502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6024									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6025									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6026									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6027	033502	255 02 0 00 033504 		JCRY1	.+2		;PASS IF CRY0 IS SET
  6028						STOP^
  6029	033503	254 04 0 00 033504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6030	033504	324 00 0 00 033505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6031									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6032									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6033									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6034	033505	255 04 0 00 033507 		JCRY0	.+2		;PASS IF CRY0 IS RESET
  6035	033506	334 00 0 00 000000 		SKIPA
  6036						STOP^
  6037	033507	254 04 0 00 033510 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6038	033510	324 00 0 00 033511 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6039									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6040									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6041									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6042	033511	255 01 0 00 033513 		JFOV	.+2		;PASS IF FOV IS RESET
  6043	033512	334 00 0 00 000000 		SKIPA
  6044						STOP^
  6045	033513	254 04 0 00 033514 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6046	033514	324 00 0 00 033515 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6047									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6048									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6049									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6050
  6051					;**********
  6052
  6053					;THIS TEST VERIFIES THAT MOVM WILL SET THE AROV AND
  6054					;CRY1 FLAGS ONLY WHEN THE DATA IS 400000,,0
  6055					;FIRST, THE FLAGS ARE RESET; THEN, MOVM [400000,,0] IS EXECUTED.
  6056					;THE ARITHMETIC FLAGS ARE CHECKED.
  6057					;IF AROV AND CRY1 ARE SET AND CRY0 AND FOV ARE RESET, THIS TEST PASSES.
  6058
  6059	033515	255 17 0 00 033516 	C12301:	JFCL	17,.+1		;CLEAR ARITHMETIC FLAGS
  6060	033516	214 00 0 00 034465 		MOVM	[XWD 400000,0]	;*MOVM [400000,,0] SHOULD SET AROV AND CRY1 ONLY
  6061	033517	255 10 0 00 033521 		JOV	.+2		;PASS IF AROV IS SET
  6062						STOP^
  6063	033520	254 04 0 00 033521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6064	033521	324 00 0 00 033522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6065									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6066									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 47-1
DAKADM	MAC	19-JAN-77 13:41		TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX                               SEQ 0141

  6067									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6068	033522	255 02 0 00 033524 		JCRY1	.+2		;PASS IF CRY0 IS SET
  6069						STOP^
  6070	033523	254 04 0 00 033524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6071	033524	324 00 0 00 033525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6072									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6073									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6074									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6075	033525	255 04 0 00 033527 		JCRY0	.+2		;PASS IF CRY0 IS RESET
  6076	033526	334 00 0 00 000000 		SKIPA
  6077						STOP^
  6078	033527	254 04 0 00 033530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6079	033530	324 00 0 00 033531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6080									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6081									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6082									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6083	033531	255 01 0 00 033533 		JFOV	.+2		;PASS IF FOV IS RESET
  6084	033532	334 00 0 00 000000 		SKIPA
  6085						STOP^
  6086	033533	254 04 0 00 033534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6087	033534	324 00 0 00 033535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6088									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6089									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6090									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6091
  6092					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 48
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOS AND SOS INSTRUCTIONS                                                   SEQ 0142

  6093					SUBTTL	TEST OF AOS AND SOS INSTRUCTIONS
  6094
  6095					;**********
  6096
  6097					;THIS TEST VERIFIES THAT AOS ADDS 1 TO MEMORY AND DOES NOT SKIP.
  6098					;FIRST, E IS CLEARED; THEN, AOS IS EXECUTED. NEXT E IS CHECKED FOR 1.
  6099					;IF C(E) IS NOT 1 OR AOS SKIPPED, THIS TEST FAILS
  6100
  6101	033535	400 00 0 00 000000 	C12600:	SETZ			;CLEAR E
  6102	033536	350 00 0 00 000000 		AOS			;*AOS SHOULD ADD 1 TO C(E) AND NOT SKIP
  6103	033537	302 00 0 00 000001 		CAIE	1		;PASS IF C(E)=0,,1 ANDAOS DID NOT SKIP
  6104						STOP^
  6105	033540	254 04 0 00 033541 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6106	033541	324 00 0 00 033542 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6107									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6108									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6109									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6110
  6111					;**********
  6112
  6113					;THIS TEST VERIFIES THAT AOS ADDS 1 TO MEMORY AND DOES NOT SKIP.
  6114					;FIRST, E IS PRELOADED WITH -1,,-1; THEN, AOS IS EXECUTED. NEXT E IS CHECKED FOR 0.
  6115					;IF C(E) IS NOT 0 OR AOS SKIPPED, THIS TEST FAILS
  6116
  6117	033542	474 00 0 00 000000 	C12700:	SETO			;PRELOAD E WITH -1,,-1
  6118	033543	350 00 0 00 000000 		AOS			;*AOS SHOULD ADD 1 TO C(E) AND NOT SKIP
  6119	033544	302 00 0 00 000000 		CAIE			;PASS IF C(E)=0,,0 AND AOS DID NOT SKIP
  6120						STOP^
  6121	033545	254 04 0 00 033546 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6122	033546	324 00 0 00 033547 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6123									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6124									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6125									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6126
  6127					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 49
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOS AND SOS INSTRUCTIONS                                                   SEQ 0143

  6128					;THIS TEST VERIFIES THAT SOS SUBTRACTS 1 FROM MEMORY AND DOES NOT SKIP.
  6129					;FIRST, E IS CLEARED; THEN, SOS IS EXECUTED. NEXT E IS CHECKED FOR -1,,-1.
  6130					;IF C(E) IS NOT -1,,-1 OR SOS SKIPPED, THIS TEST FAILS
  6131
  6132	033547	400 00 0 00 000000 	C13100:	SETZ			;CLEAR E
  6133	033550	370 00 0 00 000000 		SOS			;*SOS SHOULD SUBTRACT 1 FROM C(E) AND NOT SKIP
  6134	033551	312 00 0 00 034466 		CAME	[-1]		;PASS IF C(E)=-1,,-1 AND SOS DID NOT SKIP
  6135						STOP^
  6136	033552	254 04 0 00 033553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6137	033553	324 00 0 00 033554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6138									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6139									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6140									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6141
  6142					;**********
  6143
  6144					;THIS TEST VERIFIES THAT SOS SUBTRACTS 1 FROM MEMORY AND DOES NOT SKIP.
  6145					;FIRST, E IS PRELOADED WITH A; THEN, SOS IS EXECUTED. NEXT E IS CHECKED FOR 0.
  6146					;IF C(E) IS NOT 0 OR SOS SKIPPED, THIS TEST FAILS
  6147
  6148	033554	201 00 0 00 000001 	C13200:	MOVEI	1		;PRELOAD E WITH 1
  6149	033555	370 00 0 00 000000 		SOS			;*SOS SHOULD SUBTRACT 1 FROM C(E) AND DID NOT SKIP
  6150	033556	302 00 0 00 000000 		CAIE	0		;PASS IF C(E)=0 AND SOS DID NOT SKIP
  6151						STOP^
  6152	033557	254 04 0 00 033560 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6153	033560	324 00 0 00 033561 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6154									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6155									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6156									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6157
  6158					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 50
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOS AND SOS INSTRUCTIONS                                                   SEQ 0144

  6159					;THIS TEST VERIFIES THAT SOS SETS CRY0/1 FLAGS IF C(E) IS A NON-ZERO NUMBER OTHER
  6160					;THAN 400000,,0.  IN THIS CASE, C(E)=1.  FIRST THE FLAGS ARE RESET; THEN
  6161					;SOS IS EXECUTED.  THE  FLAGS ARE CHECKED.  IF CRY0 AND CRY1 ARE SET
  6162					;AND AROV AND FOV ARE RESET, THIS TEST PASSES.
  6163
  6164	033561	255 17 0 00 033562 	C13300:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
  6165	033562	201 00 0 00 000001 		MOVEI	1		;PRELOAD E WITH 1
  6166	033563	370 00 0 00 000000 		SOS			;*SOS SHOULD SET CRY0/1
  6167	033564	255 04 0 00 033566 		JCRY0	.+2		;PASS IF CRY0 IS SET
  6168						STOP^
  6169	033565	254 04 0 00 033566 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6170	033566	324 00 0 00 033567 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6171									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6172									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6173									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6174	033567	255 02 0 00 033571 		JCRY1	.+2		;PASS IF CRY1 IS SET
  6175						STOP^
  6176	033570	254 04 0 00 033571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6177	033571	324 00 0 00 033572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6178									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6179									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6180									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6181	033572	255 10 0 00 033574 		JOV	.+2		;PASS IF AROV IS RESET
  6182	033573	334 00 0 00 000000 		SKIPA
  6183						STOP^
  6184	033574	254 04 0 00 033575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6185	033575	324 00 0 00 033576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6186									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6187									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6188									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6189	033576	255 01 0 00 033600 		JFOV	.+2		;PASS IF FOV IS RESET
  6190	033577	334 00 0 00 000000 		SKIPA
  6191						STOP^
  6192	033600	254 04 0 00 033601 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6193	033601	324 00 0 00 033602 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6194									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6195									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6196									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6197
  6198					;**********
  6199
  6200					;THIS TEST VERIFIES THAT AOS SETS CRY0 AND CRY1 FLAG IF C(E) IS -1,,-1
  6201					;FIRST THE FLAGS ARE RESET; THEN
  6202					;AOS IS EXECUTED.  THE FLAGS ARE CHECKED.
  6203					;IF CRY0 AND CRY1 ARE SET AND AROV AND FOV ARE RESET, THIS TEST PASSES.
  6204
  6205	033602	255 17 0 00 033603 	C13400:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
  6206	033603	474 00 0 00 000000 		SETO			;PRELOAD E WITH 1
  6207	033604	350 00 0 00 000000 		AOS			;*AOS SHOULD SET CRY0 AND CRY1
  6208	033605	255 04 0 00 033607 		JCRY0	.+2		;PASS IF CRY0 IS SET
  6209						STOP^
  6210	033606	254 04 0 00 033607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6211	033607	324 00 0 00 033610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6212									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6213									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 50-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOS AND SOS INSTRUCTIONS                                                   SEQ 0145

  6214									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6215	033610	255 02 0 00 033612 		JCRY1	.+2		;PASS IF CRY1 IS SET
  6216						STOP^
  6217	033611	254 04 0 00 033612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6218	033612	324 00 0 00 033613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6219									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6220									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6221									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6222	033613	255 10 0 00 033615 		JOV	.+2		;PASS IF AROV IS RESET
  6223	033614	334 00 0 00 000000 		SKIPA
  6224						STOP^
  6225	033615	254 04 0 00 033616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6226	033616	324 00 0 00 033617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6227									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6228									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6229									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6230	033617	255 01 0 00 033621 		JFOV	.+2		;PASS IF FOV IS RESET
  6231	033620	334 00 0 00 000000 		SKIPA
  6232						STOP^
  6233	033621	254 04 0 00 033622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6234	033622	324 00 0 00 033623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6235									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6236									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6237									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6238
  6239					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 51
DAKADM	MAC	19-JAN-77 13:41		TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS                   SEQ 0146

  6240					SUBTTL	TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS
  6241
  6242					;**********
  6243
  6244					;THIS TEST VERIFIES THAT JFCL 1, WILL ALWAYS CLEAR FOV FLAG.
  6245					;FIRST, FOV IS SET VIA JRST 2, ;THEN JFCL 1,.+1 IS EXECUTED TO CLEAR FOV.
  6246					;IF FOV WAS CLEARED, THIS TEST PASSES.
  6247
  6248	033623				C13600:	SFLAG	FOV		^;SET FOV FLAG
  6249
  6250	033623	205 01 0 00 040000 		MOVSI	1,FOV
  6251	033624	255 17 0 00 033625 		JFCL	17,.+1		;RESET ALL FLAGS
  6252	033625	254 02 0 01 033626 		JRST	2,.+1(1)	;SET FOV FLAG
  6253	033626	255 01 0 00 033627 		JFCL	1,.+1		;*JFCL SHOULD RESET FOV
  6254	033627	255 01 0 00 033631 		JFCL	1,.+2		;PASS IF FOV IS RESET
  6255	033630	334 00 0 00 000000 		SKIPA			;SKIP HALT IF JFCL 1,.+1 PASSED
  6256						STOP^
  6257	033631	254 04 0 00 033632 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6258	033632	324 00 0 00 033633 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6259									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6260									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6261									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6262
  6263					;**********
  6264
  6265					;THIS TEST VERIFIES THAT JRST 2, CAN SET FXU AND JSP CAN SAVE FXU IN THE AC.
  6266					;FIRST, FXU IS SET VIA JRST 2, ;THEN, JSP IS EXECUTED. THE AC IS CHECKED
  6267					;FOR FXU.  IF FXU IS SET, THIS TEST PASSES; OTHERWISE, EITHER JRST 2, OR JSP FAILED.
  6268
  6269	033633				C13700:	SFLAG	FXU		^;*SET FXU FLAG
  6270
  6271	033633	205 01 0 00 000100 		MOVSI	1,FXU
  6272	033634	255 17 0 00 033635 		JFCL	17,.+1		;RESET ALL FLAGS
  6273	033635	254 02 0 01 033636 		JRST	2,.+1(1)	;SET FXU FLAG
  6274	033636	265 00 0 00 033637 		JSP	.+1		;*STORE FXU FLAG IN AC
  6275	033637	607 00 0 00 000100 		TLNN	FXU		;PASS IF FXU IS SET IN THE AC
  6276						STOP^
  6277	033640	254 04 0 00 033641 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6278	033641	324 00 0 00 033642 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6279									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6280									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6281									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6282
  6283					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 52
DAKADM	MAC	19-JAN-77 13:41		TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS                   SEQ 0147

  6284					;THIS TEST VERIFIES THAT JRST 2, CAN RESET FXU AND JSP CAN SAVE FXU IN THE AC.
  6285					;FIRST, FXU IS SET; THEN, FXU IS RESET VIA JRST 2,.  NEXT, JSP IS EXECUTED; AND
  6286					;THE AC IS CHECKED FOR FXU RESET.  IF FXU IS RESET IN THE AC, THIS TEST PASSES;
  6287					;OTHERWISE, JRST 2, FAILED TO CLEAR FXU OR JSP STORED FXU INCORECTLY.
  6288
  6289	033642				C14000:	SFLAG	FXU		^;SET FXU FLAG
  6290
  6291	033642	205 01 0 00 000100 		MOVSI	1,FXU
  6292	033643	255 17 0 00 033644 		JFCL	17,.+1		;RESET ALL FLAGS
  6293	033644	254 02 0 01 033645 		JRST	2,.+1(1)	;SET FXU FLAG
  6294						SFLAG			^;*RESET FXU FLAG
  6295
  6296	033645	205 01 0 00 000000 		MOVSI	1,
  6297	033646	255 17 0 00 033647 		JFCL	17,.+1		;RESET ALL FLAGS
  6298	033647	254 02 0 01 033650 		JRST	2,.+1(1)	;SET  FLAG
  6299	033650	265 00 0 00 033651 		JSP	.+1		;*STORE FXU FLAG IN THE AC
  6300	033651	603 00 0 00 000100 		TLNE	FXU		;PASS IF FXU IS RESET IN THE AC
  6301						STOP^
  6302	033652	254 04 0 00 033653 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6303	033653	324 00 0 00 033654 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6304									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6305									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6306									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6307
  6308					;**********
  6309
  6310					;THIS TEST VERIFIES THAT JRST 2, CAN SET DCK AND JSP CAN SAVE DCK IN THE AC.
  6311					;FIRST, DCK IS SET VIA JRST 2, ;THEN JSP IS EXECUTED.  THE AC IS CHECKED
  6312					;FOR DCK.  IF DCK IS SET, THIS TEST PASSES, OTHERWISE JRST 2, OR JSP FAILED.
  6313
  6314	033654				C14100:	SFLAG	DCK		^;*SET DCK FLAG
  6315
  6316	033654	205 01 0 00 000040 		MOVSI	1,DCK
  6317	033655	255 17 0 00 033656 		JFCL	17,.+1		;RESET ALL FLAGS
  6318	033656	254 02 0 01 033657 		JRST	2,.+1(1)	;SET DCK FLAG
  6319	033657	265 00 0 00 033660 		JSP	.+1		;*STORE FXU FLAG IN AC
  6320	033660	607 00 0 00 000040 		TLNN	DCK		;PASS IF FXU IS SET IN THE AC
  6321						STOP^
  6322	033661	254 04 0 00 033662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6323	033662	324 00 0 00 033663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6324									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6325									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6326									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6327
  6328					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 53
DAKADM	MAC	19-JAN-77 13:41		TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS                   SEQ 0148

  6329					;THIS TEST VERIFIES THAT JRST 2, CAN RESET DCK AND JSP CAN SAVE DCK IN THE AC.
  6330					;FIRST, FXU IS SET; THEN, DCK IS RESET VIA JRST 2,.  NEXT, JSP IS EXPECTED; AND
  6331					;THE AC IS CHECKED FOR DCK RESET.  IF DCK IS RESET IN THE AC, THIS TEST PASSES;
  6332					;OTHERWISE, JRST 2, FAILED TO CLEAR DCK OR JSP STORED DCK INCORRECTLY.
  6333
  6334	033663				C14200:	SFLAG	DCK		^;SET DCK FLAG
  6335
  6336	033663	205 01 0 00 000040 		MOVSI	1,DCK
  6337	033664	255 17 0 00 033665 		JFCL	17,.+1		;RESET ALL FLAGS
  6338	033665	254 02 0 01 033666 		JRST	2,.+1(1)	;SET DCK FLAG
  6339						SFLAG			^;*RESET DCK FLAG
  6340
  6341	033666	205 01 0 00 000000 		MOVSI	1,
  6342	033667	255 17 0 00 033670 		JFCL	17,.+1		;RESET ALL FLAGS
  6343	033670	254 02 0 01 033671 		JRST	2,.+1(1)	;SET  FLAG
  6344	033671	265 00 0 00 033672 		JSP	.+1		;*STORE DCK FLAG IN THE AC
  6345	033672	603 00 0 00 000040 		TLNE	DCK		;PASS IF DCK IS RESET IN THE AC
  6346						STOP^
  6347	033673	254 04 0 00 033674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6348	033674	324 00 0 00 033675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6349									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6350									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6351									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6352
  6353					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 54
DAKADM	MAC	19-JAN-77 13:41		TEST OF JUMPX INSTRUCTIONS                                                         SEQ 0149

  6354					SUBTTL	TEST OF JUMPX INSTRUCTIONS
  6355
  6356					;**********
  6357
  6358					;THIS TEST VERIFIES THAT JUMPL IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
  6359					;C(AC) IS NEGATIVE.  IN THIS TEST, THE AC CONTAINS -1,,-1.  HENCE,
  6360					;JUMPL SHOULD JUMP.  IF JUMPL JUMPS, THIS TEST PASSES.
  6361
  6362	033675	474 00 0 00 000000 	C14500:	SETO			;PRELOAD AC WITH -1,,-1
  6363	033676	321 00 0 00 033700 		JUMPL	.+2		;*JUMPL SHOULD JUMP BECAUSE C(AC) IS NEGATIVE
  6364						STOP^
  6365	033677	254 04 0 00 033700 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6366	033700	324 00 0 00 033701 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6367									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6368									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6369									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6370
  6371					;**********
  6372
  6373					;THIS TEST VERIFIES THAT JUMPL IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
  6374					;C(AC) IS NEGATIVE.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
  6375					;JUMPL SHOULD NOT JUMP.  IF JUMPL DOES NOT JUMP, THIS TEST PASSES.
  6376
  6377	033701	400 00 0 00 000000 	C14600:	SETZ			;PRELOAD AC WITH 0
  6378	033702	321 00 0 00 033704 		JUMPL	.+2		;*JUMPL SHOULD NOT JUMP
  6379	033703	334 00 0 00 000000 		SKIPA			;PASS IF JUMPL DOES NOT JUMP
  6380						STOP^
  6381	033704	254 04 0 00 033705 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6382	033705	324 00 0 00 033706 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6383									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6384									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6385									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6386
  6387					;**********
  6388
  6389					;THIS TEST VERIFIES THAT JUMPE IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
  6390					;C(AC)=0.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
  6391					;JUMPE SHOULD JUMP.  IF JUMPE JUMPS, THIS TEST PASSES.
  6392
  6393	033706	400 00 0 00 000000 	C14700:	SETZ			;PRELOAD AC WITH 0
  6394	033707	322 00 0 00 033711 		JUMPE	.+2		;*JUMPE SHOULD JUMP
  6395						STOP^
  6396	033710	254 04 0 00 033711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6397	033711	324 00 0 00 033712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6398									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6399									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6400									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6401
  6402					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 55
DAKADM	MAC	19-JAN-77 13:41		TEST OF JUMPX INSTRUCTIONS                                                         SEQ 0150

  6403					;THIS TEST VERIFIES THAT JUMPN IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
  6404					;C(AC) IS NON-ZERO.  IN THIS TEST, THE AC CONTAINS 1.  HENCE,
  6405					;JUMPN SHOULD JUMP.  IF JUMPN JUMPS, THIS TEST PASSES.
  6406
  6407	033712	201 00 0 00 000001 	C15000:	MOVEI	1		;PRELOAD AC WITH 1
  6408	033713	326 00 0 00 033715 		JUMPN	.+2		;*JUMPN SHOULD JUMP
  6409						STOP^
  6410	033714	254 04 0 00 033715 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6411	033715	324 00 0 00 033716 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6412									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6413									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6414									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6415
  6416					;**********
  6417
  6418					;THIS TEST VERIFIES THAT JUMPE IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
  6419					;C(AC)=0.  IN THIS TEST, THE AC CONTAINS 2.  HENCE,
  6420					;JUMPL SHOULD NOT JUMP.  IF JUMPE DOES NOT JUMP, THIS TEST PASSES.
  6421
  6422	033716	201 00 0 00 000002 	C15100:	MOVEI	2		;PRELOAD AC WITH 2
  6423	033717	322 00 0 00 033721 		JUMPE	.+2		;*JUMPE SHOULD NOT JUMP
  6424	033720	334 00 0 00 000000 		SKIPA			;PASS IF JUMPE DID NOT JUMP
  6425						STOP^
  6426	033721	254 04 0 00 033722 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6427	033722	324 00 0 00 033723 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6428									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6429									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6430									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6431
  6432					;**********
  6433
  6434					;THIS TEST VERIFIES THAT JUMPN IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
  6435					;C(AC) IS NON-ZERO.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
  6436					;JUMPN SHOULD NOT JUMP.  IF JUMPN DOES NOT JUMP, THIS TEST PASSES.
  6437
  6438	033723	400 00 0 00 000000 	C15200:	SETZ			;PRELOAD AC WITH 0
  6439	033724	326 00 0 00 033726 		JUMPN	.+2		;*JUMPN SHOULD NOT JUMP
  6440	033725	334 00 0 00 000000 		SKIPA			;PASS IF JUMPN DID NOT JUMP
  6441						STOP^
  6442	033726	254 04 0 00 033727 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6443	033727	324 00 0 00 033730 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6444									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6445									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6446									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6447
  6448					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 56
DAKADM	MAC	19-JAN-77 13:41		TEST OF JUMPX INSTRUCTIONS                                                         SEQ 0151

  6449					;THIS TEST VERIFIES THAT JUMPG IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
  6450					;C(AC) IS GREATER THAN 0.  IN THIS TEST, THE AC CONTAINS 1.  HENCE,
  6451					;JUMPG SHOULD JUMP.  IF JUMPG JUMPS, THIS TEST PASSES.
  6452
  6453	033730	201 00 0 00 000001 	C15300:	MOVEI	1		;PRELOAD  AC WITH 1
  6454	033731	327 00 0 00 033733 		JUMPG	.+2		;*JUMPG SHOULD JUMP
  6455						STOP^
  6456	033732	254 04 0 00 033733 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6457	033733	324 00 0 00 033734 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6458									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6459									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6460									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6461
  6462					;**********
  6463
  6464					;THIS TEST VERIFIES THAT JUMPG IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
  6465					;C(AC) IS GREATER THAN 0.  IN THIS TEST, THE AC CONTAINS -1,,0.  HENCE,
  6466					;JUMPG SHOULD NOT JUMP.  IF JUMPG DOES NOT JUMP, THIS TEST PASSES.
  6467
  6468	033734	205 00 0 00 777777 	C15400:	MOVSI	-1		;PRELOAD AC WITH -1,,0
  6469	033735	327 00 0 00 033737 		JUMPG	.+2		;*JUMPG SHOULD NOT JUMP
  6470	033736	334 00 0 00 000000 		SKIPA			;PASS IF JUMPG DID NOT JUMP
  6471						STOP^
  6472	033737	254 04 0 00 033740 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6473	033740	324 00 0 00 033741 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6474									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6475									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6476									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6477
  6478					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 57
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOJ AND SOJ INSTRUCTIONS                                                   SEQ 0152

  6479					SUBTTL	TEST OF AOJ AND SOJ INSTRUCTIONS
  6480
  6481					;**********
  6482
  6483					;THIS TEST VERIFIES THAT AOJ ADDS 1 TO THE AC AND DOES NOT JUMP.
  6484					;FIRST, THE AC IS PRELOADED WITH 0; THEN, AOJ IS EXECUTED.  NEXT, THE
  6485					;AC IS CHECKED FOR 1.  IF C(AC) IS NOT 1 OR AOJ SKIPPED, THIS TEST FAILS.
  6486
  6487	033741	400 00 0 00 000000 	C15500:	SETZ			;PRELOAD AC WITH 0
  6488	033742	340 00 0 00 033744 		AOJ	.+2		;*AOJ SHOULD ADD 1 TO THE AC AND NOT JUMP
  6489	033743	302 00 0 00 000001 		CAIE	1		;PASS IF C(AC)=1 AND AOJ DID NOT JUMP
  6490						STOP^
  6491	033744	254 04 0 00 033745 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6492	033745	324 00 0 00 033746 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6493									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6494									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6495									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6496
  6497					;**********
  6498
  6499					;THIS TEST VERIFIES THAT AOJ ADDS 1 TO THE AC AND DOES NOT JUMP.
  6500					;FIRST, THE AC IS PRELOADED WITH -1,,-1; THEN, AOJ IS EXECUTED.  NEXT, THE
  6501					;AC IS CHECKED FOR 0.  IF C(AC) IS NOT 0 OR AOJ SKIPPED, THIS TEST FAILS.
  6502
  6503	033746	474 00 0 00 000000 	C15600:	SETO			;PRELOAD AC WITH 0
  6504	033747	340 00 0 00 033751 		AOJ	.+2		;*AOJ SHOULD ADD 1 TO THE AC AND NOT JUMP
  6505	033750	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=1 AND AOJ DID NOT JUMP
  6506						STOP^
  6507	033751	254 04 0 00 033752 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6508	033752	324 00 0 00 033753 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6509									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6510									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6511									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6512
  6513					;**********
  6514
  6515					;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
  6516					;FIRST, THE AC IS PRELOADED WITH 0; THEN, SOJ IS EXECUTED.  NEXT, THE
  6517					;AC IS CHECKED FOR -1,,-1.  IF C(AC) IS NOT -1,,-1 OR SOJ SKIPPED, THIS TEST FAILS.
  6518
  6519	033753	400 00 0 00 000000 	C15700:	SETZ			;PRELOAD AC WITH 0
  6520	033754	360 00 0 00 033756 		SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
  6521	033755	312 00 0 00 034466 		CAME	[-1]		;PASS IF C(AC)=-1,,-1 AND SOJ DID NOT JUMP
  6522						STOP^
  6523	033756	254 04 0 00 033757 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6524	033757	324 00 0 00 033760 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6525									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6526									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6527									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6528
  6529					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 58
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOJ AND SOJ INSTRUCTIONS                                                   SEQ 0153

  6530					;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
  6531					;FIRST, THE AC IS PRELOADED WITH -1,,-1; THEN, SOJ IS EXECUTED.  NEXT, THE
  6532					;AC IS CHECKED FOR -1,,-2.  IF C(AC) IS NOT -1,,-2 OR SOJ SKIPPED, THIS TEST FAILS.
  6533
  6534	033760	474 00 0 00 000000 	C16000:	SETO			;PRELOAD AC WITH -1,,-1
  6535	033761	360 00 0 00 033763 		SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
  6536	033762	312 00 0 00 034467 		CAME	[-2]		;PASS IF C(AC)=-1,,-2 AND SOJ DID NOT JUMP
  6537						STOP^
  6538	033763	254 04 0 00 033764 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6539	033764	324 00 0 00 033765 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6540									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6541									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6542									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6543
  6544					;**********
  6545
  6546					;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
  6547					;FIRST, THE AC IS PRELOADED WITH 0,,1; THEN, SOJ IS EXECUTED.  NEXT, THE
  6548					;AC IS CHECKED FOR 0.  IF C(AC) IS NOT 0 OR SOJ SKIPPED, THIS TEST FAILS.
  6549
  6550	033765	201 00 0 00 000001 	C16100:	MOVEI	1		;PRELOAD AC WITH 1
  6551	033766	360 00 0 00 033770 		SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
  6552	033767	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0 AND SOJ DID NOT JUMP
  6553						STOP^
  6554	033770	254 04 0 00 033771 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6555	033771	324 00 0 00 033772 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6556									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6557									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6558									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6559
  6560					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 59
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOJ AND SOJ INSTRUCTIONS                                                   SEQ 0154

  6561					;THIS TEST VERIFIES THAT SOJ AC, FOLLOWED BY AOJ AC, HAS NO NET EFFECT ON C(AC).
  6562					;IN THIS CASE, THE AC IS PRELOADED WITH 0; THEN, SOJ AC, FOLLOWED BY AOJ.
  6563					;AC, IS REPEATED 7 TIMES.  THE AC IS THEN CHECKED FOR ITS ORIGINAL CONTENTS, 0.
  6564					;IF C(AC)=0, THIS TEST PASSES; OTHERWISE AOJ OR SOJ FAILED.
  6565
  6566			000017		C16200:	AC=17
  6567	033772	400 17 0 00 000000 		SETZ	AC,		;PRELOAD AC WITH 0
  6568						REPEAT	^D10,<
  6569						SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6570						AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC>
  6571
  6572	033773	360 17 0 00 033773 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6573	033774	340 17 0 00 033774 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
  6574
  6575	033775	360 17 0 00 033775 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6576	033776	340 17 0 00 033776 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
  6577
  6578	033777	360 17 0 00 033777 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6579	034000	340 17 0 00 034000 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
  6580
  6581	034001	360 17 0 00 034001 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6582	034002	340 17 0 00 034002 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
  6583
  6584	034003	360 17 0 00 034003 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6585	034004	340 17 0 00 034004 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
  6586
  6587	034005	360 17 0 00 034005 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6588	034006	340 17 0 00 034006 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
  6589
  6590	034007	360 17 0 00 034007 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6591	034010	340 17 0 00 034010 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
  6592
  6593	034011	360 17 0 00 034011 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6594	034012	340 17 0 00 034012 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
  6595
  6596	034013	360 17 0 00 034013 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6597	034014	340 17 0 00 034014 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
  6598
  6599	034015	360 17 0 00 034015 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
  6600	034016	340 17 0 00 034016 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
  6601	034017	332 00 0 00 000017 		SKIPE	AC		;PASS IF C(AC) IS UNCHANGED. I.E. C(AC)=0
  6602						STOP^
  6603	034020	254 04 0 00 034021 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6604	034021	324 00 0 00 034022 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6605									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6606									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6607									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6608
  6609					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 60
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOJ AND SOJ INSTRUCTIONS                                                   SEQ 0155

  6610					;THIS TEST VERIFIES THAT SOJ SETS CRY0/1 FLAGS IF C(E) IS A NON-ZERO NUMBER OTHER
  6611					;THAN 400000,,0.  IN THIS CASE, C(E)=1.  FIRST THE FLAGS ARE RESET; THEN
  6612					;SOJ IS EXECUTED.  THE  FLAGS ARE CHECKED.  IF CRY0 AND CRY1 ARE SET
  6613					;AND AROV AND FOV ARE RESET, THIS TEST PASSES.
  6614
  6615	034022	255 17 0 00 034023 	C16201:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
  6616	034023	201 00 0 00 000001 		MOVEI	1		;PRELOAD E WITH 1
  6617	034024	360 00 0 00 000000 		SOJ			;*SOJ SHOULD SET CRY0/1
  6618	034025	255 04 0 00 034027 		JCRY0	.+2		;PASS IF CRY0 IS SET
  6619						STOP^
  6620	034026	254 04 0 00 034027 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6621	034027	324 00 0 00 034030 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6622									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6623									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6624									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6625	034030	255 02 0 00 034032 		JCRY1	.+2		;PASS IF CRY1 IS SET
  6626						STOP^
  6627	034031	254 04 0 00 034032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6628	034032	324 00 0 00 034033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6629									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6630									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6631									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6632	034033	255 10 0 00 034035 		JOV	.+2		;PASS IF AROV IS RESET
  6633	034034	334 00 0 00 000000 		SKIPA
  6634						STOP^
  6635	034035	254 04 0 00 034036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6636	034036	324 00 0 00 034037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6637									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6638									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6639									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6640	034037	255 01 0 00 034041 		JFOV	.+2		;PASS IF FOV IS RESET
  6641	034040	334 00 0 00 000000 		SKIPA
  6642						STOP^
  6643	034041	254 04 0 00 034042 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6644	034042	324 00 0 00 034043 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6645									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6646									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6647									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6648
  6649					;**********
  6650
  6651					;THIS TEST VERIFIES THAT AOJ SETS CRY0 AND CRY1 FLAG IF C(E) IS -1,,-1
  6652					;FIRST THE FLAGS ARE RESET; THEN
  6653					;AOJ IS EXECUTED.  THE FLAGS ARE CHECKED.
  6654					;IF CRY0 AND CRY1 ARE SET AND AROV AND FOV ARE RESET, THIS TEST PASSES.
  6655
  6656	034043	255 17 0 00 034044 	C16202:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
  6657	034044	474 00 0 00 000000 		SETO			;PRELOAD E WITH 1
  6658	034045	340 00 0 00 000000 		AOJ			;*AOJ SHOULD SET CRY0 AND CRY1
  6659	034046	255 04 0 00 034050 		JCRY0	.+2		;PASS IF CRY0 IS SET
  6660						STOP^
  6661	034047	254 04 0 00 034050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6662	034050	324 00 0 00 034051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6663									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6664									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 60-1
DAKADM	MAC	19-JAN-77 13:41		TEST OF AOJ AND SOJ INSTRUCTIONS                                                   SEQ 0156

  6665									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6666	034051	255 02 0 00 034053 		JCRY1	.+2		;PASS IF CRY1 IS SET
  6667						STOP^
  6668	034052	254 04 0 00 034053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6669	034053	324 00 0 00 034054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6670									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6671									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6672									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6673	034054	255 10 0 00 034056 		JOV	.+2		;PASS IF AROV IS RESET
  6674	034055	334 00 0 00 000000 		SKIPA
  6675						STOP^
  6676	034056	254 04 0 00 034057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6677	034057	324 00 0 00 034060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6678									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6679									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6680									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6681	034060	255 01 0 00 034062 		JFOV	.+2		;PASS IF FOV IS RESET
  6682	034061	334 00 0 00 000000 		SKIPA
  6683						STOP^
  6684	034062	254 04 0 00 034063 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6685	034063	324 00 0 00 034064 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6686									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6687									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6688									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6689
  6690					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 61
DAKADM	MAC	19-JAN-77 13:41		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0157

  6691					SUBTTL	TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS
  6692
  6693					;**********
  6694
  6695					;THIS TEST VERIFIES THAT ADDM DOES NOT MODIFY C(AC)
  6696					;BOTH AC AND E ARE PRELOADED WITH -1,,-1.  THEN ADDM IS EXECUTED.
  6697					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
  6698
  6699	034064	477 00 0 00 000001 	C16400:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
  6700	034065	272 00 0 00 000001 		ADDM	1		;*ADDM SHOULD NOT AFFECT C(AC)
  6701	034066	312 00 0 00 034466 		CAME	[-1]		;PASS IF C(AC) IS UNMODIFIED BY ADDM
  6702						STOP^
  6703	034067	254 04 0 00 034070 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6704	034070	324 00 0 00 034071 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6705									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6706									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6707									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6708
  6709					;**********
  6710
  6711					;THIS TEST VERIFIES THAT HRREM DOES NOT MODIFY C(AC)
  6712					;THE AC IS PRELOADED WITH 0,,-1.  THEN HRRM IS EXECUTED.
  6713					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
  6714
  6715	034071	201 00 0 00 777777 	C16500:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
  6716	034072	572 00 0 00 000001 		HRREM	1		;*HRRM SHOULD NOT AFFECT C(AC)
  6717	034073	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC) IS UNMODIFIED BY HRRM
  6718						STOP^
  6719	034074	254 04 0 00 034075 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6720	034075	324 00 0 00 034076 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6721									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6722									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6723									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6724
  6725					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 62
DAKADM	MAC	19-JAN-77 13:41		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0158

  6726					;THIS TEST VERIFIES THAT MOVSM DOES NOT MODIFY C(AC)
  6727					;THE AC IS PRELOADED WITH 0,,-1.  THEN MOVSM IS EXECUTED.
  6728					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
  6729
  6730	034076	201 00 0 00 777777 	C16600:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
  6731	034077	206 00 0 00 000001 		MOVSM	1		;*MOVSM SHOULD NOT AFFECT C(AC)
  6732	034100	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC) IS UNMODIFIED BY MOVSM
  6733						STOP^
  6734	034101	254 04 0 00 034102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6735	034102	324 00 0 00 034103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6736									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6737									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6738									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6739
  6740					;**********
  6741
  6742					;THIS TEST VERIFIES THAT XORM DOES NOT MODIFY C(AC)
  6743					;BOTH AC AND E ARE PRELOADED WITH -1,,-1.  THEN XORM IS EXECUTED.
  6744					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
  6745
  6746	034103	477 00 0 00 000001 	C16700:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
  6747	034104	432 00 0 00 000001 		XORM	1		;*XORM SHOULD NOT AFFECT C(AC)
  6748	034105	312 00 0 00 034466 		CAME	[-1]		;PASS IF C(AC) IS UNMODIFIED BY XORM
  6749						STOP^
  6750	034106	254 04 0 00 034107 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6751	034107	324 00 0 00 034110 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6752									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6753									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6754									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6755
  6756					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 63
DAKADM	MAC	19-JAN-77 13:41		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0159

  6757					;THIS TEST VERIFIES THAT ADDB ADDS C(AC) TO C(E) AND PLACES THE
  6758					;RESULT IN BOTH AC AND E.  IN THIS TEST, BOTH AC AND E ARE PRELOADED
  6759					;WITH -1,,-1, THEN, ADDB IS EXECUTED.  C(AC) IS THEN COMPARED TO C(E);
  6760					;AND C(AC) IS THEN COMPARED TO -2.  IF BOTH OF THESE COMPARISONS SUCCEED, THIS
  6761					;TEST PASSES; OTHERWISE, ADDB FAILED
  6762
  6763	034110	477 00 0 00 000001 	C17000:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
  6764	034111	273 00 0 00 000001 		ADDB	1		;*ADDB SHOULD ADD C(AC) TO C(E) AND PLACE RESULT
  6765									;INTO BOTH AC AND E
  6766	034112	312 00 0 00 000001 		CAME	1		;PASS IF C(AC)=C(E)
  6767						STOP^
  6768	034113	254 04 0 00 034114 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6769	034114	324 00 0 00 034115 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6770									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6771									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6772									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6773	034115	312 00 0 00 034467 		CAME	[-2]		;PASS IF C(AC)=-2
  6774						STOP^
  6775	034116	254 04 0 00 034117 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6776	034117	324 00 0 00 034120 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6777									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6778									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6779									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6780
  6781					;**********
  6782
  6783					;THIS TEST VERIFIES THAT ADDM ADDS C(AC) TO C(E) AND PLACES THE RESULT IN E
  6784					;IN THIS CASE, AC, E ARE BOTH PRELOADED WITH -1; THEN, ADDM IS EXECUTED.
  6785					;E IS THEN CHECKED FOR -2.  IF C(E)=-2, THIS TEST PASSES; OTHERWISE, ADDM FAILED
  6786
  6787	034120	477 00 0 00 000001 	C17100:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
  6788	034121	272 00 0 00 000001 		ADDM	1		;*ADDM SHOULD ADD C(AC) TO C(E)
  6789	034122	312 01 0 00 034467 		CAME	1,[-2]		;PASS IF C(E)=-2
  6790						STOP^
  6791	034123	254 04 0 00 034124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6792	034124	324 00 0 00 034125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6793									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6794									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6795									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6796
  6797					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 64
DAKADM	MAC	19-JAN-77 13:41		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0160

  6798					;THIS TEST VERIFIES THAT HLLOS PLACES ONES ON THE RIGHT HALF OF E
  6799					;BUT DOES NOT AFFECT THE LEFT HALF OF E.  IN THIS CASE,
  6800					;E IS PRELOADED WITH 0; THE, HLLOS IS EXECUTED.  THE RESULT
  6801					;IN E SHOULD BE 0,,-1.  IF C(E)=0,,-1, THIS TEST PASSES
  6802
  6803	034125	402 00 0 00 000001 	C17200:	SETZM	1		;PRELOAD E WITH 0
  6804	034126	523 00 0 00 000001 		HLLOS	1		;*HLLOS SHOULD PLACE 0,,-1 INTO E
  6805	034127	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
  6806						STOP^
  6807	034130	254 04 0 00 034131 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6808	034131	324 00 0 00 034132 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6809									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6810									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6811									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6812
  6813					;**********
  6814
  6815					;THIS TEST VERIFIES THAT MOVSS SWAPS BOTHS HALVES OF E AND
  6816					;PLACES THE RESULT IN E.  IN THIS CASE, E IS PRELOADED WITH
  6817					;-1,,0; THEN, MOVSS IS EXECUTED.  THE RESULT IN E SHOULD BE 0,,-1.
  6818					;IF C(E)=0,,-1, THIS TEST PASSES
  6819
  6820	034132	205 01 0 00 777777 	C17300:	MOVSI	1,-1		;PRELOAD E WITH -1,,0
  6821	034133	207 00 0 00 000001 		MOVSS	1		;*MOVSS SHOULD PLACE 0,,-1 INTO E
  6822	034134	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
  6823						STOP^
  6824	034135	254 04 0 00 034136 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6825	034136	324 00 0 00 034137 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6826									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6827									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6828									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6829
  6830					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 65
DAKADM	MAC	19-JAN-77 13:41		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0161

  6831					;THIS TEST VERIFIES THAT AOS ADDS ONE TO MEMORY BUT DOES NOT SKIP
  6832					;FIRST, E IS PRELOADED WITH -1,-1; THEN, AOS IS EXECUTED.  NEXT, E IS CHECKED FOR 0.
  6833					;IF C(E) IS NOT 0 OR AOS SKIPPED, THIS TEST FAILS
  6834
  6835	034137	477 00 0 00 000001 	C17400:	SETOB	1		;PRELOAD E WITH -1,,-1
  6836	034140	350 00 0 00 000001 		AOS	1		;*AOS SHOULD ADD TO C(E) AND NOT SKIP
  6837	034141	302 01 0 00 000000 		CAIE	1,0		;PASS IF C(E)=0,,0 AND AOS DID NOT SKIP
  6838						STOP^
  6839	034142	254 04 0 00 034143 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6840	034143	324 00 0 00 034144 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6841									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6842									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6843									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6844
  6845					;**********
  6846
  6847					;THIS TEST VERIFIES THAT HRLM PLACES C(AC-RIGHT) INTO E-LEFT AND DOES
  6848					;NOT MODIFY E-RIGHT.  IN THIS CASE, AC IS PRELOADED WITH 0 AND E IS PRELOADED
  6849					;WITH -1,,-1.  THEN, HRLM IS EXECUTED.  E IS THEN CHECKED FOR 0,,-1.  IF
  6850					;C(E)=0,,-1, THIS TEST PASSES
  6851
  6852	034144	400 00 0 00 000000 	C17500:	SETZ			;PRELOAD AC WITH 0
  6853	034145	474 01 0 00 000000 		SETO	1,		;PRELOAD E WITH -1,,-1
  6854	034146	506 00 0 00 000001 		HRLM	1		;*HRLM SHOULD PLACE 0,,-1 INTO E
  6855	034147	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
  6856						STOP^
  6857	034150	254 04 0 00 034151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6858	034151	324 00 0 00 034152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6859									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6860									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6861									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6862
  6863					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 66
DAKADM	MAC	19-JAN-77 13:41		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0162

  6864					;THIS TEST VERIFIES THAT HRRS DOES NOT MODIFY E
  6865					;E IS PRELOADED WITH 0 AND AC IS PRELOADED WITH -1,,-1.
  6866					;HRRS IS EXECUTED; THEN E IS CHECKED.  IF C(E) DOES
  6867					;NOT CHANGE, THIS TEST PASSES
  6868
  6869	034152	474 00 0 00 000000 	C17600:	SETO			;PRELOAD AC WITH -1,,-1
  6870	034153	400 01 0 00 000000 		SETZ	1,		;PRELOAD E WITH 0,,0
  6871	034154	543 00 0 00 000001 		HRRS	1		;*HRRS SHOULD PLACE 0,,0 INTO E
  6872	034155	332 00 0 00 000001 		SKIPE	1
  6873						STOP^
  6874	034156	254 04 0 00 034157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6875	034157	324 00 0 00 034160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6876									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6877									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6878									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6879
  6880					;**********
  6881
  6882					;THIS TEST VERIFIES THAT HRRZM PLACES C(AC-RIGHT) INTO E-RIGHT AND PLACES
  6883					;ZEROS INTO E-LEFT.  IN THIS CASE, AC=E=AC1 AND C(AC)=C(E)=-1,,0.  HRRZM
  6884					;IS EXECUTED AND AC1 IS CHECKED FOR 0.  IF AC1=0, THIS TEST PASSES.
  6885
  6886	034160	474 00 0 00 000000 	C17700:	SETO			;PRELOAD AC0 WITH -1,,-1
  6887	034161	205 01 0 00 777777 		MOVSI	1,-1		;PRELOAD AC1 WITH -1,,0
  6888	034162	552 01 0 00 000001 		HRRZM	1,1		;*HRRZM SHOULD PLACE 0 INTO AC1
  6889	034163	332 00 0 00 000001 		SKIPE	1		;PASS IF C(AC1)=0
  6890						STOP^
  6891	034164	254 04 0 00 034165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6892	034165	324 00 0 00 034166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6893									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6894									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6895									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6896
  6897					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 67
DAKADM	MAC	19-JAN-77 13:41		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0163

  6898					;THIS TEST VERIFIES THAT JFCL 17,.+1 NEVER JUMPS AND DOES NOT MODIFY C(AC0).
  6899					;FIRST, AC0 IS PRELOADED; THEN, JFCL IS EXECUTED.  IF AC0 IS MODIFIED
  6900					;OR JFCL SKIPS, THIS TEST FAILS
  6901
  6902	034166	400 00 0 00 000000 	C20000:	SETZ			;CLEAR AC0
  6903	034167	255 17 0 00 034170 		JFCL	17,.+1		;*JFCL SHOULD NOT JUMP OR MODIFY C(AC0).
  6904	034170	332 00 0 00 000000 		SKIPE			;PASS IF C(AC0)=0 AND JFCL DID NOT JUMP
  6905						STOP^
  6906	034171	254 04 0 00 034172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6907	034172	324 00 0 00 034173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6908									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6909									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6910									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6911
  6912					;**********
  6913
  6914					;THIS TEST VERIFIES THAT XORM PERFORMS THE LOGICAL EXCLUSIVE OR FUNCTION
  6915					;BETWEEN C(AC) AND C(E) AND PLACES THE RESULT INTO E
  6916					;IN THIS CASE, AC AND E ARE PRELOADED WITH -1,,-1; THEN, XORM IS
  6917					;EXECUTED.  IF THE RESULT IN E IS 0, THE TEST PASSES
  6918
  6919	034173	477 00 0 00 000001 	C20100:	SETOB	1		;PRELOAD AC,E WITH -1,,-1
  6920	034174	432 00 0 00 000001 		XORM	1		;*XORM SHOULD PLACE 0 INTO E
  6921	034175	302 01 0 00 000000 		CAIE	1,0		;PASS IF C(E)=0
  6922						STOP^
  6923	034176	254 04 0 00 034177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6924	034177	324 00 0 00 034200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6925									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6926									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6927									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6928
  6929					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 68
DAKADM	MAC	19-JAN-77 13:41		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS                                    SEQ 0164

  6930					;THIS TEST VERIFIES THAT SETZB PLACES ZEROS INTO BOTH AC AND E.
  6931					;AFTER SETZB IS EXECUTED, BOTH AC AND E ARE CHECKED
  6932					;FOR 0.  IF EITHER AC OR E CONTAINS ANY ONES, THIS TEST FAILS
  6933
  6934	034200	403 00 0 00 000001 	C20200:	SETZB	1		;*SETZB SHOULD PLACE ZEROES IN BOTH AC AND E
  6935	034201	316 00 0 00 034536 		CAMN	[0]		;FAIL IF C(AC) IS NON-ZERO
  6936	034202	312 00 0 00 000001 		CAME	1		;FAIL IF C(E) IS NON-ZERO
  6937						STOP^
  6938	034203	254 04 0 00 034204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6939	034204	324 00 0 00 034205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6940									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6941									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6942									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6943
  6944					;**********
  6945
  6946					;THIS TEST VERIFIES THAT SETAB PLACES C(AC) INTO BOTH AC AND E.
  6947					;FIRST, AC IS PRELOADED WITH -1,,-1 AND E IS PRELOADED WITH 0;
  6948					;THEN, SETAB IS EXECUTED.  BOTH AC AND E ARE CHECKED FOR -1,,-1
  6949					;IF EITHER AC OR E CONTAIN ANY ZEROS, THIS TEST FAILS.
  6950
  6951	034205	400 01 0 00 000000 	C20300:	SETZ	1,		;PRELOAD E WITH 0
  6952	034206	474 00 0 00 000000 		SETO			;PRELOAD AC WITH -1,,-1
  6953	034207	427 00 0 00 000001 		SETAB	1		;*SETAB SHOULD PLACE -1,,-1 INTO BOTH AC AND E
  6954	034210	316 00 0 00 034466 		CAMN	[-1]		;FAIL IF C(AC) IS NOT -1,-1
  6955	034211	312 00 0 00 000001 		CAME	1		;FAIL IF C(E) IS NOT -1,,-1
  6956						STOP^
  6957	034212	254 04 0 00 034213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6958	034213	324 00 0 00 034214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6959									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6960									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6961									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6962
  6963					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 69
DAKADM	MAC	19-JAN-77 13:41		XCT INSTRUCTION - BASIC TESTS                                                      SEQ 0165

  6964					SUBTTL	XCT INSTRUCTION - BASIC TESTS
  6965
  6966					;**********
  6967
  6968					;THIS TEST VERIFIES THAT XCT WILL EXECUTE THE INSTRUCTION SPECIFIED BY C(E)
  6969					;IN THIS CASE, C(E) SPECIFIES A MOVEI INSTRUCTION
  6970					;AFTER EXECUTING MOVEI, CONTROL SHOULD RETURN TO
  6971					;THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING XCT.
  6972					;THIS TEST PASSES IF CONTROL RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING XCT
  6973
  6974	034214	403 00 0 00 000001 	C20400:	SETZB	1		;CLEAR AC0 AND AC1
  6975	034215	256 00 0 00 034542 		XCT	[MOVEI 1,.+2]	;*XCT SHOULD RETURN CONTROL TO NEXT INSTRUCTION
  6976	034216	334 00 0 00 000000 		SKIPA
  6977						STOP^
  6978	034217	254 04 0 00 034220 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6979	034220	324 00 0 00 034221 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6980									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6981									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6982									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  6983
  6984					;**********
  6985
  6986					;THIS TEST VERIFIES THAT XCT WILL EXECUTE THE INSTRUCTION SPECIFIED BY C(E)
  6987					;IN THIS CASE, C(E) SPECIFIES A MOVEI INSTRUCTION.
  6988					;AFTER EXECUTING MOVEI, THE AC SPECIFIED BY MOVEI IS CHECKED FOR
  6989					;0,,1 (THE EXPECTED RESULT).  IF C(AC)=0,,1, THIS TEST PASSES
  6990
  6991	034221	403 00 0 00 000001 	C20500:	SETZB	1		;CLEAR AC
  6992	034222	256 00 0 00 034543 		XCT	[MOVEI 1,1]	;*XCT OF MOVEI SHOULD PLACE 1 IN THE AC
  6993	034223	302 01 0 00 000001 		CAIE	1,1		;PASS IF C(AC)=1
  6994						STOP^
  6995	034224	254 04 0 00 034225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6996	034225	324 00 0 00 034226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  6997									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  6998									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  6999									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7000
  7001					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 70
DAKADM	MAC	19-JAN-77 13:41		XCT INSTRUCTION - BASIC TESTS                                                      SEQ 0166

  7002					;THIS TEST VERIFIES THAT A NEST OF XCT INSTRUCTIONS WILL EXECUTE
  7003					;THE INSTRUCTION SPECIFIED BY THE MOST NESTED XCT AND RETURN CONTROL TO
  7004					;THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING THE FIRST XCT.
  7005					;IN THIS CASE, THE EXECUTED INSTRUCTION IS MOVEI.  AFTER EXECUTING THE MOVEI,
  7006					;C(AC) IS CHECKED FOR 0,,-1 (THE EXPECTED RESULT).  IF C(AC)=0,,-1, THIS TEST PASSES
  7007
  7008	034226	403 00 0 00 000001 	C20600:	SETZB	1		;CLEAR AC
  7009	034227	256 00 0 00 034550 		XCT	[XCT[XCT[XCT[XCT[MOVEI 1,-1]]]]] ;*NESTED XCT OF MOVEI
  7010									;SHOULD PLACE 0,,-1 INTO AC
  7011	034230	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(AC)=0,,-1
  7012						STOP^
  7013	034231	254 04 0 00 034232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7014	034232	324 00 0 00 034233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7015									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7016									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7017									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7018
  7019					;**********
  7020
  7021					;THIS TEST VERIFIES THAT XCT WILL NOT MODIFY AN AC WHICH IS NOT SPECIFIED BY THE
  7022					;EXECUTED INSTRUCTION.  IN THIS CASE, AC0 IS CLEARED AND THEN CHECKED FOR ZERO AFTER
  7023					;THE XCT INSTRUCTION IS EXECUTED.  AC0 SHOULD NOT BE MODIFIED.
  7024
  7025	034233	403 00 0 00 000001 	C20700:	SETZB	1		;CLEAR AC0,AC1
  7026	034234	256 00 0 00 034551 		XCT	[MOVE 1,[-1]]	;*XCT SHOULD NOT MODIFY AC0
  7027	034235	332 00 0 00 000000 		SKIPE			;PASS IF AC0 WAS NOT MODIFIED
  7028						STOP^
  7029	034236	254 04 0 00 034237 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7030	034237	324 00 0 00 034240 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7031									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7032									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7033									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7034
  7035					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 71
DAKADM	MAC	19-JAN-77 13:41		XCT INSTRUCTION - BASIC TESTS                                                      SEQ 0167

  7036					;THIS TEST VERIFIES THAT XCT OF SKIPA SHOULD RETURN CONTROL TO THE
  7037					;SECOND SEQUENTIAL INSTRUCTION FOLLOWING XCT
  7038
  7039	034240	256 00 0 00 034552 	C21000:	XCT	[SKIPA]		;XCT OF SKIPA SHOULD RETURN CONTROL TO .+2
  7040						STOP^
  7041	034241	254 04 0 00 034242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7042	034242	324 00 0 00 034243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7043									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7044									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7045									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7046
  7047					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 72
DAKADM	MAC	19-JAN-77 13:41		INDIRECT ADDRESSING - BASIC TESTS                                                  SEQ 0168

  7048					SUBTTL	INDIRECT ADDRESSING - BASIC TESTS
  7049
  7050					;**********
  7051
  7052					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
  7053					;ARE WITHIN THE AC RANGE.
  7054					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
  7055					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 0,
  7056					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
  7057
  7058	034243	476 00 0 00 000001 	C21100:	SETOM	1		;PRELOAD AC WITH -1,,-1
  7059	034244	201 07 0 00 000003 		MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
  7060	034245	402 00 0 00 000003 		SETZM	3		;PRELOAD INDIRECT ADDRESS WITH 0
  7061	034246	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESSS SHOULD
  7062									;PLACE 0 INTO THE AC
  7063	034247	332 00 0 00 000001 		SKIPE	1		;PASS IF C(AC)=0
  7064						STOP^
  7065	034250	254 04 0 00 034251 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7066	034251	324 00 0 00 034252 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7067									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7068									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7069									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7070
  7071					;**********
  7072
  7073					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
  7074					;ARE WITHIN THE AC RANGE.
  7075					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
  7076					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR -1,,-1,
  7077					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
  7078
  7079	034252	402 00 0 00 000001 	C21200:	SETZM	1		;PRELOAD AC WITH -1,,-1
  7080	034253	201 07 0 00 000003 		MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
  7081	034254	476 00 0 00 000003 		SETOM	3		;PRELOAD INDIRECT ADDRESS WITH -1,,-1
  7082	034255	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
  7083									;PLACE -1,,-1 INTO THE AC
  7084	034256	312 01 0 00 034466 		CAME	1,[-1,,-1]	;PASS IF C(AC)=-1,,-1
  7085						STOP^
  7086	034257	254 04 0 00 034260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7087	034260	324 00 0 00 034261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7088									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7089									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7090									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7091
  7092					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 73
DAKADM	MAC	19-JAN-77 13:41		INDIRECT ADDRESSING - BASIC TESTS                                                  SEQ 0169

  7093					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
  7094					;ARE WITHIN THE AC RANGE.
  7095					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
  7096					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 707070,,707070,
  7097					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
  7098
  7099	034261	402 00 0 00 000001 	C21300:	SETZM	1		;PRELOAD AC WITH 0
  7100	034262	201 07 0 00 000003 		MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
  7101	034263	200 03 0 00 034553 		MOVE	3,[707070,,707070] ;PRELOAD INDIRECT ADDRESS WITH 707070,,707070
  7102	034264	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
  7103									;PLACE 707070,,707070 INTO THE AC
  7104	034265	312 01 0 00 034553 		CAME	1,[707070,,707070]	;PASS IF C(AC)=707070,,707070
  7105						STOP^
  7106	034266	254 04 0 00 034267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7107	034267	324 00 0 00 034270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7108									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7109									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7110									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7111
  7112					;**********
  7113
  7114					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN E IS WITHIN THE AC RANGE
  7115					;AND @E IS BEYOND THE AC RANGE.
  7116					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
  7117					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 707070,,707070,
  7118					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
  7119
  7120	034270	254 00 0 00 034272 	C21400:	JRST	.+2
  7121	034271	707070	707070			XWD	707070,707070	;INDIRECT ADDRESS AND ITS DATA
  7122	034272	402 00 0 00 000001 		SETZM	1		;PRELOAD AC WITH 0
  7123	034273	201 07 0 00 034271 		MOVEI	7,C21400+1	;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
  7124	034274	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
  7125									;PLACE 707070,,707070 INTO AC
  7126	034275	312 01 0 00 034271 		CAME	1,C21400+1	;PASS IF C(AC)=707070,,707070
  7127						STOP^
  7128	034276	254 04 0 00 034277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7129	034277	324 00 0 00 034300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7130									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7131									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7132									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7133
  7134					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 74
DAKADM	MAC	19-JAN-77 13:41		INDIRECT ADDRESSING - BASIC TESTS                                                  SEQ 0170

  7135					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
  7136					;ARE BEYOND THE AC RANGE.
  7137					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
  7138					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 202020,,202020,
  7139					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
  7140
  7141	034300	254 00 0 00 034303 	C21500:	JRST	.+3
  7142	034301	000000	034302				.+1		;DIRECT ADDRESS AND ITS DATA
  7143	034302	202020	202020			XWD	202020,202020	;INDIRECT ADDRESS AND ITS DATA
  7144	034303	402 00 0 00 000001 		SETZM	1		;PRELOAD AC WITH 0
  7145	034304	200 01 1 00 034301 		MOVE	1,@C21500+1	;*FWT FROM INDIRECT ADDRESS SHOULD
  7146									;PLACE 202020,,202020 INTO AC
  7147	034305	312 01 0 00 034302 		CAME	1,C21500+2	;PASS IF C(AC)=202020,,202020
  7148						STOP^
  7149	034306	254 04 0 00 034307 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7150	034307	324 00 0 00 034310 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7151									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7152									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7153									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7154
  7155					;**********
  7156
  7157					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
  7158					;ARE BEYOND THE AC RANGE.
  7159					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A CAME.
  7160
  7161	034310	254 00 0 00 034313 	C21600:	JRST	.+3
  7162	034311	000000	034312				.+1		;DIRECT ADDRESS AND ITS DATA
  7163	034312	272727	272727			XWD	272727,272727	;INDIRECT ADDRESS AND ITS DATA
  7164	034313	200 01 0 00 034312 		MOVE	1,C21600+2	;PRELOAD AC
  7165	034314	312 01 1 00 034311 		CAME	1,@C21600+1	;*CAME OF DATA FROM INDIRECT ADDRESS - NON-AC RANGE
  7166						STOP^
  7167	034315	254 04 0 00 034316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7168	034316	324 00 0 00 034317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7169									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7170									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7171									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7172
  7173					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 75
DAKADM	MAC	19-JAN-77 13:41		INDIRECT ADDRESSING - BASIC TESTS                                                  SEQ 0171

  7174					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN E IS WITHIN THE AC RANGE
  7175					;AND @E IS BEYOND THE AC RANGE.
  7176					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A CAME.
  7177
  7178	034317	254 00 0 00 034321 	C21700:	JRST	.+2
  7179	034320	252525	252525			XWD	252525,252525	;INDIRECT ADDRESS AND ITS DATA
  7180	034321	201 07 0 00 034320 		MOVEI	7,C21700+1	;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
  7181	034322	200 01 0 00 034320 		MOVE	1,C21700+1	;SETUP AC
  7182	034323	312 01 1 00 000007 		CAME	1,@7		;*CAME IF DATA FROM INDIRECT ADDRESS - AC RANGE
  7183						STOP^
  7184	034324	254 04 0 00 034325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7185	034325	324 00 0 00 034326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7186									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7187									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7188									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7189
  7190					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 76
DAKADM	MAC	19-JAN-77 13:41		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0172

  7191					SUBTTL	TEST INDIRECT ADDRESSING WITH INDEXING
  7192
  7193					;SETUP INDEX REGISTERS
  7194
  7195	034326	201 01 0 00 777774 		MOVEI	1,-4
  7196	034327	201 03 0 00 000002 		MOVEI	3,2
  7197	034330	201 04 0 00 000010 		MOVEI	4,10
  7198	034331	201 05 0 00 000001 		MOVEI	5,1
  7199	034332	201 06 0 00 000005 		MOVEI	6,5
  7200	034333	201 07 0 00 000007 		MOVEI	7,7
  7201	034334	201 10 0 00 000004 		MOVEI	10,4
  7202	034335	201 11 0 00 777772 		MOVEI	11,-6
  7203	034336	201 12 0 00 000005 		MOVEI	12,5
  7204	034337	201 13 0 00 000002 		MOVEI	13,2
  7205
  7206	034340	254 00 0 00 034371 		JRST	C22000		;RESUME TEST
  7207
  7208					;INDIRECT ADDRESSING/INDEXING TEST TABLE
  7209
  7210					;;;;;;;;;;;          ;;;;;;;;;;          ;;;;;;;;;;
  7211
  7212					;DO NOT MODIFY THIS TABLE OR TESTS C21700 THRU C22600 INDEPENDENTLY !
  7213
  7214					;;;;;;;;;;          ;;;;;;;;;;          ;;;;;;;;;;
  7215
  7216	034341	000003	034344		E217:		E217A(3)
  7217	034342	000020	034347		E220:		@E220A
  7218	034343	220220	220220		E220B:	220220,,220220
  7219	034344	000020	034351		E217A:		@E221A		;E221-4
  7220	034345	221221	221221		E221B:	221221,,221221
  7221	034346	217217	217217		E222A:	217217,,217217		;E217A+2
  7222	034347	000000	034343		E220A:		E220B
  7223	034350	000000	034350		E221:		E221
  7224	034351	000000	034345		E221A:		E221B
  7225	034352	000000	034350		E222:		E221
  7226	034353	223223	223223		E223A:	223223,,223223
  7227	034354	000004	034354		E224A:		E224A(4)	;E223-6
  7228	034355	222222	222222			222222,,222222		;E222A+7
  7229	034356	000000	034356		E225:		E225
  7230	034357	000007	034346				E222A(7)	;E222+5
  7231	034360	000020	034363				@E225A		;E225+2
  7232	034361	225225	225225		E225B:	225225,,225225
  7233	034362	000000	034362		E223:		E223
  7234	034363	000000	034361		E225A:		E225B
  7235	034364	224224	224224			224224,,224224		;E224A+10
  7236	034365	226226	226226		E226B:	226226,,226226
  7237	034366	000000	034353				E223A		;E223+4
  7238	034367	000025	034367		E226A:		@E226A(5)	;E223+5
  7239	034370	000000	034365				E226B		;E226A+1
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 77
DAKADM	MAC	19-JAN-77 13:41		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0173

  7240					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
  7241					LY.
  7242					;IN THIS CASE, MOVE 2,@E217 IS TESTED WHERE C(E217)=E217A(3) AND C(3)=0,,2.
  7243					;HENCE, THE RESULT IN THE AC SHOULD BE C(E217A+2)=217217,,217217
  7244
  7245	034371	476 00 0 00 000002 	C22000:	SETOM	2		;INITIALIZE AC
  7246	034372	200 02 1 00 034341 		MOVE	2,@E217		;TEST INDIRECT ADDRESSING WITH INDEXING
  7247	034373	312 02 0 00 034346 		CAME	2,E217A+2	;PASS IF C(AC)=217217,,217217
  7248						STOP^
  7249	034374	254 04 0 00 034375 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7250	034375	324 00 0 00 034376 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7251									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7252									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7253									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7254
  7255					;**********
  7256
  7257					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
  7258					LY.
  7259					;IN THIS CASE, MOVE 2,@E220 IS TESTED WHERE C(E220)=@E220A AND C(E220A)=E220B.
  7260					;HENCE, THE RESULT IN THE AC SHOULD BE C(E220B)=220220,,220220
  7261
  7262	034376	402 00 0 00 000002 	C22100:	SETZM	2		;INITIALIZE AC
  7263	034377	200 02 1 00 034342 		MOVE	2,@E220		;TEST INDIRECT ADDRESSING WITH INDEXING
  7264	034400	312 02 0 00 034343 		CAME	2,E220B		;PASS IF C(AC)=220220,,220220
  7265						STOP^
  7266	034401	254 04 0 00 034402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7267	034402	324 00 0 00 034403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7268									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7269									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7270									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7271
  7272					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 78
DAKADM	MAC	19-JAN-77 13:41		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0174

  7273					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
  7274					LY.
  7275					;IN THIS CASE,E221(1) 2,@E217 IS TESTED WHERE C(1)=-4 AND E221-4=E217A
  7276					;HENCE, THE RESULT IN THE AC SHOULD BE C(E217A)=@E221A=20,,E221A
  7277
  7278	034403	476 00 0 00 000002 	C22200:	SETOM	2		;INITIALIZE AC
  7279	034404	200 02 0 01 034350 		MOVE	2,E221(1)	;TEST INDIRECT ADDRESSING WITH INDEXING
  7280	034405	312 02 0 00 034344 		CAME	2,E217A		;PASS IF C(AC)=@E221A=20,,E221A
  7281						STOP^
  7282	034406	254 04 0 00 034407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7283	034407	324 00 0 00 034410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7284									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7285									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7286									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7287
  7288					;**********
  7289
  7290					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
  7291					LY.
  7292					;IN THIS CASE, MOVE 2,E222(6) IS TESTED WHERE C(6)=5
  7293					;HENCE, THE RESULT IN THE AC SHOULD BE C(E222+5)=E222A(7)=7,,E222A
  7294
  7295	034410	402 00 0 00 000002 	C22300:	SETZM	2		;INITIALIZE AC
  7296	034411	200 02 0 06 034352 		MOVE	2,E222(6)	;TEST INDIRECT ADDRESSING WITH INDEXING
  7297	034412	312 02 0 00 034357 		CAME	2,E222+5	;PASS IF C(AC)=E222A(7)=7,,E222A
  7298						STOP^
  7299	034413	254 04 0 00 034414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7300	034414	324 00 0 00 034415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7301									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7302									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7303									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7304
  7305					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 79
DAKADM	MAC	19-JAN-77 13:41		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0175

  7306					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
  7307					LY.
  7308					;IN THIS CASE, MOVE 2,@E223(10) IS TESTED WHERE C(10)=4 AND C(E223+4)=E223A
  7309					;HENCE, THE RESULT IN THE AC SHOULD BE C(E223A)=223223,,223223
  7310
  7311	034415	476 00 0 00 000002 	C22400:	SETOM	2		;INITIALIZE AC
  7312	034416	200 02 1 10 034362 		MOVE	2,@E223(10)	;TEST INDIRECT ADDRESSING WITH INDEXING
  7313	034417	312 02 0 00 034353 		CAME	2,E223A		;PASS IF C(AC)=223223,,223223
  7314						STOP^
  7315	034420	254 04 0 00 034421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7316	034421	324 00 0 00 034422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7317									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7318									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7319									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7320
  7321					;**********
  7322
  7323					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
  7324					LY.
  7325					;IN THIS CASE, MOVE 2,@E223(11) IS TESTED WHERE C(11)=-6, C(E223-6)=E224A(4) AND C(4)=10
  7326					;HENCE, THE RESULT IN THE AC SHOULD BE C(E224A+10)=224224,,224224
  7327
  7328	034422	402 00 0 00 000002 	C22500:	SETZM	2		;INITIALIZE AC
  7329	034423	200 02 1 11 034362 		MOVE	2,@E223(11)	;TEST INDIRECT ADDRESSING WITH INDEXING
  7330	034424	312 02 0 00 034364 		CAME	2,E224A+10	;PASS IF C(AC)=224224,,224224
  7331						STOP^
  7332	034425	254 04 0 00 034426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7333	034426	324 00 0 00 034427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7334									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7335									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7336									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7337
  7338					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 80
DAKADM	MAC	19-JAN-77 13:41		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0176

  7339					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
  7340					LY.
  7341					;IN THIS CASE, MOVE 2,@E225(13) IS TESTED WHERE C(13)=2, C(E225+2)=@E225A
  7342					;AND C(E225A)=E225B
  7343					;HENCE, THE RESULT IN THE AC SHOULD BE C(E225B)=225225,,225225
  7344
  7345	034427	476 00 0 00 000002 	C22600:	SETOM	2		;INITIALIZE AC
  7346	034430	200 02 1 13 034356 		MOVE	2,@E225(13)	;TEST INDIRECT ADDRESSING WITH INDEXING
  7347	034431	312 02 0 00 034361 		CAME	2,E225B		;PASS IF C(AC)=225225,,225225
  7348						STOP^
  7349	034432	254 04 0 00 034433 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7350	034433	324 00 0 00 034434 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7351									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7352									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7353									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7354
  7355					;**********
  7356
  7357					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECT
  7358					LY.
  7359					;IN THIS CASE, MOVE 2,@E223(12) IS TESTED WHERE C(12)=5, C(E223+5)=@E226A(5),
  7360					;C(5)=1 AND C(E226A+1)=E226B
  7361					;HENCE, THE RESULT IN THE AC SHOULD BE C(E226B)=226226,,226226
  7362
  7363	034434	402 00 0 00 000002 	C22700:	SETZM	2		;INITIALIZE AC
  7364	034435	200 02 1 12 034362 		MOVE	2,@E223(12)	;TEST INDIRECT ADDRESSING WITH INDEXING
  7365	034436	312 02 0 00 034365 		CAME	2,E226B		;PASS IF C(AC)=226226,,226226
  7366						STOP^
  7367	034437	254 04 0 00 034440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7368	034440	324 00 0 00 034441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  7369									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  7370									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  7371									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  7372
  7373					;**********
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 81
DAKADM	MAC	19-JAN-77 13:41		TEST INDIRECT ADDRESSING WITH INDEXING                                             SEQ 0177

  7374
  7375	034441	254 00 0 00 030057 		JRST	BEGEND
  7376					SUBTTL	*STOR* RESERVED STORAGE, JAN 18,1977
  7377
  7378					;PROGRAM LITERALS
  7379
  7380						XLIST
  7381					IFNDEF	$LPAPER,<LIST>
  7382	034442					LIT
  7383	034442	000001	000001
  7384	034443	254 00 0 00 030741
  7385	034444	000001	000000
  7386	034445	000002	000000
  7387	034446	000004	000000
  7388	034447	000010	000000
  7389	034450	000020	000000
  7390	034451	000040	000000
  7391	034452	000100	000000
  7392	034453	000200	000000
  7393	034454	000400	000000
  7394	034455	001000	000000
  7395	034456	002000	000000
  7396	034457	004000	000000
  7397	034460	010000	000000
  7398	034461	020000	000000
  7399	034462	040000	000000
  7400	034463	100000	000000
  7401	034464	200000	000000
  7402	034465	400000	000000
  7403	034466	777777	777777
  7404	034467	777777	777776
  7405	034470	777777	777775
  7406	034471	777777	777773
  7407	034472	777777	777767
  7408	034473	777777	777757
  7409	034474	777777	777737
  7410	034475	777777	777677
  7411	034476	777777	777577
  7412	034477	777777	777377
  7413	034500	777777	776777
  7414	034501	777777	775777
  7415	034502	777777	773777
  7416	034503	777777	767777
  7417	034504	777777	757777
  7418	034505	777777	737777
  7419	034506	777777	677777
  7420	034507	777777	577777
  7421	034510	777777	377777
  7422	034511	777776	777777
  7423	034512	777775	777777
  7424	034513	777773	777777
  7425	034514	777767	777777
  7426	034515	777757	777777
  7427	034516	777737	777777
  7428	034517	777677	777777
DAKAD PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) 0,2	MACRO %52(537) 14:33 19-JAN-77 PAGE 1
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 0178

  7429	034520	777577	777777
  7430	034521	777377	777777
  7431	034522	776777	777777
  7432	034523	775777	777777
  7433	034524	773777	777777
  7434	034525	767777	777777
  7435	034526	757777	777777
  7436	034527	737777	777777
  7437	034530	677777	777777
  7438	034531	577777	777777
  7439	034532	377777	777777
  7440	034533	777777	000000
  7441	034534	000000	777777
  7442	034535	252525	252525
  7443	034536	000000	000000
  7444	034537	254 04 0 00 032743
  7445	034540	377777	377777
  7446	034541	400000	400000
  7447	034542	201 01 0 00 034217
  7448	034543	201 01 0 00 000001
  7449	034544	201 01 0 00 777777
  7450	034545	256 00 0 00 034544
  7451	034546	256 00 0 00 034545
  7452	034547	256 00 0 00 034546
  7453	034550	256 00 0 00 034547
  7454	034551	200 01 0 00 034466
  7455	034552	334 00 0 00 000000
  7456	034553	707070	707070
  7457						LIST
  7458	034554	000000	000000		ENDSLD:	0
  7459
  7460					IFDEF	DEBUG,<
  7461	034555				PATCH:	BLOCK DEBUG		;PATCHING AREA
  7462					>
  7463
  7464					;PROGRAM VARIABLES
  7465	034655					VAR
  7466
  7467					IFDEF	PGMEND,<
  7468	034655	000000	000000		END:	0
  7469			030000			END	BEGIN	>

NO ERRORS DETECTED

PROGRAM BREAK IS 000000
ABSLUTE BREAK IS 034656
CPU TIME USED 00:28.911

11K CORE USED
