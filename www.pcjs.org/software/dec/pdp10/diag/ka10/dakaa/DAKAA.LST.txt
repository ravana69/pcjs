DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 1
DAKAAT	MAC	19-JAN-77 13:31		DIAGNOSTIC PARAMETERS                                                              SEQ 0007

     1					;DAKAA
     2
     3
     4
     5			000002			DECVER==2
     6			000000			MCNVER==0
     7
     8						XLIST
     9						LIST
    10						LALL
    11						NAME	\MCNVER,\DECVER^
    12
    13					TITLE	DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2
    14					^
    15
    16					;TEST DESIGNED FOR INITIAL DEBUGGING OF PROCESSOR HARDWARE
    17					;AND TO DETECT (SOLID) FAILURES IN THE FIELD.
    18
    19					;COPYRIGHT 1972,1977
    20					;DIGITAL EQUIPMENT CORPORATION
    21					;MARLBORO, MASS. 01752
    22
    23					;JOHN R. KIRCHOFF
    24					;DICK MALISKA
    25
    26	000137					LOC	137
    27	000137	000000	000002			MCNVER,,DECVER
    28
    29						NOSYM
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 2
DAKAAT	MAC	19-JAN-77 13:31		DIAGNOSTIC PARAMETERS                                                              SEQ 0008

    30					SUBTTL	DIAGNOSTIC PARAMETERS
    31
    32					;PARAMETER DEFINITIONS
    33			000001		EXCASB==1
    34			000001		USRASB==1
    35			000001		KA10==1
    36
    37					;FLAG DEFINITIONS
    38			010000		USERF=10000		;USER MODE FLAG
    39
    40
    41					;MACROS
    42
    43					; STOP - USED FOR SCOPE LOOP, IF INSTRUCTION FAILS, CHANGE (JUMPA .+1)
    44					;	 TO A (JUMPA .-X) TO CYCLE ON FAILING INSTRUCTION
    45
    46					DEFINE	STOP	(A)<
    47						HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
    48						JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
    49									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
    50									;IN THE SUBTEST) TO LOOP ON ERROR>
    51
    52					;SPECIAL FEATURE PARAMETERS
    53
    54			030742		SADR1=A00
    55			030742		SADR2=A00
    56			030742		SADR3=A00
    57			030742		SADR4=A00
    58		254000	030742		SADR5=JRST A00
    59		254000	030742		SADR6=JRST A00
    60		254000	030742		SADR7=JRST A00
    61		254000	030742		SADR8=JRST A00
    62		254000	030742		SADR9=JRST A00
    63		254000	030742		SADR10=JRST A00
    64		254000	030742		SADR11=JRST A00
    65
    66			000000		PAREA0=0
    67			000000		PAREA1=0
    68			000000		PAREA2=0
    69		444153	414100		PAREA3=SIXBIT/DAKAA/
    70		645560	000000		PAREA4=SIXBIT/TMP/
    71			000000		PAREA5=0
    72			000000		PAREA6=0
    73			001000		ITERAT==1000
    74		777777	777777		PGMEND==-1
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 1
PARAM	KLM	18-JAN-77 11:38		*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, JAN 18,1977                               SEQ 0009

    75					SUBTTL	*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, JAN 18,1977
    76
    77					DEFINE	S,<;*********************************************************************>
    78
    79					S^;*********************************************************************^
    80					;*DATA SWITCHES (READ FROM CONSOLE IN EXEC MODE OR TYPED IN IN USER MODE)
    81					;*LEFT HALF SWITCHES ARE PRE-ASSIGNED FOR SUBROUTINE PACKAGE USE
    82					;*AND CONTROL LOOPING, PRINTING (TTY OR OTHER DEVICE) AND MISC. FUNCTIONS
    83					S^;*********************************************************************^
    84
    85			400000		ABORT==	400000			;ABORT PROGRAM ON PASS COMPLETION
    86			200000		RSTART==200000			;RESTART TEST, PRINT TOTALS
    87			100000		TOTALS==100000			;PRINT TOTALS, CONTINUE
    88
    89			040000		NOPNT==	040000			;INHIBIT ALL PRINT/TYPE OUT (EXCEPT FORCED)
    90			020000		PNTLPT==020000			;PRINT ALL DATA ON LPT (LOGICAL DEVICE, USER MODE)
    91			010000		DING==	010000			;RING BELL ON ERROR
    92
    93			004000		LOOPER==004000			;ENTER EXERCISE/CHECK LOOP ON ERROR
    94			002000		ERSTOP==002000			;HALT ON TEST ERROR
    95			001000		PALERS==001000			;PRINT ALL ERRORS
    96
    97			000400		RELIAB==000400			;RELIABILITY MODE
    98			000200		TXTINH==000200			;INHIBIT ERROR TEXT
    99			000100		INHPAG==000100			;INHIBIT PAGING
   100
   101			000040		MODDVC==000040			;MODIFY DEVICE CODE
   102			000020		INHCSH==000020			;INHIBIT CACHE
   103			000010		OPRSEL==000010			;OPERATOR SELECTION
   104
   105			000004		CHAIN==	000004			;CHAIN CONTROL SWITCH
   106
   107			000002		KAHZ50==000002			;KA10 50 HERTZ POWER
   108
   109									;SWITCH 17 RESERVED !!!
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 2
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0010

   110					SUBTTL	*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977
   111
   112					S^;*********************************************************************^
   113					;*SPECIAL SUBPROGRAM LINKAGES
   114					S^;*********************************************************************^
   115
   116			027772		FSELNK=	27772	;FILE SELECT LINK
   117			027773		FRDLNK=	27773	;FILE READ LINK
   118			027774		LDLNK=	27774	;LOAD LINKAGE ADDRESS
   119			027775		DDTLNK=	27775	;DDT LINKAGE ADDRESS
   120			027776		MODLNK=	27776	;OPERATIONAL MODE CHECK LINKAGE ADDRESS
   121			027777		SUBLNK=	27777	;SUBROUTINE LINKAGE ADDRESS
   122
   123					S^;*********************************************************************^
   124					;*SPECIAL SUBROUTINE FATAL HALTS
   125					;*USED TO REPORT ERRORS THAT CAUSE THE SUBROUTINES TO BE UNUSABLE
   126					S^;*********************************************************************^
   127
   128					;ADDRESS   TAG	REASON
   129					;---------------------
   130
   131					; 1010 	NOEXEC	;PROGRAM NOT CODED FOR EXEC MODE OPERATION
   132					; 1011  PLERR	;FATAL PUSH LIST POINTER ERROR
   133					; 1012  PLERR1	;INITIAL PUSH LIST POINTER ERROR
   134					; 1013  MUOERR	;MUUO WITH LUUO HANDLER WIPED OUT
   135					; 1014  DTEBER	;DTE20 INTERRUPT WITHOUT DOORBELL
   136					; 1015  DTECER	;DTE20 CLOCK INTERRUPT WITHOUT FLAG SET
   137					; 1016  CPIERR	;CPU INITIALIZATION ERROR
   138					; 1017  EOPERR	;END OF PROGRAM ERROR
   139					; 1020  LUOERR	;INTERRUPT WITH LUUO HANDLER WIPED OUT
   140
   141					S^;*********************************************************************^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 3
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0011

   142					S^;*********************************************************************^
   143					;OPERATOR DEFINITIONS (NON-UUO'S)
   144					S^;*********************************************************************^
   145
   146		260740	000000		OPDEF	GO	[PUSHJ	P,]	;SUBROUTINE CALL
   147		263740	000000		OPDEF	RTN	[POPJ	P,]	;SUBROUTINE RETURN
   148		261740	000000		OPDEF	PUT	[PUSH	P,]	;PUT DATA ON PUSH LIST
   149		262740	000000		OPDEF	GET	[POP	P,]	;GET DATA FROM PUSH LIST
   150		254000	000000		OPDEF	PJRST	[JRST	]	;JRST TO ROUTINE THAT RTN'S
   151		254200	000000		OPDEF	HALT	[JRST	4,]	;DEFINITION FOR DDT
   152		254100	000000		OPDEF	JRSTF	[JRST	2,]	;DEFINITION FOR DDT
   153		254500	000000		OPDEF	JEN	[JRST	12,]	;DEFINITION FOR DDT
   154
   155					S^;*********************************************************************^
   156					;*SUBROUTINE INITIALIZATION CALL
   157					S^;*********************************************************************^
   158
   159		265000	030011		OPDEF	PGMINT	[JSP	0,SBINIT]	;SUBROUTINE INITIALIZATION
   160
   161					S^;*********************************************************************^
   162					;*HALTING UUO'S (A MORE GRACEFUL HALT THAN SIMPLY USING THE HALT INSTRUCTION).
   163					S^;*********************************************************************^
   164
   165		037640	000004		OPDEF	FATAL	[37B8!15B12!4]	;FATAL PROGRAMMING HALT
   166		037600	000004		OPDEF	ERRHLT	[37B8!14B12!4]	;PROGRAM ERROR HALT
   167
   168					S^;*********************************************************************^
   169					;*TERMINAL INPUT UUO'S
   170					;*ALWAYS COME FROM THE CONSOLE TERMINAL IN EXEC MODE OR THE
   171					;*CONTROLLING TERMINAL (REAL TERMINAL OR PTY) IN USER MODE.
   172					S^;*********************************************************************^
   173
   174		037000	000003		OPDEF	TTICHR 	[37B8!0B12!3]	;TTY, INPUT ANY CHARACTER
   175		037040	000003		OPDEF	TTIYES	[37B8!1B12!3]	;TTY, NORMAL RETURN Y
   176		037100	000003		OPDEF	TTINO	[37B8!2B12!3]	;TTY, NORMAL RETURN N
   177		037140	000003		OPDEF	TTIOCT	[37B8!3B12!3]	;TTY, INPUT OCTAL WORD
   178		037200	000003		OPDEF	TTIDEC	[37B8!4B12!3]	;TTY, INPUT DECIMAL WORD
   179		037240	000003		OPDEF	TTICNV	[37B8!5B12!3]	;TTY, INPUT CONVERTABLE WORD
   180		037300	000003		OPDEF	TTLOOK	[37B8!6B12!3]	;TTY, KEYBOARD CHECK
   181		037340	000003		OPDEF	TTALTM	[37B8!7B12!3]	;TTY, ALT-MODE CHECK
   182		037400	000003		OPDEF	TTSIXB	[37B8!10B12!3]	;TTY, INPUT SIXBIT WORD
   183		037440	000003		OPDEF	TTYINP	[37B8!11B12!3]	;TTY, IMAGE MODE INPUT
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 4
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0012

   184					;*TERMINAL OUTPUT UUO'S.
   185
   186		037000	000000		OPDEF	PNTA	[37B8!0B12!0]	;PRINT ASCII WORD
   187		037000	000001		OPDEF	PNTAF	[37B8!0B12!1]	;PRINT ASCII WORD FORCED
   188		037740	000000		OPDEF	PNTAL	[37B8!17B12!0]	;PRINT ASCIZ LINE
   189		037740	000001		OPDEF	PNTALF	[37B8!17B12!1]	;PRINT ASCIZ LINE FORCED
   190		037600	000003		OPDEF	PSIXL	[37B8!14B12!3]	;PRINT SIXBIT'Z LINE
   191		037640	000003		OPDEF	PSIXLF	[37B8!15B12!3]	;PRINT SIXBIT'Z LINE FORCED
   192		037000	000000		OPDEF	PNTMSG	[37B8!0B12!0]	;PRINT MESSAGE IMMEDIATE
   193		037040	000000		OPDEF	PNTMSF	[37B8!1B12!0]	;PRINT MESSAGE IMMEDIATE FORCED
   194		037100	000000		OPDEF	PSIXM	[37B8!2B12!0]	;PRINT SIXBIT'Z MSG IMMEDIATE
   195		037200	000000		OPDEF	PSIXMF	[37B8!4B12!0]	;PRINT SIXBIT'Z MSG IMM FORCED
   196		037000	000000		OPDEF	PNTCI	[37B8!0B12!0]	;PRINT CHARACTER IMMEDIATE
   197		037040	000000		OPDEF	PNTCIF	[37B8!1B12!0]	;PRINT CHARACTER IMMEDIATE FORCED
   198		037500	000000		OPDEF	PNTCHR	[37B8!12B12!0]	;PRINT CHARACTER
   199		037500	000001		OPDEF	PNTCHF	[37B8!12B12!1]	;PRINT CHARACTER FORCED
   200		037040	000000		OPDEF	PNT1	[37B8!1B12!0]	;PRINT ONE OCTAL DIGIT
   201		037040	000001		OPDEF	PNT1F	[37B8!1B12!1]	;PRINT 1 OCTAL DIGIT FORCED
   202		037100	000000		OPDEF	PNT2	[37B8!2B12!0]	;PRINT TWO OCTAL DIGITS
   203		037100	000001		OPDEF	PNT2F	[37B8!2B12!1]	;PRINT 2 OCTAL DIGITS FORCED
   204		037140	000000		OPDEF	PNT3	[37B8!3B12!0]	;PRINT THREE OCTAL DIGITS
   205		037140	000001		OPDEF	PNT3F	[37B8!3B12!1]	;PRINT THREE OCTAL DIGITS FORCED
   206		037200	000000		OPDEF	PNT4	[37B8!4B12!0]	;PRINT FOUR OCTAL DIGITS
   207		037200	000001		OPDEF	PNT4F	[37B8!4B12!1]	;PRINT FOUR OCTAL DIGITS FORCED
   208		037240	000000		OPDEF	PNT5	[37B8!5B12!0]	;PRINT FIVE OCTAL DIGITS
   209		037240	000001		OPDEF	PNT5F	[37B8!5B12!1]	;PRINT FIVE OCTAL DIGITS FORCED
   210		037300	000000		OPDEF	PNT6	[37B8!6B12!0]	;PRINT SIX OCTAL DIGITS
   211		037300	000001		OPDEF	PNT6F	[37B8!6B12!1]	;PRINT SIX OCTAL DIGITS FORCED
   212		037340	000000		OPDEF	PNT7	[37B8!7B12!0]	;PRINT 7 OCTAL DIGITS
   213		037340	000001		OPDEF	PNT7F	[37B8!7B12!1]	;PRINT 7 OCTAL DIGITS FORCED
   214		037440	000000		OPDEF	PNT11	[37B8!11B12!0]	;PRINT 11 OCTAL DIGITS
   215		037440	000001		OPDEF	PNT11F	[37B8!11B12!1]	;PRINT 11 OCTAL DIGITS FORCED.
   216		037400	000000		OPDEF	PNTADR	[37B8!10B12!0]	;PRINT PHYSICAL ADDRESS
   217		037400	000001		OPDEF	PNTADF	[37B8!10B12!1]	;PRINT PHYSICAL ADDRESS FORCED
   218		037600	000000		OPDEF	PNTOCT  [37B8!14B12!0]	;PRINT FULL WORD OCTAL
   219		037600	000001		OPDEF	PNTOTF	[37B8!14B12!1]	;PRINT FULL WORD OCTAL FORCED
   220		037540	000000		OPDEF	PNTHW	[37B8!13B12!0]	;PRINT OCTAL HALF WORDS, 6 SP 6
   221		037540	000001		OPDEF	PNTHWF	[37B8!13B12!1]	;PRINT OCTAL HALF WORDS, 6 SP 6 FORCED
   222		037700	000003		OPDEF	PNTOCS	[37B8!16B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S
   223		037740	000003		OPDEF	PNTOCF	[37B8!17B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S FORCED
   224		037640	000000		OPDEF	PNTDEC	[37B8!15B12!0]	;PRINT DECIMAL, SUPRESS LEADING 0'S
   225		037640	000001		OPDEF	PNTDCF	[37B8!15B12!1]	;PRINT DECIMAL, SUPRESS LEADING 0'S FORCED
   226		037700	000000		OPDEF	PNTDS	[37B8!16B12!0]	;PRINT DECIMAL, SPACES FOR LD 0'S
   227		037700	000001		OPDEF	PNTDSF	[37B8!16B12!1]	;PRINT DECIMAL, SPACES FOR LD 0'S FORCED
   228		037200	000002		OPDEF	PNTNM	[37B8!4B12!2]	;PRINT PROGRAM NAME
   229		037000	000002		OPDEF	PNTSIX	[37B8!0B12!2]	;PRINT SIXBIT WORD
   230		037040	000002		OPDEF	PNTSXF	[37B8!1B12!2]	;PRINT SIXBIT WORD FORCED
   231		037240	000002		OPDEF	DROPDV	[37B8!5B12!2]	;CLOSE LOGICAL FILE, USER MODE
   232		037100	000002		OPDEF	PNTCW	[37B8!2B12!2]	;PRINT DF10 CONTROL WORD
   233		037140	000002		OPDEF	PNTCWF	[37B8!3B12!2]	;PRINT DF10 CONTROL WORD FORCED
   234		037000	030242		OPDEF	PCRL	[37B8!0B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED
   235		037040	030242		OPDEF	PCRLF	[37B8!1B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED FORCED
   236		037000	000040		OPDEF	PSP	[37B8!0B12!40]	;PRINT SPACE
   237		037040	000040		OPDEF	PSPF	[37B8!1B12!40]	;PRINT SPACE FORCED
   238		037000	030243		OPDEF	PCRL2	[37B8!0B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE)
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 4-1
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0013

   239		037040	030243		OPDEF	PCRL2F	[37B8!1B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE) FORCED
   240		037040	000007		OPDEF	PBELL	[37B8!1B12!7]	;PRINT TTY BELL
   241
   242		037040	000026		OPDEF	PFORCE	[37B8!1B12!26]	;PRINT FORCE, CONTROL O OVERRIDE
   243
   244					DEFINE	PMSG	(ARG),<
   245						PSIXM	[SIXBIT\ARG'_\]>
   246
   247					DEFINE	PMSGF	(ARG),<
   248						PSIXMF	[SIXBIT\ARG'_\]>
   249
   250					;*SIXBTZ -- MACRO TO GENERATE SIXBIT DATA FOR PRINTING
   251					;*	CONSERVES CORE OVER ASCIZ
   252
   253					DEFINE	SIXBTZ	(ARG),<	[SIXBIT\ARG'_\]>
   254
   255					;*CONSOLE SWITCH INPUT UUO.
   256					;*READS CONSOLE SWITCHES IF IN EXEC MODE OR ASKS FOR THEM IF
   257					;* USER MODE.
   258
   259		037400	000002		OPDEF	SWITCH	[37B8!10B12!2]	;INPUT CONSOLE SWITCHES
   260
   261					;*CLOCK INITIALIZATION UUO - TO SET DESIRED CLOCK OPERATION
   262					;*EITHER IGNORE CLOCK, ONLY LET IT TICK OR CAUSE INTERRUPT TO OCCUR.
   263
   264		037540	000004		OPDEF	CLOKOP	[37B8!13B12!4]	;CLOCK OPERATION UUO - PDP-11 CLOCK
   265		037200	000004		OPDEF	MTROP	[37B8!4B12!4]	;CLOCK OPERATION UUO - DK20 METER
   266
   267					;*KL10 ONLY CACHE OPERATION UUO'S
   268
   269		037040	000004		OPDEF	CINVAL	[37B8!1B12!4]	;CACHE INVALIDATE
   270		037100	000004		OPDEF	CFLUSH	[37B8!2B12!4]	;CACHE FLUSH
   271		037140	000004		OPDEF	CWRTBI	[37B8!3B12!4]	;CACHE WRITE-BACK & INVALIDATE
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 5
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0014

   272					;*END OF PASS/PROGRAM UUOS
   273
   274					;PERFORMS THE END OF PASS FUNCTIONS. INCREMENT PASS COUNT,
   275					;*DECREMENT ITERATION COUNT, CHECK IF FINISHED WITH THIS PROGRAM ETC.
   276
   277		037500	000004		OPDEF	ENDUUO	[37B8!12B12!4]	;UUO TO DISPLAY LIGHTS
   278		037700	000004		OPDEF	EOPUUO	[37B8!16B12!4]	;END OF PROGRAM UUO
   279
   280					;*MEMORY MANAGEMENT UUO'S
   281					;*UUO'S TO PERFORM VARIOUS MEMORY FUNCTIONS. MAPPING, ZEROING, PAGING,
   282					;*ADDRESS CONVERSION, ETC...
   283
   284		037000	000004		OPDEF	MAPMEM	[37B8!0B12!4]	;MAP MEMORY
   285		037500	000002		OPDEF	MEMZRO	[37B8!12B12!2]	;ZERO MEMORY
   286		037440	000002		OPDEF	MEMSEG	[37B8!11B12!2]	;SETUP MEMORY SEGMENT
   287		037540	000002		OPDEF	MAPADR	[37B8!13B12!2]	;VIRTUAL TO PHYSICAL ADR CONVERT
   288		037640	000002		OPDEF	MAPCNK	[37B8!15B12!2]	;MAP MEMORY CHUNK
   289		037600	000002		OPDEF	MAPSET	[37B8!14B12!2]	;SET KI10 EXEC PAGE MAP
   290		037740	000002		OPDEF	MAPPNT	[37B8!17B12!2]	;PRINT MEMORY MAP
   291
   292					;*DEVICE CODE MODIFICATION UUO
   293					;*ALLOWS THE MODIFICATION OF IOT'S TO ONE DEVICE TO BE CHANGED TO
   294					;*IOT'S TO A DIFFERENT DEVICE CODE.
   295
   296		037340	000002		OPDEF	MODPCU	[37B8!7B12!2]	;MODIFY PERHIPERAL CODE, USER
   297		037300	000002		OPDEF	MODPCP	[37B8!6B12!2]	;MODIFY PERHIPERAL CODE, PROGRAM
   298
   299			030000			IFNDEF	MODDVL,<MODDVL==BEGIN>
   300			030000			IFNDEF	MODDVU,<MODDVU==BEGIN>
   301
   302					;*"DIAMON" FILE SELECTION AND READ UUOS
   303
   304		037240	000004		OPDEF	FSELECT	[37B8!5B12!4]	;FILE SELECTION
   305		037300	000004		OPDEF	FREAD	[37B8!6B12!4]	;FILE READ - ASCII DATA
   306		037340	000004		OPDEF	FRD36	[37B8!7B12!4]	;FILE READ - 36 BIT DATA
   307		037400	000004		OPDEF	FRD8	[37B8!10B12!4]	;FILE READ - 8 BIT DATA
   308
   309					;*KI10 ONLY UUO FOR PRINTING MARGIN VALUES
   310
   311		037700	000002		OPDEF	PNTMGN	[37B8!16B12!2]	;PRINT MARGIN VALUE
   312
   313						XLIST
   314					IFNDEF	KLOLD,<LIST
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 6
PARAM	KLM	18-JAN-77 11:38		ERROR HANDLING UUO DEFINITIONS, JAN 18,1977                                        SEQ 0015

   315					SUBTTL	ERROR HANDLING UUO DEFINITIONS, JAN 18,1977
   316
   317					S^;*********************************************************************^
   318					;*ERROR HANDLER PARAMETERS
   319					S^;*********************************************************************^
   320
   321		036000	000000		OPDEF	ERUUO	[36B8]		;ERROR CALL UUO
   322		035000	000000		OPDEF	ERLOOP	[35B8]		;ERROR LOOP, CHECKS PC,REPT,REPT1,ERROR
   323		035040	000000		OPDEF	ERLP1	[35B8!1B12]	;ERROR LOOP IF PC'S MATCH
   324		035100	000000		OPDEF	ERLP2	[35B8!2B12]	;ERROR LOOP IF ANY ERROR
   325		034000	000000		OPDEF	REPTUO	[34B8]		;REPEAT LOOP UUO
   326
   327					;*THE ERROR HANDLER MACROS
   328
   329					;*A MACRO TO REPORT AN ERROR AND LOOP
   330
   331						DEFINE	ERROR	(ADR,FORMAT,CORECT,ACTUAL,F,D,ERR)<
   332						SALL
   333						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   334							   CORECT,,ACTUAL
   335							   [SIXBIT\D'_\],,ERR]
   336						XALL
   337
   338						ERLOOP	ADR		;IF ERROR, LOOP TO ADR
   339					>
   340
   341					;*A MACRO TO REPORT AN ERROR AND NOT LOOP
   342
   343						DEFINE	ERROR1	(FORMAT,CORECT,ACTUAL,F,D,ERR)<
   344						SALL
   345						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   346							   CORECT,,ACTUAL
   347							   [SIXBIT\D'_\],,ERR]
   348						XALL	>
   349
   350					>;END OF KLOLD CONDITIONAL
   351
   352						XLIST
   353						LIST
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 1
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0016

   354					SUBTTL	*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977
   355
   356	030000					LOC	30000
   357
   358					S^;*********************************************************************^
   359					;*PROGRAM STARTING ADDRESSES
   360					;*THESE ADDRESSES CALL VARIOUS SPECIAL START ROUTINES AND OR OPTIONS
   361					;*NORMAL START ADDRESS IS 30000 ALL OTHERS ARE SPECIAL. INVOKED BECAUSE
   362					;*OF END OF PASS, POWER FAILURE, DDT START, RE-ENTERING(TYPICALLY USER
   363					;*MODE), OR ANY NUMBER OF SPECIAL FEATURE TESTS.
   364					S^;*********************************************************************^
   365
   366	030000	254 00 1 00 027776 	BEGIN:	JRST	@MODLNK		;STAND-ALONE START
   367	030001	254 00 0 00 030712 	$START:	JRST	START		;MODE CHECK STARTING ADDRESS
   368
   369	030002	254 00 1 00 027774 	DIAGMN:	JRST	@LDLNK		;DIAGNOSTIC MONITOR START
   370
   371	030003	254 00 1 00 027774 	SYSEXR:	JRST	@LDLNK		;SYSTEM EXERCISER START
   372
   373	030004	254 00 0 00 030742 	SFSTRT:	JRST	SADR1		;SPECIAL FEATURE START
   374
   375	030005	254 00 0 00 030742 	PFSTRT:	JRST	SADR2		;POWER FAIL RESTART
   376
   377	030006	254 00 0 00 030742 	REENTR:	JRST	SADR3		;REENTER START(USUALLY USER MODE ONLY)
   378
   379	030007				SRTDDT:				;COMMONLY MISTAKEN NAME FOR "DDTSRT"
   380	030007	254 00 1 00 027775 	DDTSRT:	JRST	@DDTLNK		;DDT START
   381
   382	030010	254 00 0 00 030741 	BEGIN1:	JRST	STARTA		;LOOP START(END OF PASS COMES HERE)
   383	030011	254 00 1 00 027777 	SBINIT:	JRST	@SUBLNK		;PMGINT LINKAGE
   384	030012	000000	000000		RETURN:	0			;RETURN ADDRESS STORAGE
   385
   386	030013	254000	030742		START1:	SADR7			;OPTIONAL STARTING ADR/INSTRUCTIONS
   387	030014	254000	030742		START2:	SADR8			; "
   388	030015	254000	030742		START3:	SADR9			; "
   389	030016	254000	030742		START4:	SADR10			; "
   390	030017	254000	030742		START5:	SADR11			; "
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 2
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0017

   391					S^;*********************************************************************^
   392					;*PROGRAM FIXED PARAMETER AREA
   393					S^;*********************************************************************^
   394
   395	030020	444153	414100		PNTNAM:	PAREA3		;SIXBIT PROGRAM NAME
   396	030021	645560	000000		PNTEXT:	PAREA4		;SIXBIT PROGRAM EXTENSION
   397	030022	000000	000000		RANDBS:	PAREA1		;RANDOM BASE NUMBER
   398	030023	000000	000000		SWTEXR:	PAREA2		;SYSTEM EXERCISER SWITCHES
   399	030024	000000	001000		ITRCNT:	ITERAT		;PROGRAM ITERATIONS
   400	030025	000000	030725		$PNAME:	PGMNAM		;POINTER TO PROGRAMS NAME
   401	030026	000000	000002		$PVER:	MCNVER,,DECVER	;MCN & DEC VERSION LEVEL
   402	030027	000000	030000		$MODVL:	MODDVL		;DEVICE CODE CHANGE LOWER LIMIT
   403	030030	000000	030000		$MODVU:	MODDVU		;DEVICE CODE CHANGE UPPER LIMIT
   404	030031	777777	777777		$EMODE:	IFNDEF EXCASB,<0> IFDEF EXCASB,<-1>	;EXEC ALLOWED
   405	030032	777777	777777		$UMODE:	IFNDEF USRASB,<0> IFDEF USRASB,<-1>	;USER ALLOWED
   406	030033	000000	000000		$DSKUP:	IFNDEF DSKUPD,<0> IFDEF DSKUPD,<-1>	;DISK UPDATE MODE
   407	030034	000000	000000		$MMAP:	IFNDEF MEMMAP,<0> IFDEF MEMMAP,<-1>	;ALLOW MEMORY RTNS
   408	030035	000000	000000		PAREA7:	PAREA5		;OPTIONAL PARAMETER
   409	030036	000000	000000		PAREA8:	PAREA6		;OPTIONAL PARAMETER
   410
   411					S^;*********************************************************************^
   412					;*PROGRAM VARIABLE PARAMETER AREA
   413					S^;*********************************************************************^
   414
   415	030037	000000	000000		USER:	0		; 0 = EXEC, -1 = USER MODE FLAG
   416	030040	000000	000000		KAIFLG:	0		;PROCESSOR TYPE, 0 = KA10, -1 = KI10
   417	030041	000000	000000		KLFLG:	0		;PROCESSOR TYPE, 0 = KA/KI, -1 = KL10
   418	030042	777777	777777		MONFLG:	-1		;DIAG MONITOR SPECIAL USER FLAG
   419	030043	000000	000000		MONCTL:	0		;DIAG MON/SYS EXR FLAG
   420	030044	000000	000000		MONTEN:	0		;-1= LOADED BY 10
   421	030045	000000	000000		CLOCKF:	0		;CLOCK TICKED FLAG
   422	030046	000000	000000		CONSW:	0		;CONSOLE SWITCH SETTINGS
   423	030047	000000	000000		PASCNT:	0		;PROGRAM PASS COUNT
   424	030050	000000	000000		RUNFLG:	0		;PROGRAM RUN FLAG
   425	030051	000000	000000		TESTPC:	0		;SUBTEST PC
   426	030052	000000	000000		ERRPC:	0		;ERROR PC
   427	030053	000000	000000		ERRTLS:	0		;ERROR TOTALS
   428	030054	000000	000000		TICKS:	0		;PROGRAM RUNNING TIME
   429	030055	000000	000000		MARGIN:	0		;KI10 MARGIN WORD VALUE
   430	030056	000000	000000		$ONETM:	0		;SUBROUTINE INITIALIZATION FLAG
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 3
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0018

   431					S^;*********************************************************************^
   432					;*SPECIAL PROGRAM DISPATCH ADDRESSES
   433					S^;*********************************************************************^
   434
   435	030057	037 12 0 00 000004 	BEGEND:	ENDUUO		;END OF PASS
   436	030060	254 00 0 00 030010 	$BEND1:	JRST	BEGIN1	;KEEP RUNNING PROGRAM
   437	030061	037 16 0 00 000004 	$BEND2:	EOPUUO		;END OF PROGRAM - NO RETURN
   438	030062	254000	030742		CNTLC:	SADR5		;CONTROL C XFER ADDRESS
   439	030063	254000	030742		ALTMGO:	SADR6		;ALTMODE XFER ADDRESS
   440	030064				CPOPJ1:			;SKIP RETURN
   441	030064	350 00 0 17 000000 	UUOSKP:	AOS	(P)	;SKIP RETURN FROM UUO
   442	030065				CPOPJ:			;NON-SKIP REGULAR RETURN
   443	030065	263 17 0 00 000000 	UUOEXT:	RTN		;UUO RETURN
   444	030066	255 00 0 00 000000 	UUORTN:	JFCL		;ADDITIONAL USERS UUO ROUTINE
   445	030067	255 00 0 00 000000 	$UORTX:	JFCL		;ADDITIONAL UUO LINKAGE
   446	030070	255 00 0 00 000000 	$UUOER:	JFCL		;INITED AS (JRST $UOERX)
   447	030071	255 00 0 00 000000 	$ITRHL:	JFCL		;ADDITIONAL INTERRUPT LINKAGE
   448	030072	255 00 0 00 000000 	$ITRX1:	JFCL		; "
   449	030073	255 00 0 00 000000 	$USRHL:	JFCL		; "
   450	030074	255 00 0 00 000000 	$RSRTX:	JFCL		;ADDITIONAL POWER FAIL LINKAGE
   451	030075	255 00 0 00 000000 	$RSRTY:	JFCL		; "
   452	030076	255 00 0 00 000000 	RESRT1:	JFCL		; INITED AS (JRST RESRTX)
   453	030077	255 00 0 00 000000 	RESRT2:	JFCL		; "
   454	030100	255 00 0 00 000000 	$PARER:	JFCL		;ADDITIONAL PARITY ERROR LINKAGE
   455	030101	255 00 0 00 000000 	ERMORE:	JFCL		;ADDITIONAL ERROR HANDLER LINKAGE
   456	030102	254 04 0 00 030102 		HALT	.	;IMPROPER TRANSFER HALT
   457
   458	030103	000000	000000		$PSHER:	0		;INITED AS (JRST PSHERR)
   459	030104	000000	000000		ITRCH1:	0		;PC & FLAGS OF CURRENT INTERRUPT
   460	030105	000000	000000			0		;INITED AS (JRST $ITRC1)
   461
   462					S^;*********************************************************************^
   463					;*PROCESSOR CONTROL STORAGE
   464					S^;*********************************************************************^
   465
   466	030106	000000	000000		$ACC0:	0		;INTERRUPT SAVED AC0
   467	030107	000000	000000		$SVPI:	0		;INTERRUPT SAVED PI
   468	030110	000000	000000		$SVAPR:	0		;INTERRUPT SAVED APR
   469	030111	000000	000000		$SVPAG:	0		;INTERRUPT SAVED PAG (DATAI)
   470	030112	000000	000000		$SPAG1:	0		;INTERRUPT SAVED PAG (CONI)
   471
   472	030113	000000	000000		$SVUUO:	0		;CURRENT USERS UUO
   473	030114	000000	000000		$SVUPC:	0		;PC OF CURRENT USERS UUO
   474
   475	030115	000000	000000		REPTU:	0		;REPEAT UUO ITERATIONS
   476	030116	000000	000000		SCOPE:	0		;ERROR HANDLER SCOPE LOOP FLAG
   477	030117	000000	000000		%CORFLG:0		; " CORRECT FLAG
   478	030120	000000	000000		%COREC:	0		; " CORRECT DATA
   479	030121	000000	000000		%ACTFL:	0		; " ACTUAL FLAG
   480	030122	000000	000000		%ACTUL:	0		; " ACTUAL DATA
   481	030123	000000	000000		%DISCR:	0		; " DISCREPENCY DATA
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 4
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0019

   482					S^;*********************************************************************^
   483					;*UUO DISPATCH TABLE
   484					S^;*********************************************************************^
   485						XLIST
   486						LIST
   487	030124	030070	030070		UUODIS:	LUUO1,,$UUOER
   488	030125	030070	030070			LUUO3,,LUUO2
   489	030126	030070	030070			LUUO5,,LUUO4
   490	030127	030070	030070			LUUO7,,LUUO6
   491	030130	030070	030070			LUUO11,,LUUO10
   492	030131	030070	030070			LUUO13,,LUUO12
   493	030132	030070	030070			LUUO15,,LUUO14
   494	030133	030070	030070			LUUO17,,LUUO16
   495	030134	030070	030070			LUUO21,,LUUO20
   496	030135	030070	030070			LUUO23,,LUUO22
   497	030136	030070	030070			LUUO25,,LUUO24
   498	030137	030070	030070			LUUO27,,LUUO26
   499	030140	030070	030070			LUUO31,,LUUO30
   500	030141	030070	030070			LUUO33,,LUUO32
   501
   502					S^;*********************************************************************^
   503					;*MEMORY MANAGMENT STORAGE
   504					S^;*********************************************************************^
   505
   506	030142	000000	000000		DF22F:	0		;DF10 CONTROL FLAG, 0 = 18, -1 = 22 BIT
   507	030143	000000	000000		MAPNEW:	0		;MEMORY MAPPING CONTROL FLAG, -1 = 4096K MAPPING
   508	030144	000000	000000		MEMTOT:	0		;TOTAL MEMORY SIZE IN K (1024.)
   509	030145	000000	000000		MEMLOW:	0		;LOWEST USABLE MEMORY
   510	030146				MEMSIZ:	BLOCK ^D41	;MEMORY SEGMENT POINTER TABLE
   511
   512					S^;*********************************************************************^
   513					;*PRINT CONTROL STORAGE
   514					S^;*********************************************************************^
   515
   516	030217	000000	000000		PNTFLG:	0		;PRINT FLAG, -1 WHILE IN PRINT ROUTINE
   517	030220	000000	000000		PNTENB:	0		;PRINT ENABLE
   518	030221	000000	000000		PDISF:	0		;PRINT DISABLED FLAG
   519	030222	000000	000000		PNTINH:	0		;INHIBIT PRINT INPUT CHECKS
   520	030223	000000	000000		PNTSPC:	0		;PRINT SPACE CONTROL
   521	030224	000000	000000		OPTIME:	0		;TYPE-IN WAIT TIME
   522	030225	000000	000000		$TWCNT:	0		;TIME WAITED
   523	030226	000000	000000		$DVOFF:	0		;LOGICAL DEVICE INITED FLAG
   524	030227	000000	000000		TTYFIL:	0		;TTY EXEC FILLERS FLAG
   525	030230	000000	000000		TTYSPD:	0		;TTY EXEC BAUD RATE
   526	030231	000000	000000		$TTCHR:	0		;ACTUAL TYPED IN CHAR
   527	030232	000000	000000		$CHRIN:	0		;UPPER CASED & PARITY STRIPPED CHAR
   528	030233	000000	000000		$TYPNB:	0		;TYPED IN NUMBER
   529	030234	000000	000000		$CRLF:	0		;FREE CR/LF FLAG
   530	030235	000000	000000		$TABF:	0		;TAB CONVERSION FLAG
   531	030236	000000	000000		$FFF:	0		;FORM FEED CONVERSION FLAG
   532	030237	000000	000000		$VTF:	0		;VERTICAL TAB CONVERSION FLAG
   533	030240	000000	000000		USRLFF:	0		;USER LF FILLERS
   534	030241	000000	000000		USRCRF:	0		;USER CR FILLERS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 5
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0020

   535					S^;*********************************************************************^
   536					;*THE FOLLOWING MISCELLANEOUS PRINT CHARACTERS ARE INCLUDED
   537					;*TO FACILITATE PRINTING AND ARE CALLED AS FOLLOWS:
   538					;*	MOVEI	NAME
   539					;*	PNTA		;OR PNTAF
   540					S^;*********************************************************************^
   541
   542	030242				CRLF:	ASCII/
   543	030242	015 012 000 000 000 	/
   544	030243				CRLF2:	ASCII/
   545
   546	030243	015 012 015 012 000 	/
   547	030244	054 000 000 000 000 	COMMA:	ASCII/,/
   548	030245	056 000 000 000 000 	PERIOD:	ASCII/./
   549	030246	040 000 000 000 000 	SPACE:	ASCII/ /
   550	030247	011 000 000 000 000 	TAB:	ASCII/	/
   551	030250				MINUS:
   552	030250	055 000 000 000 000 	HYPEN:	ASCII/-/
   553	030251	053 000 000 000 000 	PLUS:	ASCII/+/
   554	030252	052 000 000 000 000 	AST:	ASCII/*/
   555	030253	100 000 000 000 000 	ATSIN:	ASCII/@/
   556	030254	050 000 000 000 000 	LFP:	ASCII/(/
   557	030255	051 000 000 000 000 	RTP:	ASCII/)/
   558	030256	007 0000000000 		BELL:	BYTE (7) 007
   559	030257	077 000 000 000 000 	QUEST:	ASCII/?/
   560	030260	057 000 000 000 000 	SLASH:	ASCII!/!
   561	030261	044 000 000 000 000 	DOLLAR:	ASCII/$/
   562	030262	000000	000012		RADIX:	^D10			;DECIMAL PRINT RADIX
   563	030263	000000	000040		RADLSP:	40			;DECIMAL PRINT LEADING CHAR
   564	030264	000000	000012		RADLSC:	^D10			;DECIMAL PRINT LEADING CHAR COUNT
   565
   566					S^;*********************************************************************^
   567					;*USER MODE OUTPUT FILE INFORMATION
   568					S^;*********************************************************************^
   569
   570	030265				$OBUF:	BLOCK	3		;LOGICAL FILE OUTPUT BUFFER HEADER
   571	030270	60 62 51 56 64 00 	$OUTNM:	SIXBIT	/PRINT/		;FILE NAME
   572	030271	60 56 64 00 00 00 	$OUTEX:	SIXBIT	/PNT/		;FILE NAME EXTENSION
   573	030272					BLOCK	2
   574
   575					S^;*********************************************************************^
   576					;*DISK UPDATE MODE FILE INFORMATION
   577					S^;*********************************************************************^
   578
   579	030274				$IBUF:	BLOCK	3
   580	030277	60 62 51 56 64 00 	$INNM:	SIXBIT	/PRINT/
   581	030300	60 56 64 00 00 00 	$INEXT:	SIXBIT	/PNT/
   582	030301					BLOCK	2
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 6
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0021

   583					S^;*********************************************************************^
   584					;*PUSHDOWN LIST CONTROL INFORMATION
   585					S^;*********************************************************************^
   586
   587	030303	777577	030303		PLIST:	PLIST-PLISTE,,PLIST
   588	030304				PLISTS:	BLOCK	200
   589	030504	000000	000000		PLISTE:	0		;END OF PUSHDOWN LIST
   590
   591					S^;*********************************************************************^
   592					;*POWER LINE CLOCK FREQUENCY FLAG
   593					S^;*********************************************************************^
   594
   595	030505	000000	000000		CYCL60:	0	;0 = 60, -1 = 50 CYCLE
   596
   597					S^;*********************************************************************^
   598					;*KL10 CACHE CONTROL FLAGS
   599					S^;*********************************************************************^
   600
   601	030506	000000	000000		CSHFLG:	0	;ALLOW CACHE IF 0
   602	030507	000000	000000		CSHMEM:	0	;CACHE MEMORY SEGMENTS IF 0
   603
   604					S^;*********************************************************************^
   605					;*NUMBER INPUT DIGIT FLAG
   606					S^;*********************************************************************^
   607
   608	030510	000000	000000		TTNBRF:	0	;-1 IF ANY DIGIT TYPED
   609
   610					S^;*********************************************************************^
   611					;*KL10 & KI10 "INHPAG" SWITCH PAGING PREVENTION
   612					S^;*********************************************************************^
   613
   614	030511	000000	000000		PVPAGI:	0	;IF NON-ZERO, OVERRIDE "INHPAG" SWITCH ACTION
   615
   616					S^;*********************************************************************^
   617					;*ERROR REPORTING ROUTINE ADDITIONAL USERS CONTROL INSTRUCTIONS
   618					S^;*********************************************************************^
   619
   620	030512	000000	000000		%ERHI1:	0	;IF NON-ZERO, XCT'D AT START OF %ERUUO
   621	030513	000000	000000		%ERHI2:	0	;IF NON-ZERO, XCT'D AT END OF %ERUUO
   622	030514	000000	000000		%ERHI3:	0	;IF NON-ZERO, XCT'D AFTER "PC" OF %ERUUO
   623
   624					S^;*********************************************************************^
   625					;*SPECIAL USERS UUO INTERCEPT INSTRUCTION
   626					S^;*********************************************************************^
   627
   628	030515	000000	000000		$$UUO:	0	;IF NON-ZERO, XCT'D AT START OF $UORTN
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 7
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0022

   629					S^;*********************************************************************^
   630					;*KL10 PROCESSOR TYPE FLAG, 0=P0, 1=BBD NEW, 2=BBD OLD
   631					S^;*********************************************************************^
   632
   633	030516	000000	000000		KLTYP:	0
   634
   635					S^;*********************************************************************^
   636					;*SPECIAL USERS MUUO INTERCEPT INSTRUCTION
   637					S^;*********************************************************************^
   638
   639	030517	000000	000000		$$MUUO:	0	;IF NON-ZERO, XCT'D AT START OF MUUOER
   640
   641					S^;*********************************************************************^
   642					;*SPECIAL USERS USER MODE OUTPUT ERROR INTERCEPT INSTUCTION
   643					S^;*********************************************************************^
   644
   645	030520	000000	000000		$$OUTER:0	;IF NON-ZERO, XCT'D AT END OF USER MODE ERROR
   646
   647					S^;*********************************************************************^
   648					;*"SWITCH" CALL USAGE CONTROL
   649					S^;*********************************************************************^
   650
   651	030521	000000	000000		$$TOGGLE:0	;IF NON-ZERO, USE C(CONSW) FOR SWITCHES
   652
   653					S^;*********************************************************************^
   654					;*SPECIAL USERS ALTMODE SWITCH CALL INTERCEPT INSTRUCTIONS
   655					S^;*********************************************************************^
   656
   657	030522	000000	000000		$$TAX1:	0	;IF NON-ZERO, XCT'D AT START OF ALTMODE SWITCH CALL
   658	030523	000000	000000		$$TAX2:	0	;IF NON-ZERO, XCT'D AT END OF ALTMODE SWITCH CALL
   659
   660					S^;*********************************************************************^
   661					;*SPECIAL FUTURE EXPANSION ROOM
   662					;*IF ANY FIXED AREA TAGS ARE ADDED, REDUCE THE SIZE OF
   663					;*THIS BLOCK STATEMENT ACCORDINGLY.  THIS MUST BE DONE
   664					;*SO THAT PREVIOUS FIXED ASSIGNMENTS DO NOT CHANGE.
   665					S^;*********************************************************************^
   666
   667	030524					BLOCK	53	;HOPEFULLY THIS IS ENOUGH FOREVER
   668
   669					S^;*********************************************************************^
   670					;*END OF FIXED STORAGE
   671					S^;*********************************************************************^
   672
   673			030577			$ENDFX=<PLISTE+100>&<777700>-1
   674	030577					LOC	$ENDFX
   675	030577	000000	000000		ENDFIX:	0		;END OF FIXED STORAGE
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 1
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0023

   676					SUBTTL	*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76
   677
   678					;NEW DEFINITIONS USED BY THE KL10 SUBROUTINE PACKAGE
   679
   680			000000		AC0=	0
   681			030000		DIAGNOS=30000		;PDP-10 DIAGNOSTIC START ADDRESS
   682			010000		DDT=	10000		;PDP-10 DDT START ADDRESS
   683			020000		DIAMON=	20000		;PDP-10 DIAMON LOADER START ADDRESS
   684			020000		DONG11=	1B22		;11 DOORBELL (FROM THE 10)
   685
   686					;DTE20 DEVICE CODES
   687
   688			000200		DTE==	200		;DTE0
   689			000204		DTE0==	204
   690			000204		DTE1==	204
   691			000210		DTE2==	210
   692			000214		DTE3==	214
   693
   694					;KL10 EPT COMMUNICATION AREA
   695
   696			000440		$STD=	440		;PDP-10 DIAGNOSTIC START ADDRESS
   697			000441		$DDT=	441		;PDP-10 DDT START ADDRESS
   698			000442		$STL=	442		;PDP-10 LOADER START ADDRESS
   699			000443		$STM=	443		;PDP-10 MONITOR START ADDRESS
   700
   701			000444		$DTFLG=	444		;DTE20 OPERATION COMPLETE FLAG
   702			000445		$DTCLK=	445		;DTE20 CLOCK INTERRUPT FLAG
   703			000446		$DTCI=	446		;DTE20 CLOCK INTERRUPT INSTRUCTION
   704			000447		$DTT11=	447		;DTE20 10 TO 11 ARGUMENT
   705			000450		$DTF11=	450		;DTE20 11 TO 10 ARGUMENT
   706			000451		$DTCMD=	451		;DTE20 TO 11 COMMAND WORD
   707			000452		$DTSEQ=	452		;DTE20 OPERATION SEQUENCE NUMBER
   708			000453		$DTOPR=	453		;DTE20 OPERATIONAL DTE #
   709			000454		$DTCHR=	454		;DTE20 LAST TYPED CHARACTER
   710			000455		$DTMTD=	455		;DTE20 MONITOR TTY OUTPUT COMPLETE FLAG
   711			000456		$DTMTI=	456		;DTE20 MONITOR TTY INPUT FLAG
   712
   713			000457		$DTSWR=	457		;DTE20 CONSOLE SWITCH REGISTER
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 2
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0024

   714					;SPECIAL "FIXED" REASSIGNMENTS
   715
   716			030600			$$LOC=.			;SAVE CURRENT LOCATION
   717
   718	030000					LOC	30000
   719	030000	254 00 0 00 030600 	$$BEGIN:JRST	$$START		;SETUP SPECIAL START
   720	030001	254 00 0 00 030600 		JRST	$$START		;"DIAMON" CHAIN START ADDRESS
   721
   722	000440					LOC	440
   723	000440	254 00 0 00 030000 	$STD:	JRST	BEGIN		;SETUP FOR "STD"
   724	000443					LOC	443
   725	000443	254 00 0 00 030636 	$STM:	JRST	$SPEC		;SIMPLE RUN CONTROL
   726
   727	030057					LOC	30057
   728	030057	254 00 0 00 030641 	$BEGEND:JRST	$SPBEND		;SETUP SPECIAL "BEGEND"
   729
   730					;SPECIAL MUUO, TRAP & PAGE FAIL SETUP
   731
   732	000420					LOC	420
   733	000420	254 04 0 00 000420 	$$420:	HALT	.		;KI10 PAGE FAIL
   734	000421	255 00 0 00 000000 	$$421:	JFCL			;OVERFLOW
   735	000422	254 04 0 00 000422 	$$422:	HALT	.		;PUSHDOWN OVERFLOW
   736	000423	254 04 0 00 000423 	$$423:	HALT	.		;TRAP 3
   737	000424	000000	000000		$$424:	0			;MMUO
   738	000425	000000	000000		$$425:	0			;MMUO PC
   739	000426	000000	000000		$$426:	0			;KI10-PAGE FAIL, KL10-PROCESS CONTEXT
   740	000427	254 04 0 00 000427 	$$427:	HALT	.
   741	000430	000000	000427		$$430:	427			;MMUO NEW PC'S
   742	000431	000000	000427		$$431:	427
   743	000432	000000	000427		$$432:	427
   744	000433	000000	000427		$$433:	427
   745	000434	000000	000427		$$434:	427
   746	000435	000000	000427		$$435:	427
   747	000436	000000	000427		$$436:	427
   748	000437	000000	000427		$$437:	427
   749
   750	000500					LOC	500
   751	000500	000000	000000		$$500:	0			;KL10 PAGE FAIL WORD
   752	000501	000000	000000		$$501:	0			;KL10 PAGE FAIL PC
   753	000502	000000	000503		$$502:	503			;KL10 PAGE FAIL NEW PC
   754	000503	254 04 0 00 000503 	$$503:	HALT	.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 3
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0025

   755	030600					LOC	$$LOC		;RESET CURRENT LOCATION
   756
   757					;SPECIAL STARTUP SEQUENCE
   758
   759	030600	402 00 0 00 030037 	$$START:SETZM	USER
   760	030601	265 00 0 00 030602 		JSP	0,.+1		;IN USER MODE ?
   761	030602	603 00 0 00 010000 		TLNE	0,USERF
   762	030603	476 00 0 00 030037 		SETOM	USER		;YES, SET CONTROL WORD
   763	030604	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE ?
   764	030605	402 00 0 00 030037 		SETZM	USER		;YES, RUN AS EXEC
   765	030606	332 00 0 00 030037 		SKIPE	USER
   766	030607	254 00 0 00 030712 		JRST	START		;USER MODE, DON'T NEED CPU TYPE
   767
   768	030610	336 00 0 00 030044 	$STKIL:	SKIPN	MONTEN		;LOADED BY "DIAMON" ?
   769	030611	476 00 0 00 030024 		SETOM	ITRCNT		;NO, RUN FOREVER
   770	030612	402 00 0 00 030516 		SETZM	KLTYP
   771	030613	402 00 0 00 030041 		SETZM	KLFLG		;ASSUME KI10
   772	030614	200 01 0 00 035060 		MOVE	1,[1,,1]
   773	030615	251 01 0 00 000001 		BLT	1,1		;HOPE THIS WORKS
   774	030616	316 01 0 00 035060 		CAMN	1,[1,,1]	;IF AC NE 1,,1 AFTER BLT, KL10
   775	030617	254 00 0 00 030712 		JRST	START		;KI10, NO ADDITIONAL SETUP
   776
   777	030620	7 000 20 0 00 010040 	$STKL:	CONO	APR,10040	;SET BBD NOT BIT
   778	030621	7 000 24 0 00 000000 		CONI	APR,0
   779	030622	7 000 20 0 00 020040 		CONO	APR,20040	;CLEAR BBD NOT BIT
   780	030623	606 00 0 00 000040 		TRNN	0,40		;IF SET, KL10
   781	030624	350 00 0 00 030516 		AOS	KLTYP		;IF NOT, BBD
   782	030625	402 00 0 00 000444 		SETZM	$DTFLG
   783	030626	402 00 0 00 000445 		SETZM	$DTCLK
   784	030627	200 00 0 00 000453 		MOVE	$DTOPR		;GET DTE #
   785	030630	436 00 0 00 030670 		ORM	$$DTE0		;INSERT IN DTE I/O INSTS
   786	030631	436 00 0 00 030672 		ORM	$$DTE1
   787	030632	436 00 0 00 030704 		ORM	$$DTE2
   788	030633	436 00 0 00 030706 		ORM	$$DTE3
   789	030634	476 00 0 00 030041 		SETOM	KLFLG		;SET KL10 CONTROL FLAG
   790	030635	254 00 0 00 030712 		JRST	START
   791
   792	030636	200 00 0 00 035061 	$SPEC:	MOVE	[JRST STARTA]	;SIMPLE RUN CONTROL
   793	030637	202 00 0 00 030643 		MOVEM	$SPB1
   794	030640	254 00 0 00 030712 		JRST	START
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 4
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0026

   795					;SPECIAL "BEGEND" ROUTINE
   796
   797	030641	350 00 0 00 030047 	$SPBEND:AOS	PASCNT		;INCREMENT PASS COUNT
   798	030642	370 00 0 00 030024 		SOS	ITRCNT		;DECREMENT ITERATION COUNT
   799	030643	336 00 0 00 030037 	$SPB1:	SKIPN	USER
   800	030644	254 00 0 00 030652 		JRST	$SPBEX		;EXEC MODE
   801
   802	030645	332 00 0 00 030024 	$SPBUS:	SKIPE	ITRCNT		;USER MODE, COMPLETED ?
   803	030646	254 00 0 00 030741 		JRST	STARTA		;NO, KEEP RUNNING
   804	030647	336 00 0 00 030044 		SKIPN	MONTEN		;DONE, LOADED BY "DIAMON" ?
   805	030650	047 00 0 00 000012 		EXIT			;NO, RETURN TO MONITOR
   806	030651	254 00 1 00 030012 		JRST	@RETURN		;YES, RETURN TO "DIAMON"
   807
   808	030652	332 00 0 00 030041 	$SPBEX:	SKIPE	KLFLG
   809	030653	254 00 0 00 030660 		JRST	$SPBKL		;KL10 & EXEC
   810	030654	7 004 14 0 00 030024 		DATAO	PI,ITRCNT	;KI10 & EXEC, DISPLAY ITER COUNT
   811	030655	332 00 0 00 030024 		SKIPE	ITRCNT
   812	030656	254 00 0 00 030741 		JRST	STARTA		;NOT COMPLETED YET
   813	030657	254 00 1 00 030012 		JRST	@RETURN		;DONE
   814
   815	030660	336 00 0 00 030024 	$SPBKL:	SKIPN	ITRCNT
   816	030661	254 00 0 00 030676 		JRST	$SPKLD		;KL10, EXEC & COMPLETED
   817
   818	030662	335 00 0 00 030043 		SKIPGE	MONCTL
   819	030663	254 00 0 00 030741 		JRST	STARTA		;"DIAMON" CONTROL
   820	030664	201 00 0 00 000404 		MOVEI	0,404		;NOTIFY PDP-11 OF END OF PASS
   821	030665	202 00 0 00 000451 		MOVEM	0,$DTCMD
   822	030666	402 00 0 00 000444 		SETZM	$DTFLG
   823	030667	336 00 0 00 030516 		SKIPN	KLTYP
   824	030670	7 200 20 0 00 020000 	$$DTE0:	CONO	DTE,DONG11
   825	030671	332 00 0 00 030516 		SKIPE	KLTYP
   826	030672	7 200 20 0 00 010000 	$$DTE1:	CONO	DTE,10000
   827	030673	336 00 0 00 000444 		SKIPN	$DTFLG		;WAIT TILL 11 RESPONDS
   828	030674	254 00 0 00 030673 		JRST	.-1
   829	030675	254 00 0 00 030741 		JRST	STARTA		;KEEP RUNNING
   830
   831					;SPECIAL KL10 COMPLETED ROUTINE
   832
   833	030676	332 00 0 00 030044 	$SPKLD:	SKIPE	MONTEN
   834	030677	254 00 1 00 030012 		JRST	@RETURN		;LOADED BY "DIAMON"
   835
   836	030700	201 00 0 00 000403 		MOVEI	0,403		;NOTIFY PDP-11 OF COMPLETION
   837	030701	202 00 0 00 000451 		MOVEM	0,$DTCMD
   838	030702	402 00 0 00 000444 		SETZM	$DTFLG
   839	030703	336 00 0 00 030516 		SKIPN	KLTYP
   840	030704	7 200 20 0 00 020000 	$$DTE2:	CONO	DTE,DONG11
   841	030705	332 00 0 00 030516 		SKIPE	KLTYP
   842	030706	7 200 20 0 00 010000 	$$DTE3:	CONO	DTE,10000
   843	030707	336 00 0 00 000444 		SKIPN	$DTFLG		;SHOULD NEVER HAPPEN
   844	030710	254 00 0 00 030707 		JRST	.-1		;11 NEVER RETURNS ON END OF PROGRAM
   845	030711	254 04 0 00 030000 		HALT	BEGIN		;IF IT DOES, HALT.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 1
DAKAAM	MAC	19-JAN-77 13:42		DIAGNOSTIC SECTION                                                                 SEQ 0027

   846					SUBTTL	DIAGNOSTIC SECTION
   847
   848	030712	402 00 0 00 030037 	START:	SETZM	USER#		;CLEAR USER CONTROL WORD
   849	030713	265 00 0 00 030714 		JSP	0,.+1		;GET FLAGS
   850	030714	603 00 0 00 010000 		TLNE	USERF		;IN USER MODE?
   851	030715	476 00 0 00 030037 		SETOM	USER		;YES, SET USER CONTROL WORD
   852	030716	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE?
   853	030717	402 00 0 00 030037 		SETZM	USER		;YES, CLEAR USER CONTROL WORD
   854	030720	336 00 0 00 030037 		SKIPN	USER
   855	030721	254 00 0 00 030741 		JRST	STARTA
   856	030722	331 00 0 00 030043 		SKIPL	MONCTL
   857	030723	051 03 0 00 030725 		TTCALL	3,PGMNAM		;MENTION OUR NAME
   858	030724	254 00 0 00 030741 		JRST	STARTA
   859
   860	030725				PGMNAM:	ASCIZ/
   861	030725	015 012 120 104 120 	PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) [DAKAA]
   862	030726	055 061 060 040 113
   863	030727	101 061 060 040 102
   864	030730	101 123 111 103 040
   865	030731	111 116 123 124 122
   866	030732	125 103 124 111 117
   867	030733	116 040 104 111 101
   868	030734	107 116 117 123 124
   869	030735	111 103 040 050 061
   870	030736	051 040 133 104 101
   871	030737	113 101 101 135 015
   872	030740	012 000 000 000 000 	/
   873
   874					;BASIC INSTRUCTION TEST (3)
   875					;THE TEST IS DESIGNED FOR INITIAL DEBUGGING OF
   876					;PROCESSOR HARDWARE AND TO DETECT (SOLID) FAILURES
   877					;IN THE FIELD.
   878
   879
   880	030741	254 00 0 00 030742 	STARTA:	JRST	.+1
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 2
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0028

   881					SUBTTL	TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS
   882
   883					;NOTE: AN "*" IN THE COMMENT FIELD OF AN INSTRUCTION INDICATES THAT IT IS THE TESTED
   884					;INSTRUCTION.
   885					;**********
   886
   887					;THIS TEST VERIFIES THAT SKIPA ALWAYS SKIPS THE NEXT INSTRUCTION
   888
   889			030742		A00=.
   890	030742	334 00 0 00 000000 	A12500:	SKIPA			;*SKIPA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
   891	030743	254 04 0 00 000000 		HALT			;IF PROGRAM HALTS, SKIPA DID NOT SKIP
   892
   893					;IF PROGRAM HANGS UP ON SKIPA INSTRUCTION, CHECK AB PC EN [ABC], AB PC F/F [ABC],
   894					;AB PC B [ABC OR AB], AB PC (FETCH) EN [ABC], IR SKIPS [IR3], IR SKIPX [IR1],
   895					;IR 3XX [IR1], IR BITS 00 - 08 [IR1], F CYC ACT EN C [FI], FT6 F/F [F2],
   896					;PC CLOCK EN [PCC],  ET2 J F/F [E], PC CLK (ET2) EN [PCC], ADZ COND P [ADZ] AND
   897					;ADZ COND R [ADZ], PC CLOCK A [PCC], PC CLOCK B [PCC]
   898
   899					;IF PROGRAM HALTED ON HALT INSTRUCTION, CHECK ST1 COND [ST2]
   900
   901					;**********
   902
   903					;THIS TEST VERIFIES THAT JUMP NEVER JUMPS
   904
   905	030744	320 00 0 00 030745 	A15000:	JUMP	.+1		;*JUMP SHOULD NEVER JUMP
   906	030745	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF JUMP IS SUCCESSFUL
   907	030746	254 04 0 00 000000 		HALT			;HALT IF JUMP FAILS
   908
   909					;IF PROGRAM HANGS UP ON JUMP .+1 INSTRUCTION, THE JUMP INSTRUCTION
   910					;MAY HAVE FAILED.  CHECK ST1 COND [ST2], ST INST FET ST1 EN [ST2], ET2 D F/F [E],
   911					;IR JUMPS [IR1], IR JUMPX [IR1]
   912
   913					;**********
   914					;THIS TEST VERIFIES THAT JUMP NEVER JUMPS
   915
   916	030747	320 00 0 00 030751 	A15100:	JUMP	.+2		;*JUMP SHOULD NEVER JUMP
   917	030750	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF JUMP IS SUCCESSFUL
   918	030751	254 04 0 00 000000 		HALT			;HALT IF JUMP FAILS
   919
   920					;AB PC EN [ABC]
   921
   922					;**********
   923
   924					;THIS TEST VERIFIES THAT JUMPA .+1 ALWAYS JUMPS TO THE NEXT INSTRUCTION
   925
   926	030752	324 00 0 00 030753 	A12700:	JUMPA	.+1		;*JUMPA .+1 SHOULD NEVER JUMP
   927	030753	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF JUMPA IS SUCCESSFUL
   928	030754	254 04 0 00 000000 		HALT			;HALT IF JUMPA .+1 FAILED
   929
   930					;**********
   931
   932					;THIS TEST VERIFIES THAT JUMPA JUMPS TO THE LOCATION SPECIFIED BY E WHEN E=.+2
   933
   934	030755	324 00 0 00 030757 	A12600:	JUMPA	.+2		;*JUMPA .+2 SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
   935	030756	254 04 0 00 000000 		HALT			;PROGRAM HALTS HERE IF JUMPA .+2 FAILS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 2-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0029

   936
   937					;ST1 COND [ST2]
   938
   939					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 3
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0030

   940					;THIS TEST VERIFIES THAT SKIPA IS DATA INDEPENDENT.  HENCE, IT ALWAYS SKIPS THE NEXT
   941					;INSTRUCTION.
   942					;THE MOVE [0] INSTRUCTION IS USED TO TEST THE DATA INDEPENDENCE OF SKIPA.
   943
   944	030757	200 00 0 00 035062 	A100:	MOVE	[0]		;PRESET LOCATION 0 TO ALL ZEROS
   945	030760	334 00 0 00 000000 		SKIPA			;*SKIPA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
   946						STOP^
   947	030761	254 04 0 00 030762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   948	030762	324 00 0 00 030763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   949									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   950									;IN THE SUBTEST) TO LOOP ON ERROR^
   951
   952					;**********
   953					;THIS TEST INSURES THAT SKIPA IS DATA INDEPENDENT.  HENCE, IT ALWAYS SKIPS THE NEXT
   954					;INSTRUCTION.
   955					;THE MOVE [-1] INSTRUCTION IS USED TO TEST THE DATA INDEPENDENCE OF SKIPA.
   956
   957	030763	200 00 0 00 035063 	A200:	MOVE	[-1]		;PRESET LOCATION 0 TO ALL ONES
   958	030764	334 00 0 00 000000 		SKIPA			;*SKIPA SKOULD ALWAYS SKIP THE NEXT INSTRUCTION
   959						STOP^
   960	030765	254 04 0 00 030766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   961	030766	324 00 0 00 030767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   962									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   963									;IN THE SUBTEST) TO LOOP ON ERROR^
   964
   965					;COND P [ADZ]
   966
   967					;**********
   968					;THIS TEST VERIFIES THAT SKIPGE SKIPS THE NEXT INSTRUCTION WHEN C(E)
   969					;IS ALL ZEROS.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH ALL ZEROS.
   970
   971	030767	200 00 0 00 035062 	A300:	MOVE	[0]		;PRESET E TO ALL ZEROS
   972	030770	335 00 0 00 000000 		SKIPGE			;*SKIPGE SHOULD SKIP THE NEXT INSTRUCTION
   973						STOP^
   974	030771	254 04 0 00 030772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   975	030772	324 00 0 00 030773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   976									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   977									;IN THE SUBTEST) TO LOOP ON ERROR^
   978
   979					;COND R [ADZ], AD00 S-A-1, AD AR + EN [ADAP], AD LT AR + EN [ADAP],
   980					;AD RT AR + EN [ADAP], AD AR + EN C [ADAP], F CYC ACT EN A [F1]
   981
   982					;**********
   983
   984					;THIS TEST VERIFIES THAT SKIP IS DATA INDEPENDENT.  HENCE, SKIP NEVER SKIPS.  IT ALWAYS
   985					;CONTINUES ON TO THE NEXT INSTRUCTION.
   986
   987	030773	200 00 0 00 035063 	A400:	MOVE	[-1]		;PRESET E TO ALL ONES
   988	030774	330 00 0 00 000000 		SKIP			;*SKIP SHOULD NEVER SKIP THE NEXT INSTRUCTION
   989	030775	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
   990						STOP^
   991	030776	254 04 0 00 030777 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   992	030777	324 00 0 00 031000 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   993									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   994									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 3-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0031

   995
   996					;PC CHANGE [PCC], PC CHANGE A [PCC], SEE MEMORY CONTROL DWGS [MC1-4]
   997
   998					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 4
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0032

   999					;THIS TEST VERIFIES THAT SKIPGE WILL NOT SKIP THE NEXT INSTRUCTION WHEN C(E) IS
  1000					;NEGATIVE.  THE MOVE INSTRUCTION LOADS E WITH -1, A NEGATIVE NUMBER.
  1001
  1002	031000	200 00 0 00 035063 	A500:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NEGATIVE NUMBER
  1003	031001	335 00 0 00 000000 		SKIPGE			;*SKIPGE SHOULD NOT SKIP THE NEXT INSTRUCTION
  1004	031002	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1005						STOP^
  1006	031003	254 04 0 00 031004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1007	031004	324 00 0 00 031005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1008									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1009									;IN THE SUBTEST) TO LOOP ON ERROR^
  1010
  1011					;IF MOVE INSTRUCTION FAILED, CHECK MOVX-: FCE [F1], -IR XXXI [IR1], -IR XXXM [IR1],
  1012					;IR HWTFWT [IR3], IR FWT [IR2], IR2XX [IR1]
  1013
  1014					;IF SKIPGE FAILED, CHECK SKIPX: FCE [F1]
  1015
  1016					;**********
  1017
  1018					;THIS TEST VERIFIES THAT SKIPN WILL NOT SKIP THE NEXT INSTRUCTION WHEN
  1019					;C(E) IS ZERO.  THE MOVE INSTRUCTION  LOADS E WITH ALL ZEROS.
  1020
  1021	031005	200 00 0 00 035062 	A600:	MOVE	[0]		;PRESET E WITH ALL ZEROS
  1022	031006	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD NOT SKIP THE NEXT INSTRUCTION
  1023	031007	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1024						STOP^
  1025	031010	254 04 0 00 031011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1026	031011	324 00 0 00 031012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1027									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1028									;IN THE SUBTEST) TO LOOP ON ERROR^
  1029
  1030					;**********
  1031
  1032					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT SHOULD SKIP
  1033					;THE NEXT INSTRUCTION WHEN C(E) IS NON-ZERO.  THE MOVE INSTRUCTION LOADS
  1034					;E WITH -1, A NON-ZERO NUMBER.
  1035
  1036	031012	200 00 0 00 035063 	A700:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NON-ZERO NUMBER
  1037	031013	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1038						STOP^
  1039	031014	254 04 0 00 031015 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1040	031015	324 00 0 00 031016 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1041									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1042									;IN THE SUBTEST) TO LOOP ON ERROR^
  1043
  1044					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 5
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0033

  1045					;THIS TEST VERIFIES THAT SKIPE IS DATA DEPENDENT.  HENCE, IT SHOULD NOT
  1046					;SKIP THE NEXT INSTRUCTION WHEN C(E) IS NON-ZERO.  THE MOVE INSTRUCTION LOADS E
  1047					;WITH -1, A NON-ZERO NUMBER.
  1048
  1049	031016	200 00 0 00 035063 	A1000:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NON-ZERO NUMBER
  1050	031017	332 00 0 00 000000 		SKIPE			;*SKIPE SHOULD NOT SKIP THE NEXT INSTRUCTION
  1051	031020	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1052						STOP^
  1053	031021	254 04 0 00 031022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1054	031022	324 00 0 00 031023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1055									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1056									;IN THE SUBTEST) TO LOOP ON ERROR^
  1057
  1058					;**********
  1059
  1060					;THIS TEST VERIFIES THAT SKIPE IS DATA DEPENDENT.  HENCE, IT SHOULD SKIP
  1061					;THE NEXT INSTRUCTION WHEN C(E) IS ZERO.  THE MOVE INSTRUCTION LOADS ALL
  1062					;ZEROS INTO E.
  1063
  1064	031023	200 00 0 00 035062 	A1100:	MOVE	[0]		;PRESET E TO ALL ZEROS
  1065	031024	332 00 0 00 000000 		SKIPE			;*SKIPE SHOULD SKIP THE NEXT INSTRUCTION
  1066						STOP^
  1067	031025	254 04 0 00 031026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1068	031026	324 00 0 00 031027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1069									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1070									;IN THE SUBTEST) TO LOOP ON ERROR^
  1071
  1072					;**********
  1073
  1074					;THIS TEST VERIFIES THAT SKIP IS DATA INDEPENDENT.  HENCE, IT NEVER SKIPS.  IT ALWAYS
  1075					;CONTINUES ON TO THE NEXT INSTRUCTION.
  1076
  1077	031027	200 00 0 00 035062 	A1200:	MOVE	[0]		;PRESET E TO ALL ZEROS
  1078	031030	330 00 0 00 000000 		SKIP			;*SKIP SHOULD NEVER SKIP THE NEXT INSTRUCTION
  1079	031031	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1080						STOP^
  1081	031032	254 04 0 00 031033 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1082	031033	324 00 0 00 031034 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1084									;IN THE SUBTEST) TO LOOP ON ERROR^
  1085
  1086					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 6
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0034

  1087					;THIS TEST VERIFIES THAT SKIPL IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1088					;INSTRUCTION WHEN C(E) IS NOT NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD
  1089					;E WITH ALL ZEROS, A NON-NEGATIVE NUMBER.
  1090
  1091	031034	200 00 0 00 035062 	A1300:	MOVE	[0]		;PRESET E T0 ZERO, A NON-NEGATIVE NUMBER
  1092	031035	331 00 0 00 000000 		SKIPL			;*SKIPL SHOULD NOT SKIP THE NEXT INSTRUCTION
  1093	031036	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1094						STOP^
  1095	031037	254 04 0 00 031040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1096	031040	324 00 0 00 031041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1097									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1098									;IN THE SUBTEST) TO LOOP ON ERROR^
  1099
  1100					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 7
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0035

  1101					;THIS TEST VERIFIES THAT SKIPL IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1102					;INSTRUCTION WHEN C(E) IS NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH -1,
  1103					;A NEGATIVE NUMBER.
  1104
  1105	031041	200 00 0 00 035063 	A1400:	MOVE	[-1]		;PRESET E TO -1, A NEGATIVE NUMBER
  1106	031042	331 00 0 00 000000 		SKIPL			;*SKIPL SHOULD SKIP THE NEXT INSTRUCTION
  1107						STOP^
  1108	031043	254 04 0 00 031044 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1109	031044	324 00 0 00 031045 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1110									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1111									;IN THE SUBTEST) TO LOOP ON ERROR^
  1112
  1113					;**********
  1114
  1115					;THIS TEST VERIFIES THAT SKIPG IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1116					;INSTRUCTION WHEN C(E) IS GREATER THAN ZERO.  THE MOVE INSTRUCTION IS USED TO LOAD
  1117					;E WITH A NON-ZERO POSITIVE NUMBER.
  1118
  1119	031045	200 00 0 00 035064 	A1500:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A NON-ZERO POSITIVE NUMBER
  1120	031046	337 00 0 00 000000 		SKIPG			;*SKIPG SHOULD SKIP THE NEXT INSTRUCTION
  1121						STOP^
  1122	031047	254 04 0 00 031050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1123	031050	324 00 0 00 031051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1124									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1125									;IN THE SUBTEST) TO LOOP ON ERROR^
  1126
  1127					;**********
  1128
  1129					;THIS TEST VERIFIES THAT SKIPG IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1130					;INSTRUCTION WHEN C(E) IS NOT GREATER THAN ZERO.  THE MOVE INSTRUCTION IS USED TO
  1131					;LOAD E WITH -1, A NUMBER NOT GREATER THAN ZERO.
  1132
  1133	031051	200 00 0 00 035063 	A1600:	MOVE	[-1]		;PRESET E TO -1, A NEGATIVE NUMBER
  1134	031052	337 00 0 00 000000 		SKIPG			;*SKIPG SHOULD NOT SKIP THE NEXT INSTRUCTION
  1135	031053	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1136						STOP^
  1137	031054	254 04 0 00 031055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1138	031055	324 00 0 00 031056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1139									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1140									;IN THE SUBTEST) TO LOOP ON ERROR^
  1141
  1142					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 8
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0036

  1143					;THIS TEST VERIFIES THAT SKIPL IS DATA  DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1144					;INSTRUCTION WHEN C(E) IS NON-NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH
  1145					;377777777777, A NON-NEGATIVE NUMBER.
  1146
  1147	031056	200 00 0 00 035064 	A1700:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A NON-NEGATIVE NUMBER
  1148	031057	331 00 0 00 000000 		SKIPL			;*SKIPL SHOULD NOT SKIP THE NEXT INSTRUCTION
  1149	031060	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1150						STOP^
  1151	031061	254 04 0 00 031062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1152	031062	324 00 0 00 031063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1153									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1154									;IN THE SUBTEST) TO LOOP ON ERROR^
  1155
  1156					;**********
  1157
  1158					;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1159					;INSTRUCTION WHEN C(E) IS ZERO.  THE MOVE INSTRUCTION LOADS E WITH ALL ZEROS.
  1160
  1161	031063	200 00 0 00 035062 	A2000:	MOVE	[0]		;PRESET E TO ALL ZEROS
  1162	031064	333 00 0 00 000000 		SKIPLE			;*SKIPLE SHOULD SKIP THE NEXT INSTRUCTION
  1163						STOP^
  1164	031065	254 04 0 00 031066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1165	031066	324 00 0 00 031067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1166									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1167									;IN THE SUBTEST) TO LOOP ON ERROR^
  1168
  1169					;**********
  1170
  1171					;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1172					;INSTRUCTION WHEN E CONTAINS A NEGATIVE NUMBER.  THE MOVE INSTRUCTION IS USED TO LOAD
  1173					;E WITH 400000000000, A NEGATIVE NUMBER.
  1174
  1175	031067	200 00 0 00 035065 	A2100:	MOVE	[XWD 400000,0]	;PRESET E TO 400000000000, A NEGATIVE NUMBER.
  1176	031070	333 00 0 00 000000 		SKIPLE			;*SKIPLE SHOULD SKIP THE NEXT INSTRUCTION
  1177						STOP^
  1178	031071	254 04 0 00 031072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1179	031072	324 00 0 00 031073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1180									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1181									;IN THE SUBTEST) TO LOOP ON ERROR^
  1182
  1183					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 9
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0037

  1184					;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1185					;INSTRUCTION WHEN E CONTAINS A POSITIVE NUMBER.  THE MOVE INSTRUCTION LOADS
  1186					;E WITH 377777777777, A POSITIVE NUMBER.
  1187
  1188	031073	200 00 0 00 035064 	A2200:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A POSITIVE NUMBER
  1189	031074	333 00 0 00 000000 		SKIPLE			;*SKIPLE SHOULD NOT SKIP THE NEXT INSTRUCTION
  1190	031075	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1191						STOP^
  1192	031076	254 04 0 00 031077 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1193	031077	324 00 0 00 031100 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1194									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1195									;IN THE SUBTEST) TO LOOP ON ERROR^
  1196
  1197					;*********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 10
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0038

  1198					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1199					;INSTRUCTION ;WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1200					;LOAD 777000000000, A NON-ZERO NUMBER INTO E.
  1201
  1202	031100	200 00 0 00 035066 	A2300:	MOVE	[XWD 777000,0]	;PRESET E WITH 777000000000, A NON-ZERO NUMBER
  1203	031101	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1204						STOP^
  1205	031102	254 04 0 00 031103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1206	031103	324 00 0 00 031104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1207									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1208									;IN THE SUBTEST) TO LOOP ON ERROR^
  1209
  1210					;**********
  1211
  1212					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1213					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1214					;LOAD A NON-ZERO NUMBER, 377000000 INTO E.
  1215
  1216	031104	200 00 0 00 035067 	A2400:	MOVE	[XWD 377,0]	;PRESET E TO 377000000, A NON ZERO NUMBER
  1217	031105	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1218						STOP^
  1219	031106	254 04 0 00 031107 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1220	031107	324 00 0 00 031110 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1221									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1222									;IN THE SUBTEST) TO LOOP ON ERROR^
  1223
  1224					;**********
  1225
  1226					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1227					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1228					;LOAD E WITH A NON-ZERO NUMBER, 177000.
  1229
  1230	031110	200 00 0 00 035070 	A2500:	MOVE	[177000]	;PRESET E WITH 177000, A NON ZERO NUMBER
  1231	031111	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1232						STOP^
  1233	031112	254 04 0 00 031113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1234	031113	324 00 0 00 031114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1235									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1236									;IN THE SUBTEST) TO LOOP ON ERROR^
  1237
  1238					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 11
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0039

  1239					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1240					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1241					;LOAD 777, A NON-ZERO NUMBER INTO E.
  1242
  1243	031114	200 00 0 00 035071 	A2600:	MOVE	[777]		;PRESET E WITH 777, A NON-ZERO NUMBER
  1244	031115	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1245						STOP^
  1246	031116	254 04 0 00 031117 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1247	031117	324 00 0 00 031120 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1248									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1249									;IN THE SUBTEST) TO LOOP ON ERROR^
  1250
  1251					;**********
  1252
  1253					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1254					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1255					;LOAD E WITH 600000, A NON-ZERO NUMBER.
  1256
  1257	031120	200 00 0 00 035072 	A2700:	MOVE	[600000]	;PRESET E WITK 600000, A NON-ZERO NUMBER
  1258	031121	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1259						STOP^
  1260	031122	254 04 0 00 031123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1261	031123	324 00 0 00 031124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1262									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1263									;IN THE SUBTEST) TO LOOP ON ERROR^
  1264
  1265					;**********
  1266
  1267					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1268					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1269					;LOAD E WITH 400000000, A NON-ZERO NUMBER.
  1270
  1271	031124	200 00 0 00 035073 	A3000:	MOVE	[XWD 400,000]	;PRESET E WITH 400000000, A NON-ZERO NUMBER
  1272	031125	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1273						STOP^
  1274	031126	254 04 0 00 031127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1275	031127	324 00 0 00 031130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1276									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1277									;IN THE SUBTEST) TO LOOP ON ERROR^
  1278
  1279					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0040

  1280			003100		SN=3100
  1281			000000			ZZ=0
  1282
  1283					A3100:	REPEAT	^D36,
  1284					<;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1285					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1286					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1287					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1288					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1289
  1290					SN=SN+1
  1291						ZZ=ZZ+ZZ
  1292						IFE	ZZ,<ZZ=1>
  1293						MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1294						SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1295						STOP
  1296
  1297					;**********
  1298					>
  1299					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1300					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1301					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1302					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1303					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1304
  1305			003101		SN=SN+1
  1306			000000			ZZ=ZZ+ZZ
  1307			000001			IFE	ZZ,<ZZ=1>
  1308	031130	200 00 0 00 035074 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1309	031131	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1310						STOP^
  1311	031132	254 04 0 00 031133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1312	031133	324 00 0 00 031134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1313									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1314									;IN THE SUBTEST) TO LOOP ON ERROR^
  1315
  1316					;**********
  1317
  1318					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1319					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1320					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1321					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1322					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1323
  1324			003102		SN=SN+1
  1325			000002			ZZ=ZZ+ZZ
  1326						IFE	ZZ,<ZZ=1>
  1327	031134	200 00 0 00 035075 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1328	031135	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1329						STOP^
  1330	031136	254 04 0 00 031137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1331	031137	324 00 0 00 031140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1333									;IN THE SUBTEST) TO LOOP ON ERROR^
  1334
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0041

  1335					;**********
  1336
  1337					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1338					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1339					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1340					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1341					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1342
  1343			003103		SN=SN+1
  1344			000004			ZZ=ZZ+ZZ
  1345						IFE	ZZ,<ZZ=1>
  1346	031140	200 00 0 00 035076 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1347	031141	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1348						STOP^
  1349	031142	254 04 0 00 031143 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1350	031143	324 00 0 00 031144 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1351									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1352									;IN THE SUBTEST) TO LOOP ON ERROR^
  1353
  1354					;**********
  1355
  1356					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1357					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1358					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1359					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1360					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1361
  1362			003104		SN=SN+1
  1363			000010			ZZ=ZZ+ZZ
  1364						IFE	ZZ,<ZZ=1>
  1365	031144	200 00 0 00 035077 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1366	031145	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1367						STOP^
  1368	031146	254 04 0 00 031147 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1369	031147	324 00 0 00 031150 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1370									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1371									;IN THE SUBTEST) TO LOOP ON ERROR^
  1372
  1373					;**********
  1374
  1375					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1376					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1377					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1378					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1379					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1380
  1381			003105		SN=SN+1
  1382			000020			ZZ=ZZ+ZZ
  1383						IFE	ZZ,<ZZ=1>
  1384	031150	200 00 0 00 035100 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1385	031151	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1386						STOP^
  1387	031152	254 04 0 00 031153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1388	031153	324 00 0 00 031154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1389									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-2
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0042

  1390									;IN THE SUBTEST) TO LOOP ON ERROR^
  1391
  1392					;**********
  1393
  1394					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1395					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1396					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1397					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1398					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1399
  1400			003106		SN=SN+1
  1401			000040			ZZ=ZZ+ZZ
  1402						IFE	ZZ,<ZZ=1>
  1403	031154	200 00 0 00 035101 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1404	031155	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1405						STOP^
  1406	031156	254 04 0 00 031157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1407	031157	324 00 0 00 031160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1408									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1409									;IN THE SUBTEST) TO LOOP ON ERROR^
  1410
  1411					;**********
  1412
  1413					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1414					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1415					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1416					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1417					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1418
  1419			003107		SN=SN+1
  1420			000100			ZZ=ZZ+ZZ
  1421						IFE	ZZ,<ZZ=1>
  1422	031160	200 00 0 00 035102 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1423	031161	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1424						STOP^
  1425	031162	254 04 0 00 031163 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1426	031163	324 00 0 00 031164 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1427									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1428									;IN THE SUBTEST) TO LOOP ON ERROR^
  1429
  1430					;**********
  1431
  1432					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1433					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1434					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1435					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1436					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1437
  1438			003110		SN=SN+1
  1439			000200			ZZ=ZZ+ZZ
  1440						IFE	ZZ,<ZZ=1>
  1441	031164	200 00 0 00 035103 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1442	031165	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1443						STOP^
  1444	031166	254 04 0 00 031167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-3
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0043

  1445	031167	324 00 0 00 031170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1446									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1447									;IN THE SUBTEST) TO LOOP ON ERROR^
  1448
  1449					;**********
  1450
  1451					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1452					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1453					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1454					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1455					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1456
  1457			003111		SN=SN+1
  1458			000400			ZZ=ZZ+ZZ
  1459						IFE	ZZ,<ZZ=1>
  1460	031170	200 00 0 00 035104 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1461	031171	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1462						STOP^
  1463	031172	254 04 0 00 031173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1464	031173	324 00 0 00 031174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1465									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1466									;IN THE SUBTEST) TO LOOP ON ERROR^
  1467
  1468					;**********
  1469
  1470					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1471					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1472					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1473					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1474					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1475
  1476			003112		SN=SN+1
  1477			001000			ZZ=ZZ+ZZ
  1478						IFE	ZZ,<ZZ=1>
  1479	031174	200 00 0 00 035105 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1480	031175	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1481						STOP^
  1482	031176	254 04 0 00 031177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1483	031177	324 00 0 00 031200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1484									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1485									;IN THE SUBTEST) TO LOOP ON ERROR^
  1486
  1487					;**********
  1488
  1489					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1490					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1491					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1492					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1493					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1494
  1495			003113		SN=SN+1
  1496			002000			ZZ=ZZ+ZZ
  1497						IFE	ZZ,<ZZ=1>
  1498	031200	200 00 0 00 035106 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1499	031201	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-4
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0044

  1500						STOP^
  1501	031202	254 04 0 00 031203 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1502	031203	324 00 0 00 031204 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1503									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1504									;IN THE SUBTEST) TO LOOP ON ERROR^
  1505
  1506					;**********
  1507
  1508					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1509					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1510					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1511					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1512					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1513
  1514			003114		SN=SN+1
  1515			004000			ZZ=ZZ+ZZ
  1516						IFE	ZZ,<ZZ=1>
  1517	031204	200 00 0 00 035107 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1518	031205	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1519						STOP^
  1520	031206	254 04 0 00 031207 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1521	031207	324 00 0 00 031210 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1522									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1523									;IN THE SUBTEST) TO LOOP ON ERROR^
  1524
  1525					;**********
  1526
  1527					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1528					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1529					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1530					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1531					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1532
  1533			003115		SN=SN+1
  1534			010000			ZZ=ZZ+ZZ
  1535						IFE	ZZ,<ZZ=1>
  1536	031210	200 00 0 00 035110 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1537	031211	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1538						STOP^
  1539	031212	254 04 0 00 031213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1540	031213	324 00 0 00 031214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1541									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1542									;IN THE SUBTEST) TO LOOP ON ERROR^
  1543
  1544					;**********
  1545
  1546					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1547					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1548					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1549					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1550					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1551
  1552			003116		SN=SN+1
  1553			020000			ZZ=ZZ+ZZ
  1554						IFE	ZZ,<ZZ=1>
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-5
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0045

  1555	031214	200 00 0 00 035111 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1556	031215	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1557						STOP^
  1558	031216	254 04 0 00 031217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1559	031217	324 00 0 00 031220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1560									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1561									;IN THE SUBTEST) TO LOOP ON ERROR^
  1562
  1563					;**********
  1564
  1565					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1566					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1567					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1568					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1569					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1570
  1571			003117		SN=SN+1
  1572			040000			ZZ=ZZ+ZZ
  1573						IFE	ZZ,<ZZ=1>
  1574	031220	200 00 0 00 035112 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1575	031221	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1576						STOP^
  1577	031222	254 04 0 00 031223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1578	031223	324 00 0 00 031224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1580									;IN THE SUBTEST) TO LOOP ON ERROR^
  1581
  1582					;**********
  1583
  1584					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1585					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1586					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1587					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1588					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1589
  1590			003120		SN=SN+1
  1591			100000			ZZ=ZZ+ZZ
  1592						IFE	ZZ,<ZZ=1>
  1593	031224	200 00 0 00 035113 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1594	031225	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1595						STOP^
  1596	031226	254 04 0 00 031227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1597	031227	324 00 0 00 031230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1598									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1599									;IN THE SUBTEST) TO LOOP ON ERROR^
  1600
  1601					;**********
  1602
  1603					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1604					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1605					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1606					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1607					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1608
  1609			003121		SN=SN+1
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-6
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0046

  1610			200000			ZZ=ZZ+ZZ
  1611						IFE	ZZ,<ZZ=1>
  1612	031230	200 00 0 00 035114 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1613	031231	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1614						STOP^
  1615	031232	254 04 0 00 031233 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1616	031233	324 00 0 00 031234 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1617									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1618									;IN THE SUBTEST) TO LOOP ON ERROR^
  1619
  1620					;**********
  1621
  1622					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1623					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1624					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1625					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1626					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1627
  1628			003122		SN=SN+1
  1629			400000			ZZ=ZZ+ZZ
  1630						IFE	ZZ,<ZZ=1>
  1631	031234	200 00 0 00 035115 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1632	031235	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1633						STOP^
  1634	031236	254 04 0 00 031237 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1635	031237	324 00 0 00 031240 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1636									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1637									;IN THE SUBTEST) TO LOOP ON ERROR^
  1638
  1639					;**********
  1640
  1641					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1642					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1643					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1644					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1645					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1646
  1647			003123		SN=SN+1
  1648		000001	000000			ZZ=ZZ+ZZ
  1649						IFE	ZZ,<ZZ=1>
  1650	031240	200 00 0 00 035116 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1651	031241	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1652						STOP^
  1653	031242	254 04 0 00 031243 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1654	031243	324 00 0 00 031244 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1655									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1656									;IN THE SUBTEST) TO LOOP ON ERROR^
  1657
  1658					;**********
  1659
  1660					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1661					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1662					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1663					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1664					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-7
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0047

  1665
  1666			003124		SN=SN+1
  1667		000002	000000			ZZ=ZZ+ZZ
  1668						IFE	ZZ,<ZZ=1>
  1669	031244	200 00 0 00 035117 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1670	031245	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1671						STOP^
  1672	031246	254 04 0 00 031247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1673	031247	324 00 0 00 031250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1674									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1675									;IN THE SUBTEST) TO LOOP ON ERROR^
  1676
  1677					;**********
  1678
  1679					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1680					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1681					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1682					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1683					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1684
  1685			003125		SN=SN+1
  1686		000004	000000			ZZ=ZZ+ZZ
  1687						IFE	ZZ,<ZZ=1>
  1688	031250	200 00 0 00 035120 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1689	031251	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1690						STOP^
  1691	031252	254 04 0 00 031253 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1692	031253	324 00 0 00 031254 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1693									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1694									;IN THE SUBTEST) TO LOOP ON ERROR^
  1695
  1696					;**********
  1697
  1698					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1699					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1700					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1701					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1702					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1703
  1704			003126		SN=SN+1
  1705		000010	000000			ZZ=ZZ+ZZ
  1706						IFE	ZZ,<ZZ=1>
  1707	031254	200 00 0 00 035121 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1708	031255	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1709						STOP^
  1710	031256	254 04 0 00 031257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1711	031257	324 00 0 00 031260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1712									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1713									;IN THE SUBTEST) TO LOOP ON ERROR^
  1714
  1715					;**********
  1716
  1717					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1718					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1719					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-8
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0048

  1720					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1721					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1722
  1723			003127		SN=SN+1
  1724		000020	000000			ZZ=ZZ+ZZ
  1725						IFE	ZZ,<ZZ=1>
  1726	031260	200 00 0 00 035122 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1727	031261	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1728						STOP^
  1729	031262	254 04 0 00 031263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1730	031263	324 00 0 00 031264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1731									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1732									;IN THE SUBTEST) TO LOOP ON ERROR^
  1733
  1734					;**********
  1735
  1736					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1737					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1738					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1739					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1740					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1741
  1742			003130		SN=SN+1
  1743		000040	000000			ZZ=ZZ+ZZ
  1744						IFE	ZZ,<ZZ=1>
  1745	031264	200 00 0 00 035123 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1746	031265	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1747						STOP^
  1748	031266	254 04 0 00 031267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1749	031267	324 00 0 00 031270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1750									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1751									;IN THE SUBTEST) TO LOOP ON ERROR^
  1752
  1753					;**********
  1754
  1755					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1756					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1757					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1758					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1759					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1760
  1761			003131		SN=SN+1
  1762		000100	000000			ZZ=ZZ+ZZ
  1763						IFE	ZZ,<ZZ=1>
  1764	031270	200 00 0 00 035124 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1765	031271	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1766						STOP^
  1767	031272	254 04 0 00 031273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1768	031273	324 00 0 00 031274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1769									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1770									;IN THE SUBTEST) TO LOOP ON ERROR^
  1771
  1772					;**********
  1773
  1774					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-9
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0049

  1775					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1776					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1777					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1778					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1779
  1780			003132		SN=SN+1
  1781		000200	000000			ZZ=ZZ+ZZ
  1782						IFE	ZZ,<ZZ=1>
  1783	031274	200 00 0 00 035125 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1784	031275	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1785						STOP^
  1786	031276	254 04 0 00 031277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1787	031277	324 00 0 00 031300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1788									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1789									;IN THE SUBTEST) TO LOOP ON ERROR^
  1790
  1791					;**********
  1792
  1793					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1794					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1795					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1796					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1797					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1798
  1799			003133		SN=SN+1
  1800		000400	000000			ZZ=ZZ+ZZ
  1801						IFE	ZZ,<ZZ=1>
  1802	031300	200 00 0 00 035073 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1803	031301	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1804						STOP^
  1805	031302	254 04 0 00 031303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1806	031303	324 00 0 00 031304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1807									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1808									;IN THE SUBTEST) TO LOOP ON ERROR^
  1809
  1810					;**********
  1811
  1812					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1813					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1814					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1815					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1816					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1817
  1818			003134		SN=SN+1
  1819		001000	000000			ZZ=ZZ+ZZ
  1820						IFE	ZZ,<ZZ=1>
  1821	031304	200 00 0 00 035126 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1822	031305	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1823						STOP^
  1824	031306	254 04 0 00 031307 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1825	031307	324 00 0 00 031310 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1826									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1827									;IN THE SUBTEST) TO LOOP ON ERROR^
  1828
  1829					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-10
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0050

  1830
  1831					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1832					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1833					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1834					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1835					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1836
  1837			003135		SN=SN+1
  1838		002000	000000			ZZ=ZZ+ZZ
  1839						IFE	ZZ,<ZZ=1>
  1840	031310	200 00 0 00 035127 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1841	031311	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1842						STOP^
  1843	031312	254 04 0 00 031313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1844	031313	324 00 0 00 031314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1845									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1846									;IN THE SUBTEST) TO LOOP ON ERROR^
  1847
  1848					;**********
  1849
  1850					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1851					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1852					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1853					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1854					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1855
  1856			003136		SN=SN+1
  1857		004000	000000			ZZ=ZZ+ZZ
  1858						IFE	ZZ,<ZZ=1>
  1859	031314	200 00 0 00 035130 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1860	031315	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1861						STOP^
  1862	031316	254 04 0 00 031317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1863	031317	324 00 0 00 031320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1864									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1865									;IN THE SUBTEST) TO LOOP ON ERROR^
  1866
  1867					;**********
  1868
  1869					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1870					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1871					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1872					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1873					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1874
  1875			003137		SN=SN+1
  1876		010000	000000			ZZ=ZZ+ZZ
  1877						IFE	ZZ,<ZZ=1>
  1878	031320	200 00 0 00 035131 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1879	031321	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1880						STOP^
  1881	031322	254 04 0 00 031323 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1882	031323	324 00 0 00 031324 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1883									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1884									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-11
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0051

  1885
  1886					;**********
  1887
  1888					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1889					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1890					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1891					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1892					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1893
  1894			003140		SN=SN+1
  1895		020000	000000			ZZ=ZZ+ZZ
  1896						IFE	ZZ,<ZZ=1>
  1897	031324	200 00 0 00 035132 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1898	031325	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1899						STOP^
  1900	031326	254 04 0 00 031327 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1901	031327	324 00 0 00 031330 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1902									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1903									;IN THE SUBTEST) TO LOOP ON ERROR^
  1904
  1905					;**********
  1906
  1907					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1908					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1909					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1910					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1911					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1912
  1913			003141		SN=SN+1
  1914		040000	000000			ZZ=ZZ+ZZ
  1915						IFE	ZZ,<ZZ=1>
  1916	031330	200 00 0 00 035133 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1917	031331	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1918						STOP^
  1919	031332	254 04 0 00 031333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1920	031333	324 00 0 00 031334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1921									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1922									;IN THE SUBTEST) TO LOOP ON ERROR^
  1923
  1924					;**********
  1925
  1926					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1927					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1928					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1929					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1930					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1931
  1932			003142		SN=SN+1
  1933		100000	000000			ZZ=ZZ+ZZ
  1934						IFE	ZZ,<ZZ=1>
  1935	031334	200 00 0 00 035134 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1936	031335	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1937						STOP^
  1938	031336	254 04 0 00 031337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1939	031337	324 00 0 00 031340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 12-12
DAKAAM	MAC	19-JAN-77 13:42		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS                                         SEQ 0052

  1940									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1941									;IN THE SUBTEST) TO LOOP ON ERROR^
  1942
  1943					;**********
  1944
  1945					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1946					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1947					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1948					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1949					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1950
  1951			003143		SN=SN+1
  1952		200000	000000			ZZ=ZZ+ZZ
  1953						IFE	ZZ,<ZZ=1>
  1954	031340	200 00 0 00 035135 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1955	031341	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1956						STOP^
  1957	031342	254 04 0 00 031343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1958	031343	324 00 0 00 031344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1959									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1960									;IN THE SUBTEST) TO LOOP ON ERROR^
  1961
  1962					;**********
  1963
  1964					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1965					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1966					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1967					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1968					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1969
  1970			003144		SN=SN+1
  1971		400000	000000			ZZ=ZZ+ZZ
  1972						IFE	ZZ,<ZZ=1>
  1973	031344	200 00 0 00 035065 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1974	031345	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1975						STOP^
  1976	031346	254 04 0 00 031347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1977	031347	324 00 0 00 031350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1979									;IN THE SUBTEST) TO LOOP ON ERROR^
  1980
  1981					;**********
  1982
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 13
DAKAAM	MAC	19-JAN-77 13:42		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0053

  1983					SUBTTL	TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS
  1984
  1985					;THIS TEST VERIFIES THAT MOVEI LOADS E INTO THE AC.  SKIPG IS USED TO CHECK THAT
  1986					;THE AC WAS INDEED MODIFIED BY MOVEI.
  1987
  1988	031350	201 00 0 00 035063 	A3200:	MOVEI	[-1]		;*MOVEI SHOULD LOAD A POSITIVE NUMBER INTO AC0
  1989	031351	337 00 0 00 000000 		SKIPG			;SKIP HALT INSTRUCTION IF MOVEI LOADED AC CORRECTLY
  1990						STOP^
  1991	031352	254 04 0 00 031353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1992	031353	324 00 0 00 031354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1993									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1994									;IN THE SUBTEST) TO LOOP ON ERROR^
  1995
  1996					;IF PROGRAM HANGS UP ON MOVEI INSTRUCTION, CHECK AD FM +EN [ADFP], AD FM + EN A [ADFP],
  1997					;AD FM + F/F [ADFP], F CYC ACT EN C [F1]
  1998
  1999					;**********
  2000
  2001					;THIS TEST VERIFIES THAT SKIPL IS SENSITIVE TO THE DATA IN E AND NOT SENSITIVE TO
  2002					;THE DATA IN THE AC.  HENCE, SKIPL WILL SKIP THE NEXT INSTRUCTION ONLY IF
  2003					;C(E) IS LESS THAN ZERO.  E IS SET TO -1, A NEGATIVE NUMBER; AND
  2004					;THE AC IS SET TO 0 IN THIS TEST.  THEREFORE SKIPL SHOULD SKIP.
  2005
  2006	031354	200 00 0 00 035062 	A3300:	MOVE	[0]		;SET THE AC TO ALL ZEROS
  2007	031355	331 00 0 00 035063 		SKIPL	[-1]		;*SKIPL SHOULD SKIP BECAUSE C(E) IS NEGATIVE
  2008						STOP^
  2009	031356	254 04 0 00 031357 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2010	031357	324 00 0 00 031360 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2011									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2012									;IN THE SUBTEST) TO LOOP ON ERROR^
  2013
  2014					;**********
  2015
  2016					;THIS TEST VERIFIES THAT SKIPL IS SENSITIVE TO THE SIGN BIT IN E.  SKIPL SHOULD
  2017					;SKIP THE NEXT INSTRUCTION WHEN AND ONLY WHEN THE SIGN BIT IS SET.  IN THIS
  2018					;TEST, C(AC) IS PRESET TO ALL ZEROS, THEN SKIPL IS EXECUTED WITH C(E)=400000,,0.
  2019					;A FAILURE UCCURS IF SKIPL DOES NOT SKIP.
  2020
  2021	031360	200 00 0 00 035062 	A13100:	MOVE	[0]		;SET THE AC TO ALL ZEROS
  2022	031361	331 00 0 00 035065 		SKIPL	[400000,,0]	;*SKIPL SHOULD SKIP BECAUSE C(E) IS NEGATIVE
  2023						STOP^
  2024	031362	254 04 0 00 031363 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2025	031363	324 00 0 00 031364 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2026									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2027									;IN THE SUBTEST) TO LOOP ON ERROR^
  2028
  2029					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 14
DAKAAM	MAC	19-JAN-77 13:42		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0054

  2030					;THIS TEST VERIFIES THAT THE CAM INSTRUCTION DOES NOT MODIFY C(AC).  THE AC IS
  2031					;INITIALLY LOADED WITH ALL ZEROS; THEN CAM IS EXECUTED WITH C(E) NON-ZERO.
  2032					;THE AC IS THEN CHECKED FOR ALL ZEROS.  THIS TEST FAILS IF THE AC WAS MODIFIED BY CAM.
  2033
  2034	031364	200 00 0 00 035062 	A3400:	MOVE	[0]		;PRESET THE AC TO ALL ZEROS
  2035	031365	310 00 0 00 035136 		CAM	[1234]		;*CAM SHOULD NOT MODIFY THE AC
  2036	031366	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION SERVES AS A NO-OP.
  2037									;IT IS A PROGRAM FILLER IN CASE CAM SKIPS.)
  2038	031367	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC WAS NOT MODIFIED BY CAM
  2039						STOP^
  2040	031370	254 04 0 00 031371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2041	031371	324 00 0 00 031372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2042									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2043									;IN THE SUBTEST) TO LOOP ON ERROR^
  2044
  2045					;IF TEST HANGS ON CAM INSTRUCTION, AB PC EN [ABC], AB PC (FETCH) EN [ABC],
  2046					;IR CAXX [IR3]
  2047
  2048					;IF TEST LOOPS ON CAM INSTRUCTION, MC INSTR FETCH EN [MC1], MC INST FET ET2 EN [MC1],
  2049					;ET2 J F/F [E], IR CAXX [IR3]
  2050
  2051					;IF TEST HALTS AT HALT INSTRUCTION, SAC INH [ST2], IR CAXX [IR3], IR CAMX [IR1]
  2052
  2053					;**********
  2054
  2055					;THIS TEST VERIFIES THAT THE CAI INSTRUCTION DOES NOT MODIFY C(AC).  THE AC IS
  2056					;INITIALLY LOADED WITH ALL ZEROS; THEN CAI IS EXECUTED WITH E NON-ZERO.  THE AC IS
  2057					;THEN CHECKED FOR ALL ZEROS.  THIS TEST FAILS IF THE AC WAS MODIFIED BY CAM.
  2058
  2059	031372	200 00 0 00 035062 	A3500:	MOVE	[0]		;PRESET THE AC TO ALL ZEROS
  2060	031373	300 00 0 00 035136 		CAI	[1234]		;*CAI SHOULD NOT MODIFY THE AC
  2061	031374	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A PROGRAM FILLER
  2062									;IN CASE CAI MODIFIES THE AC.  IT SERVES AS A NO-OP)
  2063	031375	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF CAI DID NOT MODIFY THE AC
  2064						STOP^
  2065	031376	254 04 0 00 031377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2066	031377	324 00 0 00 031400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2067									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2068									;IN THE SUBTEST) TO LOOP ON ERROR^
  2069
  2070					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 15
DAKAAM	MAC	19-JAN-77 13:42		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0055

  2071					;THIS TEST VERIFIES THAT CAI DOES NOT MODIFY C(AC0) WHEN AN AC OTHER THAN AC0 IS
  2072					;SPECIFIED BY THE CAI INSTRUCTION.
  2073					;THIS IS THE FIRST TEST THAT USES AN AC OTHER THAN AC0.
  2074					;FIRST, AC0 IS LOADED WITH ALL ZEROS; THEN, THE CAI INSTRUCTION IS EXECUTED WITH
  2075					;A NON-ZERO E.  AC 0 IS THEN TESTED F0R ALL ZEROS.
  2076
  2077	031400	200 00 0 00 035062 	A3600:	MOVE	[0]		;LOAD AC0 WITH ALL ZEROS
  2078	031401	300 17 0 00 035136 		CAI	17,[1234]	;*CAI SHOULD NOT MODIFY AC0
  2079	031402	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
  2080									;CAI SKIPS THE NEXT INSTRUCTION.  IT ACTS AS A NO-OP)
  2081	031403	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF C(AC0) WAS NOT MODIFIED
  2082						STOP^
  2083	031404	254 04 0 00 031405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2084	031405	324 00 0 00 031406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2085									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2086									;IN THE SUBTEST) TO LOOP ON ERROR^
  2087
  2088					;**********
  2089
  2090					;THIS TEST VERIFIES THAT CAM DOES NOT MODIFY C(AC0) WHEN AN AC OTHER THAN AC0 IS
  2091					;SPECIFIED BY THE CAM INSTRUCTION.
  2092					;FIRST, AC0 IS LOADED WITH ALL ZEROS; THEN, THE CAM INSTRUCTION IS EXECUTED WITH
  2093					;A NON-ZERO E.  AC 0 IS THEN TESTED F0R ALL ZEROS.
  2094
  2095	031406	200 00 0 00 035062 	A3700:	MOVE	[0]		;PRESET C(AC0) TO ALL ZEROS
  2096	031407	310 17 0 00 035136 		CAM	17,[1234]	;*CAM SHOULD NOT MODIFY AC0
  2097	031410	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
  2098									;CAM SKIPS THE NEXT INSTRUCTION.  IT SERVES AS A NO-OP)
  2099	031411	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS NOT MODIFIED BY CAM
  2100						STOP^
  2101	031412	254 04 0 00 031413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2102	031413	324 00 0 00 031414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2103									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2104									;IN THE SUBTEST) TO LOOP ON ERROR^
  2105
  2106					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 16
DAKAAM	MAC	19-JAN-77 13:42		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0056

  2107					;THIS TEST VERIFIES THAT MOVE WILL PLACE C(E) INTO THE AC.  AC, E AND C(E) ARE NON-ZERO
  2108					;IN THIS TEST.  THIS TEST PASSES IF  FINAL C(AC) OF THE MOVE INSTRUCTION IS NON-ZERO.
  2109
  2110	031414	200 01 0 00 035062 	A4500:	MOVE	1,[0]		;LOAD THE AC WITH ALL ZEROS
  2111	031415	200 01 0 00 035063 		MOVE	1,[-1]		;*MOVE SHOULD PLACE ALL ONES IN THE AC
  2112	031416	336 00 0 00 000001 		SKIPN	1		;SKIP HALT INSTRUCTION IF MOVE MODIFIED THE AC
  2113						STOP^
  2114	031417	254 04 0 00 031420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2115	031420	324 00 0 00 031421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2116									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2117									;IN THE SUBTEST) TO LOOP ON ERROR^
  2118
  2119					;**********
  2120
  2121					;THIS TEST VERIFIES THAT THE MOVE INSTRUCTION WILL PLACE C(E) INTO THE AC.
  2122					;AC, E ARE NON-ZERO AND C(E)=0.
  2123					;THIS TEST FAILS IF THE FINAL C(AC) IS NOT EQUAL TO ZERO, THE ORIGINAL C(E)
  2124
  2125	031421	200 01 0 00 035062 	A4600:	MOVE	1,[0]		;*PLACE ALL ZEROS INTO THE AC
  2126	031422	332 00 0 00 000001 		SKIPE	1		;SKIP HALT INSTRUCTION IF MOVE PLACED ALL ZEROS INTO AC
  2127						STOP^
  2128	031423	254 04 0 00 031424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2129	031424	324 00 0 00 031425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2130									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2131									;IN THE SUBTEST) TO LOOP ON ERROR^
  2132
  2133					;IF JUMP .+1 OF PREVIOUS TEST FAILED, CHECK JUMPS: AD FM + EN [ADFP], IR JUMPS [IR1],
  2134					;IR JUMPX [IR1], AR AD EN [ARMA], AR AD EN A [ARMA], AR LT AD EN A [ARMA],
  2135					;AR LT ADD EN B [ARMA], AR RT AD EN A [ARMA],
  2136					;AR RT AD EN B [ARMA], AR A CLK INPUT [ARMA],
  2137					;ET2 C F/F [E], AR AD ET2 EN [ARMA], AR AD BR (ET2) B [ARMA]
  2138
  2139					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 17
DAKAAM	MAC	19-JAN-77 13:42		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0057

  2140					;THIS TEST VERIFIES THAT SOS DOES NOT MODIFY C(AC) WHEN THE AC IS AC0.
  2141					;FIRST, AC0 IS LOADED WITH ALL ZEROS AND E IS LOADED WITH A POSITIVE NUMBER;
  2142					;THEN, SOS IS EXECUTED.  SOS SHOULD SUBTRACT ONE FROM C((E)
  2143					;AND EXECUTE THE NEXT INSTRUCTION.  IT SHOULD NOT MODIFY AC0.
  2144					;THE TEST PASSES IF AC0 WAS NOT MODIFIED.
  2145
  2146	031425	200 00 0 00 035062 	A4000:	MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2147	031426	200 07 0 00 035136 		MOVE	7,[1234]	;PRESET E WITH A POSITIVE NUMBER
  2148	031427	370 00 0 00 000007 		SOS	7		;*SOS SHOULD NOT MODIFY C(AC0)
  2149	031430	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
  2150									;SOS SKIPS THE NEXT INSTRUCTION.  IT SERVES AS A NO-OP)
  2151	031431	332 00 0 00 000000 		SKIPE			;SKIP THE HALT INSTRUCTION IF C(AC0) WAS NOT MODIFIED
  2152						STOP^
  2153	031432	254 04 0 00 031433 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2154	031433	324 00 0 00 031434 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2155									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2156									;IN THE SUBTEST) TO LOOP ON ERROR^
  2157
  2158					;**********
  2159			004100		SN=4100
  2160			000000			AC=0
  2161
  2162					A4100:	REPEAT	4,
  2163					<;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2164					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2165					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2166					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2167					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2168					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2169					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2170
  2171					SN=SN+1
  2172						AC=AC+AC
  2173						IFE	AC,<AC=1>
  2174						MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2175						MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2176						SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2177						SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2178						STOP
  2179						SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2180						STOP
  2181
  2182					;**********
  2183					>
  2184					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2185					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2186					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2187					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2188					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2189					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2190					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2191
  2192			004101		SN=SN+1
  2193			000000			AC=AC+AC
  2194			000001			IFE	AC,<AC=1>
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 17-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0058

  2195	031434	200 00 0 00 035062 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2196	031435	200 01 0 00 035062 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2197	031436	330 01 0 00 035063 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2198	031437	336 00 0 00 000001 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2199						STOP^
  2200	031440	254 04 0 00 031441 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2201	031441	324 00 0 00 031442 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2202									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2203									;IN THE SUBTEST) TO LOOP ON ERROR^
  2204	031442	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2205						STOP^
  2206	031443	254 04 0 00 031444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2207	031444	324 00 0 00 031445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2208									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2209									;IN THE SUBTEST) TO LOOP ON ERROR^
  2210
  2211					;**********
  2212
  2213					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2214					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2215					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2216					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2217					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2218					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2219					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2220
  2221			004102		SN=SN+1
  2222			000002			AC=AC+AC
  2223						IFE	AC,<AC=1>
  2224	031445	200 00 0 00 035062 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2225	031446	200 02 0 00 035062 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2226	031447	330 02 0 00 035063 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2227	031450	336 00 0 00 000002 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2228						STOP^
  2229	031451	254 04 0 00 031452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2230	031452	324 00 0 00 031453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2231									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2232									;IN THE SUBTEST) TO LOOP ON ERROR^
  2233	031453	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2234						STOP^
  2235	031454	254 04 0 00 031455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2236	031455	324 00 0 00 031456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2237									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2238									;IN THE SUBTEST) TO LOOP ON ERROR^
  2239
  2240					;**********
  2241
  2242					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2243					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2244					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2245					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2246					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2247					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2248					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2249
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 17-2
DAKAAM	MAC	19-JAN-77 13:42		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS                                        SEQ 0059

  2250			004103		SN=SN+1
  2251			000004			AC=AC+AC
  2252						IFE	AC,<AC=1>
  2253	031456	200 00 0 00 035062 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2254	031457	200 04 0 00 035062 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2255	031460	330 04 0 00 035063 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2256	031461	336 00 0 00 000004 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2257						STOP^
  2258	031462	254 04 0 00 031463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2259	031463	324 00 0 00 031464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2260									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2261									;IN THE SUBTEST) TO LOOP ON ERROR^
  2262	031464	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2263						STOP^
  2264	031465	254 04 0 00 031466 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2265	031466	324 00 0 00 031467 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2266									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2267									;IN THE SUBTEST) TO LOOP ON ERROR^
  2268
  2269					;**********
  2270
  2271					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2272					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2273					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2274					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2275					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2276					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2277					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2278
  2279			004104		SN=SN+1
  2280			000010			AC=AC+AC
  2281						IFE	AC,<AC=1>
  2282	031467	200 00 0 00 035062 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2283	031470	200 10 0 00 035062 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2284	031471	330 10 0 00 035063 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2285	031472	336 00 0 00 000010 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2286						STOP^
  2287	031473	254 04 0 00 031474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2288	031474	324 00 0 00 031475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2289									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2290									;IN THE SUBTEST) TO LOOP ON ERROR^
  2291	031475	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2292						STOP^
  2293	031476	254 04 0 00 031477 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2294	031477	324 00 0 00 031500 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2295									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2296									;IN THE SUBTEST) TO LOOP ON ERROR^
  2297
  2298					;**********
  2299
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 18
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0060

  2300					SUBTTL	TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS
  2301
  2302					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL NOT MODIFY THE CONTENTS OF AC0.
  2303					;FIRST, AC0 IS LOADED WITH ALL ZEROS;  THEN,
  2304					;THE SKIP INSTRUCTION IS EXECUTED WITH C(E)=-1 AND AC0.  AC0 IS THEN TESTED FOR ALL
  2305					;ZEROS.  THE TEST FAILS IF AC0 WAS MODIFIED BY THE SKIP INSTRUCTION.
  2306
  2307	031500	200 00 0 00 035062 	A4200:	MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2308	031501	330 00 0 00 035063 		SKIP	[-1]		;*SKIP SHOULD NOT MODIFY AC0
  2309	031502	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS NOT MODIFIED BY SKIP
  2310						STOP^
  2311	031503	254 04 0 00 031504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2312	031504	324 00 0 00 031505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2313									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2314									;IN THE SUBTEST) TO LOOP ON ERROR^
  2315
  2316					;AC=0: SAC INH, IR BIT 9, 10, 11 OR 12 S-A-1
  2317
  2318					;**********
  2319
  2320					;THIS TEST VERIFIES THAT MOVSS DOES NOT MODIFY C(AC0) WHEN AC0 IS SPECIFIED AS THE AC.
  2321					;FIRST, E IS LOADED WITH ALL ONES AND THE AC (AC0)
  2322					;IS LOADED WITH ALL ZEROS; THEN, MOVSS IS EXECUTED.  MOVSS SHOULD NOT MODIFY AC0.
  2323					;AC0 IS THEN CHECKED TO INSURE THAT IT WAS NOT MODIFIED BY MOVSS.
  2324
  2325	031505	200 07 0 00 035063 	A4300:	MOVE	7,[-1]		;LOAD E OF THE MOVSS INSTRUCTION WITH ALL ONES
  2326	031506	200 00 0 00 035062 		MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2327	031507	207 00 0 00 000007 		MOVSS	7		;*MOVSS SHOULD NOT MODIFY AC0
  2328	031510	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS INTACT
  2329						STOP^
  2330	031511	254 04 0 00 031512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2331	031512	324 00 0 00 031513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2333									;IN THE SUBTEST) TO LOOP ON ERROR^
  2334
  2335					;MOVX & AC=0: SAC INH [ST2], IR XXXS [IR1]
  2336
  2337					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 19
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0061

  2338					;THIS TEST VERIFIES THAT HRRS DOES NOT MODIFY C(AC0) WHEN AC0 IS THE SPECIFIED AC.
  2339					;FIRST, E IS LOADED WITH ALL ONES AND AC0 IS LOADED WITH ALL ZEROS;
  2340					;THEN, HRRS IS EXECUTED WITH AC=AC0.  AC0 IS THEN CHECKED FOR ALL ZEROS.
  2341					;IF AC0 WAS MODIFIED BY THE HRRS INSTRUCTION, THE TEST FAIL.
  2342
  2343	031513	200 07 0 00 035063 	A4400:	MOVE	7,[-1]		;PRESET E OF THE HRRS INSTRUCTION TO ALL ONES
  2344	031514	200 00 0 00 035062 		MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2345	031515	543 00 0 00 000007 		HRRS	7		;*HRRS SHOULD NOT MODIFY THE AC WHEN THE AC IS AC0
  2346	031516	332 00 0 00 000000 		SKIPE			;SKIP THE HALT INSTRUCTION IF AC0 WAS INTACT
  2347						STOP^
  2348	031517	254 04 0 00 031520 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2349	031520	324 00 0 00 031521 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2350									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2351									;IN THE SUBTEST) TO LOOP ON ERROR^
  2352
  2353					;(HXXXS&AC=0): SAC INH [ST2], IR HWTFWT [IR3], IR XXXS [IR1], IR HWT [IR1],
  2354					;IR BITS S-A-1
  2355
  2356					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 20
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0062

  2357					;THIS TEST VERIFIES THAT THE JUMP INSTRUCTION DOES NOT MODIFY C(AC).
  2358					;THE AC IS FIRST LOADED WITH ALL ZEROS;
  2359					;THEN JUMP .+1 IS EXECUTED.  THE AC IS THEN CHECKED TO INSURE THAT IT WAS NOT MODIFIED
  2360					;BY JUMP.  THE TEST FAILS IF THE AC WAS MODIFIED
  2361
  2362	031521	200 00 0 00 035062 	A4700:	MOVE	[0]		; PRESET THE AC TO ALL ZEROS
  2363	031522	320 00 0 00 031523 		JUMP	.+1		;*JUMP SHOULD NOT MODIFY THE AC
  2364	031523	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC WAS INTACT
  2365						STOP^
  2366	031524	254 04 0 00 031525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2367	031525	324 00 0 00 031526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2368									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2369									;IN THE SUBTEST) TO LOOP ON ERROR^
  2370
  2371					;**********
  2372
  2373					;THIS TEST VERIFIES THAT MOVS WILL NOT PICK UP ANY ONES WHEN SWAPPING A WORD
  2374					;OF ALL ZEROS.  FIRST, E IS LOADED WITH A WORD OF ALL ZEROS;
  2375					;THEN, MOVS IS EXECUTED.  THE AC IS THEN CHECKED TO INSURE THAT THE RESULT DOES NOT
  2376					;CONTAIN ANY ONES.
  2377
  2378	031526	200 00 0 00 035062 	A5000:	MOVE	[0]		;PRESET E WITH ALL ZEROS
  2379	031527	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH AN AC 0F ALL ZEROS
  2380	031530	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF C(AC)=0
  2381						STOP^
  2382	031531	254 04 0 00 031532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2383	031532	324 00 0 00 031533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2384									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2385									;IN THE SUBTEST) TO LOOP ON ERROR^
  2386
  2387					;**********
  2388
  2389					;THIS TEST VERIFIES THAT A MOVS EXECUTED ON AN E CONTAINING A NON-ZERO NUMBER
  2390					;RESULTS IN A NON-ZERO NUMBER IN THE AC.  FIRST A NON-ZERO WORD
  2391					;IS LOADED INTO E; THEN, MOVS IS EXECUTED.  THE AC IS CHECKED FOR A NON-ZERO RESULT.
  2392					;IF C(AC)=0, THE TEST FAILS.
  2393
  2394	031533	200 00 0 00 035137 	A5100:	MOVE	[XWD 0,-1]	;LOAD E WITH A NON-ZERO VALUE
  2395	031534	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT IN C(AC) NON-ZERO
  2396	031535	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF C(AC) OF MOVS IS NON-ZERO
  2397						STOP^
  2398	031536	254 04 0 00 031537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2399	031537	324 00 0 00 031540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2400									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2401									;IN THE SUBTEST) TO LOOP ON ERROR^
  2402
  2403					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 21
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0063

  2404					;THIS TEST VERIFIES THAT A MOVS EXECUTED ON AN E CONTAINING A NON-ZERO NUMBER
  2405					;RESULTS IN A NON-ZERO NUMBER IN THE AC.  FIRST A NON-ZERO WORD
  2406					;IS LOADED INTO E; THEN, MOVS IS EXECUTED.  THE AC IS CHECKED FOR A NON-ZERO
  2407					;RESULT.  IF C(AC)=0, THE TEST FAILS.
  2408
  2409	031540	200 00 0 00 035140 	A5200:	MOVE	[XWD -1,0]	;LOAD E OF MOVS WITH A NON-ZERO NUMBER
  2410	031541	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH C(AC) NON-ZERO
  2411	031542	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF C(AC) OF MOVS IS NON-ZERO
  2412						STOP^
  2413	031543	254 04 0 00 031544 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2414	031544	324 00 0 00 031545 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2415									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2416									;IN THE SUBTEST) TO LOOP ON ERROR^
  2417
  2418					;**********
  2419
  2420					;THIS TEST VERIFIES THAT THE MOVS INSTRUCTION SWAPS BITS 0 AND 188 OF E
  2421					;AND STORES THEM IN THE AC UNLESS AR BIT 0 IS S-A-0.  FIRST, A WORD
  2422					;WITH BIT 0 SET TO A ONE AND BIT 18 CLEARED IS LOADED INTO E.  THEN, MOVS
  2423					;IS EXECUTED.  THE AC IS THEN CHECKED FOR A 0 IN BIT 0, WHICH IS THE
  2424					;CORRECT RESULT.
  2425
  2426	031545	200 00 0 00 035140 	A5300:	MOVE	[XWD -1,0]	;LOAD E OF MOVS WITH 777777000000
  2427	031546	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH AC BIT 0 EQUAL TO 0
  2428	031547	337 00 0 00 000000 		SKIPG			;SKIP HALT INSTRUCTION IF BIT 0 OF AC IS 0
  2429						STOP^
  2430	031550	254 04 0 00 031551 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2431	031551	324 00 0 00 031552 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2432									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2433									;IN THE SUBTEST) TO LOOP ON ERROR^
  2434
  2435					;MOVSX: AR SWAP [ARMB], AR LT AR RT A [ARMB], AR LT AR RT B [ARMB],
  2436					;AR RT AR LT A [ARMB], AR RT AR LT B [ARMB], ET2 A F/F [E], IR MOVSX [IR1],
  2437					;IR MOV(E,S)X [IR1]
  2438
  2439					;**********
  2440
  2441					;THIS TEST VERIFIES THAT THE MOVS INSTRUCTION SWAPS BITS 0 AND 18 OF E AND
  2442					;STORES THEM IN THE AC UNLESS AR BIT 0 IS S-A-1.  FIRST, A WORD WITH BIT 0
  2443					;SET TO A ONE AND BIT 18 CLEARED IS LOADED INTO E.  THEN, MOVS IS EXECUTED.
  2444					;THE AC IS CHECKED FOR A ZERO IN BIT ZERO, WHICH IS THE CORRECT RESULT.
  2445
  2446	031552	200 00 0 00 035137 	A5400:	MOVE	[XWD 0,-1]	;LOAD E OF MOVS WITH 777777
  2447	031553	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH BIT 0 OF THE AC SET
  2448	031554	331 00 0 00 000000 		SKIPL			;PASS IF AC BIT 0 IS SET
  2449						STOP^
  2450	031555	254 04 0 00 031556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2451	031556	324 00 0 00 031557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2452									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2453									;IN THE SUBTEST) TO LOOP ON ERROR^
  2454
  2455					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0064

  2456			005500		SN=5500
  2457			000000			ZZ=0
  2458
  2459					A5500:	REPEAT	^D18,
  2460					<;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2461					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2462					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2463					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2464					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2465					SN=SN+1
  2466						ZZ=ZZ+ZZ
  2467						IFE	ZZ,<ZZ=1>
  2468						MOVE	[0]		;CLEAR AC
  2469						MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2470						SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2471						STOP
  2472
  2473					;**********
  2474					>
  2475					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2476					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2477					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2478					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2479					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2480			005501		SN=SN+1
  2481			000000			ZZ=ZZ+ZZ
  2482			000001			IFE	ZZ,<ZZ=1>
  2483	031557	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2484	031560	204 00 0 00 035074 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2485	031561	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2486						STOP^
  2487	031562	254 04 0 00 031563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2488	031563	324 00 0 00 031564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2489									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2490									;IN THE SUBTEST) TO LOOP ON ERROR^
  2491
  2492					;**********
  2493
  2494					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2495					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2496					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2497					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2498					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2499			005502		SN=SN+1
  2500			000002			ZZ=ZZ+ZZ
  2501						IFE	ZZ,<ZZ=1>
  2502	031564	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2503	031565	204 00 0 00 035075 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2504	031566	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2505						STOP^
  2506	031567	254 04 0 00 031570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2507	031570	324 00 0 00 031571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2508									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2509									;IN THE SUBTEST) TO LOOP ON ERROR^
  2510
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0065

  2511					;**********
  2512
  2513					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2514					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2515					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2516					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2517					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2518			005503		SN=SN+1
  2519			000004			ZZ=ZZ+ZZ
  2520						IFE	ZZ,<ZZ=1>
  2521	031571	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2522	031572	204 00 0 00 035076 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2523	031573	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2524						STOP^
  2525	031574	254 04 0 00 031575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2526	031575	324 00 0 00 031576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2527									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2528									;IN THE SUBTEST) TO LOOP ON ERROR^
  2529
  2530					;**********
  2531
  2532					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2533					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2534					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2535					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2536					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2537			005504		SN=SN+1
  2538			000010			ZZ=ZZ+ZZ
  2539						IFE	ZZ,<ZZ=1>
  2540	031576	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2541	031577	204 00 0 00 035077 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2542	031600	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2543						STOP^
  2544	031601	254 04 0 00 031602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2545	031602	324 00 0 00 031603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2546									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2547									;IN THE SUBTEST) TO LOOP ON ERROR^
  2548
  2549					;**********
  2550
  2551					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2552					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2553					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2554					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2555					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2556			005505		SN=SN+1
  2557			000020			ZZ=ZZ+ZZ
  2558						IFE	ZZ,<ZZ=1>
  2559	031603	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2560	031604	204 00 0 00 035100 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2561	031605	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2562						STOP^
  2563	031606	254 04 0 00 031607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2564	031607	324 00 0 00 031610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2565									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-2
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0066

  2566									;IN THE SUBTEST) TO LOOP ON ERROR^
  2567
  2568					;**********
  2569
  2570					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2571					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2572					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2573					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2574					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2575			005506		SN=SN+1
  2576			000040			ZZ=ZZ+ZZ
  2577						IFE	ZZ,<ZZ=1>
  2578	031610	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2579	031611	204 00 0 00 035101 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2580	031612	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2581						STOP^
  2582	031613	254 04 0 00 031614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2583	031614	324 00 0 00 031615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2584									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2585									;IN THE SUBTEST) TO LOOP ON ERROR^
  2586
  2587					;**********
  2588
  2589					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2590					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2591					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2592					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2593					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2594			005507		SN=SN+1
  2595			000100			ZZ=ZZ+ZZ
  2596						IFE	ZZ,<ZZ=1>
  2597	031615	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2598	031616	204 00 0 00 035102 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2599	031617	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2600						STOP^
  2601	031620	254 04 0 00 031621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2602	031621	324 00 0 00 031622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2603									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2604									;IN THE SUBTEST) TO LOOP ON ERROR^
  2605
  2606					;**********
  2607
  2608					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2609					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2610					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2611					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2612					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2613			005510		SN=SN+1
  2614			000200			ZZ=ZZ+ZZ
  2615						IFE	ZZ,<ZZ=1>
  2616	031622	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2617	031623	204 00 0 00 035103 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2618	031624	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2619						STOP^
  2620	031625	254 04 0 00 031626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-3
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0067

  2621	031626	324 00 0 00 031627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2622									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2623									;IN THE SUBTEST) TO LOOP ON ERROR^
  2624
  2625					;**********
  2626
  2627					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2628					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2629					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2630					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2631					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2632			005511		SN=SN+1
  2633			000400			ZZ=ZZ+ZZ
  2634						IFE	ZZ,<ZZ=1>
  2635	031627	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2636	031630	204 00 0 00 035104 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2637	031631	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2638						STOP^
  2639	031632	254 04 0 00 031633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2640	031633	324 00 0 00 031634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2641									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2642									;IN THE SUBTEST) TO LOOP ON ERROR^
  2643
  2644					;**********
  2645
  2646					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2647					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2648					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2649					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2650					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2651			005512		SN=SN+1
  2652			001000			ZZ=ZZ+ZZ
  2653						IFE	ZZ,<ZZ=1>
  2654	031634	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2655	031635	204 00 0 00 035105 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2656	031636	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2657						STOP^
  2658	031637	254 04 0 00 031640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2659	031640	324 00 0 00 031641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2660									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2661									;IN THE SUBTEST) TO LOOP ON ERROR^
  2662
  2663					;**********
  2664
  2665					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2666					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2667					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2668					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2669					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2670			005513		SN=SN+1
  2671			002000			ZZ=ZZ+ZZ
  2672						IFE	ZZ,<ZZ=1>
  2673	031641	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2674	031642	204 00 0 00 035106 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2675	031643	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-4
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0068

  2676						STOP^
  2677	031644	254 04 0 00 031645 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2678	031645	324 00 0 00 031646 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2680									;IN THE SUBTEST) TO LOOP ON ERROR^
  2681
  2682					;**********
  2683
  2684					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2685					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2686					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2687					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2688					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2689			005514		SN=SN+1
  2690			004000			ZZ=ZZ+ZZ
  2691						IFE	ZZ,<ZZ=1>
  2692	031646	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2693	031647	204 00 0 00 035107 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2694	031650	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2695						STOP^
  2696	031651	254 04 0 00 031652 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2697	031652	324 00 0 00 031653 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2698									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2699									;IN THE SUBTEST) TO LOOP ON ERROR^
  2700
  2701					;**********
  2702
  2703					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2704					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2705					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2706					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2707					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2708			005515		SN=SN+1
  2709			010000			ZZ=ZZ+ZZ
  2710						IFE	ZZ,<ZZ=1>
  2711	031653	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2712	031654	204 00 0 00 035110 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2713	031655	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2714						STOP^
  2715	031656	254 04 0 00 031657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2716	031657	324 00 0 00 031660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2717									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2718									;IN THE SUBTEST) TO LOOP ON ERROR^
  2719
  2720					;**********
  2721
  2722					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2723					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2724					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2725					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2726					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2727			005516		SN=SN+1
  2728			020000			ZZ=ZZ+ZZ
  2729						IFE	ZZ,<ZZ=1>
  2730	031660	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-5
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0069

  2731	031661	204 00 0 00 035111 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2732	031662	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2733						STOP^
  2734	031663	254 04 0 00 031664 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2735	031664	324 00 0 00 031665 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2736									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2737									;IN THE SUBTEST) TO LOOP ON ERROR^
  2738
  2739					;**********
  2740
  2741					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2742					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2743					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2744					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2745					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2746			005517		SN=SN+1
  2747			040000			ZZ=ZZ+ZZ
  2748						IFE	ZZ,<ZZ=1>
  2749	031665	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2750	031666	204 00 0 00 035112 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2751	031667	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2752						STOP^
  2753	031670	254 04 0 00 031671 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2754	031671	324 00 0 00 031672 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2755									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2756									;IN THE SUBTEST) TO LOOP ON ERROR^
  2757
  2758					;**********
  2759
  2760					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2761					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2762					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2763					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2764					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2765			005520		SN=SN+1
  2766			100000			ZZ=ZZ+ZZ
  2767						IFE	ZZ,<ZZ=1>
  2768	031672	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2769	031673	204 00 0 00 035113 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2770	031674	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2771						STOP^
  2772	031675	254 04 0 00 031676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2773	031676	324 00 0 00 031677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2774									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2775									;IN THE SUBTEST) TO LOOP ON ERROR^
  2776
  2777					;**********
  2778
  2779					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2780					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2781					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2782					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2783					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2784			005521		SN=SN+1
  2785			200000			ZZ=ZZ+ZZ
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-6
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0070

  2786						IFE	ZZ,<ZZ=1>
  2787	031677	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2788	031700	204 00 0 00 035114 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2789	031701	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2790						STOP^
  2791	031702	254 04 0 00 031703 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2792	031703	324 00 0 00 031704 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2793									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2794									;IN THE SUBTEST) TO LOOP ON ERROR^
  2795
  2796					;**********
  2797
  2798					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2799					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2800					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2801					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2802					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2803			005522		SN=SN+1
  2804			400000			ZZ=ZZ+ZZ
  2805						IFE	ZZ,<ZZ=1>
  2806	031704	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2807	031705	204 00 0 00 035115 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2808	031706	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2809						STOP^
  2810	031707	254 04 0 00 031710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2811	031710	324 00 0 00 031711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2812									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2813									;IN THE SUBTEST) TO LOOP ON ERROR^
  2814
  2815					;**********
  2816
  2817			005600		SN=5600
  2818
  2819					A5600:	REPEAT	^D18,
  2820					<;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2821					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2822					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2823					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2824					;HALF OF THE AC IS TESTED WITH A 1.
  2825
  2826					SN=SN+1
  2827						ZZ=ZZ+ZZ
  2828						MOVE	[0]		;CLEAR AC
  2829						MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2830						SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2831						STOP
  2832
  2833					;**********
  2834					>
  2835					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2836					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2837					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2838					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2839					;HALF OF THE AC IS TESTED WITH A 1.
  2840
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-7
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0071

  2841			005601		SN=SN+1
  2842		000001	000000			ZZ=ZZ+ZZ
  2843	031711	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2844	031712	204 00 0 00 035116 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2845	031713	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2846						STOP^
  2847	031714	254 04 0 00 031715 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2848	031715	324 00 0 00 031716 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2849									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2850									;IN THE SUBTEST) TO LOOP ON ERROR^
  2851
  2852					;**********
  2853
  2854					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2855					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2856					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2857					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2858					;HALF OF THE AC IS TESTED WITH A 1.
  2859
  2860			005602		SN=SN+1
  2861		000002	000000			ZZ=ZZ+ZZ
  2862	031716	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2863	031717	204 00 0 00 035117 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2864	031720	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2865						STOP^
  2866	031721	254 04 0 00 031722 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2867	031722	324 00 0 00 031723 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2868									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2869									;IN THE SUBTEST) TO LOOP ON ERROR^
  2870
  2871					;**********
  2872
  2873					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2874					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2875					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2876					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2877					;HALF OF THE AC IS TESTED WITH A 1.
  2878
  2879			005603		SN=SN+1
  2880		000004	000000			ZZ=ZZ+ZZ
  2881	031723	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2882	031724	204 00 0 00 035120 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2883	031725	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2884						STOP^
  2885	031726	254 04 0 00 031727 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2886	031727	324 00 0 00 031730 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2887									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2888									;IN THE SUBTEST) TO LOOP ON ERROR^
  2889
  2890					;**********
  2891
  2892					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2893					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2894					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2895					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-8
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0072

  2896					;HALF OF THE AC IS TESTED WITH A 1.
  2897
  2898			005604		SN=SN+1
  2899		000010	000000			ZZ=ZZ+ZZ
  2900	031730	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2901	031731	204 00 0 00 035121 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2902	031732	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2903						STOP^
  2904	031733	254 04 0 00 031734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2905	031734	324 00 0 00 031735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2906									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2907									;IN THE SUBTEST) TO LOOP ON ERROR^
  2908
  2909					;**********
  2910
  2911					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2912					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2913					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2914					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2915					;HALF OF THE AC IS TESTED WITH A 1.
  2916
  2917			005605		SN=SN+1
  2918		000020	000000			ZZ=ZZ+ZZ
  2919	031735	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2920	031736	204 00 0 00 035122 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2921	031737	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2922						STOP^
  2923	031740	254 04 0 00 031741 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2924	031741	324 00 0 00 031742 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2925									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2926									;IN THE SUBTEST) TO LOOP ON ERROR^
  2927
  2928					;**********
  2929
  2930					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2931					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2932					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2933					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2934					;HALF OF THE AC IS TESTED WITH A 1.
  2935
  2936			005606		SN=SN+1
  2937		000040	000000			ZZ=ZZ+ZZ
  2938	031742	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2939	031743	204 00 0 00 035123 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2940	031744	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2941						STOP^
  2942	031745	254 04 0 00 031746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2943	031746	324 00 0 00 031747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2945									;IN THE SUBTEST) TO LOOP ON ERROR^
  2946
  2947					;**********
  2948
  2949					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2950					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-9
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0073

  2951					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2952					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2953					;HALF OF THE AC IS TESTED WITH A 1.
  2954
  2955			005607		SN=SN+1
  2956		000100	000000			ZZ=ZZ+ZZ
  2957	031747	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2958	031750	204 00 0 00 035124 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2959	031751	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2960						STOP^
  2961	031752	254 04 0 00 031753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2962	031753	324 00 0 00 031754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2963									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2964									;IN THE SUBTEST) TO LOOP ON ERROR^
  2965
  2966					;**********
  2967
  2968					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2969					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2970					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2971					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2972					;HALF OF THE AC IS TESTED WITH A 1.
  2973
  2974			005610		SN=SN+1
  2975		000200	000000			ZZ=ZZ+ZZ
  2976	031754	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2977	031755	204 00 0 00 035125 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2978	031756	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2979						STOP^
  2980	031757	254 04 0 00 031760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2981	031760	324 00 0 00 031761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2982									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2983									;IN THE SUBTEST) TO LOOP ON ERROR^
  2984
  2985					;**********
  2986
  2987					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2988					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2989					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2990					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2991					;HALF OF THE AC IS TESTED WITH A 1.
  2992
  2993			005611		SN=SN+1
  2994		000400	000000			ZZ=ZZ+ZZ
  2995	031761	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  2996	031762	204 00 0 00 035073 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2997	031763	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2998						STOP^
  2999	031764	254 04 0 00 031765 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3000	031765	324 00 0 00 031766 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3001									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3002									;IN THE SUBTEST) TO LOOP ON ERROR^
  3003
  3004					;**********
  3005
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-10
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0074

  3006					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3007					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3008					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3009					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3010					;HALF OF THE AC IS TESTED WITH A 1.
  3011
  3012			005612		SN=SN+1
  3013		001000	000000			ZZ=ZZ+ZZ
  3014	031766	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  3015	031767	204 00 0 00 035126 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3016	031770	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3017						STOP^
  3018	031771	254 04 0 00 031772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3019	031772	324 00 0 00 031773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3020									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3021									;IN THE SUBTEST) TO LOOP ON ERROR^
  3022
  3023					;**********
  3024
  3025					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3026					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3027					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3028					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3029					;HALF OF THE AC IS TESTED WITH A 1.
  3030
  3031			005613		SN=SN+1
  3032		002000	000000			ZZ=ZZ+ZZ
  3033	031773	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  3034	031774	204 00 0 00 035127 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3035	031775	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3036						STOP^
  3037	031776	254 04 0 00 031777 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3038	031777	324 00 0 00 032000 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3039									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3040									;IN THE SUBTEST) TO LOOP ON ERROR^
  3041
  3042					;**********
  3043
  3044					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3045					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3046					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3047					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3048					;HALF OF THE AC IS TESTED WITH A 1.
  3049
  3050			005614		SN=SN+1
  3051		004000	000000			ZZ=ZZ+ZZ
  3052	032000	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  3053	032001	204 00 0 00 035130 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3054	032002	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3055						STOP^
  3056	032003	254 04 0 00 032004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3057	032004	324 00 0 00 032005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3058									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3059									;IN THE SUBTEST) TO LOOP ON ERROR^
  3060
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-11
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0075

  3061					;**********
  3062
  3063					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3064					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3065					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3066					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3067					;HALF OF THE AC IS TESTED WITH A 1.
  3068
  3069			005615		SN=SN+1
  3070		010000	000000			ZZ=ZZ+ZZ
  3071	032005	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  3072	032006	204 00 0 00 035131 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3073	032007	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3074						STOP^
  3075	032010	254 04 0 00 032011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3076	032011	324 00 0 00 032012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3077									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3078									;IN THE SUBTEST) TO LOOP ON ERROR^
  3079
  3080					;**********
  3081
  3082					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3083					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3084					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3085					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3086					;HALF OF THE AC IS TESTED WITH A 1.
  3087
  3088			005616		SN=SN+1
  3089		020000	000000			ZZ=ZZ+ZZ
  3090	032012	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  3091	032013	204 00 0 00 035132 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3092	032014	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3093						STOP^
  3094	032015	254 04 0 00 032016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3095	032016	324 00 0 00 032017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3096									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3097									;IN THE SUBTEST) TO LOOP ON ERROR^
  3098
  3099					;**********
  3100
  3101					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3102					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3103					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3104					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3105					;HALF OF THE AC IS TESTED WITH A 1.
  3106
  3107			005617		SN=SN+1
  3108		040000	000000			ZZ=ZZ+ZZ
  3109	032017	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  3110	032020	204 00 0 00 035133 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3111	032021	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3112						STOP^
  3113	032022	254 04 0 00 032023 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3114	032023	324 00 0 00 032024 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3115									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-12
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0076

  3116									;IN THE SUBTEST) TO LOOP ON ERROR^
  3117
  3118					;**********
  3119
  3120					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3121					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3122					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3123					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3124					;HALF OF THE AC IS TESTED WITH A 1.
  3125
  3126			005620		SN=SN+1
  3127		100000	000000			ZZ=ZZ+ZZ
  3128	032024	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  3129	032025	204 00 0 00 035134 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3130	032026	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3131						STOP^
  3132	032027	254 04 0 00 032030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3133	032030	324 00 0 00 032031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3134									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3135									;IN THE SUBTEST) TO LOOP ON ERROR^
  3136
  3137					;**********
  3138
  3139					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3140					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3141					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3142					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3143					;HALF OF THE AC IS TESTED WITH A 1.
  3144
  3145			005621		SN=SN+1
  3146		200000	000000			ZZ=ZZ+ZZ
  3147	032031	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  3148	032032	204 00 0 00 035135 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3149	032033	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3150						STOP^
  3151	032034	254 04 0 00 032035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3152	032035	324 00 0 00 032036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3153									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3154									;IN THE SUBTEST) TO LOOP ON ERROR^
  3155
  3156					;**********
  3157
  3158					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3159					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3160					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3161					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3162					;HALF OF THE AC IS TESTED WITH A 1.
  3163
  3164			005622		SN=SN+1
  3165		400000	000000			ZZ=ZZ+ZZ
  3166	032036	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  3167	032037	204 00 0 00 035065 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3168	032040	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3169						STOP^
  3170	032041	254 04 0 00 032042 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 22-13
DAKAAM	MAC	19-JAN-77 13:42		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS               SEQ 0077

  3171	032042	324 00 0 00 032043 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3172									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3173									;IN THE SUBTEST) TO LOOP ON ERROR^
  3174
  3175					;**********
  3176
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 23
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0078

  3177					SUBTTL	TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)
  3178
  3179					;THIS TEST VERIFIES THAT SETM LOADS AC FROM E.  THE AC IS FIRST SET
  3180					;TO ZERO; THEN, SETM IS EXECUTED WITH ALL ONES IN E.  BIT 0 OF THE AC
  3181					;IS THEN CHECKED FOR A 1.
  3182
  3183	032043	200 00 0 00 035062 	A5700:	MOVE	[0]		;PRELOAD AC WITH ALL ZEROS
  3184	032044	414 00 0 00 035063 		SETM	[-1]		;*SETM SHOULD LOAD AC WITH ALL ONES
  3185	032045	331 00 0 00 000000 		SKIPL			;PASS TEST IF AC BIT 0 IS A ONE
  3186						STOP^
  3187	032046	254 04 0 00 032047 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3188	032047	324 00 0 00 032050 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3189									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3190									;IN THE SUBTEST) TO LOOP ON ERROR^
  3191					;FCE [F1], IR BOOLE [IR1], IRXX(0,5,12,17) [IR2]
  3192
  3193					;**********
  3194
  3195					;THIS TEST VERIFIES THAT SETM LOADS AC FROM E.  THE AC IS FIRST SET TO
  3196					;ALL ONES; THEN, SETM IS EXECUTED WITH ALL ZEROS IN E.  THE AC IS CHECKED
  3197					;FOR ALL ZEROS
  3198
  3199	032050	200 00 0 00 035063 	A6000:	MOVE	[-1]		;PRESET AC TO ALL ONES
  3200	032051	414 00 0 00 035062 		SETM	[0]		;*SETM SHOULD LOAD AC WITH ALL ONES
  3201	032052	332 00 0 00 000000 		SKIPE			;PASSES TEST IF C(AC) = 0
  3202						STOP^
  3203	032053	254 04 0 00 032054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3204	032054	324 00 0 00 032055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3206									;IN THE SUBTEST) TO LOOP ON ERROR^
  3207
  3208					;AD AR + EN [ADAP], AD AR + EN C[ADAP],
  3209					;F CYC ACT EN A[F1], IR BOOLE AD A +F[IR2],
  3210					;IR BOOLE [IR1], IRXX(1-3,6,11,15,16) [IR2]
  3211
  3212					;**********
  3213
  3214					;THIS TEST VERIFIES THAT SETZ LOADS TH AC WITH ALL ZEROS.  FIRST, A WORD
  3215					;OF ALL ZEROS IS LOADED INTO THE AC VIA A MOVE INSTC. THEN, SETZ IS
  3216					;EXECUTED.  THE AC IS CHECKED FOR ALL ZEROS.
  3217					;IF ANY BITS IN THE AC ARE SET, THE TEST FAILS.
  3218
  3219	032055	200 00 0 00 035062 	A6100:	MOVE	[0]		;RESET AC TO ALL ZEROS
  3220	032056	400 00 0 00 000000 		SETZ			;*SETZ SHOULD CLEAR THE AC
  3221	032057	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) = 0
  3222						STOP^
  3223	032060	254 04 0 00 032061 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3224	032061	324 00 0 00 032062 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3225									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3226									;IN THE SUBTEST) TO LOOP ON ERROR^
  3227
  3228					;AD MASK GEN EN [ADC1], AD MASK GEN F/F'S [ADC1]
  3229					;AD MASK EN B; F CYC ACT EN B[F1]; IRXX00 [IR1];
  3230					;IR BOOLE [IR1]
  3231
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 23-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0079

  3232					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0080

  3233					;THIS TEST VERIFIES THAT SETZ LOADS THE AC WITH ALL ZEROS.  FIRST,
  3234					;THE AC IS SET TO ALL ONES; THEN, SETZ IS EXECUTED.  THE AC IS THEN
  3235					;CHECKED FOR ALL ZEROS.  IF ANY BITS IN THE AC ARE SET, THE TEST FAILS.
  3236
  3237	032062	200 00 0 00 035063 	A6200:	MOVE	[-1]		;PRESET AC TO ALL ONES
  3238	032063	400 00 0 00 032063 		SETZ	.		;*SETZ SHOULD CLEAR THE AC
  3239	032064	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) = 0
  3240						STOP^
  3241	032065	254 04 0 00 032066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3242	032066	324 00 0 00 032067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3243									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3244									;IN THE SUBTEST) TO LOOP ON ERROR^
  3245
  3246					;AR AD EN [ARMA], AR AD ET2 EN [ARMA], IR BOOLE [IR]
  3247
  3248					;**********
  3249
  3250					;THIS TEST VERIFIES THAT THE AND INSTRUCTION OPERATING ON AN AC
  3251					;CONTAINING ALL ZEROS AND AN E CONTAINING ALL ZEROS RESULTS IN AN AC
  3252					;OF ALL ZEROS.  THE AC AND E ARE THE SAME IN THIS TEST.
  3253					;AC, E ARE LOADED WITH ZEROS; THEN, AND IS EXECUTED.  THE AC IS THEN
  3254					;CHECKED FOR ALL ZEROS.  IF ANY BITS IN THE AC ARE SET BY THE AND INSTRUCTION,
  3255					;THE TEST FAILS.
  3256
  3257
  3258	032067	200 00 0 00 035062 	A6300:	MOVE	[0]		;PRESET AC, E TO ALL ZEROS
  3259	032070	404 00 0 00 000000 		AND			;*AND SHOULD RESULT IN C(AC) = 0
  3260	032071	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) = 0
  3261						STOP^
  3262	032072	254 04 0 00 032073 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3263	032073	324 00 0 00 032074 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3264									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3265									;IN THE SUBTEST) TO LOOP ON ERROR^
  3266
  3267					;**********
  3268			006400		SN=6400
  3269			000000			ZZ=0
  3270
  3271					A6400:	REPEAT	^D36,
  3272					<;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3273					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3274					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3275					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3276					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3277					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3278					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3279
  3280					SN=SN+1
  3281						ZZ=ZZ+ZZ
  3282						IFE	ZZ,<ZZ=1>
  3283						SETZ			;PRESET E TO ALL ZEROS
  3284						MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3285									;WHERE X VARIES FROM 0 THRU 35
  3286						AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3287						SKIPE	1		;FAIL IF C(AC) NON-ZERO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0081

  3288						STOP
  3289						SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3290						STOP
  3291					;**********
  3292					>
  3293					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3294					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3295					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3296					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3297					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3298					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3299					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3300
  3301			006401		SN=SN+1
  3302			000000			ZZ=ZZ+ZZ
  3303			000001			IFE	ZZ,<ZZ=1>
  3304	032074	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3305	032075	200 01 0 00 035074 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3306									;WHERE X VARIES FROM 0 THRU 35
  3307	032076	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3308	032077	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3309						STOP^
  3310	032100	254 04 0 00 032101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3311	032101	324 00 0 00 032102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3312									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3313									;IN THE SUBTEST) TO LOOP ON ERROR^
  3314	032102	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3315						STOP^
  3316	032103	254 04 0 00 032104 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3317	032104	324 00 0 00 032105 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3318									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3319									;IN THE SUBTEST) TO LOOP ON ERROR^
  3320					;**********
  3321
  3322					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3323					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3324					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3325					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3326					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3327					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3328					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3329
  3330			006402		SN=SN+1
  3331			000002			ZZ=ZZ+ZZ
  3332						IFE	ZZ,<ZZ=1>
  3333	032105	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3334	032106	200 01 0 00 035075 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3335									;WHERE X VARIES FROM 0 THRU 35
  3336	032107	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3337	032110	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3338						STOP^
  3339	032111	254 04 0 00 032112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3340	032112	324 00 0 00 032113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3341									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3342									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-2
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0082

  3343	032113	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3344						STOP^
  3345	032114	254 04 0 00 032115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3346	032115	324 00 0 00 032116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3347									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3348									;IN THE SUBTEST) TO LOOP ON ERROR^
  3349					;**********
  3350
  3351					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3352					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3353					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3354					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3355					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3356					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3357					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3358
  3359			006403		SN=SN+1
  3360			000004			ZZ=ZZ+ZZ
  3361						IFE	ZZ,<ZZ=1>
  3362	032116	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3363	032117	200 01 0 00 035076 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3364									;WHERE X VARIES FROM 0 THRU 35
  3365	032120	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3366	032121	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3367						STOP^
  3368	032122	254 04 0 00 032123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3369	032123	324 00 0 00 032124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3370									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3371									;IN THE SUBTEST) TO LOOP ON ERROR^
  3372	032124	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3373						STOP^
  3374	032125	254 04 0 00 032126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3375	032126	324 00 0 00 032127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3376									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3377									;IN THE SUBTEST) TO LOOP ON ERROR^
  3378					;**********
  3379
  3380					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3381					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3382					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3383					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3384					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3385					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3386					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3387
  3388			006404		SN=SN+1
  3389			000010			ZZ=ZZ+ZZ
  3390						IFE	ZZ,<ZZ=1>
  3391	032127	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3392	032130	200 01 0 00 035077 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3393									;WHERE X VARIES FROM 0 THRU 35
  3394	032131	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3395	032132	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3396						STOP^
  3397	032133	254 04 0 00 032134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-3
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0083

  3398	032134	324 00 0 00 032135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3399									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3400									;IN THE SUBTEST) TO LOOP ON ERROR^
  3401	032135	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3402						STOP^
  3403	032136	254 04 0 00 032137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3404	032137	324 00 0 00 032140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3405									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3406									;IN THE SUBTEST) TO LOOP ON ERROR^
  3407					;**********
  3408
  3409					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3410					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3411					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3412					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3413					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3414					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3415					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3416
  3417			006405		SN=SN+1
  3418			000020			ZZ=ZZ+ZZ
  3419						IFE	ZZ,<ZZ=1>
  3420	032140	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3421	032141	200 01 0 00 035100 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3422									;WHERE X VARIES FROM 0 THRU 35
  3423	032142	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3424	032143	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3425						STOP^
  3426	032144	254 04 0 00 032145 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3427	032145	324 00 0 00 032146 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3428									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3429									;IN THE SUBTEST) TO LOOP ON ERROR^
  3430	032146	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3431						STOP^
  3432	032147	254 04 0 00 032150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3433	032150	324 00 0 00 032151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3434									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3435									;IN THE SUBTEST) TO LOOP ON ERROR^
  3436					;**********
  3437
  3438					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3439					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3440					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3441					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3442					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3443					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3444					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3445
  3446			006406		SN=SN+1
  3447			000040			ZZ=ZZ+ZZ
  3448						IFE	ZZ,<ZZ=1>
  3449	032151	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3450	032152	200 01 0 00 035101 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3451									;WHERE X VARIES FROM 0 THRU 35
  3452	032153	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-4
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0084

  3453	032154	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3454						STOP^
  3455	032155	254 04 0 00 032156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3456	032156	324 00 0 00 032157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3457									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3458									;IN THE SUBTEST) TO LOOP ON ERROR^
  3459	032157	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3460						STOP^
  3461	032160	254 04 0 00 032161 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3462	032161	324 00 0 00 032162 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3464									;IN THE SUBTEST) TO LOOP ON ERROR^
  3465					;**********
  3466
  3467					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3468					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3469					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3470					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3471					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3472					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3473					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3474
  3475			006407		SN=SN+1
  3476			000100			ZZ=ZZ+ZZ
  3477						IFE	ZZ,<ZZ=1>
  3478	032162	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3479	032163	200 01 0 00 035102 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3480									;WHERE X VARIES FROM 0 THRU 35
  3481	032164	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3482	032165	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3483						STOP^
  3484	032166	254 04 0 00 032167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3485	032167	324 00 0 00 032170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3486									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3487									;IN THE SUBTEST) TO LOOP ON ERROR^
  3488	032170	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3489						STOP^
  3490	032171	254 04 0 00 032172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3491	032172	324 00 0 00 032173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3492									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3493									;IN THE SUBTEST) TO LOOP ON ERROR^
  3494					;**********
  3495
  3496					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3497					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3498					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3499					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3500					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3501					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3502					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3503
  3504			006410		SN=SN+1
  3505			000200			ZZ=ZZ+ZZ
  3506						IFE	ZZ,<ZZ=1>
  3507	032173	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-5
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0085

  3508	032174	200 01 0 00 035103 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3509									;WHERE X VARIES FROM 0 THRU 35
  3510	032175	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3511	032176	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3512						STOP^
  3513	032177	254 04 0 00 032200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3514	032200	324 00 0 00 032201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3515									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3516									;IN THE SUBTEST) TO LOOP ON ERROR^
  3517	032201	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3518						STOP^
  3519	032202	254 04 0 00 032203 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3520	032203	324 00 0 00 032204 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3521									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3522									;IN THE SUBTEST) TO LOOP ON ERROR^
  3523					;**********
  3524
  3525					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3526					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3527					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3528					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3529					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3530					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3531					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3532
  3533			006411		SN=SN+1
  3534			000400			ZZ=ZZ+ZZ
  3535						IFE	ZZ,<ZZ=1>
  3536	032204	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3537	032205	200 01 0 00 035104 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3538									;WHERE X VARIES FROM 0 THRU 35
  3539	032206	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3540	032207	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3541						STOP^
  3542	032210	254 04 0 00 032211 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3543	032211	324 00 0 00 032212 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3544									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3545									;IN THE SUBTEST) TO LOOP ON ERROR^
  3546	032212	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3547						STOP^
  3548	032213	254 04 0 00 032214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3549	032214	324 00 0 00 032215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3550									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3551									;IN THE SUBTEST) TO LOOP ON ERROR^
  3552					;**********
  3553
  3554					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3555					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3556					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3557					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3558					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3559					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3560					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3561
  3562			006412		SN=SN+1
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-6
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0086

  3563			001000			ZZ=ZZ+ZZ
  3564						IFE	ZZ,<ZZ=1>
  3565	032215	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3566	032216	200 01 0 00 035105 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3567									;WHERE X VARIES FROM 0 THRU 35
  3568	032217	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3569	032220	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3570						STOP^
  3571	032221	254 04 0 00 032222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3572	032222	324 00 0 00 032223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3573									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3574									;IN THE SUBTEST) TO LOOP ON ERROR^
  3575	032223	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3576						STOP^
  3577	032224	254 04 0 00 032225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3578	032225	324 00 0 00 032226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3580									;IN THE SUBTEST) TO LOOP ON ERROR^
  3581					;**********
  3582
  3583					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3584					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3585					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3586					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3587					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3588					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3589					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3590
  3591			006413		SN=SN+1
  3592			002000			ZZ=ZZ+ZZ
  3593						IFE	ZZ,<ZZ=1>
  3594	032226	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3595	032227	200 01 0 00 035106 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3596									;WHERE X VARIES FROM 0 THRU 35
  3597	032230	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3598	032231	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3599						STOP^
  3600	032232	254 04 0 00 032233 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3601	032233	324 00 0 00 032234 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3602									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3603									;IN THE SUBTEST) TO LOOP ON ERROR^
  3604	032234	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3605						STOP^
  3606	032235	254 04 0 00 032236 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3607	032236	324 00 0 00 032237 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3608									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3609									;IN THE SUBTEST) TO LOOP ON ERROR^
  3610					;**********
  3611
  3612					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3613					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3614					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3615					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3616					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3617					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-7
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0087

  3618					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3619
  3620			006414		SN=SN+1
  3621			004000			ZZ=ZZ+ZZ
  3622						IFE	ZZ,<ZZ=1>
  3623	032237	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3624	032240	200 01 0 00 035107 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3625									;WHERE X VARIES FROM 0 THRU 35
  3626	032241	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3627	032242	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3628						STOP^
  3629	032243	254 04 0 00 032244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3630	032244	324 00 0 00 032245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3631									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3632									;IN THE SUBTEST) TO LOOP ON ERROR^
  3633	032245	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3634						STOP^
  3635	032246	254 04 0 00 032247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3636	032247	324 00 0 00 032250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3637									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3638									;IN THE SUBTEST) TO LOOP ON ERROR^
  3639					;**********
  3640
  3641					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3642					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3643					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3644					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3645					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3646					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3647					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3648
  3649			006415		SN=SN+1
  3650			010000			ZZ=ZZ+ZZ
  3651						IFE	ZZ,<ZZ=1>
  3652	032250	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3653	032251	200 01 0 00 035110 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3654									;WHERE X VARIES FROM 0 THRU 35
  3655	032252	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3656	032253	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3657						STOP^
  3658	032254	254 04 0 00 032255 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3659	032255	324 00 0 00 032256 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3660									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3661									;IN THE SUBTEST) TO LOOP ON ERROR^
  3662	032256	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3663						STOP^
  3664	032257	254 04 0 00 032260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3665	032260	324 00 0 00 032261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3666									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3667									;IN THE SUBTEST) TO LOOP ON ERROR^
  3668					;**********
  3669
  3670					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3671					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3672					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-8
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0088

  3673					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3674					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3675					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3676					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3677
  3678			006416		SN=SN+1
  3679			020000			ZZ=ZZ+ZZ
  3680						IFE	ZZ,<ZZ=1>
  3681	032261	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3682	032262	200 01 0 00 035111 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3683									;WHERE X VARIES FROM 0 THRU 35
  3684	032263	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3685	032264	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3686						STOP^
  3687	032265	254 04 0 00 032266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3688	032266	324 00 0 00 032267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3689									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3690									;IN THE SUBTEST) TO LOOP ON ERROR^
  3691	032267	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3692						STOP^
  3693	032270	254 04 0 00 032271 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3694	032271	324 00 0 00 032272 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3695									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3696									;IN THE SUBTEST) TO LOOP ON ERROR^
  3697					;**********
  3698
  3699					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3700					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3701					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3702					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3703					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3704					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3705					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3706
  3707			006417		SN=SN+1
  3708			040000			ZZ=ZZ+ZZ
  3709						IFE	ZZ,<ZZ=1>
  3710	032272	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3711	032273	200 01 0 00 035112 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3712									;WHERE X VARIES FROM 0 THRU 35
  3713	032274	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3714	032275	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3715						STOP^
  3716	032276	254 04 0 00 032277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3717	032277	324 00 0 00 032300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3718									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3719									;IN THE SUBTEST) TO LOOP ON ERROR^
  3720	032300	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3721						STOP^
  3722	032301	254 04 0 00 032302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3723	032302	324 00 0 00 032303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3724									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3725									;IN THE SUBTEST) TO LOOP ON ERROR^
  3726					;**********
  3727
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-9
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0089

  3728					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3729					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3730					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3731					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3732					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3733					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3734					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3735
  3736			006420		SN=SN+1
  3737			100000			ZZ=ZZ+ZZ
  3738						IFE	ZZ,<ZZ=1>
  3739	032303	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3740	032304	200 01 0 00 035113 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3741									;WHERE X VARIES FROM 0 THRU 35
  3742	032305	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3743	032306	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3744						STOP^
  3745	032307	254 04 0 00 032310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3746	032310	324 00 0 00 032311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3748									;IN THE SUBTEST) TO LOOP ON ERROR^
  3749	032311	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3750						STOP^
  3751	032312	254 04 0 00 032313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3752	032313	324 00 0 00 032314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3753									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3754									;IN THE SUBTEST) TO LOOP ON ERROR^
  3755					;**********
  3756
  3757					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3758					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3759					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3760					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3761					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3762					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3763					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3764
  3765			006421		SN=SN+1
  3766			200000			ZZ=ZZ+ZZ
  3767						IFE	ZZ,<ZZ=1>
  3768	032314	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3769	032315	200 01 0 00 035114 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3770									;WHERE X VARIES FROM 0 THRU 35
  3771	032316	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3772	032317	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3773						STOP^
  3774	032320	254 04 0 00 032321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3775	032321	324 00 0 00 032322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3776									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3777									;IN THE SUBTEST) TO LOOP ON ERROR^
  3778	032322	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3779						STOP^
  3780	032323	254 04 0 00 032324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3781	032324	324 00 0 00 032325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3782									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-10
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0090

  3783									;IN THE SUBTEST) TO LOOP ON ERROR^
  3784					;**********
  3785
  3786					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3787					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3788					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3789					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3790					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3791					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3792					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3793
  3794			006422		SN=SN+1
  3795			400000			ZZ=ZZ+ZZ
  3796						IFE	ZZ,<ZZ=1>
  3797	032325	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3798	032326	200 01 0 00 035115 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3799									;WHERE X VARIES FROM 0 THRU 35
  3800	032327	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3801	032330	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3802						STOP^
  3803	032331	254 04 0 00 032332 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3804	032332	324 00 0 00 032333 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3805									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3806									;IN THE SUBTEST) TO LOOP ON ERROR^
  3807	032333	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3808						STOP^
  3809	032334	254 04 0 00 032335 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3810	032335	324 00 0 00 032336 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3811									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3812									;IN THE SUBTEST) TO LOOP ON ERROR^
  3813					;**********
  3814
  3815					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3816					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3817					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3818					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3819					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3820					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3821					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3822
  3823			006423		SN=SN+1
  3824		000001	000000			ZZ=ZZ+ZZ
  3825						IFE	ZZ,<ZZ=1>
  3826	032336	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3827	032337	200 01 0 00 035116 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3828									;WHERE X VARIES FROM 0 THRU 35
  3829	032340	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3830	032341	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3831						STOP^
  3832	032342	254 04 0 00 032343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3833	032343	324 00 0 00 032344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3835									;IN THE SUBTEST) TO LOOP ON ERROR^
  3836	032344	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3837						STOP^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-11
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0091

  3838	032345	254 04 0 00 032346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3839	032346	324 00 0 00 032347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3840									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3841									;IN THE SUBTEST) TO LOOP ON ERROR^
  3842					;**********
  3843
  3844					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3845					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3846					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3847					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3848					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3849					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3850					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3851
  3852			006424		SN=SN+1
  3853		000002	000000			ZZ=ZZ+ZZ
  3854						IFE	ZZ,<ZZ=1>
  3855	032347	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3856	032350	200 01 0 00 035117 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3857									;WHERE X VARIES FROM 0 THRU 35
  3858	032351	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3859	032352	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3860						STOP^
  3861	032353	254 04 0 00 032354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3862	032354	324 00 0 00 032355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3863									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3864									;IN THE SUBTEST) TO LOOP ON ERROR^
  3865	032355	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3866						STOP^
  3867	032356	254 04 0 00 032357 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3868	032357	324 00 0 00 032360 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3869									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3870									;IN THE SUBTEST) TO LOOP ON ERROR^
  3871					;**********
  3872
  3873					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3874					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3875					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3876					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3877					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3878					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3879					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3880
  3881			006425		SN=SN+1
  3882		000004	000000			ZZ=ZZ+ZZ
  3883						IFE	ZZ,<ZZ=1>
  3884	032360	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3885	032361	200 01 0 00 035120 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3886									;WHERE X VARIES FROM 0 THRU 35
  3887	032362	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3888	032363	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3889						STOP^
  3890	032364	254 04 0 00 032365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3891	032365	324 00 0 00 032366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-12
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0092

  3893									;IN THE SUBTEST) TO LOOP ON ERROR^
  3894	032366	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3895						STOP^
  3896	032367	254 04 0 00 032370 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3897	032370	324 00 0 00 032371 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3898									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3899									;IN THE SUBTEST) TO LOOP ON ERROR^
  3900					;**********
  3901
  3902					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3903					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3904					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3905					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3906					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3907					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3908					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3909
  3910			006426		SN=SN+1
  3911		000010	000000			ZZ=ZZ+ZZ
  3912						IFE	ZZ,<ZZ=1>
  3913	032371	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3914	032372	200 01 0 00 035121 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3915									;WHERE X VARIES FROM 0 THRU 35
  3916	032373	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3917	032374	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3918						STOP^
  3919	032375	254 04 0 00 032376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3920	032376	324 00 0 00 032377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3921									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3922									;IN THE SUBTEST) TO LOOP ON ERROR^
  3923	032377	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3924						STOP^
  3925	032400	254 04 0 00 032401 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3926	032401	324 00 0 00 032402 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3927									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3928									;IN THE SUBTEST) TO LOOP ON ERROR^
  3929					;**********
  3930
  3931					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3932					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3933					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3934					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3935					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3936					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3937					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3938
  3939			006427		SN=SN+1
  3940		000020	000000			ZZ=ZZ+ZZ
  3941						IFE	ZZ,<ZZ=1>
  3942	032402	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3943	032403	200 01 0 00 035122 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3944									;WHERE X VARIES FROM 0 THRU 35
  3945	032404	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3946	032405	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3947						STOP^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-13
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0093

  3948	032406	254 04 0 00 032407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3949	032407	324 00 0 00 032410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3950									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3951									;IN THE SUBTEST) TO LOOP ON ERROR^
  3952	032410	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3953						STOP^
  3954	032411	254 04 0 00 032412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3955	032412	324 00 0 00 032413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3956									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3957									;IN THE SUBTEST) TO LOOP ON ERROR^
  3958					;**********
  3959
  3960					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3961					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3962					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3963					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3964					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3965					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3966					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3967
  3968			006430		SN=SN+1
  3969		000040	000000			ZZ=ZZ+ZZ
  3970						IFE	ZZ,<ZZ=1>
  3971	032413	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3972	032414	200 01 0 00 035123 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3973									;WHERE X VARIES FROM 0 THRU 35
  3974	032415	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3975	032416	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3976						STOP^
  3977	032417	254 04 0 00 032420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3978	032420	324 00 0 00 032421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3979									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3980									;IN THE SUBTEST) TO LOOP ON ERROR^
  3981	032421	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3982						STOP^
  3983	032422	254 04 0 00 032423 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3984	032423	324 00 0 00 032424 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3985									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3986									;IN THE SUBTEST) TO LOOP ON ERROR^
  3987					;**********
  3988
  3989					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3990					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3991					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3992					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3993					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3994					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3995					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3996
  3997			006431		SN=SN+1
  3998		000100	000000			ZZ=ZZ+ZZ
  3999						IFE	ZZ,<ZZ=1>
  4000	032424	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4001	032425	200 01 0 00 035124 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4002									;WHERE X VARIES FROM 0 THRU 35
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-14
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0094

  4003	032426	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4004	032427	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4005						STOP^
  4006	032430	254 04 0 00 032431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4007	032431	324 00 0 00 032432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4008									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4009									;IN THE SUBTEST) TO LOOP ON ERROR^
  4010	032432	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4011						STOP^
  4012	032433	254 04 0 00 032434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4013	032434	324 00 0 00 032435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4014									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4015									;IN THE SUBTEST) TO LOOP ON ERROR^
  4016					;**********
  4017
  4018					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4019					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4020					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4021					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4022					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4023					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4024					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4025
  4026			006432		SN=SN+1
  4027		000200	000000			ZZ=ZZ+ZZ
  4028						IFE	ZZ,<ZZ=1>
  4029	032435	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4030	032436	200 01 0 00 035125 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4031									;WHERE X VARIES FROM 0 THRU 35
  4032	032437	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4033	032440	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4034						STOP^
  4035	032441	254 04 0 00 032442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4036	032442	324 00 0 00 032443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4037									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4038									;IN THE SUBTEST) TO LOOP ON ERROR^
  4039	032443	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4040						STOP^
  4041	032444	254 04 0 00 032445 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4042	032445	324 00 0 00 032446 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4043									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4044									;IN THE SUBTEST) TO LOOP ON ERROR^
  4045					;**********
  4046
  4047					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4048					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4049					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4050					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4051					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4052					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4053					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4054
  4055			006433		SN=SN+1
  4056		000400	000000			ZZ=ZZ+ZZ
  4057						IFE	ZZ,<ZZ=1>
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-15
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0095

  4058	032446	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4059	032447	200 01 0 00 035073 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4060									;WHERE X VARIES FROM 0 THRU 35
  4061	032450	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4062	032451	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4063						STOP^
  4064	032452	254 04 0 00 032453 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4065	032453	324 00 0 00 032454 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4066									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4067									;IN THE SUBTEST) TO LOOP ON ERROR^
  4068	032454	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4069						STOP^
  4070	032455	254 04 0 00 032456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4071	032456	324 00 0 00 032457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4072									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4073									;IN THE SUBTEST) TO LOOP ON ERROR^
  4074					;**********
  4075
  4076					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4077					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4078					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4079					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4080					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4081					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4082					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4083
  4084			006434		SN=SN+1
  4085		001000	000000			ZZ=ZZ+ZZ
  4086						IFE	ZZ,<ZZ=1>
  4087	032457	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4088	032460	200 01 0 00 035126 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4089									;WHERE X VARIES FROM 0 THRU 35
  4090	032461	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4091	032462	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4092						STOP^
  4093	032463	254 04 0 00 032464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4094	032464	324 00 0 00 032465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4095									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4096									;IN THE SUBTEST) TO LOOP ON ERROR^
  4097	032465	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4098						STOP^
  4099	032466	254 04 0 00 032467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4100	032467	324 00 0 00 032470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4101									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4102									;IN THE SUBTEST) TO LOOP ON ERROR^
  4103					;**********
  4104
  4105					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4106					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4107					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4108					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4109					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4110					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4111					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4112
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-16
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0096

  4113			006435		SN=SN+1
  4114		002000	000000			ZZ=ZZ+ZZ
  4115						IFE	ZZ,<ZZ=1>
  4116	032470	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4117	032471	200 01 0 00 035127 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4118									;WHERE X VARIES FROM 0 THRU 35
  4119	032472	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4120	032473	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4121						STOP^
  4122	032474	254 04 0 00 032475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4123	032475	324 00 0 00 032476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4124									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4125									;IN THE SUBTEST) TO LOOP ON ERROR^
  4126	032476	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4127						STOP^
  4128	032477	254 04 0 00 032500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4129	032500	324 00 0 00 032501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4130									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4131									;IN THE SUBTEST) TO LOOP ON ERROR^
  4132					;**********
  4133
  4134					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4135					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4136					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4137					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4138					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4139					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4140					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4141
  4142			006436		SN=SN+1
  4143		004000	000000			ZZ=ZZ+ZZ
  4144						IFE	ZZ,<ZZ=1>
  4145	032501	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4146	032502	200 01 0 00 035130 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4147									;WHERE X VARIES FROM 0 THRU 35
  4148	032503	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4149	032504	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4150						STOP^
  4151	032505	254 04 0 00 032506 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4152	032506	324 00 0 00 032507 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4153									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4154									;IN THE SUBTEST) TO LOOP ON ERROR^
  4155	032507	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4156						STOP^
  4157	032510	254 04 0 00 032511 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4158	032511	324 00 0 00 032512 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4159									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4160									;IN THE SUBTEST) TO LOOP ON ERROR^
  4161					;**********
  4162
  4163					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4164					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4165					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4166					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4167					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-17
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0097

  4168					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4169					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4170
  4171			006437		SN=SN+1
  4172		010000	000000			ZZ=ZZ+ZZ
  4173						IFE	ZZ,<ZZ=1>
  4174	032512	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4175	032513	200 01 0 00 035131 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4176									;WHERE X VARIES FROM 0 THRU 35
  4177	032514	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4178	032515	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4179						STOP^
  4180	032516	254 04 0 00 032517 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4181	032517	324 00 0 00 032520 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4182									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4183									;IN THE SUBTEST) TO LOOP ON ERROR^
  4184	032520	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4185						STOP^
  4186	032521	254 04 0 00 032522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4187	032522	324 00 0 00 032523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4188									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4189									;IN THE SUBTEST) TO LOOP ON ERROR^
  4190					;**********
  4191
  4192					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4193					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4194					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4195					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4196					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4197					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4198					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4199
  4200			006440		SN=SN+1
  4201		020000	000000			ZZ=ZZ+ZZ
  4202						IFE	ZZ,<ZZ=1>
  4203	032523	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4204	032524	200 01 0 00 035132 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4205									;WHERE X VARIES FROM 0 THRU 35
  4206	032525	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4207	032526	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4208						STOP^
  4209	032527	254 04 0 00 032530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4210	032530	324 00 0 00 032531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4211									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4212									;IN THE SUBTEST) TO LOOP ON ERROR^
  4213	032531	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4214						STOP^
  4215	032532	254 04 0 00 032533 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4216	032533	324 00 0 00 032534 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4217									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4218									;IN THE SUBTEST) TO LOOP ON ERROR^
  4219					;**********
  4220
  4221					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4222					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-18
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0098

  4223					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4224					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4225					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4226					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4227					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4228
  4229			006441		SN=SN+1
  4230		040000	000000			ZZ=ZZ+ZZ
  4231						IFE	ZZ,<ZZ=1>
  4232	032534	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4233	032535	200 01 0 00 035133 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4234									;WHERE X VARIES FROM 0 THRU 35
  4235	032536	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4236	032537	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4237						STOP^
  4238	032540	254 04 0 00 032541 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4239	032541	324 00 0 00 032542 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4240									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4241									;IN THE SUBTEST) TO LOOP ON ERROR^
  4242	032542	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4243						STOP^
  4244	032543	254 04 0 00 032544 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4245	032544	324 00 0 00 032545 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4246									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4247									;IN THE SUBTEST) TO LOOP ON ERROR^
  4248					;**********
  4249
  4250					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4251					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4252					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4253					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4254					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4255					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4256					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4257
  4258			006442		SN=SN+1
  4259		100000	000000			ZZ=ZZ+ZZ
  4260						IFE	ZZ,<ZZ=1>
  4261	032545	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4262	032546	200 01 0 00 035134 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4263									;WHERE X VARIES FROM 0 THRU 35
  4264	032547	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4265	032550	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4266						STOP^
  4267	032551	254 04 0 00 032552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4268	032552	324 00 0 00 032553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4269									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4270									;IN THE SUBTEST) TO LOOP ON ERROR^
  4271	032553	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4272						STOP^
  4273	032554	254 04 0 00 032555 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4274	032555	324 00 0 00 032556 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4275									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4276									;IN THE SUBTEST) TO LOOP ON ERROR^
  4277					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-19
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0099

  4278
  4279					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4280					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4281					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4282					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4283					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4284					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4285					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4286
  4287			006443		SN=SN+1
  4288		200000	000000			ZZ=ZZ+ZZ
  4289						IFE	ZZ,<ZZ=1>
  4290	032556	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4291	032557	200 01 0 00 035135 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4292									;WHERE X VARIES FROM 0 THRU 35
  4293	032560	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4294	032561	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4295						STOP^
  4296	032562	254 04 0 00 032563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4297	032563	324 00 0 00 032564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4298									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4299									;IN THE SUBTEST) TO LOOP ON ERROR^
  4300	032564	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4301						STOP^
  4302	032565	254 04 0 00 032566 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4303	032566	324 00 0 00 032567 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4304									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4305									;IN THE SUBTEST) TO LOOP ON ERROR^
  4306					;**********
  4307
  4308					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4309					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4310					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4311					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4312					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4313					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4314					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4315
  4316			006444		SN=SN+1
  4317		400000	000000			ZZ=ZZ+ZZ
  4318						IFE	ZZ,<ZZ=1>
  4319	032567	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4320	032570	200 01 0 00 035065 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4321									;WHERE X VARIES FROM 0 THRU 35
  4322	032571	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4323	032572	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4324						STOP^
  4325	032573	254 04 0 00 032574 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4326	032574	324 00 0 00 032575 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4327									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4328									;IN THE SUBTEST) TO LOOP ON ERROR^
  4329	032575	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4330						STOP^
  4331	032576	254 04 0 00 032577 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4332	032577	324 00 0 00 032600 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 24-20
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0100

  4333									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4334									;IN THE SUBTEST) TO LOOP ON ERROR^
  4335					;**********
  4336
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0101

  4337			006500		SN=6500
  4338			000000			ZZ=0
  4339
  4340					A6500:	REPEAT	^D36,
  4341					<;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4342					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4343					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4344					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4345					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4346					SN=SN+1
  4347						ZZ=ZZ+ZZ
  4348						IFE	ZZ,<ZZ=1>
  4349						MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4350						AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4351									;POSITION WITH ITSELF SHOULD RESULT WITH
  4352									;C(AC) NONZERO
  4353						SKIPN			;PASS TEST IF C(AC) NONZERO
  4354						STOP
  4355
  4356					;**********
  4357					>
  4358					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4359					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4360					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4361					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4362					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4363			006501		SN=SN+1
  4364			000000			ZZ=ZZ+ZZ
  4365			000001			IFE	ZZ,<ZZ=1>
  4366	032600	200 00 0 00 035074 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4367	032601	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4368									;POSITION WITH ITSELF SHOULD RESULT WITH
  4369									;C(AC) NONZERO
  4370	032602	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4371						STOP^
  4372	032603	254 04 0 00 032604 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4373	032604	324 00 0 00 032605 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4374									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4375									;IN THE SUBTEST) TO LOOP ON ERROR^
  4376
  4377					;**********
  4378
  4379					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4380					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4381					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4382					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4383					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4384			006502		SN=SN+1
  4385			000002			ZZ=ZZ+ZZ
  4386						IFE	ZZ,<ZZ=1>
  4387	032605	200 00 0 00 035075 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4388	032606	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4389									;POSITION WITH ITSELF SHOULD RESULT WITH
  4390									;C(AC) NONZERO
  4391	032607	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0102

  4392						STOP^
  4393	032610	254 04 0 00 032611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4394	032611	324 00 0 00 032612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4395									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4396									;IN THE SUBTEST) TO LOOP ON ERROR^
  4397
  4398					;**********
  4399
  4400					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4401					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4402					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4403					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4404					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4405			006503		SN=SN+1
  4406			000004			ZZ=ZZ+ZZ
  4407						IFE	ZZ,<ZZ=1>
  4408	032612	200 00 0 00 035076 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4409	032613	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4410									;POSITION WITH ITSELF SHOULD RESULT WITH
  4411									;C(AC) NONZERO
  4412	032614	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4413						STOP^
  4414	032615	254 04 0 00 032616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4415	032616	324 00 0 00 032617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4416									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4417									;IN THE SUBTEST) TO LOOP ON ERROR^
  4418
  4419					;**********
  4420
  4421					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4422					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4423					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4424					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4425					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4426			006504		SN=SN+1
  4427			000010			ZZ=ZZ+ZZ
  4428						IFE	ZZ,<ZZ=1>
  4429	032617	200 00 0 00 035077 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4430	032620	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4431									;POSITION WITH ITSELF SHOULD RESULT WITH
  4432									;C(AC) NONZERO
  4433	032621	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4434						STOP^
  4435	032622	254 04 0 00 032623 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4436	032623	324 00 0 00 032624 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4437									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4438									;IN THE SUBTEST) TO LOOP ON ERROR^
  4439
  4440					;**********
  4441
  4442					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4443					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4444					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4445					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4446					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-2
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0103

  4447			006505		SN=SN+1
  4448			000020			ZZ=ZZ+ZZ
  4449						IFE	ZZ,<ZZ=1>
  4450	032624	200 00 0 00 035100 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4451	032625	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4452									;POSITION WITH ITSELF SHOULD RESULT WITH
  4453									;C(AC) NONZERO
  4454	032626	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4455						STOP^
  4456	032627	254 04 0 00 032630 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4457	032630	324 00 0 00 032631 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4458									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4459									;IN THE SUBTEST) TO LOOP ON ERROR^
  4460
  4461					;**********
  4462
  4463					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4464					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4465					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4466					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4467					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4468			006506		SN=SN+1
  4469			000040			ZZ=ZZ+ZZ
  4470						IFE	ZZ,<ZZ=1>
  4471	032631	200 00 0 00 035101 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4472	032632	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4473									;POSITION WITH ITSELF SHOULD RESULT WITH
  4474									;C(AC) NONZERO
  4475	032633	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4476						STOP^
  4477	032634	254 04 0 00 032635 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4478	032635	324 00 0 00 032636 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4479									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4480									;IN THE SUBTEST) TO LOOP ON ERROR^
  4481
  4482					;**********
  4483
  4484					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4485					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4486					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4487					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4488					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4489			006507		SN=SN+1
  4490			000100			ZZ=ZZ+ZZ
  4491						IFE	ZZ,<ZZ=1>
  4492	032636	200 00 0 00 035102 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4493	032637	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4494									;POSITION WITH ITSELF SHOULD RESULT WITH
  4495									;C(AC) NONZERO
  4496	032640	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4497						STOP^
  4498	032641	254 04 0 00 032642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4499	032642	324 00 0 00 032643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4500									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4501									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-3
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0104

  4502
  4503					;**********
  4504
  4505					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4506					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4507					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4508					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4509					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4510			006510		SN=SN+1
  4511			000200			ZZ=ZZ+ZZ
  4512						IFE	ZZ,<ZZ=1>
  4513	032643	200 00 0 00 035103 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4514	032644	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4515									;POSITION WITH ITSELF SHOULD RESULT WITH
  4516									;C(AC) NONZERO
  4517	032645	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4518						STOP^
  4519	032646	254 04 0 00 032647 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4520	032647	324 00 0 00 032650 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4521									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4522									;IN THE SUBTEST) TO LOOP ON ERROR^
  4523
  4524					;**********
  4525
  4526					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4527					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4528					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4529					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4530					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4531			006511		SN=SN+1
  4532			000400			ZZ=ZZ+ZZ
  4533						IFE	ZZ,<ZZ=1>
  4534	032650	200 00 0 00 035104 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4535	032651	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4536									;POSITION WITH ITSELF SHOULD RESULT WITH
  4537									;C(AC) NONZERO
  4538	032652	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4539						STOP^
  4540	032653	254 04 0 00 032654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4541	032654	324 00 0 00 032655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4542									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4543									;IN THE SUBTEST) TO LOOP ON ERROR^
  4544
  4545					;**********
  4546
  4547					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4548					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4549					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4550					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4551					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4552			006512		SN=SN+1
  4553			001000			ZZ=ZZ+ZZ
  4554						IFE	ZZ,<ZZ=1>
  4555	032655	200 00 0 00 035105 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4556	032656	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-4
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0105

  4557									;POSITION WITH ITSELF SHOULD RESULT WITH
  4558									;C(AC) NONZERO
  4559	032657	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4560						STOP^
  4561	032660	254 04 0 00 032661 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4562	032661	324 00 0 00 032662 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4563									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4564									;IN THE SUBTEST) TO LOOP ON ERROR^
  4565
  4566					;**********
  4567
  4568					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4569					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4570					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4571					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4572					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4573			006513		SN=SN+1
  4574			002000			ZZ=ZZ+ZZ
  4575						IFE	ZZ,<ZZ=1>
  4576	032662	200 00 0 00 035106 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4577	032663	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4578									;POSITION WITH ITSELF SHOULD RESULT WITH
  4579									;C(AC) NONZERO
  4580	032664	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4581						STOP^
  4582	032665	254 04 0 00 032666 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4583	032666	324 00 0 00 032667 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4584									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4585									;IN THE SUBTEST) TO LOOP ON ERROR^
  4586
  4587					;**********
  4588
  4589					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4590					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4591					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4592					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4593					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4594			006514		SN=SN+1
  4595			004000			ZZ=ZZ+ZZ
  4596						IFE	ZZ,<ZZ=1>
  4597	032667	200 00 0 00 035107 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4598	032670	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4599									;POSITION WITH ITSELF SHOULD RESULT WITH
  4600									;C(AC) NONZERO
  4601	032671	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4602						STOP^
  4603	032672	254 04 0 00 032673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4604	032673	324 00 0 00 032674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4605									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4606									;IN THE SUBTEST) TO LOOP ON ERROR^
  4607
  4608					;**********
  4609
  4610					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4611					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-5
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0106

  4612					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4613					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4614					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4615			006515		SN=SN+1
  4616			010000			ZZ=ZZ+ZZ
  4617						IFE	ZZ,<ZZ=1>
  4618	032674	200 00 0 00 035110 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4619	032675	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4620									;POSITION WITH ITSELF SHOULD RESULT WITH
  4621									;C(AC) NONZERO
  4622	032676	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4623						STOP^
  4624	032677	254 04 0 00 032700 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4625	032700	324 00 0 00 032701 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4626									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4627									;IN THE SUBTEST) TO LOOP ON ERROR^
  4628
  4629					;**********
  4630
  4631					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4632					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4633					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4634					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4635					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4636			006516		SN=SN+1
  4637			020000			ZZ=ZZ+ZZ
  4638						IFE	ZZ,<ZZ=1>
  4639	032701	200 00 0 00 035111 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4640	032702	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4641									;POSITION WITH ITSELF SHOULD RESULT WITH
  4642									;C(AC) NONZERO
  4643	032703	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4644						STOP^
  4645	032704	254 04 0 00 032705 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4646	032705	324 00 0 00 032706 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4647									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4648									;IN THE SUBTEST) TO LOOP ON ERROR^
  4649
  4650					;**********
  4651
  4652					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4653					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4654					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4655					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4656					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4657			006517		SN=SN+1
  4658			040000			ZZ=ZZ+ZZ
  4659						IFE	ZZ,<ZZ=1>
  4660	032706	200 00 0 00 035112 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4661	032707	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4662									;POSITION WITH ITSELF SHOULD RESULT WITH
  4663									;C(AC) NONZERO
  4664	032710	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4665						STOP^
  4666	032711	254 04 0 00 032712 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-6
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0107

  4667	032712	324 00 0 00 032713 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4668									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4669									;IN THE SUBTEST) TO LOOP ON ERROR^
  4670
  4671					;**********
  4672
  4673					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4674					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4675					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4676					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4677					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4678			006520		SN=SN+1
  4679			100000			ZZ=ZZ+ZZ
  4680						IFE	ZZ,<ZZ=1>
  4681	032713	200 00 0 00 035113 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4682	032714	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4683									;POSITION WITH ITSELF SHOULD RESULT WITH
  4684									;C(AC) NONZERO
  4685	032715	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4686						STOP^
  4687	032716	254 04 0 00 032717 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4688	032717	324 00 0 00 032720 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4689									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4690									;IN THE SUBTEST) TO LOOP ON ERROR^
  4691
  4692					;**********
  4693
  4694					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4695					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4696					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4697					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4698					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4699			006521		SN=SN+1
  4700			200000			ZZ=ZZ+ZZ
  4701						IFE	ZZ,<ZZ=1>
  4702	032720	200 00 0 00 035114 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4703	032721	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4704									;POSITION WITH ITSELF SHOULD RESULT WITH
  4705									;C(AC) NONZERO
  4706	032722	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4707						STOP^
  4708	032723	254 04 0 00 032724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4709	032724	324 00 0 00 032725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4710									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4711									;IN THE SUBTEST) TO LOOP ON ERROR^
  4712
  4713					;**********
  4714
  4715					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4716					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4717					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4718					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4719					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4720			006522		SN=SN+1
  4721			400000			ZZ=ZZ+ZZ
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-7
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0108

  4722						IFE	ZZ,<ZZ=1>
  4723	032725	200 00 0 00 035115 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4724	032726	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4725									;POSITION WITH ITSELF SHOULD RESULT WITH
  4726									;C(AC) NONZERO
  4727	032727	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4728						STOP^
  4729	032730	254 04 0 00 032731 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4730	032731	324 00 0 00 032732 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4731									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4732									;IN THE SUBTEST) TO LOOP ON ERROR^
  4733
  4734					;**********
  4735
  4736					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4737					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4738					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4739					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4740					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4741			006523		SN=SN+1
  4742		000001	000000			ZZ=ZZ+ZZ
  4743						IFE	ZZ,<ZZ=1>
  4744	032732	200 00 0 00 035116 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4745	032733	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4746									;POSITION WITH ITSELF SHOULD RESULT WITH
  4747									;C(AC) NONZERO
  4748	032734	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4749						STOP^
  4750	032735	254 04 0 00 032736 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4751	032736	324 00 0 00 032737 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4752									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4753									;IN THE SUBTEST) TO LOOP ON ERROR^
  4754
  4755					;**********
  4756
  4757					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4758					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4759					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4760					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4761					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4762			006524		SN=SN+1
  4763		000002	000000			ZZ=ZZ+ZZ
  4764						IFE	ZZ,<ZZ=1>
  4765	032737	200 00 0 00 035117 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4766	032740	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4767									;POSITION WITH ITSELF SHOULD RESULT WITH
  4768									;C(AC) NONZERO
  4769	032741	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4770						STOP^
  4771	032742	254 04 0 00 032743 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4772	032743	324 00 0 00 032744 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4773									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4774									;IN THE SUBTEST) TO LOOP ON ERROR^
  4775
  4776					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-8
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0109

  4777
  4778					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4779					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4780					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4781					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4782					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4783			006525		SN=SN+1
  4784		000004	000000			ZZ=ZZ+ZZ
  4785						IFE	ZZ,<ZZ=1>
  4786	032744	200 00 0 00 035120 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4787	032745	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4788									;POSITION WITH ITSELF SHOULD RESULT WITH
  4789									;C(AC) NONZERO
  4790	032746	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4791						STOP^
  4792	032747	254 04 0 00 032750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4793	032750	324 00 0 00 032751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4794									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4795									;IN THE SUBTEST) TO LOOP ON ERROR^
  4796
  4797					;**********
  4798
  4799					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4800					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4801					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4802					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4803					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4804			006526		SN=SN+1
  4805		000010	000000			ZZ=ZZ+ZZ
  4806						IFE	ZZ,<ZZ=1>
  4807	032751	200 00 0 00 035121 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4808	032752	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4809									;POSITION WITH ITSELF SHOULD RESULT WITH
  4810									;C(AC) NONZERO
  4811	032753	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4812						STOP^
  4813	032754	254 04 0 00 032755 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4814	032755	324 00 0 00 032756 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4815									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4816									;IN THE SUBTEST) TO LOOP ON ERROR^
  4817
  4818					;**********
  4819
  4820					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4821					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4822					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4823					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4824					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4825			006527		SN=SN+1
  4826		000020	000000			ZZ=ZZ+ZZ
  4827						IFE	ZZ,<ZZ=1>
  4828	032756	200 00 0 00 035122 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4829	032757	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4830									;POSITION WITH ITSELF SHOULD RESULT WITH
  4831									;C(AC) NONZERO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-9
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0110

  4832	032760	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4833						STOP^
  4834	032761	254 04 0 00 032762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4835	032762	324 00 0 00 032763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4836									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4837									;IN THE SUBTEST) TO LOOP ON ERROR^
  4838
  4839					;**********
  4840
  4841					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4842					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4843					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4844					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4845					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4846			006530		SN=SN+1
  4847		000040	000000			ZZ=ZZ+ZZ
  4848						IFE	ZZ,<ZZ=1>
  4849	032763	200 00 0 00 035123 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4850	032764	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4851									;POSITION WITH ITSELF SHOULD RESULT WITH
  4852									;C(AC) NONZERO
  4853	032765	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4854						STOP^
  4855	032766	254 04 0 00 032767 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4856	032767	324 00 0 00 032770 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4857									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4858									;IN THE SUBTEST) TO LOOP ON ERROR^
  4859
  4860					;**********
  4861
  4862					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4863					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4864					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4865					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4866					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4867			006531		SN=SN+1
  4868		000100	000000			ZZ=ZZ+ZZ
  4869						IFE	ZZ,<ZZ=1>
  4870	032770	200 00 0 00 035124 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4871	032771	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4872									;POSITION WITH ITSELF SHOULD RESULT WITH
  4873									;C(AC) NONZERO
  4874	032772	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4875						STOP^
  4876	032773	254 04 0 00 032774 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4877	032774	324 00 0 00 032775 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4878									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4879									;IN THE SUBTEST) TO LOOP ON ERROR^
  4880
  4881					;**********
  4882
  4883					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4884					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4885					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4886					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-10
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0111

  4887					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4888			006532		SN=SN+1
  4889		000200	000000			ZZ=ZZ+ZZ
  4890						IFE	ZZ,<ZZ=1>
  4891	032775	200 00 0 00 035125 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4892	032776	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4893									;POSITION WITH ITSELF SHOULD RESULT WITH
  4894									;C(AC) NONZERO
  4895	032777	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4896						STOP^
  4897	033000	254 04 0 00 033001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4898	033001	324 00 0 00 033002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4899									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4900									;IN THE SUBTEST) TO LOOP ON ERROR^
  4901
  4902					;**********
  4903
  4904					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4905					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4906					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4907					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4908					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4909			006533		SN=SN+1
  4910		000400	000000			ZZ=ZZ+ZZ
  4911						IFE	ZZ,<ZZ=1>
  4912	033002	200 00 0 00 035073 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4913	033003	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4914									;POSITION WITH ITSELF SHOULD RESULT WITH
  4915									;C(AC) NONZERO
  4916	033004	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4917						STOP^
  4918	033005	254 04 0 00 033006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4919	033006	324 00 0 00 033007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4920									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4921									;IN THE SUBTEST) TO LOOP ON ERROR^
  4922
  4923					;**********
  4924
  4925					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4926					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4927					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4928					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4929					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4930			006534		SN=SN+1
  4931		001000	000000			ZZ=ZZ+ZZ
  4932						IFE	ZZ,<ZZ=1>
  4933	033007	200 00 0 00 035126 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4934	033010	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4935									;POSITION WITH ITSELF SHOULD RESULT WITH
  4936									;C(AC) NONZERO
  4937	033011	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4938						STOP^
  4939	033012	254 04 0 00 033013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4940	033013	324 00 0 00 033014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4941									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-11
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0112

  4942									;IN THE SUBTEST) TO LOOP ON ERROR^
  4943
  4944					;**********
  4945
  4946					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4947					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4948					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4949					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4950					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4951			006535		SN=SN+1
  4952		002000	000000			ZZ=ZZ+ZZ
  4953						IFE	ZZ,<ZZ=1>
  4954	033014	200 00 0 00 035127 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4955	033015	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4956									;POSITION WITH ITSELF SHOULD RESULT WITH
  4957									;C(AC) NONZERO
  4958	033016	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4959						STOP^
  4960	033017	254 04 0 00 033020 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4961	033020	324 00 0 00 033021 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4962									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4963									;IN THE SUBTEST) TO LOOP ON ERROR^
  4964
  4965					;**********
  4966
  4967					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4968					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4969					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4970					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4971					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4972			006536		SN=SN+1
  4973		004000	000000			ZZ=ZZ+ZZ
  4974						IFE	ZZ,<ZZ=1>
  4975	033021	200 00 0 00 035130 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4976	033022	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4977									;POSITION WITH ITSELF SHOULD RESULT WITH
  4978									;C(AC) NONZERO
  4979	033023	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4980						STOP^
  4981	033024	254 04 0 00 033025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4982	033025	324 00 0 00 033026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4983									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4984									;IN THE SUBTEST) TO LOOP ON ERROR^
  4985
  4986					;**********
  4987
  4988					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4989					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4990					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4991					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4992					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4993			006537		SN=SN+1
  4994		010000	000000			ZZ=ZZ+ZZ
  4995						IFE	ZZ,<ZZ=1>
  4996	033026	200 00 0 00 035131 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-12
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0113

  4997	033027	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4998									;POSITION WITH ITSELF SHOULD RESULT WITH
  4999									;C(AC) NONZERO
  5000	033030	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5001						STOP^
  5002	033031	254 04 0 00 033032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5003	033032	324 00 0 00 033033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5004									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5005									;IN THE SUBTEST) TO LOOP ON ERROR^
  5006
  5007					;**********
  5008
  5009					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5010					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5011					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5012					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5013					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5014			006540		SN=SN+1
  5015		020000	000000			ZZ=ZZ+ZZ
  5016						IFE	ZZ,<ZZ=1>
  5017	033033	200 00 0 00 035132 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5018	033034	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5019									;POSITION WITH ITSELF SHOULD RESULT WITH
  5020									;C(AC) NONZERO
  5021	033035	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5022						STOP^
  5023	033036	254 04 0 00 033037 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5024	033037	324 00 0 00 033040 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5025									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5026									;IN THE SUBTEST) TO LOOP ON ERROR^
  5027
  5028					;**********
  5029
  5030					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5031					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5032					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5033					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5034					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5035			006541		SN=SN+1
  5036		040000	000000			ZZ=ZZ+ZZ
  5037						IFE	ZZ,<ZZ=1>
  5038	033040	200 00 0 00 035133 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5039	033041	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5040									;POSITION WITH ITSELF SHOULD RESULT WITH
  5041									;C(AC) NONZERO
  5042	033042	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5043						STOP^
  5044	033043	254 04 0 00 033044 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5045	033044	324 00 0 00 033045 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5046									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5047									;IN THE SUBTEST) TO LOOP ON ERROR^
  5048
  5049					;**********
  5050
  5051					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-13
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0114

  5052					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5053					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5054					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5055					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5056			006542		SN=SN+1
  5057		100000	000000			ZZ=ZZ+ZZ
  5058						IFE	ZZ,<ZZ=1>
  5059	033045	200 00 0 00 035134 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5060	033046	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5061									;POSITION WITH ITSELF SHOULD RESULT WITH
  5062									;C(AC) NONZERO
  5063	033047	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5064						STOP^
  5065	033050	254 04 0 00 033051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5066	033051	324 00 0 00 033052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5067									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5068									;IN THE SUBTEST) TO LOOP ON ERROR^
  5069
  5070					;**********
  5071
  5072					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5073					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5074					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5075					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5076					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5077			006543		SN=SN+1
  5078		200000	000000			ZZ=ZZ+ZZ
  5079						IFE	ZZ,<ZZ=1>
  5080	033052	200 00 0 00 035135 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5081	033053	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5082									;POSITION WITH ITSELF SHOULD RESULT WITH
  5083									;C(AC) NONZERO
  5084	033054	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5085						STOP^
  5086	033055	254 04 0 00 033056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5087	033056	324 00 0 00 033057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5088									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5089									;IN THE SUBTEST) TO LOOP ON ERROR^
  5090
  5091					;**********
  5092
  5093					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5094					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5095					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5096					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5097					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5098			006544		SN=SN+1
  5099		400000	000000			ZZ=ZZ+ZZ
  5100						IFE	ZZ,<ZZ=1>
  5101	033057	200 00 0 00 035065 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5102	033060	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5103									;POSITION WITH ITSELF SHOULD RESULT WITH
  5104									;C(AC) NONZERO
  5105	033061	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5106						STOP^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 25-14
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0115

  5107	033062	254 04 0 00 033063 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5108	033063	324 00 0 00 033064 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5109									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5110									;IN THE SUBTEST) TO LOOP ON ERROR^
  5111
  5112					;**********
  5113
  5114					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE
  5115					;C(AC)=0 AND C(E)=0 AND E OUTSIDE OF THE AC RANGE IS ALL ZEROS IN THE AC.
  5116					;FIRST, THE AC IS CLEARED; THEN, THE C(AC) IS ANDED WITH C(E) WHEN
  5117					;E GREATER THAN 20 AND C(E)=0. THE RESULT SHOULD BE C(AC)=0.
  5118					;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5119
  5120	033064	200 00 0 00 035062 	A6600:	MOVE	[0]		;PRESET AC TO ALL ZEROS
  5121	033065	404 00 0 00 035062 		AND	[0]		;*AND OF TWO WORDS OF ALL ZEROS
  5122									;SHOULD RESULT IN C(AC)=0
  5123	033066	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5124						STOP^
  5125	033067	254 04 0 00 033070 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5126	033070	324 00 0 00 033071 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5127									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5128									;IN THE SUBTEST) TO LOOP ON ERROR^
  5129
  5130					;**********
  5131
  5132					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(AC)=0
  5133					;AND C(E) IS ALL ONES IS AN AC CONTAINING ALL ZEROS.  FIRST, THE AC IS
  5134					;CLEARED; THEN THE C(AC) IS ANDED WITH AN E CONTAINING ALL ONES, WHERE
  5135					;E IS BEYOND THE AC RANGE.  THE RESULT SHOULD BE C(AC)=0.
  5136					;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5137
  5138	033071	200 00 0 00 035062 	A6700:	MOVE	[0]		;PRESET AC TO ALL ZEROS
  5139	033072	404 00 0 00 035063 		AND	[-1]		;*AND OF TWO WORDS WHERE C(AC)=0 SHOULD RESULT IN C(AC)=0
  5140	033073	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5141						STOP^
  5142	033074	254 04 0 00 033075 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5143	033075	324 00 0 00 033076 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5144									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5145									;IN THE SUBTEST) TO LOOP ON ERROR^
  5146
  5147					;AD FM+EN [ADFP],AD FM+EN A [ADFP],
  5148					;F CYC ACT EN C [F1],IR BOOLE AD FM+F [IR2],
  5149					;IR BOOLE [IR1],IRXX(1,4,5,11,13,16) [IR2]
  5150
  5151					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 26
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0116

  5152					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(E)=0
  5153					;AND C(AC) IS ALL ONES IS AN AC CONTAINING ALL ZEROS. FIRST, THE
  5154					;AC IS SET TO ALL ONES; THEN, THE AC IS ANDED WITH AN E CONTAINING ALL
  5155					;ZEROS, WHERE E IS BEYOND THE AC RANGE.  THE RESULT SHOULD BE C(AC)=0.
  5156					;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5157
  5158	033076	200 00 0 00 035063 	A7000:	MOVE	[-1]		;PRESET AC TO ALL ONES
  5159	033077	404 00 0 00 035062 		AND	[0]		;*AND OF TWO WORDS WHERE C(E)=0 SHOULD RESULT IN C(AC)=0
  5160	033100	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5161						STOP^
  5162	033101	254 04 0 00 033102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5163	033102	324 00 0 00 033103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5164									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5165									;IN THE SUBTEST) TO LOOP ON ERROR^
  5166
  5167					;**********
  5168
  5169					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(E) IS
  5170					;ALL ONES AND C(AC) IS ALL ONES IS AN AC CONTAINING ALL ONES.  FIRST, THE
  5171					;AC IS SET TO ALL ONES; THEN, C(AC) IS ANDED WITH AN E CONTAINING ALL
  5172					;ONES.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5173					;IF C(AC) IS ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5174
  5175	033103	200 00 0 00 035063 	A7100:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
  5176	033104	404 00 0 00 035063 		AND	[-1]		;*AND OF TWO WORDS OF ALL ONES SHOULD
  5177									;RESULT IN C(AC)=ALL ONES
  5178	033105	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON ZERO
  5179						STOP^
  5180	033106	254 04 0 00 033107 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5181	033107	324 00 0 00 033110 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5182									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5183									;IN THE SUBTEST) TO LOOP ON ERROR^
  5184
  5185					;**********
  5186
  5187					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5188					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHERE CONTENTS IS NON-ZERO.
  5189					;FIRST, THE AC IS CLEARED, THEN, XOR IS EXECUTED WHERE C(E) IS NON-ZERO.
  5190					;THE AC IS THEN CHECKED FOR NON-ZERO CONTENTS.
  5191	033110	200 00 0 00 035062 	A7200:	MOVE	[0]		;CLEAR AC
  5192	033111	430 00 0 00 035141 		XOR	[707070707070]	;*XOR WITH C(AC)=0 AND C(E)=7070707070 SHOULD
  5193									;RESTULT IN C(AC)=707070707070
  5194	033112	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5195						STOP^
  5196	033113	254 04 0 00 033114 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5197	033114	324 00 0 00 033115 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5198									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5199									;IN THE SUBTEST) TO LOOP ON ERROR^
  5200
  5201					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0117

  5202			007300		SN=7300
  5203			000000			ZZ=0
  5204
  5205					A7300:	REPEAT	^D36,
  5206					<;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5207					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5208					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5209					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5210					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5211					SN=SN+1
  5212						ZZ=ZZ+ZZ
  5213						IFE	ZZ,<ZZ=1>
  5214						MOVE	[0]		;CLEAR AC
  5215						XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5216									;RESULT IN C(AC) NONZERO
  5217						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5218						STOP
  5219
  5220					;**********
  5221					>
  5222					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5223					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5224					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5225					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5226					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5227			007301		SN=SN+1
  5228			000000			ZZ=ZZ+ZZ
  5229			000001			IFE	ZZ,<ZZ=1>
  5230	033115	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5231	033116	430 00 0 00 035074 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5232									;RESULT IN C(AC) NONZERO
  5233	033117	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5234						STOP^
  5235	033120	254 04 0 00 033121 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5236	033121	324 00 0 00 033122 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5237									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5238									;IN THE SUBTEST) TO LOOP ON ERROR^
  5239
  5240					;**********
  5241
  5242					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5243					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5244					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5245					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5246					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5247			007302		SN=SN+1
  5248			000002			ZZ=ZZ+ZZ
  5249						IFE	ZZ,<ZZ=1>
  5250	033122	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5251	033123	430 00 0 00 035075 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5252									;RESULT IN C(AC) NONZERO
  5253	033124	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5254						STOP^
  5255	033125	254 04 0 00 033126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5256	033126	324 00 0 00 033127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0118

  5257									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5258									;IN THE SUBTEST) TO LOOP ON ERROR^
  5259
  5260					;**********
  5261
  5262					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5263					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5264					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5265					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5266					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5267			007303		SN=SN+1
  5268			000004			ZZ=ZZ+ZZ
  5269						IFE	ZZ,<ZZ=1>
  5270	033127	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5271	033130	430 00 0 00 035076 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5272									;RESULT IN C(AC) NONZERO
  5273	033131	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5274						STOP^
  5275	033132	254 04 0 00 033133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5276	033133	324 00 0 00 033134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5277									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5278									;IN THE SUBTEST) TO LOOP ON ERROR^
  5279
  5280					;**********
  5281
  5282					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5283					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5284					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5285					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5286					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5287			007304		SN=SN+1
  5288			000010			ZZ=ZZ+ZZ
  5289						IFE	ZZ,<ZZ=1>
  5290	033134	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5291	033135	430 00 0 00 035077 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5292									;RESULT IN C(AC) NONZERO
  5293	033136	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5294						STOP^
  5295	033137	254 04 0 00 033140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5296	033140	324 00 0 00 033141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5297									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5298									;IN THE SUBTEST) TO LOOP ON ERROR^
  5299
  5300					;**********
  5301
  5302					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5303					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5304					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5305					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5306					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5307			007305		SN=SN+1
  5308			000020			ZZ=ZZ+ZZ
  5309						IFE	ZZ,<ZZ=1>
  5310	033141	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5311	033142	430 00 0 00 035100 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-2
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0119

  5312									;RESULT IN C(AC) NONZERO
  5313	033143	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5314						STOP^
  5315	033144	254 04 0 00 033145 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5316	033145	324 00 0 00 033146 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5317									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5318									;IN THE SUBTEST) TO LOOP ON ERROR^
  5319
  5320					;**********
  5321
  5322					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5323					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5324					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5325					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5326					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5327			007306		SN=SN+1
  5328			000040			ZZ=ZZ+ZZ
  5329						IFE	ZZ,<ZZ=1>
  5330	033146	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5331	033147	430 00 0 00 035101 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5332									;RESULT IN C(AC) NONZERO
  5333	033150	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5334						STOP^
  5335	033151	254 04 0 00 033152 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5336	033152	324 00 0 00 033153 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5338									;IN THE SUBTEST) TO LOOP ON ERROR^
  5339
  5340					;**********
  5341
  5342					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5343					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5344					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5345					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5346					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5347			007307		SN=SN+1
  5348			000100			ZZ=ZZ+ZZ
  5349						IFE	ZZ,<ZZ=1>
  5350	033153	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5351	033154	430 00 0 00 035102 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5352									;RESULT IN C(AC) NONZERO
  5353	033155	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5354						STOP^
  5355	033156	254 04 0 00 033157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5356	033157	324 00 0 00 033160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5357									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5358									;IN THE SUBTEST) TO LOOP ON ERROR^
  5359
  5360					;**********
  5361
  5362					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5363					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5364					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5365					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5366					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-3
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0120

  5367			007310		SN=SN+1
  5368			000200			ZZ=ZZ+ZZ
  5369						IFE	ZZ,<ZZ=1>
  5370	033160	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5371	033161	430 00 0 00 035103 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5372									;RESULT IN C(AC) NONZERO
  5373	033162	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5374						STOP^
  5375	033163	254 04 0 00 033164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5376	033164	324 00 0 00 033165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5377									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5378									;IN THE SUBTEST) TO LOOP ON ERROR^
  5379
  5380					;**********
  5381
  5382					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5383					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5384					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5385					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5386					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5387			007311		SN=SN+1
  5388			000400			ZZ=ZZ+ZZ
  5389						IFE	ZZ,<ZZ=1>
  5390	033165	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5391	033166	430 00 0 00 035104 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5392									;RESULT IN C(AC) NONZERO
  5393	033167	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5394						STOP^
  5395	033170	254 04 0 00 033171 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5396	033171	324 00 0 00 033172 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5397									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5398									;IN THE SUBTEST) TO LOOP ON ERROR^
  5399
  5400					;**********
  5401
  5402					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5403					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5404					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5405					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5406					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5407			007312		SN=SN+1
  5408			001000			ZZ=ZZ+ZZ
  5409						IFE	ZZ,<ZZ=1>
  5410	033172	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5411	033173	430 00 0 00 035105 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5412									;RESULT IN C(AC) NONZERO
  5413	033174	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5414						STOP^
  5415	033175	254 04 0 00 033176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5416	033176	324 00 0 00 033177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5417									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5418									;IN THE SUBTEST) TO LOOP ON ERROR^
  5419
  5420					;**********
  5421
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-4
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0121

  5422					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5423					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5424					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5425					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5426					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5427			007313		SN=SN+1
  5428			002000			ZZ=ZZ+ZZ
  5429						IFE	ZZ,<ZZ=1>
  5430	033177	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5431	033200	430 00 0 00 035106 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5432									;RESULT IN C(AC) NONZERO
  5433	033201	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5434						STOP^
  5435	033202	254 04 0 00 033203 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5436	033203	324 00 0 00 033204 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5437									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5438									;IN THE SUBTEST) TO LOOP ON ERROR^
  5439
  5440					;**********
  5441
  5442					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5443					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5444					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5445					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5446					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5447			007314		SN=SN+1
  5448			004000			ZZ=ZZ+ZZ
  5449						IFE	ZZ,<ZZ=1>
  5450	033204	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5451	033205	430 00 0 00 035107 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5452									;RESULT IN C(AC) NONZERO
  5453	033206	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5454						STOP^
  5455	033207	254 04 0 00 033210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5456	033210	324 00 0 00 033211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5457									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5458									;IN THE SUBTEST) TO LOOP ON ERROR^
  5459
  5460					;**********
  5461
  5462					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5463					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5464					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5465					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5466					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5467			007315		SN=SN+1
  5468			010000			ZZ=ZZ+ZZ
  5469						IFE	ZZ,<ZZ=1>
  5470	033211	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5471	033212	430 00 0 00 035110 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5472									;RESULT IN C(AC) NONZERO
  5473	033213	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5474						STOP^
  5475	033214	254 04 0 00 033215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5476	033215	324 00 0 00 033216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-5
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0122

  5477									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5478									;IN THE SUBTEST) TO LOOP ON ERROR^
  5479
  5480					;**********
  5481
  5482					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5483					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5484					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5485					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5486					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5487			007316		SN=SN+1
  5488			020000			ZZ=ZZ+ZZ
  5489						IFE	ZZ,<ZZ=1>
  5490	033216	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5491	033217	430 00 0 00 035111 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5492									;RESULT IN C(AC) NONZERO
  5493	033220	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5494						STOP^
  5495	033221	254 04 0 00 033222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5496	033222	324 00 0 00 033223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5497									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5498									;IN THE SUBTEST) TO LOOP ON ERROR^
  5499
  5500					;**********
  5501
  5502					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5503					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5504					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5505					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5506					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5507			007317		SN=SN+1
  5508			040000			ZZ=ZZ+ZZ
  5509						IFE	ZZ,<ZZ=1>
  5510	033223	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5511	033224	430 00 0 00 035112 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5512									;RESULT IN C(AC) NONZERO
  5513	033225	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5514						STOP^
  5515	033226	254 04 0 00 033227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5516	033227	324 00 0 00 033230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5517									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5518									;IN THE SUBTEST) TO LOOP ON ERROR^
  5519
  5520					;**********
  5521
  5522					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5523					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5524					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5525					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5526					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5527			007320		SN=SN+1
  5528			100000			ZZ=ZZ+ZZ
  5529						IFE	ZZ,<ZZ=1>
  5530	033230	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5531	033231	430 00 0 00 035113 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-6
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0123

  5532									;RESULT IN C(AC) NONZERO
  5533	033232	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5534						STOP^
  5535	033233	254 04 0 00 033234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5536	033234	324 00 0 00 033235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5537									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5538									;IN THE SUBTEST) TO LOOP ON ERROR^
  5539
  5540					;**********
  5541
  5542					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5543					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5544					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5545					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5546					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5547			007321		SN=SN+1
  5548			200000			ZZ=ZZ+ZZ
  5549						IFE	ZZ,<ZZ=1>
  5550	033235	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5551	033236	430 00 0 00 035114 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5552									;RESULT IN C(AC) NONZERO
  5553	033237	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5554						STOP^
  5555	033240	254 04 0 00 033241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5556	033241	324 00 0 00 033242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5557									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5558									;IN THE SUBTEST) TO LOOP ON ERROR^
  5559
  5560					;**********
  5561
  5562					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5563					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5564					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5565					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5566					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5567			007322		SN=SN+1
  5568			400000			ZZ=ZZ+ZZ
  5569						IFE	ZZ,<ZZ=1>
  5570	033242	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5571	033243	430 00 0 00 035115 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5572									;RESULT IN C(AC) NONZERO
  5573	033244	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5574						STOP^
  5575	033245	254 04 0 00 033246 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5576	033246	324 00 0 00 033247 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5577									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5578									;IN THE SUBTEST) TO LOOP ON ERROR^
  5579
  5580					;**********
  5581
  5582					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5583					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5584					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5585					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5586					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-7
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0124

  5587			007323		SN=SN+1
  5588		000001	000000			ZZ=ZZ+ZZ
  5589						IFE	ZZ,<ZZ=1>
  5590	033247	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5591	033250	430 00 0 00 035116 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5592									;RESULT IN C(AC) NONZERO
  5593	033251	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5594						STOP^
  5595	033252	254 04 0 00 033253 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5596	033253	324 00 0 00 033254 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5598									;IN THE SUBTEST) TO LOOP ON ERROR^
  5599
  5600					;**********
  5601
  5602					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5603					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5604					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5605					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5606					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5607			007324		SN=SN+1
  5608		000002	000000			ZZ=ZZ+ZZ
  5609						IFE	ZZ,<ZZ=1>
  5610	033254	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5611	033255	430 00 0 00 035117 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5612									;RESULT IN C(AC) NONZERO
  5613	033256	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5614						STOP^
  5615	033257	254 04 0 00 033260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5616	033260	324 00 0 00 033261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5617									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5618									;IN THE SUBTEST) TO LOOP ON ERROR^
  5619
  5620					;**********
  5621
  5622					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5623					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5624					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5625					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5626					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5627			007325		SN=SN+1
  5628		000004	000000			ZZ=ZZ+ZZ
  5629						IFE	ZZ,<ZZ=1>
  5630	033261	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5631	033262	430 00 0 00 035120 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5632									;RESULT IN C(AC) NONZERO
  5633	033263	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5634						STOP^
  5635	033264	254 04 0 00 033265 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5636	033265	324 00 0 00 033266 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5637									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5638									;IN THE SUBTEST) TO LOOP ON ERROR^
  5639
  5640					;**********
  5641
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-8
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0125

  5642					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5643					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5644					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5645					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5646					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5647			007326		SN=SN+1
  5648		000010	000000			ZZ=ZZ+ZZ
  5649						IFE	ZZ,<ZZ=1>
  5650	033266	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5651	033267	430 00 0 00 035121 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5652									;RESULT IN C(AC) NONZERO
  5653	033270	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5654						STOP^
  5655	033271	254 04 0 00 033272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5656	033272	324 00 0 00 033273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5657									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5658									;IN THE SUBTEST) TO LOOP ON ERROR^
  5659
  5660					;**********
  5661
  5662					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5663					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5664					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5665					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5666					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5667			007327		SN=SN+1
  5668		000020	000000			ZZ=ZZ+ZZ
  5669						IFE	ZZ,<ZZ=1>
  5670	033273	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5671	033274	430 00 0 00 035122 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5672									;RESULT IN C(AC) NONZERO
  5673	033275	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5674						STOP^
  5675	033276	254 04 0 00 033277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5676	033277	324 00 0 00 033300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5677									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5678									;IN THE SUBTEST) TO LOOP ON ERROR^
  5679
  5680					;**********
  5681
  5682					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5683					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5684					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5685					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5686					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5687			007330		SN=SN+1
  5688		000040	000000			ZZ=ZZ+ZZ
  5689						IFE	ZZ,<ZZ=1>
  5690	033300	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5691	033301	430 00 0 00 035123 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5692									;RESULT IN C(AC) NONZERO
  5693	033302	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5694						STOP^
  5695	033303	254 04 0 00 033304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5696	033304	324 00 0 00 033305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-9
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0126

  5697									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5698									;IN THE SUBTEST) TO LOOP ON ERROR^
  5699
  5700					;**********
  5701
  5702					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5703					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5704					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5705					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5706					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5707			007331		SN=SN+1
  5708		000100	000000			ZZ=ZZ+ZZ
  5709						IFE	ZZ,<ZZ=1>
  5710	033305	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5711	033306	430 00 0 00 035124 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5712									;RESULT IN C(AC) NONZERO
  5713	033307	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5714						STOP^
  5715	033310	254 04 0 00 033311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5716	033311	324 00 0 00 033312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5717									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5718									;IN THE SUBTEST) TO LOOP ON ERROR^
  5719
  5720					;**********
  5721
  5722					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5723					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5724					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5725					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5726					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5727			007332		SN=SN+1
  5728		000200	000000			ZZ=ZZ+ZZ
  5729						IFE	ZZ,<ZZ=1>
  5730	033312	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5731	033313	430 00 0 00 035125 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5732									;RESULT IN C(AC) NONZERO
  5733	033314	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5734						STOP^
  5735	033315	254 04 0 00 033316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5736	033316	324 00 0 00 033317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5737									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5738									;IN THE SUBTEST) TO LOOP ON ERROR^
  5739
  5740					;**********
  5741
  5742					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5743					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5744					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5745					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5746					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5747			007333		SN=SN+1
  5748		000400	000000			ZZ=ZZ+ZZ
  5749						IFE	ZZ,<ZZ=1>
  5750	033317	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5751	033320	430 00 0 00 035073 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-10
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0127

  5752									;RESULT IN C(AC) NONZERO
  5753	033321	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5754						STOP^
  5755	033322	254 04 0 00 033323 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5756	033323	324 00 0 00 033324 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5757									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5758									;IN THE SUBTEST) TO LOOP ON ERROR^
  5759
  5760					;**********
  5761
  5762					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5763					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5764					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5765					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5766					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5767			007334		SN=SN+1
  5768		001000	000000			ZZ=ZZ+ZZ
  5769						IFE	ZZ,<ZZ=1>
  5770	033324	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5771	033325	430 00 0 00 035126 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5772									;RESULT IN C(AC) NONZERO
  5773	033326	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5774						STOP^
  5775	033327	254 04 0 00 033330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5776	033330	324 00 0 00 033331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5777									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5778									;IN THE SUBTEST) TO LOOP ON ERROR^
  5779
  5780					;**********
  5781
  5782					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5783					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5784					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5785					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5786					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5787			007335		SN=SN+1
  5788		002000	000000			ZZ=ZZ+ZZ
  5789						IFE	ZZ,<ZZ=1>
  5790	033331	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5791	033332	430 00 0 00 035127 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5792									;RESULT IN C(AC) NONZERO
  5793	033333	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5794						STOP^
  5795	033334	254 04 0 00 033335 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5796	033335	324 00 0 00 033336 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5797									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5798									;IN THE SUBTEST) TO LOOP ON ERROR^
  5799
  5800					;**********
  5801
  5802					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5803					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5804					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5805					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5806					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-11
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0128

  5807			007336		SN=SN+1
  5808		004000	000000			ZZ=ZZ+ZZ
  5809						IFE	ZZ,<ZZ=1>
  5810	033336	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5811	033337	430 00 0 00 035130 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5812									;RESULT IN C(AC) NONZERO
  5813	033340	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5814						STOP^
  5815	033341	254 04 0 00 033342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5816	033342	324 00 0 00 033343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5817									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5818									;IN THE SUBTEST) TO LOOP ON ERROR^
  5819
  5820					;**********
  5821
  5822					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5823					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5824					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5825					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5826					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5827			007337		SN=SN+1
  5828		010000	000000			ZZ=ZZ+ZZ
  5829						IFE	ZZ,<ZZ=1>
  5830	033343	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5831	033344	430 00 0 00 035131 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5832									;RESULT IN C(AC) NONZERO
  5833	033345	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5834						STOP^
  5835	033346	254 04 0 00 033347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5836	033347	324 00 0 00 033350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5837									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5838									;IN THE SUBTEST) TO LOOP ON ERROR^
  5839
  5840					;**********
  5841
  5842					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5843					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5844					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5845					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5846					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5847			007340		SN=SN+1
  5848		020000	000000			ZZ=ZZ+ZZ
  5849						IFE	ZZ,<ZZ=1>
  5850	033350	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5851	033351	430 00 0 00 035132 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5852									;RESULT IN C(AC) NONZERO
  5853	033352	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5854						STOP^
  5855	033353	254 04 0 00 033354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5856	033354	324 00 0 00 033355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5857									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5858									;IN THE SUBTEST) TO LOOP ON ERROR^
  5859
  5860					;**********
  5861
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-12
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0129

  5862					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5863					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5864					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5865					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5866					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5867			007341		SN=SN+1
  5868		040000	000000			ZZ=ZZ+ZZ
  5869						IFE	ZZ,<ZZ=1>
  5870	033355	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5871	033356	430 00 0 00 035133 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5872									;RESULT IN C(AC) NONZERO
  5873	033357	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5874						STOP^
  5875	033360	254 04 0 00 033361 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5876	033361	324 00 0 00 033362 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5877									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5878									;IN THE SUBTEST) TO LOOP ON ERROR^
  5879
  5880					;**********
  5881
  5882					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5883					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5884					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5885					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5886					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5887			007342		SN=SN+1
  5888		100000	000000			ZZ=ZZ+ZZ
  5889						IFE	ZZ,<ZZ=1>
  5890	033362	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5891	033363	430 00 0 00 035134 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5892									;RESULT IN C(AC) NONZERO
  5893	033364	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5894						STOP^
  5895	033365	254 04 0 00 033366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5896	033366	324 00 0 00 033367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5897									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5898									;IN THE SUBTEST) TO LOOP ON ERROR^
  5899
  5900					;**********
  5901
  5902					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5903					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5904					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5905					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5906					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5907			007343		SN=SN+1
  5908		200000	000000			ZZ=ZZ+ZZ
  5909						IFE	ZZ,<ZZ=1>
  5910	033367	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5911	033370	430 00 0 00 035135 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5912									;RESULT IN C(AC) NONZERO
  5913	033371	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5914						STOP^
  5915	033372	254 04 0 00 033373 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5916	033373	324 00 0 00 033374 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-13
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0130

  5917									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5918									;IN THE SUBTEST) TO LOOP ON ERROR^
  5919
  5920					;**********
  5921
  5922					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5923					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5924					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5925					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5926					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5927			007344		SN=SN+1
  5928		400000	000000			ZZ=ZZ+ZZ
  5929						IFE	ZZ,<ZZ=1>
  5930	033374	200 00 0 00 035062 		MOVE	[0]		;CLEAR AC
  5931	033375	430 00 0 00 035065 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5932									;RESULT IN C(AC) NONZERO
  5933	033376	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5934						STOP^
  5935	033377	254 04 0 00 033400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5936	033400	324 00 0 00 033401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5937									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5938									;IN THE SUBTEST) TO LOOP ON ERROR^
  5939
  5940					;**********
  5941
  5942			007400		SN=7400
  5943			000000			ZZ=0
  5944
  5945					A7400:	REPEAT	^D36,
  5946					<;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5947					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  5948					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  5949					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  5950					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5951					SN=SN+1
  5952						ZZ=ZZ+ZZ
  5953						IFE	ZZ,<ZZ=1>
  5954						MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  5955						XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  5956									;RESULT IN C(AC) NON-ZERO
  5957						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5958						STOP
  5959
  5960					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  5961					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  5962					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  5963					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  5964
  5965					;**********
  5966					>
  5967					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5968					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  5969					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  5970					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  5971					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-14
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0131

  5972			007401		SN=SN+1
  5973			000000			ZZ=ZZ+ZZ
  5974			000001			IFE	ZZ,<ZZ=1>
  5975	033401	200 00 0 00 035074 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  5976	033402	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  5977									;RESULT IN C(AC) NON-ZERO
  5978	033403	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5979						STOP^
  5980	033404	254 04 0 00 033405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5981	033405	324 00 0 00 033406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5982									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5983									;IN THE SUBTEST) TO LOOP ON ERROR^
  5984
  5985					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  5986					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  5987					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  5988					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  5989
  5990					;**********
  5991
  5992					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5993					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  5994					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  5995					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  5996					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5997			007402		SN=SN+1
  5998			000002			ZZ=ZZ+ZZ
  5999						IFE	ZZ,<ZZ=1>
  6000	033406	200 00 0 00 035075 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6001	033407	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6002									;RESULT IN C(AC) NON-ZERO
  6003	033410	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6004						STOP^
  6005	033411	254 04 0 00 033412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6006	033412	324 00 0 00 033413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6007									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6008									;IN THE SUBTEST) TO LOOP ON ERROR^
  6009
  6010					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6011					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6012					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6013					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6014
  6015					;**********
  6016
  6017					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6018					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6019					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6020					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6021					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6022			007403		SN=SN+1
  6023			000004			ZZ=ZZ+ZZ
  6024						IFE	ZZ,<ZZ=1>
  6025	033413	200 00 0 00 035076 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6026	033414	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-15
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0132

  6027									;RESULT IN C(AC) NON-ZERO
  6028	033415	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6029						STOP^
  6030	033416	254 04 0 00 033417 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6031	033417	324 00 0 00 033420 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6032									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6033									;IN THE SUBTEST) TO LOOP ON ERROR^
  6034
  6035					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6036					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6037					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6038					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6039
  6040					;**********
  6041
  6042					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6043					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6044					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6045					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6046					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6047			007404		SN=SN+1
  6048			000010			ZZ=ZZ+ZZ
  6049						IFE	ZZ,<ZZ=1>
  6050	033420	200 00 0 00 035077 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6051	033421	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6052									;RESULT IN C(AC) NON-ZERO
  6053	033422	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6054						STOP^
  6055	033423	254 04 0 00 033424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6056	033424	324 00 0 00 033425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6057									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6058									;IN THE SUBTEST) TO LOOP ON ERROR^
  6059
  6060					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6061					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6062					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6063					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6064
  6065					;**********
  6066
  6067					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6068					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6069					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6070					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6071					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6072			007405		SN=SN+1
  6073			000020			ZZ=ZZ+ZZ
  6074						IFE	ZZ,<ZZ=1>
  6075	033425	200 00 0 00 035100 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6076	033426	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6077									;RESULT IN C(AC) NON-ZERO
  6078	033427	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6079						STOP^
  6080	033430	254 04 0 00 033431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6081	033431	324 00 0 00 033432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-16
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0133

  6082									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6083									;IN THE SUBTEST) TO LOOP ON ERROR^
  6084
  6085					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6086					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6087					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6088					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6089
  6090					;**********
  6091
  6092					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6093					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6094					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6095					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6096					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6097			007406		SN=SN+1
  6098			000040			ZZ=ZZ+ZZ
  6099						IFE	ZZ,<ZZ=1>
  6100	033432	200 00 0 00 035101 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6101	033433	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6102									;RESULT IN C(AC) NON-ZERO
  6103	033434	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6104						STOP^
  6105	033435	254 04 0 00 033436 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6106	033436	324 00 0 00 033437 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6107									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6108									;IN THE SUBTEST) TO LOOP ON ERROR^
  6109
  6110					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6111					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6112					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6113					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6114
  6115					;**********
  6116
  6117					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6118					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6119					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6120					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6121					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6122			007407		SN=SN+1
  6123			000100			ZZ=ZZ+ZZ
  6124						IFE	ZZ,<ZZ=1>
  6125	033437	200 00 0 00 035102 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6126	033440	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6127									;RESULT IN C(AC) NON-ZERO
  6128	033441	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6129						STOP^
  6130	033442	254 04 0 00 033443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6131	033443	324 00 0 00 033444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6132									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6133									;IN THE SUBTEST) TO LOOP ON ERROR^
  6134
  6135					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6136					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-17
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0134

  6137					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6138					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6139
  6140					;**********
  6141
  6142					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6143					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6144					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6145					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6146					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6147			007410		SN=SN+1
  6148			000200			ZZ=ZZ+ZZ
  6149						IFE	ZZ,<ZZ=1>
  6150	033444	200 00 0 00 035103 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6151	033445	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6152									;RESULT IN C(AC) NON-ZERO
  6153	033446	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6154						STOP^
  6155	033447	254 04 0 00 033450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6156	033450	324 00 0 00 033451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6157									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6158									;IN THE SUBTEST) TO LOOP ON ERROR^
  6159
  6160					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6161					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6162					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6163					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6164
  6165					;**********
  6166
  6167					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6168					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6169					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6170					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6171					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6172			007411		SN=SN+1
  6173			000400			ZZ=ZZ+ZZ
  6174						IFE	ZZ,<ZZ=1>
  6175	033451	200 00 0 00 035104 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6176	033452	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6177									;RESULT IN C(AC) NON-ZERO
  6178	033453	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6179						STOP^
  6180	033454	254 04 0 00 033455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6181	033455	324 00 0 00 033456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6182									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6183									;IN THE SUBTEST) TO LOOP ON ERROR^
  6184
  6185					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6186					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6187					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6188					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6189
  6190					;**********
  6191
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-18
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0135

  6192					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6193					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6194					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6195					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6196					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6197			007412		SN=SN+1
  6198			001000			ZZ=ZZ+ZZ
  6199						IFE	ZZ,<ZZ=1>
  6200	033456	200 00 0 00 035105 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6201	033457	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6202									;RESULT IN C(AC) NON-ZERO
  6203	033460	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6204						STOP^
  6205	033461	254 04 0 00 033462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6206	033462	324 00 0 00 033463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6207									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6208									;IN THE SUBTEST) TO LOOP ON ERROR^
  6209
  6210					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6211					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6212					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6213					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6214
  6215					;**********
  6216
  6217					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6218					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6219					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6220					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6221					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6222			007413		SN=SN+1
  6223			002000			ZZ=ZZ+ZZ
  6224						IFE	ZZ,<ZZ=1>
  6225	033463	200 00 0 00 035106 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6226	033464	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6227									;RESULT IN C(AC) NON-ZERO
  6228	033465	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6229						STOP^
  6230	033466	254 04 0 00 033467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6231	033467	324 00 0 00 033470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6232									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6233									;IN THE SUBTEST) TO LOOP ON ERROR^
  6234
  6235					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6236					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6237					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6238					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6239
  6240					;**********
  6241
  6242					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6243					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6244					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6245					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6246					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-19
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0136

  6247			007414		SN=SN+1
  6248			004000			ZZ=ZZ+ZZ
  6249						IFE	ZZ,<ZZ=1>
  6250	033470	200 00 0 00 035107 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6251	033471	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6252									;RESULT IN C(AC) NON-ZERO
  6253	033472	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6254						STOP^
  6255	033473	254 04 0 00 033474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6256	033474	324 00 0 00 033475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6257									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6258									;IN THE SUBTEST) TO LOOP ON ERROR^
  6259
  6260					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6261					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6262					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6263					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6264
  6265					;**********
  6266
  6267					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6268					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6269					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6270					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6271					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6272			007415		SN=SN+1
  6273			010000			ZZ=ZZ+ZZ
  6274						IFE	ZZ,<ZZ=1>
  6275	033475	200 00 0 00 035110 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6276	033476	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6277									;RESULT IN C(AC) NON-ZERO
  6278	033477	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6279						STOP^
  6280	033500	254 04 0 00 033501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6281	033501	324 00 0 00 033502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6282									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6283									;IN THE SUBTEST) TO LOOP ON ERROR^
  6284
  6285					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6286					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6287					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6288					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6289
  6290					;**********
  6291
  6292					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6293					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6294					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6295					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6296					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6297			007416		SN=SN+1
  6298			020000			ZZ=ZZ+ZZ
  6299						IFE	ZZ,<ZZ=1>
  6300	033502	200 00 0 00 035111 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6301	033503	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-20
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0137

  6302									;RESULT IN C(AC) NON-ZERO
  6303	033504	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6304						STOP^
  6305	033505	254 04 0 00 033506 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6306	033506	324 00 0 00 033507 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6307									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6308									;IN THE SUBTEST) TO LOOP ON ERROR^
  6309
  6310					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6311					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6312					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6313					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6314
  6315					;**********
  6316
  6317					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6318					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6319					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6320					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6321					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6322			007417		SN=SN+1
  6323			040000			ZZ=ZZ+ZZ
  6324						IFE	ZZ,<ZZ=1>
  6325	033507	200 00 0 00 035112 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6326	033510	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6327									;RESULT IN C(AC) NON-ZERO
  6328	033511	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6329						STOP^
  6330	033512	254 04 0 00 033513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6331	033513	324 00 0 00 033514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6333									;IN THE SUBTEST) TO LOOP ON ERROR^
  6334
  6335					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6336					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6337					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6338					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6339
  6340					;**********
  6341
  6342					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6343					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6344					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6345					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6346					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6347			007420		SN=SN+1
  6348			100000			ZZ=ZZ+ZZ
  6349						IFE	ZZ,<ZZ=1>
  6350	033514	200 00 0 00 035113 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6351	033515	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6352									;RESULT IN C(AC) NON-ZERO
  6353	033516	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6354						STOP^
  6355	033517	254 04 0 00 033520 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6356	033520	324 00 0 00 033521 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-21
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0138

  6357									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6358									;IN THE SUBTEST) TO LOOP ON ERROR^
  6359
  6360					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6361					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6362					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6363					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6364
  6365					;**********
  6366
  6367					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6368					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6369					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6370					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6371					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6372			007421		SN=SN+1
  6373			200000			ZZ=ZZ+ZZ
  6374						IFE	ZZ,<ZZ=1>
  6375	033521	200 00 0 00 035114 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6376	033522	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6377									;RESULT IN C(AC) NON-ZERO
  6378	033523	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6379						STOP^
  6380	033524	254 04 0 00 033525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6381	033525	324 00 0 00 033526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6382									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6383									;IN THE SUBTEST) TO LOOP ON ERROR^
  6384
  6385					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6386					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6387					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6388					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6389
  6390					;**********
  6391
  6392					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6393					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6394					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6395					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6396					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6397			007422		SN=SN+1
  6398			400000			ZZ=ZZ+ZZ
  6399						IFE	ZZ,<ZZ=1>
  6400	033526	200 00 0 00 035115 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6401	033527	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6402									;RESULT IN C(AC) NON-ZERO
  6403	033530	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6404						STOP^
  6405	033531	254 04 0 00 033532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6406	033532	324 00 0 00 033533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6407									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6408									;IN THE SUBTEST) TO LOOP ON ERROR^
  6409
  6410					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6411					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-22
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0139

  6412					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6413					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6414
  6415					;**********
  6416
  6417					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6418					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6419					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6420					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6421					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6422			007423		SN=SN+1
  6423		000001	000000			ZZ=ZZ+ZZ
  6424						IFE	ZZ,<ZZ=1>
  6425	033533	200 00 0 00 035116 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6426	033534	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6427									;RESULT IN C(AC) NON-ZERO
  6428	033535	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6429						STOP^
  6430	033536	254 04 0 00 033537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6431	033537	324 00 0 00 033540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6432									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6433									;IN THE SUBTEST) TO LOOP ON ERROR^
  6434
  6435					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6436					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6437					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6438					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6439
  6440					;**********
  6441
  6442					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6443					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6444					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6445					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6446					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6447			007424		SN=SN+1
  6448		000002	000000			ZZ=ZZ+ZZ
  6449						IFE	ZZ,<ZZ=1>
  6450	033540	200 00 0 00 035117 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6451	033541	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6452									;RESULT IN C(AC) NON-ZERO
  6453	033542	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6454						STOP^
  6455	033543	254 04 0 00 033544 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6456	033544	324 00 0 00 033545 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6457									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6458									;IN THE SUBTEST) TO LOOP ON ERROR^
  6459
  6460					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6461					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6462					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6463					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6464
  6465					;**********
  6466
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-23
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0140

  6467					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6468					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6469					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6470					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6471					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6472			007425		SN=SN+1
  6473		000004	000000			ZZ=ZZ+ZZ
  6474						IFE	ZZ,<ZZ=1>
  6475	033545	200 00 0 00 035120 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6476	033546	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6477									;RESULT IN C(AC) NON-ZERO
  6478	033547	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6479						STOP^
  6480	033550	254 04 0 00 033551 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6481	033551	324 00 0 00 033552 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6482									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6483									;IN THE SUBTEST) TO LOOP ON ERROR^
  6484
  6485					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6486					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6487					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6488					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6489
  6490					;**********
  6491
  6492					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6493					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6494					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6495					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6496					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6497			007426		SN=SN+1
  6498		000010	000000			ZZ=ZZ+ZZ
  6499						IFE	ZZ,<ZZ=1>
  6500	033552	200 00 0 00 035121 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6501	033553	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6502									;RESULT IN C(AC) NON-ZERO
  6503	033554	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6504						STOP^
  6505	033555	254 04 0 00 033556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6506	033556	324 00 0 00 033557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6507									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6508									;IN THE SUBTEST) TO LOOP ON ERROR^
  6509
  6510					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6511					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6512					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6513					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6514
  6515					;**********
  6516
  6517					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6518					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6519					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6520					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6521					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-24
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0141

  6522			007427		SN=SN+1
  6523		000020	000000			ZZ=ZZ+ZZ
  6524						IFE	ZZ,<ZZ=1>
  6525	033557	200 00 0 00 035122 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6526	033560	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6527									;RESULT IN C(AC) NON-ZERO
  6528	033561	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6529						STOP^
  6530	033562	254 04 0 00 033563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6531	033563	324 00 0 00 033564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6532									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6533									;IN THE SUBTEST) TO LOOP ON ERROR^
  6534
  6535					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6536					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6537					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6538					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6539
  6540					;**********
  6541
  6542					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6543					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6544					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6545					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6546					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6547			007430		SN=SN+1
  6548		000040	000000			ZZ=ZZ+ZZ
  6549						IFE	ZZ,<ZZ=1>
  6550	033564	200 00 0 00 035123 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6551	033565	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6552									;RESULT IN C(AC) NON-ZERO
  6553	033566	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6554						STOP^
  6555	033567	254 04 0 00 033570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6556	033570	324 00 0 00 033571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6557									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6558									;IN THE SUBTEST) TO LOOP ON ERROR^
  6559
  6560					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6561					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6562					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6563					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6564
  6565					;**********
  6566
  6567					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6568					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6569					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6570					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6571					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6572			007431		SN=SN+1
  6573		000100	000000			ZZ=ZZ+ZZ
  6574						IFE	ZZ,<ZZ=1>
  6575	033571	200 00 0 00 035124 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6576	033572	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-25
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0142

  6577									;RESULT IN C(AC) NON-ZERO
  6578	033573	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6579						STOP^
  6580	033574	254 04 0 00 033575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6581	033575	324 00 0 00 033576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6582									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6583									;IN THE SUBTEST) TO LOOP ON ERROR^
  6584
  6585					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6586					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6587					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6588					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6589
  6590					;**********
  6591
  6592					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6593					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6594					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6595					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6596					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6597			007432		SN=SN+1
  6598		000200	000000			ZZ=ZZ+ZZ
  6599						IFE	ZZ,<ZZ=1>
  6600	033576	200 00 0 00 035125 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6601	033577	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6602									;RESULT IN C(AC) NON-ZERO
  6603	033600	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6604						STOP^
  6605	033601	254 04 0 00 033602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6606	033602	324 00 0 00 033603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6607									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6608									;IN THE SUBTEST) TO LOOP ON ERROR^
  6609
  6610					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6611					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6612					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6613					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6614
  6615					;**********
  6616
  6617					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6618					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6619					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6620					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6621					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6622			007433		SN=SN+1
  6623		000400	000000			ZZ=ZZ+ZZ
  6624						IFE	ZZ,<ZZ=1>
  6625	033603	200 00 0 00 035073 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6626	033604	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6627									;RESULT IN C(AC) NON-ZERO
  6628	033605	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6629						STOP^
  6630	033606	254 04 0 00 033607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6631	033607	324 00 0 00 033610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-26
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0143

  6632									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6633									;IN THE SUBTEST) TO LOOP ON ERROR^
  6634
  6635					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6636					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6637					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6638					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6639
  6640					;**********
  6641
  6642					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6643					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6644					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6645					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6646					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6647			007434		SN=SN+1
  6648		001000	000000			ZZ=ZZ+ZZ
  6649						IFE	ZZ,<ZZ=1>
  6650	033610	200 00 0 00 035126 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6651	033611	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6652									;RESULT IN C(AC) NON-ZERO
  6653	033612	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6654						STOP^
  6655	033613	254 04 0 00 033614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6656	033614	324 00 0 00 033615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6657									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6658									;IN THE SUBTEST) TO LOOP ON ERROR^
  6659
  6660					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6661					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6662					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6663					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6664
  6665					;**********
  6666
  6667					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6668					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6669					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6670					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6671					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6672			007435		SN=SN+1
  6673		002000	000000			ZZ=ZZ+ZZ
  6674						IFE	ZZ,<ZZ=1>
  6675	033615	200 00 0 00 035127 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6676	033616	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6677									;RESULT IN C(AC) NON-ZERO
  6678	033617	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6679						STOP^
  6680	033620	254 04 0 00 033621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6681	033621	324 00 0 00 033622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6682									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6683									;IN THE SUBTEST) TO LOOP ON ERROR^
  6684
  6685					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6686					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-27
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0144

  6687					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6688					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6689
  6690					;**********
  6691
  6692					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6693					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6694					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6695					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6696					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6697			007436		SN=SN+1
  6698		004000	000000			ZZ=ZZ+ZZ
  6699						IFE	ZZ,<ZZ=1>
  6700	033622	200 00 0 00 035130 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6701	033623	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6702									;RESULT IN C(AC) NON-ZERO
  6703	033624	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6704						STOP^
  6705	033625	254 04 0 00 033626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6706	033626	324 00 0 00 033627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6707									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6708									;IN THE SUBTEST) TO LOOP ON ERROR^
  6709
  6710					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6711					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6712					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6713					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6714
  6715					;**********
  6716
  6717					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6718					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6719					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6720					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6721					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6722			007437		SN=SN+1
  6723		010000	000000			ZZ=ZZ+ZZ
  6724						IFE	ZZ,<ZZ=1>
  6725	033627	200 00 0 00 035131 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6726	033630	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6727									;RESULT IN C(AC) NON-ZERO
  6728	033631	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6729						STOP^
  6730	033632	254 04 0 00 033633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6731	033633	324 00 0 00 033634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6732									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6733									;IN THE SUBTEST) TO LOOP ON ERROR^
  6734
  6735					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6736					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6737					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6738					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6739
  6740					;**********
  6741
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-28
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0145

  6742					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6743					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6744					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6745					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6746					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6747			007440		SN=SN+1
  6748		020000	000000			ZZ=ZZ+ZZ
  6749						IFE	ZZ,<ZZ=1>
  6750	033634	200 00 0 00 035132 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6751	033635	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6752									;RESULT IN C(AC) NON-ZERO
  6753	033636	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6754						STOP^
  6755	033637	254 04 0 00 033640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6756	033640	324 00 0 00 033641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6757									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6758									;IN THE SUBTEST) TO LOOP ON ERROR^
  6759
  6760					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6761					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6762					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6763					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6764
  6765					;**********
  6766
  6767					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6768					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6769					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6770					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6771					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6772			007441		SN=SN+1
  6773		040000	000000			ZZ=ZZ+ZZ
  6774						IFE	ZZ,<ZZ=1>
  6775	033641	200 00 0 00 035133 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6776	033642	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6777									;RESULT IN C(AC) NON-ZERO
  6778	033643	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6779						STOP^
  6780	033644	254 04 0 00 033645 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6781	033645	324 00 0 00 033646 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6782									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6783									;IN THE SUBTEST) TO LOOP ON ERROR^
  6784
  6785					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6786					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6787					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6788					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6789
  6790					;**********
  6791
  6792					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6793					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6794					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6795					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6796					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-29
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0146

  6797			007442		SN=SN+1
  6798		100000	000000			ZZ=ZZ+ZZ
  6799						IFE	ZZ,<ZZ=1>
  6800	033646	200 00 0 00 035134 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6801	033647	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6802									;RESULT IN C(AC) NON-ZERO
  6803	033650	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6804						STOP^
  6805	033651	254 04 0 00 033652 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6806	033652	324 00 0 00 033653 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6807									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6808									;IN THE SUBTEST) TO LOOP ON ERROR^
  6809
  6810					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6811					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6812					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6813					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6814
  6815					;**********
  6816
  6817					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6818					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6819					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6820					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6821					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6822			007443		SN=SN+1
  6823		200000	000000			ZZ=ZZ+ZZ
  6824						IFE	ZZ,<ZZ=1>
  6825	033653	200 00 0 00 035135 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6826	033654	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6827									;RESULT IN C(AC) NON-ZERO
  6828	033655	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6829						STOP^
  6830	033656	254 04 0 00 033657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6831	033657	324 00 0 00 033660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6832									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6833									;IN THE SUBTEST) TO LOOP ON ERROR^
  6834
  6835					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6836					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6837					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6838					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6839
  6840					;**********
  6841
  6842					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6843					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6844					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6845					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6846					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6847			007444		SN=SN+1
  6848		400000	000000			ZZ=ZZ+ZZ
  6849						IFE	ZZ,<ZZ=1>
  6850	033660	200 00 0 00 035065 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6851	033661	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 27-30
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0147

  6852									;RESULT IN C(AC) NON-ZERO
  6853	033662	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6854						STOP^
  6855	033663	254 04 0 00 033664 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6856	033664	324 00 0 00 033665 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6857									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6858									;IN THE SUBTEST) TO LOOP ON ERROR^
  6859
  6860					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6861					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6862					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6863					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6864
  6865					;**********
  6866
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0148

  6867			007500		SN=7500
  6868			000000			ZZ=0
  6869
  6870					A7500:	REPEAT ^D36,
  6871					<;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6872					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6873					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6874					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6875					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6876					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6877					;INDICATE AN ILLEGAL CARRY GENERATION.
  6878					SN=SN+1
  6879						ZZ=ZZ+ZZ
  6880						IFE	ZZ,<ZZ=1>
  6881						MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6882						XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6883						SKIPE			;PASS TEST IF C(AC)=0
  6884						STOP
  6885
  6886					;**********
  6887					>
  6888					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6889					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6890					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6891					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6892					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6893					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6894					;INDICATE AN ILLEGAL CARRY GENERATION.
  6895			007501		SN=SN+1
  6896			000000			ZZ=ZZ+ZZ
  6897			000001			IFE	ZZ,<ZZ=1>
  6898	033665	200 00 0 00 035074 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6899	033666	430 00 0 00 035074 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6900	033667	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6901						STOP^
  6902	033670	254 04 0 00 033671 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6903	033671	324 00 0 00 033672 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6904									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6905									;IN THE SUBTEST) TO LOOP ON ERROR^
  6906
  6907					;**********
  6908
  6909					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6910					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6911					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6912					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6913					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6914					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6915					;INDICATE AN ILLEGAL CARRY GENERATION.
  6916			007502		SN=SN+1
  6917			000002			ZZ=ZZ+ZZ
  6918						IFE	ZZ,<ZZ=1>
  6919	033672	200 00 0 00 035075 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6920	033673	430 00 0 00 035075 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6921	033674	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0149

  6922						STOP^
  6923	033675	254 04 0 00 033676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6924	033676	324 00 0 00 033677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6925									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6926									;IN THE SUBTEST) TO LOOP ON ERROR^
  6927
  6928					;**********
  6929
  6930					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6931					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6932					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6933					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6934					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6935					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6936					;INDICATE AN ILLEGAL CARRY GENERATION.
  6937			007503		SN=SN+1
  6938			000004			ZZ=ZZ+ZZ
  6939						IFE	ZZ,<ZZ=1>
  6940	033677	200 00 0 00 035076 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6941	033700	430 00 0 00 035076 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6942	033701	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6943						STOP^
  6944	033702	254 04 0 00 033703 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6945	033703	324 00 0 00 033704 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6946									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6947									;IN THE SUBTEST) TO LOOP ON ERROR^
  6948
  6949					;**********
  6950
  6951					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6952					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6953					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6954					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6955					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6956					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6957					;INDICATE AN ILLEGAL CARRY GENERATION.
  6958			007504		SN=SN+1
  6959			000010			ZZ=ZZ+ZZ
  6960						IFE	ZZ,<ZZ=1>
  6961	033704	200 00 0 00 035077 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6962	033705	430 00 0 00 035077 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6963	033706	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6964						STOP^
  6965	033707	254 04 0 00 033710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6966	033710	324 00 0 00 033711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6967									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6968									;IN THE SUBTEST) TO LOOP ON ERROR^
  6969
  6970					;**********
  6971
  6972					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6973					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6974					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6975					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6976					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-2
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0150

  6977					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6978					;INDICATE AN ILLEGAL CARRY GENERATION.
  6979			007505		SN=SN+1
  6980			000020			ZZ=ZZ+ZZ
  6981						IFE	ZZ,<ZZ=1>
  6982	033711	200 00 0 00 035100 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6983	033712	430 00 0 00 035100 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6984	033713	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6985						STOP^
  6986	033714	254 04 0 00 033715 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6987	033715	324 00 0 00 033716 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6988									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6989									;IN THE SUBTEST) TO LOOP ON ERROR^
  6990
  6991					;**********
  6992
  6993					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6994					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6995					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6996					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6997					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6998					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6999					;INDICATE AN ILLEGAL CARRY GENERATION.
  7000			007506		SN=SN+1
  7001			000040			ZZ=ZZ+ZZ
  7002						IFE	ZZ,<ZZ=1>
  7003	033716	200 00 0 00 035101 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7004	033717	430 00 0 00 035101 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7005	033720	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7006						STOP^
  7007	033721	254 04 0 00 033722 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7008	033722	324 00 0 00 033723 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7009									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7010									;IN THE SUBTEST) TO LOOP ON ERROR^
  7011
  7012					;**********
  7013
  7014					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7015					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7016					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7017					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7018					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7019					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7020					;INDICATE AN ILLEGAL CARRY GENERATION.
  7021			007507		SN=SN+1
  7022			000100			ZZ=ZZ+ZZ
  7023						IFE	ZZ,<ZZ=1>
  7024	033723	200 00 0 00 035102 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7025	033724	430 00 0 00 035102 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7026	033725	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7027						STOP^
  7028	033726	254 04 0 00 033727 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7029	033727	324 00 0 00 033730 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7030									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7031									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-3
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0151

  7032
  7033					;**********
  7034
  7035					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7036					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7037					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7038					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7039					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7040					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7041					;INDICATE AN ILLEGAL CARRY GENERATION.
  7042			007510		SN=SN+1
  7043			000200			ZZ=ZZ+ZZ
  7044						IFE	ZZ,<ZZ=1>
  7045	033730	200 00 0 00 035103 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7046	033731	430 00 0 00 035103 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7047	033732	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7048						STOP^
  7049	033733	254 04 0 00 033734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7050	033734	324 00 0 00 033735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7051									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7052									;IN THE SUBTEST) TO LOOP ON ERROR^
  7053
  7054					;**********
  7055
  7056					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7057					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7058					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7059					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7060					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7061					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7062					;INDICATE AN ILLEGAL CARRY GENERATION.
  7063			007511		SN=SN+1
  7064			000400			ZZ=ZZ+ZZ
  7065						IFE	ZZ,<ZZ=1>
  7066	033735	200 00 0 00 035104 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7067	033736	430 00 0 00 035104 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7068	033737	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7069						STOP^
  7070	033740	254 04 0 00 033741 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7071	033741	324 00 0 00 033742 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7072									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7073									;IN THE SUBTEST) TO LOOP ON ERROR^
  7074
  7075					;**********
  7076
  7077					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7078					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7079					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7080					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7081					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7082					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7083					;INDICATE AN ILLEGAL CARRY GENERATION.
  7084			007512		SN=SN+1
  7085			001000			ZZ=ZZ+ZZ
  7086						IFE	ZZ,<ZZ=1>
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-4
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0152

  7087	033742	200 00 0 00 035105 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7088	033743	430 00 0 00 035105 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7089	033744	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7090						STOP^
  7091	033745	254 04 0 00 033746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7092	033746	324 00 0 00 033747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7093									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7094									;IN THE SUBTEST) TO LOOP ON ERROR^
  7095
  7096					;**********
  7097
  7098					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7099					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7100					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7101					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7102					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7103					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7104					;INDICATE AN ILLEGAL CARRY GENERATION.
  7105			007513		SN=SN+1
  7106			002000			ZZ=ZZ+ZZ
  7107						IFE	ZZ,<ZZ=1>
  7108	033747	200 00 0 00 035106 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7109	033750	430 00 0 00 035106 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7110	033751	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7111						STOP^
  7112	033752	254 04 0 00 033753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7113	033753	324 00 0 00 033754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7114									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7115									;IN THE SUBTEST) TO LOOP ON ERROR^
  7116
  7117					;**********
  7118
  7119					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7120					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7121					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7122					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7123					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7124					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7125					;INDICATE AN ILLEGAL CARRY GENERATION.
  7126			007514		SN=SN+1
  7127			004000			ZZ=ZZ+ZZ
  7128						IFE	ZZ,<ZZ=1>
  7129	033754	200 00 0 00 035107 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7130	033755	430 00 0 00 035107 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7131	033756	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7132						STOP^
  7133	033757	254 04 0 00 033760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7134	033760	324 00 0 00 033761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7135									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7136									;IN THE SUBTEST) TO LOOP ON ERROR^
  7137
  7138					;**********
  7139
  7140					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7141					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-5
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0153

  7142					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7143					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7144					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7145					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7146					;INDICATE AN ILLEGAL CARRY GENERATION.
  7147			007515		SN=SN+1
  7148			010000			ZZ=ZZ+ZZ
  7149						IFE	ZZ,<ZZ=1>
  7150	033761	200 00 0 00 035110 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7151	033762	430 00 0 00 035110 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7152	033763	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7153						STOP^
  7154	033764	254 04 0 00 033765 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7155	033765	324 00 0 00 033766 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7156									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7157									;IN THE SUBTEST) TO LOOP ON ERROR^
  7158
  7159					;**********
  7160
  7161					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7162					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7163					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7164					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7165					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7166					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7167					;INDICATE AN ILLEGAL CARRY GENERATION.
  7168			007516		SN=SN+1
  7169			020000			ZZ=ZZ+ZZ
  7170						IFE	ZZ,<ZZ=1>
  7171	033766	200 00 0 00 035111 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7172	033767	430 00 0 00 035111 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7173	033770	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7174						STOP^
  7175	033771	254 04 0 00 033772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7176	033772	324 00 0 00 033773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7177									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7178									;IN THE SUBTEST) TO LOOP ON ERROR^
  7179
  7180					;**********
  7181
  7182					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7183					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7184					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7185					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7186					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7187					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7188					;INDICATE AN ILLEGAL CARRY GENERATION.
  7189			007517		SN=SN+1
  7190			040000			ZZ=ZZ+ZZ
  7191						IFE	ZZ,<ZZ=1>
  7192	033773	200 00 0 00 035112 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7193	033774	430 00 0 00 035112 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7194	033775	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7195						STOP^
  7196	033776	254 04 0 00 033777 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-6
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0154

  7197	033777	324 00 0 00 034000 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7198									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7199									;IN THE SUBTEST) TO LOOP ON ERROR^
  7200
  7201					;**********
  7202
  7203					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7204					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7205					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7206					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7207					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7208					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7209					;INDICATE AN ILLEGAL CARRY GENERATION.
  7210			007520		SN=SN+1
  7211			100000			ZZ=ZZ+ZZ
  7212						IFE	ZZ,<ZZ=1>
  7213	034000	200 00 0 00 035113 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7214	034001	430 00 0 00 035113 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7215	034002	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7216						STOP^
  7217	034003	254 04 0 00 034004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7218	034004	324 00 0 00 034005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7219									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7220									;IN THE SUBTEST) TO LOOP ON ERROR^
  7221
  7222					;**********
  7223
  7224					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7225					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7226					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7227					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7228					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7229					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7230					;INDICATE AN ILLEGAL CARRY GENERATION.
  7231			007521		SN=SN+1
  7232			200000			ZZ=ZZ+ZZ
  7233						IFE	ZZ,<ZZ=1>
  7234	034005	200 00 0 00 035114 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7235	034006	430 00 0 00 035114 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7236	034007	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7237						STOP^
  7238	034010	254 04 0 00 034011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7239	034011	324 00 0 00 034012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7240									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7241									;IN THE SUBTEST) TO LOOP ON ERROR^
  7242
  7243					;**********
  7244
  7245					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7246					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7247					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7248					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7249					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7250					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7251					;INDICATE AN ILLEGAL CARRY GENERATION.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-7
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0155

  7252			007522		SN=SN+1
  7253			400000			ZZ=ZZ+ZZ
  7254						IFE	ZZ,<ZZ=1>
  7255	034012	200 00 0 00 035115 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7256	034013	430 00 0 00 035115 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7257	034014	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7258						STOP^
  7259	034015	254 04 0 00 034016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7260	034016	324 00 0 00 034017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7261									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7262									;IN THE SUBTEST) TO LOOP ON ERROR^
  7263
  7264					;**********
  7265
  7266					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7267					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7268					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7269					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7270					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7271					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7272					;INDICATE AN ILLEGAL CARRY GENERATION.
  7273			007523		SN=SN+1
  7274		000001	000000			ZZ=ZZ+ZZ
  7275						IFE	ZZ,<ZZ=1>
  7276	034017	200 00 0 00 035116 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7277	034020	430 00 0 00 035116 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7278	034021	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7279						STOP^
  7280	034022	254 04 0 00 034023 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7281	034023	324 00 0 00 034024 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7282									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7283									;IN THE SUBTEST) TO LOOP ON ERROR^
  7284
  7285					;**********
  7286
  7287					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7288					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7289					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7290					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7291					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7292					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7293					;INDICATE AN ILLEGAL CARRY GENERATION.
  7294			007524		SN=SN+1
  7295		000002	000000			ZZ=ZZ+ZZ
  7296						IFE	ZZ,<ZZ=1>
  7297	034024	200 00 0 00 035117 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7298	034025	430 00 0 00 035117 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7299	034026	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7300						STOP^
  7301	034027	254 04 0 00 034030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7302	034030	324 00 0 00 034031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7303									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7304									;IN THE SUBTEST) TO LOOP ON ERROR^
  7305
  7306					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-8
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0156

  7307
  7308					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7309					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7310					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7311					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7312					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7313					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7314					;INDICATE AN ILLEGAL CARRY GENERATION.
  7315			007525		SN=SN+1
  7316		000004	000000			ZZ=ZZ+ZZ
  7317						IFE	ZZ,<ZZ=1>
  7318	034031	200 00 0 00 035120 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7319	034032	430 00 0 00 035120 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7320	034033	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7321						STOP^
  7322	034034	254 04 0 00 034035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7323	034035	324 00 0 00 034036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7324									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7325									;IN THE SUBTEST) TO LOOP ON ERROR^
  7326
  7327					;**********
  7328
  7329					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7330					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7331					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7332					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7333					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7334					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7335					;INDICATE AN ILLEGAL CARRY GENERATION.
  7336			007526		SN=SN+1
  7337		000010	000000			ZZ=ZZ+ZZ
  7338						IFE	ZZ,<ZZ=1>
  7339	034036	200 00 0 00 035121 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7340	034037	430 00 0 00 035121 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7341	034040	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7342						STOP^
  7343	034041	254 04 0 00 034042 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7344	034042	324 00 0 00 034043 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7345									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7346									;IN THE SUBTEST) TO LOOP ON ERROR^
  7347
  7348					;**********
  7349
  7350					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7351					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7352					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7353					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7354					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7355					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7356					;INDICATE AN ILLEGAL CARRY GENERATION.
  7357			007527		SN=SN+1
  7358		000020	000000			ZZ=ZZ+ZZ
  7359						IFE	ZZ,<ZZ=1>
  7360	034043	200 00 0 00 035122 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7361	034044	430 00 0 00 035122 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-9
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0157

  7362	034045	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7363						STOP^
  7364	034046	254 04 0 00 034047 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7365	034047	324 00 0 00 034050 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7366									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7367									;IN THE SUBTEST) TO LOOP ON ERROR^
  7368
  7369					;**********
  7370
  7371					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7372					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7373					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7374					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7375					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7376					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7377					;INDICATE AN ILLEGAL CARRY GENERATION.
  7378			007530		SN=SN+1
  7379		000040	000000			ZZ=ZZ+ZZ
  7380						IFE	ZZ,<ZZ=1>
  7381	034050	200 00 0 00 035123 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7382	034051	430 00 0 00 035123 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7383	034052	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7384						STOP^
  7385	034053	254 04 0 00 034054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7386	034054	324 00 0 00 034055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7387									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7388									;IN THE SUBTEST) TO LOOP ON ERROR^
  7389
  7390					;**********
  7391
  7392					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7393					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7394					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7395					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7396					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7397					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7398					;INDICATE AN ILLEGAL CARRY GENERATION.
  7399			007531		SN=SN+1
  7400		000100	000000			ZZ=ZZ+ZZ
  7401						IFE	ZZ,<ZZ=1>
  7402	034055	200 00 0 00 035124 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7403	034056	430 00 0 00 035124 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7404	034057	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7405						STOP^
  7406	034060	254 04 0 00 034061 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7407	034061	324 00 0 00 034062 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7408									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7409									;IN THE SUBTEST) TO LOOP ON ERROR^
  7410
  7411					;**********
  7412
  7413					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7414					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7415					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7416					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-10
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0158

  7417					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7418					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7419					;INDICATE AN ILLEGAL CARRY GENERATION.
  7420			007532		SN=SN+1
  7421		000200	000000			ZZ=ZZ+ZZ
  7422						IFE	ZZ,<ZZ=1>
  7423	034062	200 00 0 00 035125 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7424	034063	430 00 0 00 035125 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7425	034064	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7426						STOP^
  7427	034065	254 04 0 00 034066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7428	034066	324 00 0 00 034067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7429									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7430									;IN THE SUBTEST) TO LOOP ON ERROR^
  7431
  7432					;**********
  7433
  7434					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7435					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7436					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7437					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7438					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7439					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7440					;INDICATE AN ILLEGAL CARRY GENERATION.
  7441			007533		SN=SN+1
  7442		000400	000000			ZZ=ZZ+ZZ
  7443						IFE	ZZ,<ZZ=1>
  7444	034067	200 00 0 00 035073 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7445	034070	430 00 0 00 035073 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7446	034071	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7447						STOP^
  7448	034072	254 04 0 00 034073 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7449	034073	324 00 0 00 034074 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7450									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7451									;IN THE SUBTEST) TO LOOP ON ERROR^
  7452
  7453					;**********
  7454
  7455					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7456					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7457					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7458					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7459					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7460					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7461					;INDICATE AN ILLEGAL CARRY GENERATION.
  7462			007534		SN=SN+1
  7463		001000	000000			ZZ=ZZ+ZZ
  7464						IFE	ZZ,<ZZ=1>
  7465	034074	200 00 0 00 035126 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7466	034075	430 00 0 00 035126 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7467	034076	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7468						STOP^
  7469	034077	254 04 0 00 034100 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7470	034100	324 00 0 00 034101 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-11
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0159

  7472									;IN THE SUBTEST) TO LOOP ON ERROR^
  7473
  7474					;**********
  7475
  7476					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7477					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7478					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7479					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7480					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7481					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7482					;INDICATE AN ILLEGAL CARRY GENERATION.
  7483			007535		SN=SN+1
  7484		002000	000000			ZZ=ZZ+ZZ
  7485						IFE	ZZ,<ZZ=1>
  7486	034101	200 00 0 00 035127 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7487	034102	430 00 0 00 035127 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7488	034103	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7489						STOP^
  7490	034104	254 04 0 00 034105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7491	034105	324 00 0 00 034106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7492									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7493									;IN THE SUBTEST) TO LOOP ON ERROR^
  7494
  7495					;**********
  7496
  7497					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7498					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7499					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7500					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7501					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7502					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7503					;INDICATE AN ILLEGAL CARRY GENERATION.
  7504			007536		SN=SN+1
  7505		004000	000000			ZZ=ZZ+ZZ
  7506						IFE	ZZ,<ZZ=1>
  7507	034106	200 00 0 00 035130 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7508	034107	430 00 0 00 035130 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7509	034110	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7510						STOP^
  7511	034111	254 04 0 00 034112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7512	034112	324 00 0 00 034113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7513									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7514									;IN THE SUBTEST) TO LOOP ON ERROR^
  7515
  7516					;**********
  7517
  7518					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7519					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7520					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7521					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7522					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7523					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7524					;INDICATE AN ILLEGAL CARRY GENERATION.
  7525			007537		SN=SN+1
  7526		010000	000000			ZZ=ZZ+ZZ
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-12
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0160

  7527						IFE	ZZ,<ZZ=1>
  7528	034113	200 00 0 00 035131 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7529	034114	430 00 0 00 035131 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7530	034115	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7531						STOP^
  7532	034116	254 04 0 00 034117 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7533	034117	324 00 0 00 034120 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7534									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7535									;IN THE SUBTEST) TO LOOP ON ERROR^
  7536
  7537					;**********
  7538
  7539					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7540					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7541					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7542					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7543					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7544					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7545					;INDICATE AN ILLEGAL CARRY GENERATION.
  7546			007540		SN=SN+1
  7547		020000	000000			ZZ=ZZ+ZZ
  7548						IFE	ZZ,<ZZ=1>
  7549	034120	200 00 0 00 035132 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7550	034121	430 00 0 00 035132 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7551	034122	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7552						STOP^
  7553	034123	254 04 0 00 034124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7554	034124	324 00 0 00 034125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7555									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7556									;IN THE SUBTEST) TO LOOP ON ERROR^
  7557
  7558					;**********
  7559
  7560					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7561					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7562					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7563					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7564					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7565					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7566					;INDICATE AN ILLEGAL CARRY GENERATION.
  7567			007541		SN=SN+1
  7568		040000	000000			ZZ=ZZ+ZZ
  7569						IFE	ZZ,<ZZ=1>
  7570	034125	200 00 0 00 035133 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7571	034126	430 00 0 00 035133 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7572	034127	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7573						STOP^
  7574	034130	254 04 0 00 034131 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7575	034131	324 00 0 00 034132 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7576									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7577									;IN THE SUBTEST) TO LOOP ON ERROR^
  7578
  7579					;**********
  7580
  7581					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-13
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0161

  7582					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7583					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7584					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7585					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7586					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7587					;INDICATE AN ILLEGAL CARRY GENERATION.
  7588			007542		SN=SN+1
  7589		100000	000000			ZZ=ZZ+ZZ
  7590						IFE	ZZ,<ZZ=1>
  7591	034132	200 00 0 00 035134 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7592	034133	430 00 0 00 035134 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7593	034134	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7594						STOP^
  7595	034135	254 04 0 00 034136 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7596	034136	324 00 0 00 034137 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7598									;IN THE SUBTEST) TO LOOP ON ERROR^
  7599
  7600					;**********
  7601
  7602					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7603					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7604					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7605					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7606					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7607					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7608					;INDICATE AN ILLEGAL CARRY GENERATION.
  7609			007543		SN=SN+1
  7610		200000	000000			ZZ=ZZ+ZZ
  7611						IFE	ZZ,<ZZ=1>
  7612	034137	200 00 0 00 035135 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7613	034140	430 00 0 00 035135 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7614	034141	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7615						STOP^
  7616	034142	254 04 0 00 034143 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7617	034143	324 00 0 00 034144 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7618									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7619									;IN THE SUBTEST) TO LOOP ON ERROR^
  7620
  7621					;**********
  7622
  7623					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7624					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7625					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7626					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7627					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7628					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7629					;INDICATE AN ILLEGAL CARRY GENERATION.
  7630			007544		SN=SN+1
  7631		400000	000000			ZZ=ZZ+ZZ
  7632						IFE	ZZ,<ZZ=1>
  7633	034144	200 00 0 00 035065 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7634	034145	430 00 0 00 035065 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7635	034146	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7636						STOP^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 28-14
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0162

  7637	034147	254 04 0 00 034150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7638	034150	324 00 0 00 034151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7639									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7640									;IN THE SUBTEST) TO LOOP ON ERROR^
  7641
  7642					;**********
  7643
  7644					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION WHERE
  7645					;C(AC)=C(E)=0 IS AN AC CONTAINING ALL ZEROS; FIRST THE AC IS CLEARED; THEN
  7646					;XOR IS EXECUTED WITH C(E)=0.  THE RESULT IN THE AC IS CHECKED FOR ALL ZEROS
  7647
  7648	034151	200 00 0 00 035062 	A7600:	MOVE	[0]		;INITIALIZE AC TO ALL ZEROS
  7649	034152	430 00 0 00 035062 		XOR	[0]		;*XOR WITH C(AC)=C(E)=0 SHOULD RESULT INC(AC)=0
  7650	034153	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7651						STOP^
  7652	034154	254 04 0 00 034155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7653	034155	324 00 0 00 034156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7654									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7655									;IN THE SUBTEST) TO LOOP ON ERROR^
  7656
  7657					;**********
  7658
  7659					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7660					;C(AC)=0 AND C(E) ALL ONES IS AN AC CONTAINING ALL ZEROS SINCE
  7661					;THE EQUIVALENCE FUNCTION SHOULD SET ONLY LIKE BITS.  FIRST, THE AC
  7662					;SHOULD BE CLEARED; THEN, EQV IS EXECUTED WITH E CONTAINING ALL ONES.
  7663					;THE AC IS THEN CHECKED FOR ALL ZEROS
  7664
  7665	034156	200 00 0 00 035062 	A7700:	MOVE	[0]		;CLEAR THE AC
  7666	034157	444 00 0 00 035063 		EQV	[-1]		;*EQV WITH C(AC)=0 AND C(E) ALL ONES SHOULD
  7667									;RESULT IN C(AC)=0
  7668	034160	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7669						STOP^
  7670	034161	254 04 0 00 034162 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7671	034162	324 00 0 00 034163 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7672									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7673									;IN THE SUBTEST) TO LOOP ON ERROR^
  7674
  7675					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0163

  7676			010000		SN=10000
  7677			000000			ZZ=0
  7678
  7679					A10000:	REPEAT	^D18,
  7680					<;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7681					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7682					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7683					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7684					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7685					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7686					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7687					SN=SN+1
  7688						ZZ=ZZ+ZZ+1
  7689						IFE	<ZZ-1>,<ZZ=-2>
  7690						MOVE	[0]		;PRESET AC TO ALL ZEROS
  7691						EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7692									;RESULT IN C(AC) NON-ZERO
  7693						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7694						STOP
  7695
  7696					;**********
  7697					>
  7698					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7699					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7700					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7701					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7702					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7703					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7704					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7705			010001		SN=SN+1
  7706			000001			ZZ=ZZ+ZZ+1
  7707		777777	777776			IFE	<ZZ-1>,<ZZ=-2>
  7708	034163	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7709	034164	444 00 0 00 035142 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7710									;RESULT IN C(AC) NON-ZERO
  7711	034165	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7712						STOP^
  7713	034166	254 04 0 00 034167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7714	034167	324 00 0 00 034170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7715									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7716									;IN THE SUBTEST) TO LOOP ON ERROR^
  7717
  7718					;**********
  7719
  7720					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7721					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7722					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7723					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7724					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7725					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7726					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7727			010002		SN=SN+1
  7728		777777	777775			ZZ=ZZ+ZZ+1
  7729						IFE	<ZZ-1>,<ZZ=-2>
  7730	034170	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0164

  7731	034171	444 00 0 00 035143 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7732									;RESULT IN C(AC) NON-ZERO
  7733	034172	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7734						STOP^
  7735	034173	254 04 0 00 034174 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7736	034174	324 00 0 00 034175 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7737									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7738									;IN THE SUBTEST) TO LOOP ON ERROR^
  7739
  7740					;**********
  7741
  7742					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7743					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7744					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7745					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7746					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7747					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7748					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7749			010003		SN=SN+1
  7750		777777	777773			ZZ=ZZ+ZZ+1
  7751						IFE	<ZZ-1>,<ZZ=-2>
  7752	034175	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7753	034176	444 00 0 00 035144 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7754									;RESULT IN C(AC) NON-ZERO
  7755	034177	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7756						STOP^
  7757	034200	254 04 0 00 034201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7758	034201	324 00 0 00 034202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7759									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7760									;IN THE SUBTEST) TO LOOP ON ERROR^
  7761
  7762					;**********
  7763
  7764					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7765					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7766					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7767					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7768					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7769					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7770					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7771			010004		SN=SN+1
  7772		777777	777767			ZZ=ZZ+ZZ+1
  7773						IFE	<ZZ-1>,<ZZ=-2>
  7774	034202	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7775	034203	444 00 0 00 035145 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7776									;RESULT IN C(AC) NON-ZERO
  7777	034204	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7778						STOP^
  7779	034205	254 04 0 00 034206 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7780	034206	324 00 0 00 034207 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7781									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7782									;IN THE SUBTEST) TO LOOP ON ERROR^
  7783
  7784					;**********
  7785
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-2
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0165

  7786					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7787					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7788					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7789					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7790					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7791					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7792					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7793			010005		SN=SN+1
  7794		777777	777757			ZZ=ZZ+ZZ+1
  7795						IFE	<ZZ-1>,<ZZ=-2>
  7796	034207	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7797	034210	444 00 0 00 035146 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7798									;RESULT IN C(AC) NON-ZERO
  7799	034211	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7800						STOP^
  7801	034212	254 04 0 00 034213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7802	034213	324 00 0 00 034214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7803									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7804									;IN THE SUBTEST) TO LOOP ON ERROR^
  7805
  7806					;**********
  7807
  7808					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7809					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7810					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7811					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7812					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7813					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7814					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7815			010006		SN=SN+1
  7816		777777	777737			ZZ=ZZ+ZZ+1
  7817						IFE	<ZZ-1>,<ZZ=-2>
  7818	034214	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7819	034215	444 00 0 00 035147 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7820									;RESULT IN C(AC) NON-ZERO
  7821	034216	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7822						STOP^
  7823	034217	254 04 0 00 034220 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7824	034220	324 00 0 00 034221 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7825									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7826									;IN THE SUBTEST) TO LOOP ON ERROR^
  7827
  7828					;**********
  7829
  7830					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7831					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7832					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7833					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7834					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7835					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7836					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7837			010007		SN=SN+1
  7838		777777	777677			ZZ=ZZ+ZZ+1
  7839						IFE	<ZZ-1>,<ZZ=-2>
  7840	034221	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-3
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0166

  7841	034222	444 00 0 00 035150 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7842									;RESULT IN C(AC) NON-ZERO
  7843	034223	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7844						STOP^
  7845	034224	254 04 0 00 034225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7846	034225	324 00 0 00 034226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7847									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7848									;IN THE SUBTEST) TO LOOP ON ERROR^
  7849
  7850					;**********
  7851
  7852					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7853					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7854					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7855					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7856					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7857					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7858					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7859			010010		SN=SN+1
  7860		777777	777577			ZZ=ZZ+ZZ+1
  7861						IFE	<ZZ-1>,<ZZ=-2>
  7862	034226	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7863	034227	444 00 0 00 035151 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7864									;RESULT IN C(AC) NON-ZERO
  7865	034230	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7866						STOP^
  7867	034231	254 04 0 00 034232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7868	034232	324 00 0 00 034233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7869									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7870									;IN THE SUBTEST) TO LOOP ON ERROR^
  7871
  7872					;**********
  7873
  7874					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7875					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7876					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7877					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7878					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7879					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7880					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7881			010011		SN=SN+1
  7882		777777	777377			ZZ=ZZ+ZZ+1
  7883						IFE	<ZZ-1>,<ZZ=-2>
  7884	034233	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7885	034234	444 00 0 00 035152 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7886									;RESULT IN C(AC) NON-ZERO
  7887	034235	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7888						STOP^
  7889	034236	254 04 0 00 034237 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7890	034237	324 00 0 00 034240 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7891									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7892									;IN THE SUBTEST) TO LOOP ON ERROR^
  7893
  7894					;**********
  7895
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-4
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0167

  7896					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7897					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7898					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7899					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7900					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7901					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7902					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7903			010012		SN=SN+1
  7904		777777	776777			ZZ=ZZ+ZZ+1
  7905						IFE	<ZZ-1>,<ZZ=-2>
  7906	034240	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7907	034241	444 00 0 00 035153 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7908									;RESULT IN C(AC) NON-ZERO
  7909	034242	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7910						STOP^
  7911	034243	254 04 0 00 034244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7912	034244	324 00 0 00 034245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7913									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7914									;IN THE SUBTEST) TO LOOP ON ERROR^
  7915
  7916					;**********
  7917
  7918					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7919					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7920					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7921					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7922					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7923					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7924					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7925			010013		SN=SN+1
  7926		777777	775777			ZZ=ZZ+ZZ+1
  7927						IFE	<ZZ-1>,<ZZ=-2>
  7928	034245	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7929	034246	444 00 0 00 035154 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7930									;RESULT IN C(AC) NON-ZERO
  7931	034247	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7932						STOP^
  7933	034250	254 04 0 00 034251 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7934	034251	324 00 0 00 034252 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7935									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7936									;IN THE SUBTEST) TO LOOP ON ERROR^
  7937
  7938					;**********
  7939
  7940					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7941					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7942					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7943					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7944					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7945					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7946					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7947			010014		SN=SN+1
  7948		777777	773777			ZZ=ZZ+ZZ+1
  7949						IFE	<ZZ-1>,<ZZ=-2>
  7950	034252	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-5
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0168

  7951	034253	444 00 0 00 035155 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7952									;RESULT IN C(AC) NON-ZERO
  7953	034254	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7954						STOP^
  7955	034255	254 04 0 00 034256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7956	034256	324 00 0 00 034257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7957									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7958									;IN THE SUBTEST) TO LOOP ON ERROR^
  7959
  7960					;**********
  7961
  7962					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7963					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7964					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7965					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7966					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7967					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7968					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7969			010015		SN=SN+1
  7970		777777	767777			ZZ=ZZ+ZZ+1
  7971						IFE	<ZZ-1>,<ZZ=-2>
  7972	034257	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7973	034260	444 00 0 00 035156 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7974									;RESULT IN C(AC) NON-ZERO
  7975	034261	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7976						STOP^
  7977	034262	254 04 0 00 034263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7978	034263	324 00 0 00 034264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7979									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7980									;IN THE SUBTEST) TO LOOP ON ERROR^
  7981
  7982					;**********
  7983
  7984					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7985					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7986					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7987					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7988					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7989					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  7990					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7991			010016		SN=SN+1
  7992		777777	757777			ZZ=ZZ+ZZ+1
  7993						IFE	<ZZ-1>,<ZZ=-2>
  7994	034264	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7995	034265	444 00 0 00 035157 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7996									;RESULT IN C(AC) NON-ZERO
  7997	034266	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7998						STOP^
  7999	034267	254 04 0 00 034270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8000	034270	324 00 0 00 034271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8001									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8002									;IN THE SUBTEST) TO LOOP ON ERROR^
  8003
  8004					;**********
  8005
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-6
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0169

  8006					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8007					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8008					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8009					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8010					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8011					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8012					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8013			010017		SN=SN+1
  8014		777777	737777			ZZ=ZZ+ZZ+1
  8015						IFE	<ZZ-1>,<ZZ=-2>
  8016	034271	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8017	034272	444 00 0 00 035160 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8018									;RESULT IN C(AC) NON-ZERO
  8019	034273	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8020						STOP^
  8021	034274	254 04 0 00 034275 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8022	034275	324 00 0 00 034276 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8023									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8024									;IN THE SUBTEST) TO LOOP ON ERROR^
  8025
  8026					;**********
  8027
  8028					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8029					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8030					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8031					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8032					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8033					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8034					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8035			010020		SN=SN+1
  8036		777777	677777			ZZ=ZZ+ZZ+1
  8037						IFE	<ZZ-1>,<ZZ=-2>
  8038	034276	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8039	034277	444 00 0 00 035161 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8040									;RESULT IN C(AC) NON-ZERO
  8041	034300	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8042						STOP^
  8043	034301	254 04 0 00 034302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8044	034302	324 00 0 00 034303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8045									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8046									;IN THE SUBTEST) TO LOOP ON ERROR^
  8047
  8048					;**********
  8049
  8050					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8051					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8052					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8053					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8054					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8055					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8056					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8057			010021		SN=SN+1
  8058		777777	577777			ZZ=ZZ+ZZ+1
  8059						IFE	<ZZ-1>,<ZZ=-2>
  8060	034303	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-7
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0170

  8061	034304	444 00 0 00 035162 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8062									;RESULT IN C(AC) NON-ZERO
  8063	034305	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8064						STOP^
  8065	034306	254 04 0 00 034307 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8066	034307	324 00 0 00 034310 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8067									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8068									;IN THE SUBTEST) TO LOOP ON ERROR^
  8069
  8070					;**********
  8071
  8072					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8073					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8074					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8075					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8076					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8077					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8078					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8079			010022		SN=SN+1
  8080		777777	377777			ZZ=ZZ+ZZ+1
  8081						IFE	<ZZ-1>,<ZZ=-2>
  8082	034310	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8083	034311	444 00 0 00 035163 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8084									;RESULT IN C(AC) NON-ZERO
  8085	034312	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8086						STOP^
  8087	034313	254 04 0 00 034314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8088	034314	324 00 0 00 034315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8089									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8090									;IN THE SUBTEST) TO LOOP ON ERROR^
  8091
  8092					;**********
  8093
  8094			010100		SN=10100
  8095			000000			ZZ=0
  8096
  8097					A10100:	REPEAT	^D18,
  8098					<;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8099					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8100					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8101					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8102					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8103					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8104					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8105					SN=SN+1
  8106						ZZ=ZZ+ZZ+1
  8107						IFE	<ZZ-1>,<ZZ=-2>
  8108						MOVE	[0]		;PRESET AC TO ALL ZEROS
  8109						EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8110									;RESULT IN C(AC) NON-ZERO
  8111						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8112						STOP
  8113
  8114					;**********
  8115					>
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-8
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0171

  8116					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8117					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8118					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8119					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8120					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8121					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8122					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8123			010101		SN=SN+1
  8124			000001			ZZ=ZZ+ZZ+1
  8125		777777	777776			IFE	<ZZ-1>,<ZZ=-2>
  8126	034315	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8127	034316	444 00 0 00 035164 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8128									;RESULT IN C(AC) NON-ZERO
  8129	034317	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8130						STOP^
  8131	034320	254 04 0 00 034321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8132	034321	324 00 0 00 034322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8133									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8134									;IN THE SUBTEST) TO LOOP ON ERROR^
  8135
  8136					;**********
  8137
  8138					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8139					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8140					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8141					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8142					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8143					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8144					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8145			010102		SN=SN+1
  8146		777777	777775			ZZ=ZZ+ZZ+1
  8147						IFE	<ZZ-1>,<ZZ=-2>
  8148	034322	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8149	034323	444 00 0 00 035165 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8150									;RESULT IN C(AC) NON-ZERO
  8151	034324	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8152						STOP^
  8153	034325	254 04 0 00 034326 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8154	034326	324 00 0 00 034327 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8155									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8156									;IN THE SUBTEST) TO LOOP ON ERROR^
  8157
  8158					;**********
  8159
  8160					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8161					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8162					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8163					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8164					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8165					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8166					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8167			010103		SN=SN+1
  8168		777777	777773			ZZ=ZZ+ZZ+1
  8169						IFE	<ZZ-1>,<ZZ=-2>
  8170	034327	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-9
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0172

  8171	034330	444 00 0 00 035166 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8172									;RESULT IN C(AC) NON-ZERO
  8173	034331	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8174						STOP^
  8175	034332	254 04 0 00 034333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8176	034333	324 00 0 00 034334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8177									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8178									;IN THE SUBTEST) TO LOOP ON ERROR^
  8179
  8180					;**********
  8181
  8182					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8183					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8184					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8185					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8186					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8187					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8188					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8189			010104		SN=SN+1
  8190		777777	777767			ZZ=ZZ+ZZ+1
  8191						IFE	<ZZ-1>,<ZZ=-2>
  8192	034334	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8193	034335	444 00 0 00 035167 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8194									;RESULT IN C(AC) NON-ZERO
  8195	034336	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8196						STOP^
  8197	034337	254 04 0 00 034340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8198	034340	324 00 0 00 034341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8199									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8200									;IN THE SUBTEST) TO LOOP ON ERROR^
  8201
  8202					;**********
  8203
  8204					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8205					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8206					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8207					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8208					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8209					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8210					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8211			010105		SN=SN+1
  8212		777777	777757			ZZ=ZZ+ZZ+1
  8213						IFE	<ZZ-1>,<ZZ=-2>
  8214	034341	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8215	034342	444 00 0 00 035170 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8216									;RESULT IN C(AC) NON-ZERO
  8217	034343	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8218						STOP^
  8219	034344	254 04 0 00 034345 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8220	034345	324 00 0 00 034346 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8221									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8222									;IN THE SUBTEST) TO LOOP ON ERROR^
  8223
  8224					;**********
  8225
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-10
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0173

  8226					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8227					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8228					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8229					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8230					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8231					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8232					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8233			010106		SN=SN+1
  8234		777777	777737			ZZ=ZZ+ZZ+1
  8235						IFE	<ZZ-1>,<ZZ=-2>
  8236	034346	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8237	034347	444 00 0 00 035171 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8238									;RESULT IN C(AC) NON-ZERO
  8239	034350	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8240						STOP^
  8241	034351	254 04 0 00 034352 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8242	034352	324 00 0 00 034353 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8243									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8244									;IN THE SUBTEST) TO LOOP ON ERROR^
  8245
  8246					;**********
  8247
  8248					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8249					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8250					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8251					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8252					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8253					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8254					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8255			010107		SN=SN+1
  8256		777777	777677			ZZ=ZZ+ZZ+1
  8257						IFE	<ZZ-1>,<ZZ=-2>
  8258	034353	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8259	034354	444 00 0 00 035172 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8260									;RESULT IN C(AC) NON-ZERO
  8261	034355	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8262						STOP^
  8263	034356	254 04 0 00 034357 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8264	034357	324 00 0 00 034360 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8265									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8266									;IN THE SUBTEST) TO LOOP ON ERROR^
  8267
  8268					;**********
  8269
  8270					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8271					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8272					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8273					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8274					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8275					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8276					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8277			010110		SN=SN+1
  8278		777777	777577			ZZ=ZZ+ZZ+1
  8279						IFE	<ZZ-1>,<ZZ=-2>
  8280	034360	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-11
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0174

  8281	034361	444 00 0 00 035173 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8282									;RESULT IN C(AC) NON-ZERO
  8283	034362	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8284						STOP^
  8285	034363	254 04 0 00 034364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8286	034364	324 00 0 00 034365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8287									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8288									;IN THE SUBTEST) TO LOOP ON ERROR^
  8289
  8290					;**********
  8291
  8292					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8293					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8294					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8295					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8296					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8297					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8298					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8299			010111		SN=SN+1
  8300		777777	777377			ZZ=ZZ+ZZ+1
  8301						IFE	<ZZ-1>,<ZZ=-2>
  8302	034365	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8303	034366	444 00 0 00 035174 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8304									;RESULT IN C(AC) NON-ZERO
  8305	034367	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8306						STOP^
  8307	034370	254 04 0 00 034371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8308	034371	324 00 0 00 034372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8309									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8310									;IN THE SUBTEST) TO LOOP ON ERROR^
  8311
  8312					;**********
  8313
  8314					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8315					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8316					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8317					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8318					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8319					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8320					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8321			010112		SN=SN+1
  8322		777777	776777			ZZ=ZZ+ZZ+1
  8323						IFE	<ZZ-1>,<ZZ=-2>
  8324	034372	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8325	034373	444 00 0 00 035175 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8326									;RESULT IN C(AC) NON-ZERO
  8327	034374	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8328						STOP^
  8329	034375	254 04 0 00 034376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8330	034376	324 00 0 00 034377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8331									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8332									;IN THE SUBTEST) TO LOOP ON ERROR^
  8333
  8334					;**********
  8335
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-12
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0175

  8336					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8337					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8338					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8339					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8340					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8341					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8342					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8343			010113		SN=SN+1
  8344		777777	775777			ZZ=ZZ+ZZ+1
  8345						IFE	<ZZ-1>,<ZZ=-2>
  8346	034377	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8347	034400	444 00 0 00 035176 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8348									;RESULT IN C(AC) NON-ZERO
  8349	034401	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8350						STOP^
  8351	034402	254 04 0 00 034403 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8352	034403	324 00 0 00 034404 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8353									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8354									;IN THE SUBTEST) TO LOOP ON ERROR^
  8355
  8356					;**********
  8357
  8358					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8359					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8360					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8361					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8362					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8363					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8364					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8365			010114		SN=SN+1
  8366		777777	773777			ZZ=ZZ+ZZ+1
  8367						IFE	<ZZ-1>,<ZZ=-2>
  8368	034404	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8369	034405	444 00 0 00 035177 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8370									;RESULT IN C(AC) NON-ZERO
  8371	034406	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8372						STOP^
  8373	034407	254 04 0 00 034410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8374	034410	324 00 0 00 034411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8375									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8376									;IN THE SUBTEST) TO LOOP ON ERROR^
  8377
  8378					;**********
  8379
  8380					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8381					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8382					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8383					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8384					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8385					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8386					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8387			010115		SN=SN+1
  8388		777777	767777			ZZ=ZZ+ZZ+1
  8389						IFE	<ZZ-1>,<ZZ=-2>
  8390	034411	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-13
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0176

  8391	034412	444 00 0 00 035200 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8392									;RESULT IN C(AC) NON-ZERO
  8393	034413	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8394						STOP^
  8395	034414	254 04 0 00 034415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8396	034415	324 00 0 00 034416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8397									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8398									;IN THE SUBTEST) TO LOOP ON ERROR^
  8399
  8400					;**********
  8401
  8402					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8403					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8404					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8405					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8406					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8407					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8408					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8409			010116		SN=SN+1
  8410		777777	757777			ZZ=ZZ+ZZ+1
  8411						IFE	<ZZ-1>,<ZZ=-2>
  8412	034416	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8413	034417	444 00 0 00 035201 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8414									;RESULT IN C(AC) NON-ZERO
  8415	034420	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8416						STOP^
  8417	034421	254 04 0 00 034422 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8418	034422	324 00 0 00 034423 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8419									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8420									;IN THE SUBTEST) TO LOOP ON ERROR^
  8421
  8422					;**********
  8423
  8424					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8425					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8426					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8427					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8428					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8429					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8430					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8431			010117		SN=SN+1
  8432		777777	737777			ZZ=ZZ+ZZ+1
  8433						IFE	<ZZ-1>,<ZZ=-2>
  8434	034423	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8435	034424	444 00 0 00 035202 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8436									;RESULT IN C(AC) NON-ZERO
  8437	034425	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8438						STOP^
  8439	034426	254 04 0 00 034427 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8440	034427	324 00 0 00 034430 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8441									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8442									;IN THE SUBTEST) TO LOOP ON ERROR^
  8443
  8444					;**********
  8445
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-14
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0177

  8446					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8447					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8448					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8449					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8450					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8451					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8452					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8453			010120		SN=SN+1
  8454		777777	677777			ZZ=ZZ+ZZ+1
  8455						IFE	<ZZ-1>,<ZZ=-2>
  8456	034430	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8457	034431	444 00 0 00 035203 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8458									;RESULT IN C(AC) NON-ZERO
  8459	034432	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8460						STOP^
  8461	034433	254 04 0 00 034434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8462	034434	324 00 0 00 034435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8464									;IN THE SUBTEST) TO LOOP ON ERROR^
  8465
  8466					;**********
  8467
  8468					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8469					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8470					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8471					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8472					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8473					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8474					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8475			010121		SN=SN+1
  8476		777777	577777			ZZ=ZZ+ZZ+1
  8477						IFE	<ZZ-1>,<ZZ=-2>
  8478	034435	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8479	034436	444 00 0 00 035204 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8480									;RESULT IN C(AC) NON-ZERO
  8481	034437	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8482						STOP^
  8483	034440	254 04 0 00 034441 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8484	034441	324 00 0 00 034442 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8485									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8486									;IN THE SUBTEST) TO LOOP ON ERROR^
  8487
  8488					;**********
  8489
  8490					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8491					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8492					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8493					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8494					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8495					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
  8496					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8497			010122		SN=SN+1
  8498		777777	377777			ZZ=ZZ+ZZ+1
  8499						IFE	<ZZ-1>,<ZZ=-2>
  8500	034442	200 00 0 00 035062 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 29-15
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0178

  8501	034443	444 00 0 00 035064 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8502									;RESULT IN C(AC) NON-ZERO
  8503	034444	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8504						STOP^
  8505	034445	254 04 0 00 034446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8506	034446	324 00 0 00 034447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8507									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8508									;IN THE SUBTEST) TO LOOP ON ERROR^
  8509
  8510					;**********
  8511
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 30
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0179

  8512					;THIS TEST VERIFIES THAT THE RESULT OF AN AC CONTAINING ALL ZEROS
  8513					;EQUIVALENCED WITH AN E CONTAINING ALL ZEROS IS AN AC CONTAINING ALL
  8514					;ONES; AND FUTHERMORE, IF THIS AC CONTAINING ALL ONES IS EQUIVALANCED
  8515					;WITH AN E CONTAINING ALL ZEROS, THE FINAL RESULT IN THE AC
  8516					;SHOULD BE ALL ZEROS.  FIRST, THE AC IS INITIALIZED TO ALL ZEROS, THEN,
  8517					;THIS AC IS EQUIVALENCED TWICE WITH AN E CONTAINING ALL ZEROS.  THE AC IS
  8518					;THEN CHECKED FOR ALL ZEROS
  8519
  8520	034447	200 00 0 00 035062 	A10200:	MOVE	[0]		;CLEAR THE AC
  8521	034450	444 00 0 00 035062 		EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=ALL ONES
  8522	034451	444 00 0 00 035062 		EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=0
  8523	034452	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8524						STOP^
  8525	034453	254 04 0 00 034454 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8526	034454	324 00 0 00 034455 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8527									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8528									;IN THE SUBTEST) TO LOOP ON ERROR^
  8529
  8530					;**********
  8531
  8532					;THIS TEST VERIFIES THAT THE RESULT OF AN AC CONTAINING ALL ONES
  8533					;EQUIVALENCED WITH AN E CONTAINING ALL ONES IS AN AC CONTAINING ALL ONES;
  8534					;AND FUTHERMORE, IF THIS AC CONTAINING ALL ONES ISEQUIVALENCED WITH AN E
  8535					;CONTAINING ALL ZEROS, THE FINAL RESULT IN THE AC SHOULD BE ALL ZEROS.
  8536					;FIRST, THE AC IS INITIALIZED TO ALL ONES; THEN, THIS AC IS
  8537					;EQUIVALENCED WITH AN E OF ALL ONES.  NEXT, THIS SAME AC IS EQUIVALENCED
  8538					;WITH AN E OF ALL ZEROS.  THE AC IS THEN CHECKED FOR ALL ZEROS.
  8539
  8540	034455	200 00 0 00 035063 	A10300:	MOVE	[-1]		;SET C(AC) TO ALL ONES
  8541	034456	444 00 0 00 035063 		EQV	[-1]		;*EQV SHOULD RESULT IN C(AC) OF ALL ONES
  8542	034457	444 00 0 00 035062 		EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=0
  8543	034460	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8544						STOP^
  8545	034461	254 04 0 00 034462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8546	034462	324 00 0 00 034463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8547									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8548									;IN THE SUBTEST) TO LOOP ON ERROR^
  8549
  8550					;**********
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0180

  8551			013000		SN=13000
  8552			000000			ZZ=0
  8553
  8554					A13000:	REPEAT	^D36,
  8555					<;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8556					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8557					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8558					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8559					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8560					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8561					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8562					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8563					SN=SN+1
  8564						ZZ=ZZ+ZZ
  8565						IFE	ZZ,<ZZ=1>
  8566						MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8567						AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8568						EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8569						EQV	[0]		;RESULTS IN C(AC)=0
  8570						SKIPE			;PASS TEST IF C(AC)=0
  8571						STOP
  8572
  8573					;**********
  8574					>
  8575					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8576					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8577					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8578					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8579					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8580					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8581					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8582					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8583			013001		SN=SN+1
  8584			000000			ZZ=ZZ+ZZ
  8585			000001			IFE	ZZ,<ZZ=1>
  8586	034463	200 00 0 00 035074 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8587	034464	404 00 0 00 035074 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8588	034465	444 00 0 00 035074 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8589	034466	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8590	034467	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8591						STOP^
  8592	034470	254 04 0 00 034471 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8593	034471	324 00 0 00 034472 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8594									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8595									;IN THE SUBTEST) TO LOOP ON ERROR^
  8596
  8597					;**********
  8598
  8599					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8600					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8601					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8602					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8603					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8604					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8605					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-1
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0181

  8606					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8607			013002		SN=SN+1
  8608			000002			ZZ=ZZ+ZZ
  8609						IFE	ZZ,<ZZ=1>
  8610	034472	200 00 0 00 035075 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8611	034473	404 00 0 00 035075 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8612	034474	444 00 0 00 035075 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8613	034475	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8614	034476	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8615						STOP^
  8616	034477	254 04 0 00 034500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8617	034500	324 00 0 00 034501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8618									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8619									;IN THE SUBTEST) TO LOOP ON ERROR^
  8620
  8621					;**********
  8622
  8623					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8624					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8625					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8626					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8627					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8628					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8629					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8630					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8631			013003		SN=SN+1
  8632			000004			ZZ=ZZ+ZZ
  8633						IFE	ZZ,<ZZ=1>
  8634	034501	200 00 0 00 035076 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8635	034502	404 00 0 00 035076 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8636	034503	444 00 0 00 035076 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8637	034504	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8638	034505	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8639						STOP^
  8640	034506	254 04 0 00 034507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8641	034507	324 00 0 00 034510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8642									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8643									;IN THE SUBTEST) TO LOOP ON ERROR^
  8644
  8645					;**********
  8646
  8647					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8648					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8649					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8650					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8651					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8652					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8653					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8654					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8655			013004		SN=SN+1
  8656			000010			ZZ=ZZ+ZZ
  8657						IFE	ZZ,<ZZ=1>
  8658	034510	200 00 0 00 035077 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8659	034511	404 00 0 00 035077 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8660	034512	444 00 0 00 035077 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-2
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0182

  8661	034513	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8662	034514	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8663						STOP^
  8664	034515	254 04 0 00 034516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8665	034516	324 00 0 00 034517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8666									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8667									;IN THE SUBTEST) TO LOOP ON ERROR^
  8668
  8669					;**********
  8670
  8671					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8672					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8673					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8674					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8675					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8676					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8677					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8678					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8679			013005		SN=SN+1
  8680			000020			ZZ=ZZ+ZZ
  8681						IFE	ZZ,<ZZ=1>
  8682	034517	200 00 0 00 035100 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8683	034520	404 00 0 00 035100 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8684	034521	444 00 0 00 035100 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8685	034522	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8686	034523	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8687						STOP^
  8688	034524	254 04 0 00 034525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8689	034525	324 00 0 00 034526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8691									;IN THE SUBTEST) TO LOOP ON ERROR^
  8692
  8693					;**********
  8694
  8695					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8696					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8697					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8698					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8699					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8700					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8701					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8702					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8703			013006		SN=SN+1
  8704			000040			ZZ=ZZ+ZZ
  8705						IFE	ZZ,<ZZ=1>
  8706	034526	200 00 0 00 035101 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8707	034527	404 00 0 00 035101 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8708	034530	444 00 0 00 035101 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8709	034531	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8710	034532	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8711						STOP^
  8712	034533	254 04 0 00 034534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8713	034534	324 00 0 00 034535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8714									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8715									;IN THE SUBTEST) TO LOOP ON ERROR^
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-3
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0183

  8716
  8717					;**********
  8718
  8719					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8720					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8721					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8722					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8723					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8724					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8725					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8726					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8727			013007		SN=SN+1
  8728			000100			ZZ=ZZ+ZZ
  8729						IFE	ZZ,<ZZ=1>
  8730	034535	200 00 0 00 035102 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8731	034536	404 00 0 00 035102 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8732	034537	444 00 0 00 035102 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8733	034540	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8734	034541	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8735						STOP^
  8736	034542	254 04 0 00 034543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8737	034543	324 00 0 00 034544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8738									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8739									;IN THE SUBTEST) TO LOOP ON ERROR^
  8740
  8741					;**********
  8742
  8743					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8744					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8745					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8746					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8747					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8748					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8749					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8750					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8751			013010		SN=SN+1
  8752			000200			ZZ=ZZ+ZZ
  8753						IFE	ZZ,<ZZ=1>
  8754	034544	200 00 0 00 035103 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8755	034545	404 00 0 00 035103 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8756	034546	444 00 0 00 035103 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8757	034547	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8758	034550	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8759						STOP^
  8760	034551	254 04 0 00 034552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8761	034552	324 00 0 00 034553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8762									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8763									;IN THE SUBTEST) TO LOOP ON ERROR^
  8764
  8765					;**********
  8766
  8767					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8768					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8769					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8770					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-4
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0184

  8771					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8772					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8773					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8774					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8775			013011		SN=SN+1
  8776			000400			ZZ=ZZ+ZZ
  8777						IFE	ZZ,<ZZ=1>
  8778	034553	200 00 0 00 035104 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8779	034554	404 00 0 00 035104 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8780	034555	444 00 0 00 035104 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8781	034556	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8782	034557	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8783						STOP^
  8784	034560	254 04 0 00 034561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8785	034561	324 00 0 00 034562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8786									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8787									;IN THE SUBTEST) TO LOOP ON ERROR^
  8788
  8789					;**********
  8790
  8791					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8792					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8793					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8794					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8795					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8796					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8797					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8798					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8799			013012		SN=SN+1
  8800			001000			ZZ=ZZ+ZZ
  8801						IFE	ZZ,<ZZ=1>
  8802	034562	200 00 0 00 035105 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8803	034563	404 00 0 00 035105 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8804	034564	444 00 0 00 035105 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8805	034565	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8806	034566	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8807						STOP^
  8808	034567	254 04 0 00 034570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8809	034570	324 00 0 00 034571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8810									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8811									;IN THE SUBTEST) TO LOOP ON ERROR^
  8812
  8813					;**********
  8814
  8815					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8816					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8817					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8818					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8819					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8820					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8821					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8822					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8823			013013		SN=SN+1
  8824			002000			ZZ=ZZ+ZZ
  8825						IFE	ZZ,<ZZ=1>
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-5
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0185

  8826	034571	200 00 0 00 035106 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8827	034572	404 00 0 00 035106 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8828	034573	444 00 0 00 035106 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8829	034574	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8830	034575	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8831						STOP^
  8832	034576	254 04 0 00 034577 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8833	034577	324 00 0 00 034600 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8835									;IN THE SUBTEST) TO LOOP ON ERROR^
  8836
  8837					;**********
  8838
  8839					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8840					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8841					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8842					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8843					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8844					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8845					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8846					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8847			013014		SN=SN+1
  8848			004000			ZZ=ZZ+ZZ
  8849						IFE	ZZ,<ZZ=1>
  8850	034600	200 00 0 00 035107 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8851	034601	404 00 0 00 035107 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8852	034602	444 00 0 00 035107 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8853	034603	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8854	034604	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8855						STOP^
  8856	034605	254 04 0 00 034606 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8857	034606	324 00 0 00 034607 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8858									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8859									;IN THE SUBTEST) TO LOOP ON ERROR^
  8860
  8861					;**********
  8862
  8863					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8864					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8865					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8866					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8867					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8868					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8869					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8870					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8871			013015		SN=SN+1
  8872			010000			ZZ=ZZ+ZZ
  8873						IFE	ZZ,<ZZ=1>
  8874	034607	200 00 0 00 035110 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8875	034610	404 00 0 00 035110 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8876	034611	444 00 0 00 035110 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8877	034612	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8878	034613	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8879						STOP^
  8880	034614	254 04 0 00 034615 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-6
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0186

  8881	034615	324 00 0 00 034616 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8882									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8883									;IN THE SUBTEST) TO LOOP ON ERROR^
  8884
  8885					;**********
  8886
  8887					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8888					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8889					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8890					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8891					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8892					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8893					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8894					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8895			013016		SN=SN+1
  8896			020000			ZZ=ZZ+ZZ
  8897						IFE	ZZ,<ZZ=1>
  8898	034616	200 00 0 00 035111 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8899	034617	404 00 0 00 035111 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8900	034620	444 00 0 00 035111 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8901	034621	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8902	034622	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8903						STOP^
  8904	034623	254 04 0 00 034624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8905	034624	324 00 0 00 034625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8906									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8907									;IN THE SUBTEST) TO LOOP ON ERROR^
  8908
  8909					;**********
  8910
  8911					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8912					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8913					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8914					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8915					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8916					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8917					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8918					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8919			013017		SN=SN+1
  8920			040000			ZZ=ZZ+ZZ
  8921						IFE	ZZ,<ZZ=1>
  8922	034625	200 00 0 00 035112 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8923	034626	404 00 0 00 035112 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8924	034627	444 00 0 00 035112 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8925	034630	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8926	034631	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8927						STOP^
  8928	034632	254 04 0 00 034633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8929	034633	324 00 0 00 034634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8930									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8931									;IN THE SUBTEST) TO LOOP ON ERROR^
  8932
  8933					;**********
  8934
  8935					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-7
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0187

  8936					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8937					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8938					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8939					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8940					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8941					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8942					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8943			013020		SN=SN+1
  8944			100000			ZZ=ZZ+ZZ
  8945						IFE	ZZ,<ZZ=1>
  8946	034634	200 00 0 00 035113 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8947	034635	404 00 0 00 035113 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8948	034636	444 00 0 00 035113 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8949	034637	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8950	034640	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8951						STOP^
  8952	034641	254 04 0 00 034642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8953	034642	324 00 0 00 034643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8954									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8955									;IN THE SUBTEST) TO LOOP ON ERROR^
  8956
  8957					;**********
  8958
  8959					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8960					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8961					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8962					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8963					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8964					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8965					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8966					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8967			013021		SN=SN+1
  8968			200000			ZZ=ZZ+ZZ
  8969						IFE	ZZ,<ZZ=1>
  8970	034643	200 00 0 00 035114 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8971	034644	404 00 0 00 035114 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8972	034645	444 00 0 00 035114 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8973	034646	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8974	034647	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8975						STOP^
  8976	034650	254 04 0 00 034651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8977	034651	324 00 0 00 034652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8979									;IN THE SUBTEST) TO LOOP ON ERROR^
  8980
  8981					;**********
  8982
  8983					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8984					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8985					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8986					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8987					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8988					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8989					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8990					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-8
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0188

  8991			013022		SN=SN+1
  8992			400000			ZZ=ZZ+ZZ
  8993						IFE	ZZ,<ZZ=1>
  8994	034652	200 00 0 00 035115 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8995	034653	404 00 0 00 035115 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8996	034654	444 00 0 00 035115 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8997	034655	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  8998	034656	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8999						STOP^
  9000	034657	254 04 0 00 034660 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9001	034660	324 00 0 00 034661 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9002									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9003									;IN THE SUBTEST) TO LOOP ON ERROR^
  9004
  9005					;**********
  9006
  9007					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9008					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9009					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9010					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9011					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9012					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9013					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9014					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9015			013023		SN=SN+1
  9016		000001	000000			ZZ=ZZ+ZZ
  9017						IFE	ZZ,<ZZ=1>
  9018	034661	200 00 0 00 035116 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9019	034662	404 00 0 00 035116 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9020	034663	444 00 0 00 035116 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9021	034664	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9022	034665	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9023						STOP^
  9024	034666	254 04 0 00 034667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9025	034667	324 00 0 00 034670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9026									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9027									;IN THE SUBTEST) TO LOOP ON ERROR^
  9028
  9029					;**********
  9030
  9031					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9032					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9033					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9034					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9035					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9036					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9037					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9038					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9039			013024		SN=SN+1
  9040		000002	000000			ZZ=ZZ+ZZ
  9041						IFE	ZZ,<ZZ=1>
  9042	034670	200 00 0 00 035117 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9043	034671	404 00 0 00 035117 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9044	034672	444 00 0 00 035117 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9045	034673	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-9
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0189

  9046	034674	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9047						STOP^
  9048	034675	254 04 0 00 034676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9049	034676	324 00 0 00 034677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9050									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9051									;IN THE SUBTEST) TO LOOP ON ERROR^
  9052
  9053					;**********
  9054
  9055					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9056					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9057					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9058					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9059					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9060					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9061					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9062					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9063			013025		SN=SN+1
  9064		000004	000000			ZZ=ZZ+ZZ
  9065						IFE	ZZ,<ZZ=1>
  9066	034677	200 00 0 00 035120 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9067	034700	404 00 0 00 035120 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9068	034701	444 00 0 00 035120 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9069	034702	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9070	034703	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9071						STOP^
  9072	034704	254 04 0 00 034705 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9073	034705	324 00 0 00 034706 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9074									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9075									;IN THE SUBTEST) TO LOOP ON ERROR^
  9076
  9077					;**********
  9078
  9079					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9080					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9081					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9082					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9083					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9084					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9085					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9086					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9087			013026		SN=SN+1
  9088		000010	000000			ZZ=ZZ+ZZ
  9089						IFE	ZZ,<ZZ=1>
  9090	034706	200 00 0 00 035121 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9091	034707	404 00 0 00 035121 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9092	034710	444 00 0 00 035121 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9093	034711	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9094	034712	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9095						STOP^
  9096	034713	254 04 0 00 034714 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9097	034714	324 00 0 00 034715 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9098									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9099									;IN THE SUBTEST) TO LOOP ON ERROR^
  9100
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-10
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0190

  9101					;**********
  9102
  9103					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9104					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9105					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9106					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9107					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9108					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9109					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9110					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9111			013027		SN=SN+1
  9112		000020	000000			ZZ=ZZ+ZZ
  9113						IFE	ZZ,<ZZ=1>
  9114	034715	200 00 0 00 035122 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9115	034716	404 00 0 00 035122 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9116	034717	444 00 0 00 035122 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9117	034720	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9118	034721	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9119						STOP^
  9120	034722	254 04 0 00 034723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9121	034723	324 00 0 00 034724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9122									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9123									;IN THE SUBTEST) TO LOOP ON ERROR^
  9124
  9125					;**********
  9126
  9127					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9128					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9129					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9130					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9131					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9132					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9133					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9134					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9135			013030		SN=SN+1
  9136		000040	000000			ZZ=ZZ+ZZ
  9137						IFE	ZZ,<ZZ=1>
  9138	034724	200 00 0 00 035123 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9139	034725	404 00 0 00 035123 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9140	034726	444 00 0 00 035123 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9141	034727	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9142	034730	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9143						STOP^
  9144	034731	254 04 0 00 034732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9145	034732	324 00 0 00 034733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9146									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9147									;IN THE SUBTEST) TO LOOP ON ERROR^
  9148
  9149					;**********
  9150
  9151					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9152					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9153					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9154					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9155					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-11
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0191

  9156					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9157					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9158					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9159			013031		SN=SN+1
  9160		000100	000000			ZZ=ZZ+ZZ
  9161						IFE	ZZ,<ZZ=1>
  9162	034733	200 00 0 00 035124 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9163	034734	404 00 0 00 035124 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9164	034735	444 00 0 00 035124 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9165	034736	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9166	034737	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9167						STOP^
  9168	034740	254 04 0 00 034741 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9169	034741	324 00 0 00 034742 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9170									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9171									;IN THE SUBTEST) TO LOOP ON ERROR^
  9172
  9173					;**********
  9174
  9175					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9176					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9177					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9178					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9179					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9180					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9181					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9182					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9183			013032		SN=SN+1
  9184		000200	000000			ZZ=ZZ+ZZ
  9185						IFE	ZZ,<ZZ=1>
  9186	034742	200 00 0 00 035125 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9187	034743	404 00 0 00 035125 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9188	034744	444 00 0 00 035125 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9189	034745	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9190	034746	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9191						STOP^
  9192	034747	254 04 0 00 034750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9193	034750	324 00 0 00 034751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9194									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9195									;IN THE SUBTEST) TO LOOP ON ERROR^
  9196
  9197					;**********
  9198
  9199					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9200					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9201					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9202					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9203					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9204					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9205					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9206					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9207			013033		SN=SN+1
  9208		000400	000000			ZZ=ZZ+ZZ
  9209						IFE	ZZ,<ZZ=1>
  9210	034751	200 00 0 00 035073 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-12
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0192

  9211	034752	404 00 0 00 035073 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9212	034753	444 00 0 00 035073 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9213	034754	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9214	034755	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9215						STOP^
  9216	034756	254 04 0 00 034757 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9217	034757	324 00 0 00 034760 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9218									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9219									;IN THE SUBTEST) TO LOOP ON ERROR^
  9220
  9221					;**********
  9222
  9223					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9224					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9225					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9226					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9227					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9228					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9229					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9230					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9231			013034		SN=SN+1
  9232		001000	000000			ZZ=ZZ+ZZ
  9233						IFE	ZZ,<ZZ=1>
  9234	034760	200 00 0 00 035126 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9235	034761	404 00 0 00 035126 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9236	034762	444 00 0 00 035126 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9237	034763	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9238	034764	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9239						STOP^
  9240	034765	254 04 0 00 034766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9241	034766	324 00 0 00 034767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9242									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9243									;IN THE SUBTEST) TO LOOP ON ERROR^
  9244
  9245					;**********
  9246
  9247					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9248					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9249					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9250					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9251					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9252					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9253					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9254					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9255			013035		SN=SN+1
  9256		002000	000000			ZZ=ZZ+ZZ
  9257						IFE	ZZ,<ZZ=1>
  9258	034767	200 00 0 00 035127 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9259	034770	404 00 0 00 035127 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9260	034771	444 00 0 00 035127 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9261	034772	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9262	034773	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9263						STOP^
  9264	034774	254 04 0 00 034775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9265	034775	324 00 0 00 034776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-13
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0193

  9266									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9267									;IN THE SUBTEST) TO LOOP ON ERROR^
  9268
  9269					;**********
  9270
  9271					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9272					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9273					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9274					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9275					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9276					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9277					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9278					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9279			013036		SN=SN+1
  9280		004000	000000			ZZ=ZZ+ZZ
  9281						IFE	ZZ,<ZZ=1>
  9282	034776	200 00 0 00 035130 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9283	034777	404 00 0 00 035130 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9284	035000	444 00 0 00 035130 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9285	035001	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9286	035002	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9287						STOP^
  9288	035003	254 04 0 00 035004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9289	035004	324 00 0 00 035005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9290									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9291									;IN THE SUBTEST) TO LOOP ON ERROR^
  9292
  9293					;**********
  9294
  9295					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9296					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9297					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9298					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9299					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9300					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9301					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9302					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9303			013037		SN=SN+1
  9304		010000	000000			ZZ=ZZ+ZZ
  9305						IFE	ZZ,<ZZ=1>
  9306	035005	200 00 0 00 035131 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9307	035006	404 00 0 00 035131 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9308	035007	444 00 0 00 035131 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9309	035010	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9310	035011	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9311						STOP^
  9312	035012	254 04 0 00 035013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9313	035013	324 00 0 00 035014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9314									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9315									;IN THE SUBTEST) TO LOOP ON ERROR^
  9316
  9317					;**********
  9318
  9319					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9320					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-14
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0194

  9321					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9322					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9323					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9324					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9325					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9326					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9327			013040		SN=SN+1
  9328		020000	000000			ZZ=ZZ+ZZ
  9329						IFE	ZZ,<ZZ=1>
  9330	035014	200 00 0 00 035132 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9331	035015	404 00 0 00 035132 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9332	035016	444 00 0 00 035132 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9333	035017	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9334	035020	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9335						STOP^
  9336	035021	254 04 0 00 035022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9337	035022	324 00 0 00 035023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9338									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9339									;IN THE SUBTEST) TO LOOP ON ERROR^
  9340
  9341					;**********
  9342
  9343					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9344					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9345					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9346					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9347					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9348					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9349					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9350					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9351			013041		SN=SN+1
  9352		040000	000000			ZZ=ZZ+ZZ
  9353						IFE	ZZ,<ZZ=1>
  9354	035023	200 00 0 00 035133 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9355	035024	404 00 0 00 035133 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9356	035025	444 00 0 00 035133 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9357	035026	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9358	035027	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9359						STOP^
  9360	035030	254 04 0 00 035031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9361	035031	324 00 0 00 035032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9362									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9363									;IN THE SUBTEST) TO LOOP ON ERROR^
  9364
  9365					;**********
  9366
  9367					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9368					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9369					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9370					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9371					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9372					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9373					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9374					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9375			013042		SN=SN+1
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-15
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0195

  9376		100000	000000			ZZ=ZZ+ZZ
  9377						IFE	ZZ,<ZZ=1>
  9378	035032	200 00 0 00 035134 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9379	035033	404 00 0 00 035134 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9380	035034	444 00 0 00 035134 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9381	035035	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9382	035036	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9383						STOP^
  9384	035037	254 04 0 00 035040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9385	035040	324 00 0 00 035041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9386									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9387									;IN THE SUBTEST) TO LOOP ON ERROR^
  9388
  9389					;**********
  9390
  9391					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9392					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9393					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9394					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9395					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9396					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9397					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9398					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9399			013043		SN=SN+1
  9400		200000	000000			ZZ=ZZ+ZZ
  9401						IFE	ZZ,<ZZ=1>
  9402	035041	200 00 0 00 035135 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9403	035042	404 00 0 00 035135 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9404	035043	444 00 0 00 035135 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9405	035044	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9406	035045	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9407						STOP^
  9408	035046	254 04 0 00 035047 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9409	035047	324 00 0 00 035050 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9410									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9411									;IN THE SUBTEST) TO LOOP ON ERROR^
  9412
  9413					;**********
  9414
  9415					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9416					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9417					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9418					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9419					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9420					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9421					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9422					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9423			013044		SN=SN+1
  9424		400000	000000			ZZ=ZZ+ZZ
  9425						IFE	ZZ,<ZZ=1>
  9426	035050	200 00 0 00 035065 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9427	035051	404 00 0 00 035065 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9428	035052	444 00 0 00 035065 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9429	035053	444 00 0 00 035062 		EQV	[0]		;RESULTS IN C(AC)=0
  9430	035054	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 31-16
DAKAAM	MAC	19-JAN-77 13:42		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)                           SEQ 0196

  9431						STOP^
  9432	035055	254 04 0 00 035056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9433	035056	324 00 0 00 035057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9434									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9435									;IN THE SUBTEST) TO LOOP ON ERROR^
  9436
  9437					;**********
  9438
  9439	035057	254 00 0 00 030057 	ENDXX:	JRST	BEGEND		;LOOP PROGRAM
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 1
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 0197

  9440					SUBTTL	*STOR* RESERVED STORAGE, JAN 18,1977
  9441
  9442					;PROGRAM LITERALS
  9443
  9444						XLIST
  9445					IFNDEF	$LPAPER,<LIST>
  9446	035060					LIT
  9447	035060	000001	000001
  9448	035061	254 00 0 00 030741
  9449	035062	000000	000000
  9450	035063	777777	777777
  9451	035064	377777	777777
  9452	035065	400000	000000
  9453	035066	777000	000000
  9454	035067	000377	000000
  9455	035070	000000	177000
  9456	035071	000000	000777
  9457	035072	000000	600000
  9458	035073	000400	000000
  9459	035074	000000	000001
  9460	035075	000000	000002
  9461	035076	000000	000004
  9462	035077	000000	000010
  9463	035100	000000	000020
  9464	035101	000000	000040
  9465	035102	000000	000100
  9466	035103	000000	000200
  9467	035104	000000	000400
  9468	035105	000000	001000
  9469	035106	000000	002000
  9470	035107	000000	004000
  9471	035110	000000	010000
  9472	035111	000000	020000
  9473	035112	000000	040000
  9474	035113	000000	100000
  9475	035114	000000	200000
  9476	035115	000000	400000
  9477	035116	000001	000000
  9478	035117	000002	000000
  9479	035120	000004	000000
  9480	035121	000010	000000
  9481	035122	000020	000000
  9482	035123	000040	000000
  9483	035124	000100	000000
  9484	035125	000200	000000
  9485	035126	001000	000000
  9486	035127	002000	000000
  9487	035130	004000	000000
  9488	035131	010000	000000
  9489	035132	020000	000000
  9490	035133	040000	000000
  9491	035134	100000	000000
  9492	035135	200000	000000
  9493	035136	000000	001234
  9494	035137	000000	777777
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 1-1
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 0198

  9495	035140	777777	000000
  9496	035141	707070	707070
  9497	035142	777777	777776
  9498	035143	777777	777775
  9499	035144	777777	777773
  9500	035145	777777	777767
  9501	035146	777777	777757
  9502	035147	777777	777737
  9503	035150	777777	777677
  9504	035151	777777	777577
  9505	035152	777777	777377
  9506	035153	777777	776777
  9507	035154	777777	775777
  9508	035155	777777	773777
  9509	035156	777777	767777
  9510	035157	777777	757777
  9511	035160	777777	737777
  9512	035161	777777	677777
  9513	035162	777777	577777
  9514	035163	777777	377777
  9515	035164	777776	777777
  9516	035165	777775	777777
  9517	035166	777773	777777
  9518	035167	777767	777777
  9519	035170	777757	777777
  9520	035171	777737	777777
  9521	035172	777677	777777
  9522	035173	777577	777777
  9523	035174	777377	777777
  9524	035175	776777	777777
  9525	035176	775777	777777
  9526	035177	773777	777777
  9527	035200	767777	777777
  9528	035201	757777	777777
  9529	035202	737777	777777
  9530	035203	677777	777777
  9531	035204	577777	777777
  9532						LIST
  9533	035205	000000	000000		ENDSLD:	0
  9534
  9535					IFDEF	DEBUG,<
  9536					PATCH:	BLOCK DEBUG		;PATCHING AREA
  9537					>
  9538
  9539					;PROGRAM VARIABLES
  9540	035206					VAR
  9541
  9542					IFDEF	PGMEND,<
  9543	035206	000000	000000		END:	0
  9544			030000			END	BEGIN	>

NO ERRORS DETECTED

PROGRAM BREAK IS 000000
ABSLUTE BREAK IS 035207
DAKAA PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) 0,2	MACRO %52(537) 13:54 19-JAN-77 PAGE 1-2
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 0199

CPU TIME USED 00:40.863

11K CORE USED
