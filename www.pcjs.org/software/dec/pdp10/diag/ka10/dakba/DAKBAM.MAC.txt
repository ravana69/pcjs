;INITIALIZE UUO HANDLER

START:	PGMINT			;INITIALIZE SUBROUTINES
	MOVE	0,RANDBS	;EXEC, SETUP RANDOM BASE
	SKIPE	USER		;USER, USE TIME OF DAY IN JIFFIES
	CALL	0,[SIXBIT/TIMER/]
	MOVEM	0,RAN		;SETUP RANDOM BASE

;INITIALIZE COMPLEXITY TABLE
	A=0
STARTA:	SETZM	CMPLXT		;STORE A TABLE OF POWERS OF 2
	MOVEI	1,1		;OR 0.
	SWITCH
	TLNN	RELIAB		;FAST CYCLE SWITCH SET ?
	SETZM	1		;YES, STORE ZERO'S
	REPEAT	7,
<	MOVEM	1,CMPLXT+1+A
	LSH	1,1
	A=A+1>
;INITIALIZE RUN TIME

	MOVEI	1,1
	TLNE	RELIAB		;FAST CYCLE SWITCH SET ?
	MOVEI	1,7		;NO, MULTIPLY RUNNING TIME
	MOVEM	1,RTIME		;STORE IN RTIME

	JRST	CAM1		;GO PERFORM DIAGNOSTIC

RENTR1:	DROPDV			;CLOSE LOGICAL OUTPUT FILE
	CALL	[SIXBIT .EXIT.]

PGMNAM:	ASCIZ/
PDP-10  KA10 BASIC INSTRUCTION RELIABILITY TEST 1 (DAKBA)
(COMPARES, SKIPS, EXCHANGES, BOOLE, ROTATES, TESTS, ETC.)
/
;CONSTANTS

RTIME:	0
CMPLXT:	BLOCK	20
SUBTTL	DIAGNOSTIC SECTION
	LALL

;TEST CAMN,CAME (SIMPLE)
;THE CONTENTS OF THE AC IS COMPARED WITH ITSELF
;AN ERROR WILL OCCUR IF CAMN SKIPS OR CAME FAILS TO SKIP
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)
;15 ACS ARE USED IN THE TEST

	AC=2
CAM1:	SETUP 20,0
	RANDOM
CAMNE1:	REPEAT ^D10,
<	MOVE	AC,RAN
	CAMN	AC,AC		;C(AC) = C(AC)
	CAME	AC,AC
	ERROR	AC,AC		;CHECK CAME,CAMN
	AC=<AC+1>&17
>
	AC=2
	LOOP CAMNE1-3,CAMNE1


;TEST MOVE TO AC,FURTHER TEST OF CAME
;THE C(AC) IS COMPARED WITH THE CONTENTS OF THE RANDOM
;NUMBER GENERATOR. 15 ACS ARE USED IN THE TEST
;ERRORS ARE PRINTED IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
MOVAC:	SETUP 20,0
	RANDOM
MOVAC1:	REPEAT ^D10,
<	MOVE AC,RAN		;MOVE RAN INTO AC.
	CAME AC,RAN		;RANDOM SHOULD EQUAL AC
	ERROR AC,RAN		;IF NOT MOVE FAILED
	CAME AC,RAN#		;IF  AC=RAN CAME FAILED
	ERROR AC,RAN#		;IF PREVIOUS WORKED,INHIBIT STORE
	AC=<AC+1>&17		;AC ON CAME FAILED
>
	AC=2
	LOOP MOVAC1-3,MOVAC1

;TEST THE SKIP INST FOR NO SKIP,ABILITY TO LOAD
;AN AC,AC SELECTION,AND AC0 LOGIC(NOT LOADING 0)
;ERRORS ARE PRESENTED IN THE FORM(PC,AC,C(AC),CORRECT)

	AC=5
SKP:	SETUP 30,0
	RANDOM
SKP1:	MOVE [0]		;DO NOT USE AC0 FOR SKIP
	REPEAT ^D8,
<	SKIP AC1,RAN#		;STORE IN AC,DO NOT SKIP,CHECK
	CAME AC1,AC		;NEW AC AGAINST PREVIOUSLY
	ERROR AC1,AC		;STORED AC. IF AC=AC+1(SKIP LOGIC)
	CAME [0]		;IF NOT= STORE CYCLE
	ERROR [0]		;IF 0 NONE ZERO ADDR/STORE
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=5
	LOOP SKP1-4,SKP1

;TEST SKIPA INST FOR PC INCREMENT,ABILITY TO LOAD AN AC,
;AC SELECTION AND AC0 LOGIC(NOT LOADING 0).ERRORS ARE
;PRESENTED IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=5
SKPA:	SETUP 30,0
	RANDOM
SKPA1:	MOVE [0]		;DO NOT USE AC0 FOR SKIPA
	REPEAT ^D8,
<	SKIPA AC1,AC		;LOAD AC1 AND SKIP
	ER AC,[ASCII /SKP/]	;FAILED TO SKIP.
	CAME AC,RAN		;C(E) GET CHANGED?
	ERROR AC,RAN		;YES.
	CAME AC1,RAN		;AC GET LOADED WITH RAN?
	ERROR AC1,RAN		;NO.
	CAME 0,[0]		;C(AC0) STILL = 0?
	ERROR [0]		;CHECK STORE CYCLE,AC ADDRESS
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=5
	LOOP SKPA1-4,SKPA1


;TEST EXCH. BOTH AC AND E ARE AC'S. CHECK FOR
;CORRECT DATA IN AC AND C(E).
;C(E) = -1, C(AC) = RAN NUM.

	AC=5
EXCH1:	SETUP 200,0
EXCH2:	RANDOM
EXCH3:	SETOB	AC1,RAN1	;MAKE C(E) = -1.
	EXCH	AC,AC1		;DO THE EXCH.
	CAME	AC,RAN1		;THE C(AC) SHOULD = ORIG C(E).
	ERR	RAN1,RAN
	CAME	AC1,RAN		;THE C(E) SHOULD = ORIG C(AC).
	ERR	RAN1,RAN
	LOOP	EXCH2,EXCH3


;TEST SETCA FOR COMPLEMENT AC AND NOT STORING IN C(E)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)
;SETCA DOES NOT NORMALLY CHANGE THE CONTENTS OF "E"

	AC=10
BOLCA:	REPEAT 2,
<	SETUP 100,2
	RANDOM
	MOVE AC2,[0]		;CLEAR AC2, USED TO INSURE
	SETCA AC,AC2		;SETCA DOES NOT STORE IN C(E)
	CAMN AC,RAN#		;IF AC UNCHANGED CNTL PULSES
	ERROR AC,RAN		;FOR INST SETCA FAILED
	REPEAT 3,
<	SETCA AC,AC2>
	CAME AC,RAN#		;A TOTAL OF 4 COMPLEMENTS
	ERROR AC,RAN		;SHOULD PRODUCE ORIGINAL NUM
	CAME AC2,[0]		;IF SETCA STORED C(E)
	ERROR AC2,[0]		;C(AC2) WILL NO LONGER BE 0.
	LOOP .-16,.-15
	AC=AC+17
>

;TEST SETCAI ABILITY TO COMPLEMENT AC AND FAILURE TO FETCH C(E)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT
;SETCA IS INDEXED FOR NOISE PURPOSES

	AC=5
BOLCAI:	SETUP 40,0
BOLCA1:	RANDOM
BOLCA2:	REPEAT 4,
<	MOVE AC1,AC		;MOVE RANDOM TO AN AC
	SETCAI AC1,-1(AC)	;TWO COMP SHOULD PRODUCE
	SETCAI AC1,777000(AC)	;ORIGINAL NUMBER
	CAME AC1,AC		;SETCAI FAILED
	ERROR AC1,AC
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=5
	LOOP BOLCA1,BOLCA2


;TEST XOR TO ZERO,XOR 0 TO N,N TO N,-1 TO N
;THREE ACS ARE USED IN THE TEST
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT

	AC=1
BOLX:	REPEAT 3,
<	SETUP 200,0
	RANDOM
	MOVE AC,[0]		;CLEAR THE AC
	XOR AC,RAN		;0 EXCLUSIVE ORED WITH
	CAME AC,RAN		;RANDOM SHOULD = RANDOM
	ERROR AC,RAN		;XOR FAILED
	XOR AC,[0]		;ANY NUMBER XORED
	CAME AC,RAN		;WITH THE NUMBER 0
	ERROR AC,RAN		;SHOULD  REMAIN UNCHANGED
	XOR AC,RAN		;ANY NUMBER XORED
	CAME AC,[0]		;WITH ITSELF SHOULD
	ERROR AC,[0]		;EQUAL 0
	XOR AC,[-1]		;SET AC TO ALL ONES
	XOR AC,RAN		;AC SHOULD CONTAIN COMP OF RAN
	XOR AC,[-1]		;RECOMPLEMENT AC TO ORIG
	CAME AC,RAN		;CHECK FOR RANDOM
	ERROR AC,RAN		;XOR FAILED
	LOOP .-22,.-21
	AC=AC+1
>


;TEST SETZI AND IOR. SETZI ABILITY TO CLEAR,IOR RAN TO 0,
;RANDOM TO RANDOM,RANDOM TO COMP RANDOM,0 TO RANDOM
;ERROR IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=5
BOLZI:	SETUP 100,0
	RANDOM
BOLZI1:	REPEAT 2,
<	MOVE AC,RAN#		;LOAD THE AC THEN
	SETZI AC,(AC)		;TRY TO CLEAR IT,INDEX REDUNDANT
	CAME AC,[0]		;IF NOT 0
	ERROR AC,[0]		;SETZI FAILED
	IOR AC,RAN		;INCLUSIVE OR OF A
	CAME AC,RAN		;NUMBER TO 0 SHOULD PRODUCE
	ERROR AC,RAN		;THE NUMBER
	IOR AC,RAN		;IOR SAME NUMBERS
	CAME AC,RAN		;SHOULD HAVE NO EFFECT
	ERROR AC,RAN		;ON AC.IOR FAILED
	IOR AC,[0]		;IOR OF NO BITS SHOULD DO NOTHING
	CAME AC,RAN
	ERROR AC,RAN		;IOR FAILED
	SETCA AC,0
	IOR AC,RAN		;INCLUSIVE OR OF COMP NUMBERS
	CAME AC,[-1]		;SHOULD SET ALL BITS
	ERROR AC,[-1]		;IOR FAILED
	IOR AC,[-1]		;ALL BITS TO ALL BITS
	CAME AC,[-1]		;PRODUCE ALL BITS
	ERROR AC,[-1]
	AC=<AC+1>&17
>
	AC=5
	LOOP BOLZI1-4,BOLZI1

;TEST AND FOR 0 TO 0,1 TO 1,0 TO 1,1 TO 0
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BOLA:	SETUP 400,0
	RANDOM
BOLA1:	AND AC,RAN		;NUMBER AND NUMBeR
	CAME AC,RAN		;SHOULD EQUAL NUMBER
	ERROR AC,RAN		;IF NOT, "AND" FAILED.
	AND AC,[-1]		;"AND" OF ALL BITS WITH
	CAME AC,RAN		;ANY NUMBER SHOULD
	ERROR AC,RAN		;LEAVE THE NUMBER UNCHANGED
	SETCA AC,
	AND AC,RAN		;"AND" OF A NUMBER WITH ITS
	CAME AC,[0]		;COMPLEMENT SHOULD
	ERROR AC,[0]		;PRODUCE 0
	LOOP BOLA1-4,BOLA1

;TEST ORCA AND SETO. 1 TO 0,1 TO 1, 0 TO 0, 1 TO 0,0 TO 1
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)
;ONE AC IS USED FOR TESTING

	AC=12
BOLOS:	SETUP 300,0
	RANDOM
BOLOS1:	SETO AC,.		;WILL CHANGE THIS INST IF FETCH/STORE C(E).
	CAME AC,[-1]		;CHECK FOR ALL BITS SET
	ERROR AC,[-1]		;SETO FAILED
	ORCA AC,RAN		;-1 ORED TO RANDOM
	CAME AC,RAN		;SHOULD PRODUCE RANDOM
	ERROR AC,RAN		;IF AC COMP PROBELY
	ORCA AC,RAN		;RANDOM TO RANDOM SHOULD
	CAME AC,[-1]		;PRODUCE -1
	ERROR AC,[-1]		;IF AC COMPLEMENTED PROPERLY
	ORCA  AC,[0]		;WITH NO BITS EFFECT IC COMP AC
	ORCA AC,RAN
	CAME AC,[-1]		;NO BITS COMPLEMENTS TO PRODUCE
	ERROR AC,[-1]		;ALL ONES
	LOOP BOLOS1-4,BOLOS1


;TEST ANDCA.1 TO 1,0 TO 0, 0 TO 1,0 TO 0,1 TO 1,1 TO 0
;ERRORS ARE IN THE FORM(PC,AC,C(AC),CORRECT
;ONE AC IS USED

	AC=13
BOLAC:	SETUP 200,1
	RANDOM
BOLAC1:	ANDCA AC,RAN		;ANDCA OF LIKE NUMBERS
	CAME AC,[0]		;SHOULD PRODUCE 0
	ERROR AC,[0]		;ANDCA FAILED
	ANDCA AC,RAN
	CAME AC,RAN		;ANDCA OF ZERO AND NUMBER
	ERROR AC,RAN		;SHOULD PRODUCE NUMBER
	SETO AC,.		;SET ALL BITS
	ANDCA AC,RAN
	CAME AC,[0]		;ANDCA OF ALL BITS WITH NUMBER
	ERROR AC,[0]		;SHOULD PRODUCE 0
	LOOP BOLAC1-4,BOLAC1


;TEST EQV,1 TO 1,0 TO 0,1 TO 0,0 TO 1. EQV =(SET ALL LIKE BITS)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=14
BOLEQ:	SETUP 200,2
	RANDOM
BOLEQ1:	EQV AC,RAN		;WHEN NUMBERS ARE EQUAL
	CAME AC,[-1]		;EQV SHOULD PRODUCE ALL
	ERROR AC,[-1]		;BITS SET.EQV FAILED
	EQV AC,RAN#
	CAME AC,RAN		;WITH AC SET,EQV SHOULD
	ERROR AC,RAN		;PRODUCE C(E) IN THE AC
	SETZI AC,-1
	EQV AC,RAN		;WHEN AC=0 EQV SHOULD
	SETCA AC,.		;PRODUCE COMPLEMENT OF
	CAME AC,RAN		;C(E)
	ERROR AC,RAN		;EQV FAILED
	LOOP BOLEQ1-3,BOLEQ1


;TEST SETM. SET THE CONTENTS OF MEMORY TO THE AC
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BOLSM:	SETUP 100,0
	RANDOM
BOLSM1:	REPEAT 2,
<	SETM AC1,RAN		;THE NET RESULT OF SETM
	CAME AC1,AC		;IS THE SAME AS MOVE
	ERROR AC1,RAN		;SETM FAILED
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=10
	LOOP BOLSM1-4,BOLSM1

;TEST SETCM. (MOVE THE COMPLEMENT OF MEMORY TO AC)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=14
BOLCM:	SETUP 100,0
	RANDOM
BOLCM1:	SETCM AC1,RAN		;COMP OF RANDOM TO AC
	SETCM AC2,AC1		;RECOMP TO AC2
	CAME AC2,RAN
	ERROR AC2,RAN		;SETCM 1 OR 2 FAILED
	LOOP BOLCM1-3,BOLCM1


;TEST ORCM. (INCLUSIVE OR THE CONTENTS OF COMPLEMENTED MEMORY
;TO THE CONTENTS OF AC.) ERRORS ARE IN THE FORM (PC,AC,
;C(AC),CORRECT

	AC=5
BOLOC:	SETUP 140,0
	RANDOM
BOLOC1:	ORCM AC,RAN		;LIKE NUMBERS SHOULD PRODUCE
	CAME AC,[-1]		;ALL BITS SET
	ERROR AC,[-1]
	ORCM AC,RAN		;ANY NUMBER ORED WITH ALL
	CAME AC,[-1]		;ONES SHOULD PRODUCE
	ERROR AC,[-1]		;ALL ONES
	SETZI AC,-1
	ORCM AC,RAN		;THE RANDOM NUMBER IS
	SETCA AC,.		;ORED TO 0. THIS SHOULD
	CAME AC,RAN		;PRODUCE THE  COMPLEMENT
	ERROR AC,RAN		;OF RANDOM
	ORCM AC,[-1]
	CAME AC,RAN		;ORING -1 SHOULD LEAVE
	ERROR AC,RAN		;AC UNCHANGED
	LOOP BOLOC1-3,BOLOC1


;TEST ANDCM (AND WITH THE COMP OF MEMORY)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BOLAX:	SETUP 140,0
	RANDOM
BOLAX1:	ANDCM AC,RAN		;LIKE NUMBERS SHOULD
	CAME AC,[0]		;PRODUCE 0
	ERROR AC,[0]		;ANDCM FAILED
	ANDCM AC,RAN		;ANYTHING ANDED TO
	CAME AC,[0]		;ZERO SHOULD = 0
	ERROR AC,[0]
	SETO	AC,
	ANDCM AC,RAN		;AC SHOULD - COMP OF MEMORY
	ANDCM AC,[0]		;AC SHOULD REMAIN UNCHANGED
	XOR AC,[-1]		;COMP AC
	CAME AC,RAN		;AFTER COMP SHOULD EQUAL
	ERROR AC,RAN		;RANDOM. ANDCM FAILED
	LOOP BOLAX1-3,BOLAX1


;TEST ORCB (INCLUSIVE OR THE COMPLEMENT OF AC AND C(E))
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=1
BOLOB:	SETUP 140,0
	RANDOM
BOLOB1:	ORCB AC,RAN		;PRODUCE COMP OF RAN
	ORCB AC,[-1]		;COMP AC
	CAME AC,RAN		;CHECK ORCB
	ERROR AC,RAN
	ORCB AC,[-1]		;COMP AC
	ORCB AC,RAN		;ANY TWO COMPLEMENTED NUMBERS
	CAME AC,[-1]		;SHOULD PRODUCE ALL ONES
	ERROR AC,[-1]
	ORCB AC,[0]		;AC COMPLEMENTS TO 0
	CAME AC,[-1]
	ERROR AC,[-1]		;ORCB FAILED
	LOOP BOLOB1-4,BOLOB1


;TEST ANDCB (AND WITH BOTH OPERANDS COMPLEMENTED)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
BOLAB:	SETUP 140,0
	RANDOM
BOLAB1:	ANDCB AC,RAN		;PRODUCE COMP OF RAN
	ANDCB AC,[0]		;COMP AC
	CAME AC,RAN		;CHECK FOR ORIGIONAL NUMBER
	ERROR AC,RAN		;ANDCB FAILED
	ANDCB AC,[0]		;COMPLEMENT AC
	ANDCB AC,[0]		;RECOMPLEMENT AC
	CAME AC,RAN		;SHOULD PRODUCE ORIGIONAL
	ERROR AC,RAN		;ANDCB FAILED
	ANDCB AC,[-1]		;RESULT SHOULD BE 0 IF
	CAME AC,[0]		;CONTENTS OF E
	ERROR AC,[0]		;CONTAINS NO BITS AFTER COMP
	ANDCB AC,RAN		;AC SHOULD EQUAL COMP OF RAN
	ANDCB AC,[0]		;COMP AC
	CAME AC,RAN		;THE AND TO 0
	ERROR AC,RAN		;FAILED
	LOOP BOLAB1-3,BOLAB1


;TEST SETA (EFFECTIVELY A NO OPERATION IN THIS MODE)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=3
BOLSA:	SETUP 100,0
	RANDOM
		;DO 7 SETA'S.
BOLSA1:	REPEAT 7,<
	SETA AC,.>
	CAME AC,RAN		;C(AC) SHOULD = ORIG. C(AC)
	ERROR AC,RAN
	LOOP BOLSA1-3,BOLSA1


;TEST IORM, WHERE E IS AN AC. THE INST IS TESTED
;FOR NOT STORING IN AC AS WELL AS STORING PROPERLY
;IN E.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=11
BMIOR:	SETUP 100,1
BMIOR1:	RANDOM
BMIOR2:	MOVS AC1,AC		;AC=C(E) ORIG
	CAMN AC,AC1		;HALVES SAME?
	JRST BMIOR1		;YES. REJECT.
	SETCM AC		;SIM AN
	AND AC1			;IOR
	XOR	AC		;INST
	IORM AC,AC1		;RESULT TO AC1
	CAMN AC,AC1		;BOTH SAME?
	ERROR AC,AC1		;YES. STORED IN AC.
	CAME AC1,0		;C(E) = SIM. ANS?
	ERROR AC,0		;NO. IORM FAILED.
	LOOP BMIOR1,BMIOR2


;TEST ORCAM, WHERE E IS AN AC. THE INSTRUCTION IS TESTED
;FOR NOT STORING IN AC AS WELL AS STORING PROPERLY IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=12
BMICA:	SETUP 100,1
BMICA1:	RANDOM
BMICA2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETCM AC2,AC1		;MOVE COMPLEMENT OF NUMBER
	SETCM	AC		;SIMULATE
	AND	AC2		;THE INSTRUCTION
	XOR	AC		;IN AC0.
	ORCAM AC1,AC		;RESULT TO C(E)
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. STORED IN AC.
	CAME AC,0		;C(E) = SIM. ANS?
	ERROR AC,0		;NO. ORCAM FAILED.
	LOOP BMICA1,BMICA2


;TEST ORCMM, WHERE E IS AN AC. THE INSTRUCTION
;IS TESTED FOR NOT STORING IN AC AS WELL AS THE
;CORRECT ANSWER IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=13
BMICM:	SETUP 100,0
BMICM1:	RANDOM
BMICM2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETCM AC2,AC		;SIMULATE
	SETCM	AC1		;THE
	AND	AC2		;INSTRUCTION
	XOR	AC1		;IN AC0
	CAMN	0,AC1		;IS SIMULATED ANS
	JRST	BMICM1		;= C(AC)?...REJECT.
	ORCMM AC1,AC		;IF AC1 = AC, STORE INHIBIT
	CAMN AC1,AC
	ERROR AC1,AC		;FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;ORCMM FAILED.
	LOOP BMICM1,BMICM2


;TEST ORCBM, WHERE E IS AN AC. THE INSTRUCTION
;IS TESTED FOR NOT STORING IN AC AS WELL AS THE
;CORRECT ANSWER IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=14
BMICB:	SETUP 200,0
BMICB1:	RANDOM
BMICB2:	MOVS AC1,AC		;AC1= 0101,0011
	SETCM AC2,AC		;AC2= 1100,1010
	SETCM	AC2		;AC0 = 0011,0101
	ANDCM	AC1		;AC0 = 0010,0100
	XOR	AC2		;AC0 = 1110,1110
	ORCBM AC1,AC		;SHOULD PRODUCE SAME LOGIC
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;ORCBM FAILED.
	LOOP BMICB1,BMICB2


;TEST XORM, WHERE E IS AN AC. THE INSTRUCTION IS
;TESTED FOR NOT STORING AC AS WELL AS CONTENTS
;OF E CORRECTNESS.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BMX:	SETUP 200,1
BMX1:	RANDOM
BMX2:	JUMPE AC,BMX1		;REJECT IF RAN = 0.
	MOVS AC1,AC		;SECOND RANDOM NUMBER.
	SETCM	AC
	ANDCA	AC1		;PERFORM
	MOVE AC2,AC		;A PSEUDO
	IOR AC2,AC1		;EXCLUSIVE
	ANDCA	AC2		;OR INSTRUCTION
	XORM AC1,AC		;DO THE XOR
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;XORM FAILED.
	LOOP BMX1,BMX2


;TEST EQVM, WHERE E IS AN AC. THE INSTRUCTION
;IS TESTED FOR NOT STORING AC AS WELL AS
;CORRECTNESS OF C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BMEQ:	SETUP 100,0
BMEQ1:	RANDOM
BMEQ2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETCM AC1		;EQV IS SAME LOGIC
	XOR AC			;AS XOR WITH COMP AC
	EQVM AC1,AC		;EQV SETS ALL LIKE BITS
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;EQVM FAILED.
	LOOP BMEQ1,BMEQ2



;TEST ANDM, WHERE E IS AN AC. THE INSTRUCTION IS
;TESTED FOR NOT STORING IN AC AS WELL AS STORING
;PROPERLY IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=3
BMAN:	SETUP 100,0
BMAN1:	RANDOM
BMAN2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	MOVE	AC		;SIMULATE
	IOR	AC1		;AN "AND"
	XOR	AC1		;INSTRUCTION.
	XOR AC			;IN AC0
	CAMN AC1,AC		;REJECT THE NUMBER
	JRST BMAN1		;IF EQUAL.
	ANDM AC1,AC		;THE INSTRUCTION
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;AND FAILED.
	LOOP BMAN1,BMAN2



;TEST ANDCAM, WHERE E IS AN AC. THE INSTRUCTION IS
;TESTED FOR NOT STORING IN AN AC AS WELL AS
;STORING C(E) PROPERLY.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=4
BMACA:	SETUP 100,0
BMACA1:	RANDOM
BMACA2:	JUMPE AC,BMACA1		;REJECT IF RAN = 0.
	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETM	AC		;SIMULATE
	ORCA	AC1		;ANDCA
	SETCA			;LOGIC
	ANDCAM AC1,AC		;THE INSTRUCTION
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;ANDCA FAILED.
	LOOP BMACA1,BMACA2


;TEST ANDCMM, WHERE E IS AN AC. THE INSTRUCTION IS
;TESTED FOR NOT STORING IN AN AC AS WELL AS
;STORING C(E) PROPERLY.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=5
BMACM:	SETUP 100,0
BMACM1:	RANDOM
BMACM2:	JUMPE AC,BMACM1		;REJECT IF RAN = 0.
	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETAM AC1,0		;AC1 TO AC0.
	IOR	AC		;SIMULATE
	XOR	AC		;THE INSTUCTION
	CAMN	0,AC1		;SIM ANS = C(AC)?
	JRST	BMACM1		;YES. REJECT.
	ANDCMM AC1,AC		;DO AN ANDCMM INSTRUCTION.
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;ANDCMM FAILED.
	LOOP BMACM1,BMACM2


;TEST ANDCBM, WHERE E IS AN AC. THE INSTRUCTION
;IS TESTED FOR NOT STORING IN AC AS WELL AS STORING
;PROPERLY IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=7
BMACB:	SETUP 100,0
BMACB1:	RANDOM
BMACB2:	MOVS AC1,AC		;SECOND RANDOM NUMBER.
	SETCM	AC1		;SIMULATE
	SETCM 1,AC		;AN
	AND	1		;ANDCBM INST.
	ANDCBM	AC1,AC		;DO AN ANDCBM.
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;ANDCBM FAILED.
	LOOP BMACB1,BMACB2


;TEST SETCAM, WHERE E IS AN AC. THE INSTRUCTION
;IS TESTED FOR NOT STORING IN AC AS WELL AS
;PROPER C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BMCMM:	SETUP 200,0
BMCMM1:	RANDOM
BMCMM2:	MOVS AC1,AC		;CHECK FOR NO CHANGE
	CAMN	AC1,AC		;IN 8 COMPLEMENTS
	JRST BMCMM1		;REJECT IF HALF SAME.

	REPEAT 10,<
	SETCMM AC1,AC>
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,RAN		;C(E) SHOULD = ORIG. C(E).
	ERROR AC,RAN		;SETCMM FAILED.
	LOOP BMCMM1,BMCMM2


 ;TEST SETCAM, WHERE E IS AN AC. TEST FOR NOT
;STORING IN AC AS WELL AS PROPER STORAGE IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=11
BMCAM:	SETUP 100,0
BMCAM1:	RANDOM
BMCAM2:	MOVS AC1,AC		;SECOND RANDOM NUMBER.
	SETCM	AC1		;SIMULATE SETCAM.
	SETCAM AC1,AC		;DO SETCAM.
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;SETCAM FAILED.
	LOOP BMCAM1,BMACM2


;TEST SETAM, WHERE E IS AN AC.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BMSA:	SETUP 100,0
BMSA1:	RANDOM
BMSA2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	CAMN AC1,AC
	JRST BMSA1		;REJECT IF SAME.
	SETAM AC,AC1		;C(AC) TO C(AC1)
	CAME AC,AC1		;EQUAL?
	ERROR AC,AC1		;NO.
	CAME AC1,RAN		;C(E) SHOULD = ORIG C(AC).
	ERROR AC1,RAN		;SETAM FAILED.
	LOOP BMSA1,BMSA2


;TEST SETOM, WHERE E IS AN AC.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BMSM:	SETUP 100,0
BMSM1:	RANDOM
BMSM2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETOM AC1,AC		;DO SETOM INST.
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,[-1]		;C(E) SHOULD = A -1.
	ERROR AC,[-1]		;SETOM FAILED.
	LOOP BMSM1,BMSM2


;TEST SETMM, WHERE E IS AN AC.
;ERRORS ARE IN THE FORM (PC, AC,C(AC),CORRECT)

	AC=10
BMSMM:	SETUP 100,0
BMSMM1:	RANDOM
BMSMM2:	MOVS AC1,AC		;A SECOND RANDOM NUMBER
	CAMN AC,AC1		;REJECT IF
	JRST BMSMM1		;HALF SAME
		;DO 8 SETMM...SHOULD NOT CHANGE C(E).
	REPEAT 10,<
	SETMM AC1,AC>
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,RAN		;C(E) SHOULD = ORIG. C(E).
	ERROR AC,RAN		;SETMM FAILED.
	LOOP BMSMM1,BMSMM2


;TEST SETZM, WHERE E IS AN AC. TESTS FOR NOT STORING
;IN AC AS WELL AS STORING IN C(E) PROPERLY.

	AC=10
SETZM1:	SETUP 40,0
SETZM2:	RANDOM
SETZM3:	JUMPE AC,SETZM2		;REJECT IF C(AC) = 0.
	SETOB AC1,RAN1		;SET C(AC) TO ALL ONES.
	SETZM AC1,AC		;DO SETZM
	CAME AC,[0]		;DID AC GET CLEARED?
	EERR	,RAN1		;NO.
	CAME AC1,[-1]		;DOES C(AC1) STILL = -1?
	EERR	,RAN1		;NO.
	LOOP SETZM2,SETZM3


;TEST ROT LEFT 3X(2X18). CHECKING FOR AC1 NOT CHANGED
;AS WELL AS C(AC) BEING THE PROPER NUMBER.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
ROTL2:	SETUP 200,2
ROTL2A:	RANDOM
ROTL2B:	SETOB AC1,RAN1		;SET AC+1 TO ALL ONES.
		;DO 6 X (ROT LEFT 18 PLACES).
	REPEAT 3,<
	ROT AC,22
	ROT AC,22>
	CAME AC,RAN		;C(AC)SHOULD = C(AC) BEFORE ROT.
	EERRI	,22
	CAME AC1,[-1]		;AC1 SHOULD NOT HAVE CHANGED.
	ERR	RAN1,22
	LOOP ROTL2A,ROTL2B

;TEST ROT RIGHT 3X(2X18)..CHECKING FOR AC1 NOT
;CHANGED AS WELL AS C(AC) ENDING UP BEING
;THE SAME AS IT WAS BEFORE THE ROT.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
ROTR2:	SETUP 300,2
ROTR2A:	RANDOM
ROTR2B:	SETOB AC1,RAN1		;SET AC+1 TO ALL ONES.
		;DO 6 X (ROT RIGHT 18 PLACES).
	REPEAT 3,<
	ROT AC,-22
	ROT AC,-22>
	CAME AC,RAN		;C(AC) SHOULD = C(AC) BEFORE ROT.
	EERR	,-22
	CAME AC1,[-1]		;C(AC1) SHOULD STILL = -1.
	ERRI	RAN1,-22
	LOOP ROTR2A,ROTR2B


;TEST ROT LEFT 3X36. CHECKING FOR AC1 NOT
;CHANGED AND C(AC) = WHAT IT WAS BEFORE
;ROT.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
RTL36:	SETUP 300,2
RTL36A:	RANDOM
RTL36B:	SETOB	AC1,RAN1	;SET AC+1 TO ALL ONES.
		;DO 3 X (ROT LEFT 36 PLACES).
	REPEAT 3,<
	ROT AC,44>
	CAME AC,RAN		;C(AC) SHOULD = C(AC) BEFORE ROT.
	EERRI	,44
	CAME AC1,[-1]		;C(AC1) SHOULD STILL = -1.
	ERRI	RAN1,44
	LOOP RTL36A,RTL36B


;TEST ROT RIGHT 3X36. CHECKING FOR AC1 NOT
;CHANGED AND C(AC) = WHAT IT DID BEFORE ROT.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
RTR36:	SETUP 300,2
RTR36A:	RANDOM
RTR36B:	SETOB AC1,RAN1		;SET AC+1 TO ALL ONES.
		;DO 3 X (ROT RIGHT 36 PLACES).
	REPEAT 3,<
	ROT AC,-44>
	CAME AC,RAN		;C(AC) SHOULD = RAN.
	EERRI	,-44
	CAME AC1,[-1]		;C(AC1) SHOULD STILL = -1.
	ERRI	RAN1,-44
	LOOP RTR36A,RTR36B


;TEST ROTC LEFT 3X36 THROUGH ALL AC'S CHECKING
;FOR C(AC) AND C(AC1) BEING EXCHANGED
;AFTER THE ROTC.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
RTCL:	SETUP 100,2
RTCLA:	RANDOM

RTCLB:	REPEAT ^D10,<
	MOVE AC,RAN		;MOVE A RAN NUM INTO AN AC.
	SETOB	AC1,RAN1	;SET AC+1 TO ALL ONES.
		;DO 3 X (ROTC LEFT 36 PLACES).
	REPEAT 3,<
	ROTC AC,44>
	CAME AC1,RAN		;C(AC1) SHOULD = RAN.
	EERRI	,44
	CAME AC,[-1]		;C(AC) SHOULD = A -1.
	ERRI	RAN1,44
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=2
	LOOP RTCLA,RTCLB


;TEST ROTC RIGHT 3X36 THROUGH ALL AC'S. CHECKING
;FOR C(AC) AND C(AC1) BEING EXCHANGED.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
RTCR:	SETUP 100,2
RTCRA:	RANDOM

RTCRB:	REPEAT ^D10,<
	MOVE AC,RAN		;MOVE A RAN NUM INTO AN AC.
	SETOB AC1,RAN1		;SET AC+1 TO ALL ONES.
		;DO 3 X (ROTC RIGHT 36 PLACES).
	REPEAT 3,<
	ROTC AC,-44>
	CAME AC1,RAN		;C(AC1) SHOULD = C(AC) BEFORE ROTC.
	EERRI	,-44
	CAME AC,[-1]		;C(AC) SHOULD = C(AC1) BEFORE ROTC.
	ERRI	RAN1,-44
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=2
	LOOP RTCRA,RTCRB


;TEST ROT. ROT A RANDOM NUMBER A RANDOM NUMBER OF TIMES
;IN ONE DIRECTION AND THEN THE SAME NUMBER OF TIMES
;IN THE OPPOSITE DIRECTION.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT).

	AC=2
ROTLR:	SETUP 100,4
ROTLR1:	RANDOM
	MOVE AC3,RAN		;CHECK TO SEE
	AND AC3,[377]		;THAT THE RIGHT MOST 8 BITS
	JUMPE AC3,ROTLR1	;DO NOT = 0..REJECT IF THEY DO.
ROTLR2:	MOVN AC2,RAN		;PUT 2'S COMP OF RAN INTO AC2.
	SETOB AC1,RAN1		;SET AC+1 TO ALL ONES.
	ROT AC,(AC)		;ROT AC A RANDOM NUMBER OF TIMES.
	ROT AC,(AC2)		;ROT AC THE SAME NUM OF TIMES
				;IN THE OPPOSITE DIRECTION.
	CAME AC,RAN		;C(AC) SHOULD STILL = C(RAN).
	ERROR AC,RAN
	CAME AC1,[-1]		;C(AC1) SHOULD STILL = -1.
	ERROR AC1,[-1]
	LOOP ROTLR1,ROTLR2


;TEST ROTC. DO A ROTC WITH A RANDOM NUMBER A RANDOM
;NUMBER OF TIMES IN ONE DIRECTION AND THEN THE SAME
;NUMBER OF TIMES IN THE OPPOSITE DIRECTION.
;REPEAT THIS TEST FOR ALL AC'S.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
RTCLR:	SETUP 200,3
RTCLR1:	RANDOM
	MOVE AC3,RAN		;CHECK TO SEE
	AND AC3,[377]		;THAT THE RIGHT MOST 8 BITS
	JUMPE AC3,RTCLR1	;DO NOT = 0..REJECT IF THEY DO.

RTCLR2:	REPEAT ^D10,<
	MOVE AC,RAN		;MOVE A RAN NUM INTO AN AC.
	MOVN AC2,RAN		;MOVE THE 2'S COMP INTO ANOTHER AC.
	SETO AC1,		;SET AC1 TO ALL ONES.
	ROTC AC,(AC)		;ROTC AC A RANDOM NUMBER OF
				;TIMES IN ONE DIRECTION.
	ROTC AC,(AC2)		;ROTC AC THE SAME NUMBER OF
				;TIMES IN THE OPPOSITE DIRECTION.
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN.
	ERROR AC,RAN
	CAME AC1,[-1]		;C(AC1) SHOULD STILL =-1
	ERROR AC1,[-1]
	AC=<AC+1>&17
	AC1=<AC+1>&17
	AC2=<AC+2>&17

>
	AC=2
	LOOP RTCLR1,RTCLR2


;TEST OVERFLOW ON A ROT LEFT...AROV SHOULD NOT COME UP.

	AC=2
ROTOV:	SETUP 20,0
ROTOV1:	RANDOM
ROTOV2:	JUMPE AC,ROTOV1		;REJECT IF RAN = 0.
	CAMN AC,[-1]		;ALSO REJECT IF RAN = -1.
	JRST ROTOV1
	JFCL 10,.+1		;CLEAR OV FLAG.
	ROT AC,256		;ROT C(AC) 256 TIMES.
	JFCL 10,.+2		;OV FLAG GET SET?
	JRST .+2		;NO.
	ER AC,[ASCII /OV/]	;YES. SHOULD NOT SET ON A ROT.
	LOOP ROTOV1,ROTOV2


;TEST OVERFLOW FLAG ON A ROT RIGHT...SHOULD NEVER GET SET.

	AC=3
RTROV:	SETUP 20,0
RTROV1:	RANDOM
RTROV2:	JUMPE AC,RTROV1		;REJECT IF RAN = 0.
	CAMN AC,[-1]		;ALSO REJECT IF RAN = -1.
	JRST RTROV1
	JFCL 10,.+1		;CLEAR OVERFLOW FLAG.
	ROT AC,-256		;ROT AC RIGHT 256 TIMES.
	JFCL 10,.+2		;OVERFLOW FALG GET SET?
	JRST .+2		;NO.
	ER AC,[ASCII /OV/]
	LOOP RTROV1,RTROV2


;TEST MOVEM. AFTER <MOVEM AC,AC1> FOLLOWED BY
;<MOVEM AC1,AC>, C(AC) SHOULD = ORIG C(AC).
;RAN TO RAN1.

	AC=2
MVEM1:	SETUP 30,0
MVEM2:	RANDOM
		;DO 3 SETS OF MOVEM'S.
MVEM3:	REPEAT 3,<
	MOVEM AC,AC1
	MOVEM AC1,AC>
	CAME	AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERROR	AC,RAN
	CAME AC1,RAN		;C(AC1) SHOULD ALSO = ORIG. C(AC).
	ERROR AC1,RAN
	LOOP MVEM2,MVEM3


;TEST MOVES. AFTER 6 MOVES IN A ROW, THE C(E)
;SHOULD = ORIG C(E).

	AC=2
MVES1:	SETUP 200,1
MVES2:	RANDOM
		;DO 6 MOVE INSTRUCTIONS.
MVES3:	REPEAT 3,<
	MOVES	AC1,AC
	MOVES	AC1,AC>
	CAME	AC1,AC		;C(AC) SHOULD = C(E).
	ERROR	AC1,AC
	CAME	AC,RAN		;C(E) SHOULD = ORIG C(E).
	ERROR	AC,RAN
	LOOP MVES2,MVES3


;TEST MOVS INSTRUCTION...TWO MOVS SHOULD GIVE SAME NUMBER.

	AC=4
MOVSA:	SETUP 200,2
MOVSB:	RANDOM
		;DO 6 MOVS INSTRUCTIONS.
MOVSC:	REPEAT 3,<
	MOVS AC,AC
	MOVS AC,AC>
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN.
	EERR	,RAN
	LOOP MOVSB,MOVSC


;TEST MOVS INSTRUCTION...MOVS FOLLOWED BY ROT SHOULD GIVE
;SAME NUMBER.

	AC=5
MOVS1:	SETUP 200,1
MOVS2:	RANDOM
MOVS3:	MOVS AC,AC		;DO MOVS INSTRUCTION.
	ROT AC,22		;ROT LEFT 18 PLACES.
	CAME AC,RAN		;C(AC) SHOULD NOW = RAN.
	EERR	,RAN
	LOOP MOVS2,MOVS3


;TEST MOVSM....TWO MOVSM SHOULD GIVE THE ORIG. NUM.

	AC=6
MOVSMA:	SETUP 300,1
MOVSMB:	RANDOM

MOVSMC:	REPEAT 3,<
	MOVSM AC,AC1
	MOVSM AC1,AC>
	CAME AC,RAN		;C(AC) SHOULD NOW BE = TO RAN.
	ERROR AC,RAN
	LOOP MOVSMB,MOVSMC


;TEST MOVSS...TWO MOVSS SHOULD GIVE THE ORIGINAL NUMBER.

	AC=7
MOVSSA:	SETUP 200,0
MOVSSB:	RANDOM
MOVSSC:	SETZB 0,RAN1		;CLEAR AC0.

	REPEAT 3,<
	MOVSS	AC
	MOVSS	AC>
	CAME AC,RAN		;C(AC) SHOULD NOW BE = TO RAN.
	EERR	,RAN1
	CAME	[0]		;C(AC0) SHOULD STILL = 0.
	EERR	,RAN1
	LOOP MOVSSB,MOVSSC


;TEST MOVSI.

	AC=10
MOVSIA:	SETUP 100,0
MOVSIB:	RANDOM
	MOVE AC2,RAN		;PUT RAN INTO AN AC.
MOVSIC:	ANDI AC,-1		;SIMULATE
	ROT AC,22		;A MOVSI INST.
	MOVSI AC1,(AC2)		;DO MOVSI.
	CAME AC1,AC		;C(AC1) SHOULD = SIM. ANS.
	ERROR AC1,AC
	LOOP MOVSIB,MOVSIC


;TEST LSH. SIMULATE A LSH 18 PLACES WITH A MOVSI.

	AC=11
LSHA:	SETUP 200,1
LSHB:	RANDOM
LSHC:	SETO	AC1,		;SET AC+1 TO ALL ONES.
	MOVSI AC2,(AC)		;SIMULATE LSH 18 PLACES.
	LSH AC,22		;DO LSH
	CAME AC,AC2		;C(AC) SHOULD = SIM. ANS.
	ERROR AC,AC2
	CAME AC1,[-1]		;AC1 GET CHANGED?
	ERROR AC1,[-1]		;YES.
	LOOP LSHB,LSHC


;TEST LSH RIGHT 18 PLACES.

	AC=10
LSH1:	SETUP 200,1
LSH2:	RANDOM
LSH3:	SETOB AC1,RAN1		;SET C(AC+1) TO ALL ONES.
	LSH AC,-22		;DO LSH RIGHT 18 PLACES.
	MOVS AC2,RAN		;SIMULATE
	ANDI AC2,-1		;LSH.
	CAME AC,AC2		;C(AC) SHOULD = SIM. ANS.
	EERRI	,-22
	CAME AC1,[-1]		;C(AC+1) GET CHANGED?
	ERRI	RAN1,-22
	LOOP LSH2,LSH3


;TEST ASH ABILITY TO SET OR NOT SET OVERFLOW FLAG.

	AC=10
ASHOV:	SETUP 30,0
ASHOV1:	SETO	AC,		;SET AC TO ALL ONES..1,1 CONDITION.
	JFCL	10,.+1		;CLEAR OV FLAG.
	ASH AC,1		;DO ASH.
	JFCL 10,.+2		;OVERFLOW FLAG GET SET?
	JRST .+2		;NO.
	ER AC,[ASCII /OV/]	;YES. 1,1 CONDITION SHOULD NOT SET IT.
	JFCL 10,.+1		;CLEAR OV FLAG.
	SETZ AC,		;CLEAR AC...0,0 CONDITION.
	ASH AC,1		;DO ASH.
	JFCL 10,.+2		;OVERFLOW FLAG GET SET?
	JRST .+2		;NO.
	ER AC,[ASCII /OV/]	;YES. 0,0 COND. SHOULDN'T SET IT.
	JFCL 10,.+1		;CLEAR OV FLAG.
	MOVSI AC,377777		;SET AC FOR 0,1 CONDITION.
	ASH AC,1		;DO ASH.
	JFCL 10,.+2		;OVERFLOW FLAG GET SET?
	ER AC,[ASCII /OV/]	;NO. 0,1 COND. SHOULD SET IT.
	JFCL 10,.+1		;CLEAR OV FLAG.
	MOVSI AC,400000		;SET AC FOR 1,0 CONDITION.
	ASH AC,1		;DO ASH.
	JFCL 10,.+2		;OV FLAG GET SET?
	ER AC,[ASCII /OV/]	;NO. 1,0 COND. SHOULD SET IT.
	LOOP ASHOV1,ASHOV1


;TEST ASH. DO ASH RIGHT 36 PLACES WITH ORIG.
;C(AC) = 400000000000. AFTER ASH THE C(AC) SHOULD = A -1.

	AC=10
ASH1:	SETUP 20,0
ASH2:	MOVE AC,[XWD 400000,0]	;MAKE C(AC) = ALL 0'S WITH SIGN BIT SET.
	ASH AC,-44		;DO ASH RIGHT 36 PLACES...SIGN
	CAME AC,[-1]		;BIT SHOULD HAVE SET ALL BITS TO A ONE.
	ERROR AC,[-1]
	LOOP ASH2,ASH2


;TEST ASH. DO ASH LEFT 36 PLACES WITH ORIG. C(AC) =
;TO A -1. AFTER ASH THE C(AC) SHOULD = THE SIGN
;BIT SET AND THE REST ZEROS.

	AC=11
ASH3:	SETUP 20,0
ASH4:	MOVE AC,[-1]		;MAKE C(AC) = A -1.
	ASH AC,44		;DO ASH LEFT 36 PLACES..0'S GOING
	CAME AC,[XWD 400000,0]	;INTO BIT 35 SHOULD JUST LEAVE SIGN BIT SET.
	ERROR AC,[0]
	LOOP ASH4,ASH4


;TEST ADD. RAN TO 0 CONDITION.

	AC=10
ADD1:	SETUP 100,0
ADD2:	RANDOM
ADD3:	SETZ AC,		;CLEAR AC.
	ADD AC,RAN		;ADD RAN TO 0.
	CAME AC,RAN		;C(AC) SHOULD = RAN NUM.
	ERROR AC,RAN
	LOOP ADD2,ADD3


; TEST ADD. 0 TO RAN CONDITION.

	AC=10
ADD1A:	SETUP 100,0
ADD2A:	RANDOM
		;ADD A CONSTANT 0 TO RAN 5 TIMES.
ADD3A:	REPEAT 5,<
	ADD AC,[0]>
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN NUM.
	ERROR AC,RAN
	LOOP ADD2A,ADD3A


;TEST ADD. ADD 1'S COMP OF RAN TO RAN.
;SHOULD GET A -1.

	AC=10
ADD1B:	SETUP 100,0
ADD2B:	RANDOM
ADD3B:	SETCM AC1,RAN		;1'S COMP OF RAN TO AC1.
	ADD AC,AC1		;ADD IT TO RAN.
	CAME AC,[-1]		;C(AC) SHOULD = -1.
	ERROR AC,[-1]
	LOOP ADD2B,ADD3B


;TEST ADD. CHECK CRY0,CRY1,AND OV FLAGS.
;ADD, TO A RANDOM NUMBER, A -1 AND THEN A +1.
;CRY0 AND CRY1 SHOULD BOTH GET SET AND AROV SHOULD NOT GET SET.

	AC=10
ADD1C:	SETUP 400,2
ADD2C:	RANDOM
ADD3C:	JFCL 17,.+1		;CLEAR ALL FLAGS.
	ADD AC,[-1]		;ADD A -1 TO RAN.
	ADD AC,[1]		;ADD A +1 TO ANS OF ADDITION OF RAN AND A -1.
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERROR AC,RAN
	JFCL 4,CRY0A
	JFCL 2,.+2
	JRST	BOTHF
	ER	AC,[ASCII /CRY0/];CRY0 FAILED TO GET SET.
CRY0A:	JFCL	2,.+2
	ER	AC,[ASCII /CRY1/];CRY1 FAILED TO GET SET.
	JRST	AROVA
BOTHF:	ER	AC,[ASCII /CRY01/];BOTH CRY0 + CRY1 FAILED TO GET SET.
AROVA:	JFCL	10,.+2
	JRST	ADD4C
	ER	AC,[ASCII /OV/]	;AROV GOT SET.
ADD4C:	LOOP ADD2C,ADD3C


;TEST ADDM. WHERE E IS AN AC.
;RAN TO 0 CONDITION.

	AC=4
ADDM1:	SETUP 100,0
ADDM2:	RANDOM
	MOVE AC2,RAN		;SAVE RAN IN AN AC.
ADDM3:	SETZB AC1,RAN1		;MAKE C(E) = 0.
	ADDM AC,AC1		;DO ADDM.
	CAME AC2,AC1		;C(E) SHOULD =ORIG C(AC).
	ERRM RAN1,RAN
	LOOP ADDM2,ADDM3


;TEST ADDM. WHERE E IS AN AC.
;0 TO RAN CONDITION.

	AC=5
ADDM1A:	SETUP 100,0
ADDM2A:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
ADDM3A:	SETZB AC1,RAN1		;MAKE C(AC) = 0.
	ADDM AC1,AC		;DO ADDM.
	CAME AC2,AC		;C(E) SHOULD = ORIG C(E).
	EERRM	,RAN1
	LOOP ADDM2A,ADDM3A


;TEST ADDM. WHERE E IS AN AC.
;1'S COMP RAN TO RAN.

	AC=6
ADDM1B:	SETUP 100,0
ADDM2B:	RANDOM
ADDM3B:	SETCM AC1,AC		;MAKE C(AC) = 1'S COMP OF C(E).
	MOVE RAN1,AC1		;SAVE C(AC) IN CASE OF ERROR.
	ADDM AC1,AC		;DO ADDM.
	CAME AC,[-1]		;C(E) SHOULD = A -1.
	EERRM	,RAN1
	LOOP ADDM2B,ADDM3B


;TEST ADDI. CHECK C(AC) FOR CORRECT DATA.
;0 TO RAN CONDITION.

	AC=2
ADDI1:	SETUP 20,0
ADDI2:	RANDOM
ADDI3:	ADDI AC,0		;DO ADDI.
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	EERRI	,0
	LOOP ADDI2,ADDI3


;TEST ADDI. CHECK FOR CORRECT DATA IN AC.
;RAN TO 0 CONDITION.

	AC=2
ADDI1A:	SETUP 100,0
ADDI2A:	RANDOM
ADDI3A:	SETZB AC1,RAN1		;CLEAR C(AC).
	MOVEI AC2,(AC)		;SIMULATE ADDI.
	ADDI AC1,(AC)		;DO ADDI.
	CAME AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,(AC)
	LOOP ADDI2A,ADDI3A


;TEST ADDI. CHECK FOR CORRECT DATA IN AC.
;1'S COMP RAN TO RAN.

	AC=3
ADDI1B:	SETUP 40,0
ADDI2B:	RANDOM
ADDI3B:	SETCM AC1,AC		;MAKE C(AC) = 1'S COMP OF E.
	MOVE AC2,AC1		;SIMULATE
	IORI AC2,-1		;ADDI INST.
	MOVE RAN1,AC1		;SAVE C(AC) IN CASE OF ERROR.
	ADDI AC1,(AC)		;DO ADDI.
	CAME AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	ERRI RAN1,(AC)
	LOOP ADDI2B,ADDI3B


;TEST ADDB. CHECK FOR C(AC) = C(E), AND CORRECT
;DATA IN AC FOR 0 TO RAN CONDITION.

	AC=4
ADDB1:	SETUP 100,0
ADDB2:	RANDOM
ADDB3:	SETZB AC1,RAN1		;CLEAR C(E).
	ADDB AC,AC1		;DO ADDB.
	CAME AC,AC1		;C(AC) SHOULLD = C(E).
	ERR RAN1,RAN
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR RAN1,RAN
	LOOP ADDB2,ADDB3


;TEST ADDB. CHECK FOR C(AC) = C(E), AND CORRECT
;DATA IN AC FOR RAN TO 0 CONDITION.

	AC=5
ADDB1A:	SETUP 100,0
ADDB2A:	RANDOM
ADDB3A:	SETZB AC1,RAN1		;CLEAR C(AC).
	ADDB AC1,AC		;DO ADDB.
	CAME AC1,AC		;C(AC) SHOULD = C(E).
	EERR	,RAN1
	CAME AC1,RAN		;C(AC) SHOULD = ORIG C(E).
	EERR	,RAN1
	LOOP ADDB2A,ADDB3A


;TEST ADDB. CHECK FOR C(AC) = C(E), AND CORRECT DATA
;IN AC FOR NOT RAN TO RAN CONDITION.

	AC=6
ADDB1B:	SETUP 100,0
ADDB2B:	RANDOM
ADDB3B:	SETCM AC1,AC		;MAKE C(E) = 1'S COMP OF C(AC).
	MOVE RAN1,AC1		;SAVE C(E) IN CASE OF ERROR.
	ADDB AC,AC1		;DO ADDB.
	CAME AC,AC1		;C(AC) SHOULD = C(E).
	ERR	RAN1,RAN
	CAME AC,[-1]		;C(AC) SHOULD = A -1.
	ERR RAN1,RAN
	LOOP ADDB2B,ADDB3B


;TEST SUB. CHECK C(AC) FOR CORRECT DATA.
;0 TO RAN CONDITION.

	AC=2
SUB1:	SETUP 100,0
SUB2:	RANDOM
SUB3:	SETZB AC1,RAN1		;CLEAR C(E).

	REPEAT 3,<
	SUB AC,AC1>
	CAME AC,RAN		;C(AC) SHOULD STILL = ORIG C(AC).
	ERR RAN1,RAN
	LOOP SUB2,SUB3


;TEST SUB. CHECK C(AC) FOR CORRECT DATA.
;RAN TO 0 CONDITION.

	AC=2
SUB1A:	SETUP 100,0
SUB1B:	RANDOM
SUB1C:	SETZB AC1,RAN1		;CLEAR C(AC).
	MOVN AC2,RAN		;ANY NUM FROM 0 = 2'S COMP OF THAT NUM.
	SUB AC1,AC		;SUBTRACT RAN FROM 0.
	CAME AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	EERR	,RAN1
	LOOP SUB1B,SUB1C


;TEST SUB. CHECK C(AC) FOR CORRECT DATA.
;SUB RAN FROM RAN.

	AC=2
SUB2A:	SETUP 100,0
SUB2B:	RANDOM
SUB2C:	MOVE AC1,AC		;MAKE C(E) = C(AC).
	SUB AC,AC1		;SUB RAN FROM RAN.
	CAME AC,[0]		;C(AC) SHOULD = 0.
	EERR	,RAN
	LOOP SUB2B,SUB2C


;TEST SUBM. WHERE E IS AN AC.
;RAN TO 0 CONDITION.

	AC=7
SUBM1:	SETUP 100,0
SUBM2:	RANDOM
SUBM3:	SETZB AC1,RAN1		;CLEAR C(AC).
	MOVN AC2,AC		;SIM SUB..RAN FROM 0 = 2'S COMP RAN.
	SUBM AC1,AC		;DO SUBM.
	CAME AC2,AC		;C(E) SHOULD = SIM. ANS.
	EERRM	,RAN1
	LOOP SUBM2,SUBM3

;TEST SUBM. SHERE E IS AN AC.
;0 TO RAN CONDITION.

	AC=10
SUBM1A:	SETUP 100,0
SUBM2A:	RANDOM
	MOVE AC2,RAN		;SAVE RAN IN AN AC.
SUBM3A:	SETZB AC1,RAN1		;CLEAR C(E).
	SUBM AC,AC1		;DO SUBM...0 FROM RAN = RAN.
	CAME AC2,AC1		;C(E) SHOULD = ORIG C(AC).
	ERRM RAN1,RAN
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERRM RAN1,RAN
	LOOP SUBM2A,SUBM3A


;TEST SUBM. WHERE E IS AN AC.
;RAN TO RAN CONDITION.

	AC=11
SUBM1B:	SETUP 100,0
SUBM2B:	RANDOM
SUBM3B:	MOVE AC1,AC		;MAKE C(E) = C(AC).
	SUBM AC,AC1		;DO SUBM.
	CAME AC1,[0]		;C(E) SHOULD = 0.
	EERRM	,RAN
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	EERRM	,RAN
	LOOP SUBM2B,SUBM3B


;TEST SUBI. CHECK C(AC) FOR CORRECT DATA.
;0 TO RAN CONDITION.

	AC=10
SUBI1:	SETUP 20,0
SUBI2:	RANDOM
SUBI3:	SUBI	AC,0		;DO SUBI..0 FROM RAN = RAN.
	CAME	AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	EERRI	,0
	LOOP	SUBI2,SUBI3


;TEST SUBI. CHECK C(AC) FOR CORRECT DATA.
;RAN TO 0 CONDITION.

	AC=10
SUBI1A:	SETUP 20,0
SUBI2A:	RANDOM
SUBI3A:	SETZB	AC1,RAN1	;CLEAR C(AC).
	MOVNI	AC2,(AC)	;SIM SUB..RAN FROM 0 = 2'S COMP RAN.
	SUBI	AC1,(AC)	;DO SUBI.
	CAME	AC1,AC2		;C(AC) SHOULD = SIM ANS.
	ERRI	RAN1,(AC)
	LOOP	SUBI2A,SUBI3A


;TEST SUBI. CHECK C(AC) FOR CORRECT DATA.
;RAN TO RAN CONDITION.

	AC=10
SUBI1B:	SETUP 20,0
SUBI2B:	RANDOM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
SUBI3B:	MOVE	AC1,AC		;SIMULATE A
	AND	AC1,[XWD -1,0]	;SUBI RAN FROM RAN.
	SUBI	AC,(AC)		;DO SUBI.
	CAME	AC,AC1		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,(RAN1)
	LOOP	SUBI2B,SUBI3B


;TEST SUBB. CHECK THAT C(AC) = C(E) AND C(AC)
;= CORRECT DATA.
;0 TO RAN.

	AC=10
SUBB1:	SETUP 20,0
SUBB2:	RANDOM
SUBB3:	SETZB	AC1,RAN1	;CLEAR C(E).
	SUBB	AC,AC1		;DO SUBB..0 FROM RAN = RAN.
	CAME	AC,AC1		;C(AC) SHOULD = C(E).
	ERR	RAN1,RAN
	CAME	AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR	RAN1,RAN
	LOOP	SUBB2,SUBB3


;TEST SUBB. CHECK C(AC) = C(E) AND C(AC) FOR
;CORRECT DATA.
;RAN TO 0 CONDITION.

	AC=10
SUBB1A:	SETUP 20,0
SUBB2A:	RANDOM
SUBB3A:	SETZB	AC1,RAN1	;CLEAR C(AC).
	MOVN	AC2,AC		;SIMULATE SUB...RAN FROM 0 = 2'S COMP RAN.
	SUBB	AC1,AC		;DO SUBB.
	CAME	AC1,AC		;C(AC) SHOULD = C(E).
	EERR	,RAN1
	CAME	AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	EERR	,RAN1
	LOOP	SUBB2A,SUBB3A


;TEST SUBB. CHECK C(AC) = C(E) AND FOR
;CORRECT DATA IN AC.
;RAN TO RAN CONDITION.

	AC=10
SUBB1B:	SETUP 40,0
SUBB2B:	RANDOM
SUBB3B:	MOVE	AC1,AC		;MAKE C(E) = C(AC).
	SUBB	AC,AC1		;DO SUBB..RAN FROM RAN = 0.
	CAME	AC,AC1		;C(AC) SHOULD = C(E).
	EERR	,RAN
	CAME	AC,[0]		;C(AC) SHOULD = 0.
	EERR	,RAN
	LOOP	SUBB2B,SUBB3B



;TEST MOVEI. CHECK C(AC) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=2
MVEI1:	SETUP 20,0
MVEI2:	RANDOM
	MOVE AC2,RAN		;SAVE RAN IN AN AC.
MVEI3:	MOVSS RAN1,AC		;MAKE C(AC) = SEC RAN NUM.
	MOVE AC1,RAN		;SIMULATE
	LSH AC1,22		;A
	LSH AC1,-22		;MOVEI.
	MOVEI AC,(AC2)		;DO A MOVEI.
	CAME AC,AC1		;C(AC) SHOULD = SIM. ANS.
	ERRI RAN1,(AC2)
	LOOP MVEI2,MVEI3


;TEST MOVN. TWO MOVN INSTRUCTIONS SHOULD NOT CHANGE C(AC).

	AC=2
MOVN1:	SETUP 200,0
MOVN2:	RANDOM
		;DO 6 X (MOVN RAN TO RAN).
MOVN3:	REPEAT 3,<
	MOVN AC,AC
	MOVN AC,AC>
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN NUM.
	ERROR AC,RAN
	LOOP MOVN2,MOVN3


;TEST MOVNI. CHECK C(AC) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=2
MVNI1:	SETUP 40,0
MVNI2:	RANDOM
	MOVE AC2,RAN		;SAVE RAN IN AN AC.
MVNI3:	MOVSS RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	SETCA AC1,		;A
	ADD AC1,[1]		;MOVNI INST.
	MOVNI AC,(AC2)		;DO A MOVNI.
	CAME AC,AC1		;C(AC) SHOULD = SIM. ANS.
	ERRI RAN1,(AC2)
	LOOP MVNI2,MVNI3


;TEST MOVNM. WHERE E IS AN AC.
;CHECK C(E) FOR CORRECT DATA.
;RAN TO RAN.

	AC=2
MVNM1:	SETUP 100,0
MVNM2:	RANDOM
	MOVE RAN1,RAN		;SAVE RAN IN AN AC.
MVNM3:	MOVE AC1,AC		;MAKE C(E) = C(AC).
		;DO 3 X 2(MOVNM).
	REPEAT 3,<
	MOVNM AC,AC1
	MOVNM AC1,AC>
	CAME RAN1,AC		;C(E) SHOULD = ORIG C(E).
	EERRM	,RAN
	LOOP MVNM2,MVNM3


;TEST MOVNS. WHERE E IS AN AC.
;CHECK PROPER STORING OF C(E) INTO AC.
;TWO MOVNS = ORIG NUMBER.
;C(E) = RAN.

	AC=3
MVNS1:	SETUP 100,0
MVNS2:	RANDOM
	MOVE AC2,RAN		;PUT C(RAN) INTO AC2 FOR FUTURE COMPARE.
MVNS3:	SETOB AC1,RAN1		;MAKE C(AC) = -1.
		;DO 3 X 2(MOVNS).
	REPEAT 3,<
	MOVNS AC1,AC
	MOVNS AC1,AC>
	CAME AC1,AC		;C(AC) SHOULD = C(E).
	EERRM	,RAN1
	CAME AC2,AC		;C(E) SHOULD = ORIG. C(E).
	EERRM	,RAN1
	LOOP MVNS2,MVNS3


;TEST MOVNS. WHERE E IS AN AC.
;CHECK FOR NOT LOADING C(E) INTO AC WHEN AC= 0.
;TWO MOVNS = ORIGINAL NUM.
;C(E) = RAN.

	AC=10
MVNSA:	SETUP 40,0
MVNSB:	RANDOM
	MOVE AC2,RAN		;SAVE RAN IN AN AC.
MVNSC:	SETOB RAN1		;MAKE C(AC) = -1.
		;DO 3 X 2(MOVNS).
	REPEAT 3,<
	MOVNS AC
	MOVNS AC>
	CAMN AC		;C(AC) SHOULD NOT = C(E).
	EERRM	,RAN1
	CAME AC2,AC		;C(AC) SHOULD = ORIG C(AC).
	EERRM	,RAN1
	LOOP MVNSB, MVNSC


;TEST MOVM. CHECK F(AC) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=7
MVM1:	SETUP 40,0
MVM2:	RANDOM
MVM3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E) = 1ST RAN NUM.
	SETCM	AC2,AC1		;SIMULATE
	TLNN	AC1,400000	;A
	MOVE	AC2,AC1		;MOVM
	TLNE	AC1,400000	;INST.
	ADD	AC2,[1]
	MOVM	AC,AC1		;DO A MOVM.
	CAME	AC,AC2		;C(AC) SHOULD = SIM. ANS.
	EERR	,RAN1
	LOOP	MVM2, MVM3


;TEST MOVMI. CHECK C(AC) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=10
MVMI1:	SETUP 40,0
MVMI2:	RANDOM
MVMI3:	MOVEI	AC1,AC		;SIMULATE A MOVMI INST...MOVEI.
	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVMI	AC,(AC1)	;DO MOVMI.
	CAME	AC,AC1		;C(AC) SHOULD = SIM ANS.
	ERRI	RAN1,(AC1)
	LOOP	MVMI2, MVMI3


;TEST MOVMM. CHECK C(AC) + C(E) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=11
MVMM1:	SETUP 200,0
MVMM2:	RANDOM
MVMM3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E) = RAN.
	SETCM	AC2,AC		;SIMULATE
	TLNN	AC,400000	;A
	MOVE	AC2,AC		;MOVMM
	TLNE	AC,400000	;INST
	ADD	AC2,[1]
	MOVMM	AC,AC1		;DO A MOVMM INST.
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	EERRM	,RAN1
	CAME	AC1,AC2		;C(E) SHOULD = SIM. ANS.
	EERRM	,RAN1
	LOOP	MVMM2, MVMM3


;TEST MOVMS. CHECK C(E) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=10
MVMS1:	SETUP 200,0
MVMS2:	RANDOM
MVMS3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E) = RAN.
	SETCM	AC2,RAN		;SIMULATE
	TLNN	AC1,400000	;A
	MOVE	AC2,AC1		;MOVMS
	TLNE	AC1,400000	;INST.
	ADD	AC2,[1]
	MOVMS	AC,AC1		;DO A MOVMS.
	CAME	AC,AC1		;C(AC) SHOULD = C(E).
	EERRM	,RAN1
	CAME	AC1,AC2		;C(E) SHOULD = SIM. ANS.
	EERRM	,RAN1
	LOOP	MVMS2, MVMS3


;TEST LSH. A LSH LEFT AND A LSH RIGHT SHOULD
;GIVE THE SAME NUMBER WITH A ZERO SIGN BIT.

	AC=2
LSH1P:	SETUP 40,0
LSH1PA:	RANDOM
LSH1PB:	AND AC,[XWD 377777,-1]	;SIMULATE A LSH LEFT THEN RIGHT.
	MOVE AC1,RAN		;MOVE RANDOM NUM INTO AN AC
		;AND DO 3(LSH LEFT 1 PLACE THEN RIGHT 1 PLACE).
	REPEAT 3,<
	LSH AC1,1
	LSH AC1,-1>
	CAME AC1,AC		;C(AC1) = SIM. ANS?
	ERROR AC1,AC		;NO. LSH FAILED.
	LOOP LSH1PA,LSH1PB


;TEST TDN,TDNA. CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN1 TO RAN CONDITION.

	AC=2
TDN1:	SETUP 100,0
TDN2:	RANDOM
TDN3:	MOVS AC1,AC		;PUT SECOND RAN. NUM. INTO "E".
	TDN AC,AC1		;NO SKIP, NO DATA CHANGE.
	JRST	.+2		;HERE..GO AROUND ERR UUO.
	ER	AC,[ASCII /TST/];TDN SKIPPED.
	TDNA AC,AC1		;SKIP, NO DATA CHANGE.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR	AC1,RAN
	LOOP TDN2,TDN3


;TEST TDNN,TDNE. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO 0 CONDITION.

	AC=3
TDNE1A:	SETUP 100,0
TDNE2A:	RANDOM
TDNE3A:	SETZB AC1,RAN1		;CLEAR C(AC).
	TDNN AC1,AC		;C(E) + C(AC) =0..NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDNN SKIPPED.
	TDNE AC1,AC		;C(E) + C(AC) = 0. SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,[0]		;C(AC) SHOULD STILL = 0.
	ERR	AC,RAN1
	LOOP TDNE2A,TDNE3A


;TEST TDNN,TDNE. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE FOR 0 TO RAN CONDITION.

	AC=4
TDNE1B:	SETUP 40,0
TDNE2B:	RANDOM
TDNE3B:	SETZ AC1,		;CLEAR C(E).
	TDNN AC,AC1		;C(E) + C(AC) = 0. NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDNN SKIPPED.
	TDNE AC,AC1		;C(E) + C(AC) = 0. SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR	AC1,RAN
	LOOP TDNE2B,TDNE3B


;TEST TDNN,TDNE. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO -1 CONDITION.

	AC=5
TDNE1C:	SETUP 40,0
TDNE2C:	RANDOM
	JUMPE AC,TDNE2C		;REJECT IF RAN = 0.
TDNE3C:	SETOB AC1,RAN1		;SET C(AC) TO ALL ONES.
	TDNE AC1,AC		;C(E) + C(AC) NOT = 0..NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDNE SKIPPED.
	TDNN AC1,AC		;C(E) + C(AC) NOT = 0..SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,[-1]		;C(AC) SHOULD = ORIG C(AC).
	ERR AC,RAN1
	LOOP TDNE2C,TDNE3C


;TEST TDNE,TDNN. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE IN AC FOR -1 TO RAN CONDITION.

	AC=6
TDNE1D:	SETUP 40,0
TDNE2D:	RANDOM
	JUMPE AC,TDNE2D		;REJECT IF RAN = 0.
TDNE3D:	SETO AC1,		;SET C(E) TO ALL ONES.
	TDNE AC,AC1		;C(E) + C(AC) NOT = 0..NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDNE SKIPPED.
	TDNN AC,AC1		;C(E) + C(AC) NOT = 0..SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR AC1,RAN
	LOOP TDNE2D,TDNE3D


;TEST TDNE,TDNN. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO RAN CONDITION.

	AC=7
TDNE1E:	SETUP 20,0
TDNE2E:	RANDOM
	JUMPE AC,TDNE2E		;REJECT IF RAN = 0.
TDNE3E:	MOVE AC1,AC		;MAKE C(E) = C(AC).
	TDNE AC,AC1		;C(E) + C(AC) NOT = 0..NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDNE SKIPPED.
	TDNN AC,AC1		;C(E) + C(AC) NOT = 0. SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR AC1,RAN
	LOOP TDNE2E,TDNE3E


;TEST TDNE,TDNN. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE IN AC FOR NOT RAN TO RAN CONDITON.

	AC=10
TDNE1F:	SETUP 20,0
TDNE2F:	RANDOM
TDNE3F:	SETCM AC1,AC		;MAKE C(E) = 1'S COMP OF C(AC).
	TDNN AC,AC1		;C(E) + C(AC) = 0..NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDNN SKIPPED.
	TDNE AC,AC1		;C(E) + C(AC) = 0..SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR AC1,RAN
	LOOP TDNE2F,TDNE3F


;TEST TDZ,TDZA. CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION.

	AC=11
TDZA1:	SETUP 100,0
TDZA2:	RANDOM
TDZA3:	SETCM AC1,AC		;MAKE C(E) 1'S COMP OF C(AC).
	TDZ AC,AC1		;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII/TST/]	;TDZ SKIPPED.
	TDZA AC,AC1		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN NUM.
	ERR AC1,RAN
	CAMN AC1,RAN		;C(E) SHOULD NOT = RAN.
	ERR AC1,RAN
	LOOP TDZA2,TDZA3


;TEST TDZ,TDZA. CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION.

	AC=10
TDZAA:	SETUP 100,1
TDZAB:	RANDOM
TDZAC:	TDZ AC,AC		;SHOULD NOT SKIP.
	CAME AC,[0]		;SHOULD CLEAR C(AC).
	EERR	,RAN
	MOVE AC,RAN		;RESTORE AC.
	TDZA AC,AC		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,[0]		;C(AC) SHOULD BE CLEARED.
	EERR	,RAN
	LOOP TDZAB,TDZAC



;TEST TDZ,TDZA. CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION.

	AC=10
TDZB1:	SETUP 100,0
TDZB2:	RANDOM
TDZB3:	MOVS AC1,AC		;MAKE C(E) A DIFF. RAN. NUM.
	MOVE AC2,AC1		;SIMULATE
	XOR AC2,AC		;A
	AND AC2,AC		;TDZ.
	TDZ AC,AC1		;TDZ SHOULD NOT SKIP.
	CAME AC,AC2		;C(AC) SHOULD = SIM. ANS.
	ERR AC1,RAN
	MOVE AC,RAN		;RESTORE AC.
	TDZA AC,AC1		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;C(AC) SHOULD = SIM. ANS.
	ERR AC1,RAN
	LOOP TDZB2,TDZB3

;TEST TDZE, TDZN. CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR FLOATING ONE IN C(E) AND
;THAT BIT CLEARED IN RANDOM NUM. IN AC.

	AC=10
TDZE1:	SETUP 100,0
	MOVEI AC1,1		;SETUP AC1 TO CONTAIN A MASK BIT.
TDZE2:	RANDOM
	ROT AC1,1		;ROT TO TEST NEXT BIT.
TDZE3:	ANDCM AC,AC1		;CLEAR MASK BIT IN AC.
	MOVE AC2,AC		;SAVE FOR FUTURE COMPARE.
	TDZN AC,AC1		;C(E) + C(AC) = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/]	;TDZN SKIPPED.
	TDZE AC,AC1		;C(E) + C(AC) = 0...SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;C(AC) SHOULD = ORIG C(AC).
	ERR AC1,AC2
	LOOP TDZE2,TDZE3


;TEST TDZE, TDZN. CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR FLOATING ONE IN C(E)
;AND THAT BIT SET IN RAN. NUM. IN C(AC).

	AC=10
TDZEA:	SETUP 100,0
	MOVEI AC1,1		;SET MASK BIT IN C(E).
TDZEB:	RANDOM
	ROT AC1,1		;ROT MASK BIT TO TEST NEXT BIT.
TDZEC:	IOR AC,AC1		;SET MASK BIT IN AC.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVE AC2,AC		;SIMULATE
	ANDCM AC2,AC1		;A TDZ.
	TDZE AC,AC1		;C(E) + C(AC) NOT = 0...NO SKIP.
	CAME AC,AC2		;C(AC) SHOULD = SIM. ANS.
	ERR AC1,RAN1
	IOR AC,AC1		;RESET MASK BIT IN AC.
	TDZN AC,AC1		;C(E) + C(AC) NOT = 0...SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;AND C(AC) SHOULD = SIM. ANS.
	ERR AC1,RAN1
	LOOP TDZEB,TDZEC


;TEST TDZE,TDZN. SET AND ROT A MASK BIT IN AC
;AND CHECK SKIP/NO SKIP AND PROPER C(AC)
;FOR MASK BIT IN AC ANS RANDOM NUMBER IN E.

	AC=10
TDZNA:	SETUP 100,0
	MOVEI AC1,1		;SETUP AC1 FOR MASK BIT.
TDZNB:	RANDOM
	ROT AC1,1		;ROT AC1 TO TEST NEXT BIT.
	MOVE AC2,AC1		;SAVE MASK BIT.
TDZNC:	MOVE AC1,AC2		;RESTORE MASK BIT IF ERROR.
	ANDCM AC,AC1		;CLEAR MASK BIT IN RAN NUM.
	TDZN AC1,AC		;C(E) + C(AC) =0..SHOULDN'T SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDZN SKIPPED.
	TDZE AC1,AC		;C(E) + C(AC) = 0..SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,AC2		;C(AC1) SHOULD NOT HAVE CHANGED.
	ERR AC,AC2
	LOOP TDZNB,TDZNC


;TEST TDZE,TDZN. SET AND ROT A MASK BIT IN AC
;AND CHECK SKIP/NO SKIP AND PROPER C(AC)
;FOR MASK BIT IN AC AND RANDOM NUMBER IN E.
;RANDOM NUMBER HAS MASK BIT SET.

	AC=10
TDZN1:	SETUP 40,0
	MOVEI AC1,1		;SETUP AC1 FOR MASK BIT.
TDZN2:	RANDOM
	ROT AC1,1		;ROT AC1 TO TEST NEXT BIT.
TDZN3:	MOVE AC2,AC1		;SAVE MASK BIT.
	IOR AC,AC1		;SET MASK BIT IN RAN.
	TDZE AC1,AC		;C(E) + C(AC) NOT = 0...NO SKIP.
	CAME AC1,[0]		;C(AC) SHOULD = 0.
	ERR AC,AC2
	MOVE AC1,AC2		;RESTORE MASK BIT.
	TDZN AC1,AC		;C(E) + C(AC) NOT = 0...SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,[0]		;AC1 SHOULD HAVE GOTTEN CLEARED OUT.
	ERR AC,AC2
	MOVE AC1,AC2		;RESTORE MASK BIT.
	LOOP TDZN2,TDZN3


;TEST TDO TDOA. CHECK FOR SKIP/NO SKIP ANS CORRECT DATA
;IN AC FOR RAN TO NOT RAN.

	AC=10
TDOA1:	SETUP 100,0
TDOA2:	RANDOM
TDOA3:	SETCM AC1,AC		;MAKE "C(E)" = COMP OF RAN.
	TDO AC,AC1		;SHOULD NOT SKIP.
	CAME AC,[-1]		;AC SHOULD HAVE ALL BITS SET.
	ERR AC1,RAN
	MOVE AC,RAN		;RESTORE AC.
	TDOA AC,AC1		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,[-1]		;AC SHOULD HAVE ALL BITS SET.
	ERR AC1,RAN
	LOOP TDOA2,TDOA3


;TEST TDO,TDOA. CHECK SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION.

	AC=2
TDOAA:	SETUP 40,0
TDOAB:	RANDOM
TDOAC:	TDO AC,AC		;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/] ;TDO SKIPPED.
	TDOA AC,AC		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD NOT HAVE CHANGED.
	EERR	,RAN
	LOOP TDOAB,TDOAC


;TEST TDO, TDOA. CHECK FOR SKIP/NO SKIP
;AND CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION.

	AC=2
TDOB1:	SETUP 400,3
TDOB2:	RANDOM
TDOB3:	MOVS AC1,AC		;MAKE AC1 ANOTHER RAN NUM.
	MOVE AC2,AC		;SIMULATE
	XOR AC2,AC1		;A
	IOR AC2,AC		;TDO INST.
	TDO AC,AC1		;SHOULD NOT SKIP.
	CAME AC,AC2		;C(AC) = SIM. ANS?
	ERR AC1,RAN		;NO.
	MOVE AC,RAN		;RESTORE AC.
	TDOA AC,AC1		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;C(AC) = SIM ANS?
	ERR AC1,RAN		;NO.
	LOOP TDOB2,TDOB3


;TEST TDOE,TDON. ROT A MASK BIT IN E AND SET THAT
;BIT IN AC BEFORE TDO. CHECK FOR SKIP/NO SKIP
;AND PROPER DATA IN AC.

	AC=2
TDOE1:	SETUP 40,0
	MOVEI AC1,1		;SETUP A MASK BIT IN "E".
TDOE2:	RANDOM
	ROT AC1,		;ROT MASK BIT TO TEST NEXT BIT.
TDOE3:	IOR AC,AC1		;SET MASK BIT IN AC.
	MOVE AC2,AC		;SAVE AC IN AC2.
	TDOE AC,AC1		;C(E) + C(AC) NOT = 0. NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDOE SKIPPED.
	TDON AC,AC1		;C(E) + C(AC) NOT = 0..SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;C(AC) SHOULD NOT CHANGE.
	ERR AC1,AC2
	LOOP TDOE2,TDOE3


;TEST TDOE,TDON. ROT A MASK BIT IN E AND CLEAR THAT
;BIT IN AC BEFORE TDO. CHECK FOR SKIP/NO SKIP
;AND PROPER DATA IN AC.

	AC=3
TDOEA:	SETUP 40,0
	MOVEI AC1,1		;SETUP MASK BIT IN"E".
TDOEB:	RANDOM
	ROT AC1,1		;ROT MASK BIT TO TEST NEXT BIT.
TDOEC:	ANDCM AC,AC1		;CLEAR MASK BIT IN AC.
	MOVE RAN1,AC		;SAVE AC.
	MOVE AC2,AC		;SIMULATE
	IOR AC2,AC1		;A TDO.
	TDOE AC,AC1		;C(E) + C(AC) = 0. SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;C(AC) = SIM ANS?
	ERR AC1,RAN1		;NO.
	MOVE AC,RAN1		;RESTORE AC.
	TDON AC,AC1		;C(E) + C(AC) = 0..NO SKIP.
 	CAME AC,AC2		;C(AC) = SIM. ANS?
	ERR AC1,RAN1		;NO.
	LOOP TDOEB,TDOEC


;TEST TDOE,TDON. ROT A MASK BIT IN AC AND CLEAR THAT
;BIT IN E BEFORE TDO. CHECK FOR SKIP/NO SKIP
;AND PROPER DATA IN AC.

	AC=4
TDONA:	SETUP 40,0
	MOVEI AC1,1		;SETUP  A MASK BIT IN AC.
TDONB:	RANDOM
	ROT AC1,1		;ROT BIT TO TEST NEXT BIT.
	MOVE AC2,AC1		;SAVE MASK BIT SO IN CASE
TDONC:	MOVE AC1,AC2		;OF ERROR IT CAN BE RESTORED.
	ANDCM AC,AC1		;CLEAR MASK BIT IN E.
	JUMPE AC,TDONB		;REJECT IF C(AC) = 0.
	MOVE AC3,AC		;SIMULATE
	IOR AC3,AC1		;TDO.
	TDOE AC1,AC		;C(E) + C(AC) = 0...SKIP.
	ER	AC1,[ASCII /TST/];TDOE DID NOT SKIP.
	CAME	AC1,AC3		;C(AC) SHOULD = SIM. ANS.
	ERR	AC,AC2
	TDON AC1,AC		;C(E) + C(AC) NOT = 0...SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,AC3		;C(AC) SHOULD = SIM. ANS.
	ERR AC,AC2
	MOVE AC1,AC2		;RESTORE AC.
	LOOP TDONB,TDONC


;TEST TDOE,TDON. ROT A MASK BIT IN AC  AND SET
;THAT BIT IN E BEFORE TDO. CHECK FOR SKIP/ NO SKIP
;AND CORRECT DATA IN AC.

	AC=5
TDON1:	SETUP 40,0
	MOVEI AC1,1		;SETUP AC TO CONTAIN A MASK BIT.
TDON2:	RANDOM
	ROT AC1,1		;ROT TO TEST NEXT BIT.
	MOVE AC2,AC1		;SAVE C(AC) SO IT CAN BE
TDON3:	MOVE AC1,AC2		;RESTORED IN CASE OF ERROR.
	IOR AC,AC1		;SET MASK BIT IN E.
	TDOE AC1,AC		;C(E) + C(AC) NOT = 0...NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDOE SKIPPED.
	TDON AC1,AC		;C(E) + C(AC) NOT = 0...SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,AC		;C(AC) SHOULD = C(E).
	ERR AC,AC2
	MOVE AC1,AC2		;RESTORE AC.
	LOOP TDON2,TDON3


;TEST TDC. CHECK FOR SKIP/NO SKIP AND CORRECT
;DATA FOR NOT RAN TO RAN CONDITION.

	AC=6
TDC1:	SETUP 100,0
TDC2:	RANDOM
TDC3:	SETCM AC1,RAN		;MAKE C("E") = COMP. OF RAN.
	TDC AC,AC1		;NO SKIP.
	CAME AC,[-1]		;C(AC) SHOULD = A -1.
	ERR AC1,RAN
	SETO RAN1,		;SET RAN1 FOR ERROR MESSAGE.
	TDC AC,AC1		;NO SKIP.
	CAME AC,RAN		;C(AC) SHOULD = RAN AGAIN.
	ERR AC1,RAN1
	LOOP TDC2,TDC3


;TEST TDCA. CHECKING FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION.

	AC=10
TDCA1:	SETUP 100,0
TDCA2:	RANDOM
TDCA3:	SETCM AC1,RAN		;MAKE C("E") = COMP OF RAN.
	TDC AC,AC1		;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDC SKIPPED.
	TDCA AC,AC1		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;TWO TDC'S SHOULD RETURN C(AC)
				;TO IT'S ORIGINAL VALUE.
	ERR AC1,RAN
	LOOP TDCA2,TDCA3


;TEST TDCE. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION.

	AC=11
TDCE1:	SETUP 100,0
TDCE2:	RANDOM
TDCE3:	SETZB AC1,RAN1		;CLEAR BOTH AC AND RAN1.
	TDCE AC1,AC		;C(E) + C(AC) = 0. SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,RAN		;C(AC) SHOULD = RAN.
	EERR	,RAN1
	LOOP TDCE2,TDCE3


;TEST TDCE,TDCN. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION.

	AC=11
TDCEA:	SETUP 100,0
TDCEB:	RANDOM
TDCEC:	SETZ AC1,		;CLEAR C(E).
	TDCN AC,AC1		;C(E) + C(AC) = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDCN SKIPPED.
	TDCE AC,AC1		;C(E) + C(AC) = 0. SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN.
	ERR AC1,RAN
	LOOP TDCEB,TDCEC


;TEST TDCE. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION.

	AC=10
TDCE4:	SETUP 100,0
TDCE5:	RANDOM
	JUMPE AC,TDCE5		;REJECT IF RAN = 0.
TDCE6:	SETOB AC1,RAN1		;SET C(AC) TO ALL ONES.
	SETCM AC2,AC		;SIMULATE A TDC.
	TDCE AC1,AC		;C(E) + C(AC) NOT = 0. NO SKIP.
	CAME  AC1,AC2		;C(AC) = SIM.. ANS?
	ERR AC,RAN1		;NO.
	LOOP TDCE5,TDCE6


;TEST TDCE,TDCN. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION.

	AC=10
TDCED:	SETUP 100,0
TDCEE:	RANDOM
	JUMPE AC,TDCEE		;REJECT IF RAN = 0.
	CAMN AC,[-1]		;C(AC) = -1?
	JRST	TDCEE		;YES. REJECT.
TDCEF:	SETOB AC1,RAN1		;SET C(E) TO ALL ONES.
	TDCE AC,AC1		;C(E) + C(AC) NOT = 0. NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDCE SKIPPED.
	TDCN AC,AC1		;C(E) + C(AC) NOT = 0..SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR RAN1,RAN
	LOOP TDCEE,TDCEF


;TEST TDCE. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION.

	AC=10
TDCE7:	SETUP 100,0
TDCE8:	RANDOM
	JUMPE AC,TDCE8		;REJECT IF RAN = 0.
TDCE9:	MOVE AC1,RAN		;MAKE C("AC") = C("E").
	TDCE AC1,AC		;C(E) + C(AC) NOT = 0. NO SKIP.
	CAME AC1,[0]		;C(AC) SHOULD = 0.
	ERR AC,AC
	LOOP TDCE8,TDCE9


;TEST TDCE. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO NOT RAN.

	AC=10
TDCEG:	SETUP 100,0
TDCEH:	RANDOM
TDCEI:	SETCM AC1,AC		;MAKE C("AC") = TO COMP OF RAN.
	MOVE RAN1,AC1		;SAVE C(AC) IN CASE OF ERROR.
	TDCE AC1,AC		;C(E) + C(AC) = 0. SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,[-1]		;C(AC) SHOULD = -1.
	ERR AC,RAN1
	LOOP TDCEH,TDCEI



	JRST	BEGEND		;REPEAT TEST

