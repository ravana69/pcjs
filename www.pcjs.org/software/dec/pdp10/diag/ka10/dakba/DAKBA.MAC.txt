;MAINDEC-10-DAKBA

DECVER=002
MCNVER=000

	XLIST
DEFINE	NAME	(MCNVER,DECVER),<

TITLE	DAKBA  PDP-10  KA10 BASIC INSTRUCTION RELIABILITY TEST (1), VERSION MCNVER,DECVER >
	LIST
	LALL

NAME	\MCNVER,\DECVER

	XALL

;TEST DESIGNED FOR RANDOM NUMBER TESTING OF THE PDP-10 BASIC INSTRUCTIONS
;(COMPARES,SKIPS,EXCHANGES,BOOLE,ROTATES,TESTS,ETC.)

;COPYRIGHT 1977
;DIGITAL EQUIPMENT CORPORATION
;MARLBORO, MASS. 01752

;JOHN R. KIRCHOFF

	LOC	137
MCNVER,,DECVER

	NOSYM
SUBTTL	DIAGNOSTIC PARAMETERS

;LUUO DEFINITIONS

OPDEF	ERR	[1B8]
OPDEF	ERRM	[2B8]
OPDEF	ERRI	[3B8]
OPDEF	ERROR	[4B8]
OPDEF	ER	[5B8]
OPDEF	EERR	[11B8]
OPDEF	EERRM	[12B8]
OPDEF	EERRI	[13B8]
LUUO1=ERRMES
LUUO2=ERRMES
LUUO3=ERRMES
LUUO4=ERRMES
LUUO5=ERRMES
LUUO11=ERRMES
LUUO12=ERRMES
LUUO13=ERRMES

;SUBROUTINE ASSEMBLY DEFINITIONS

EXCASB==1
USRASB==1
DEBUG==40
KLOLD==1
KA10=10
PGMEND==1
ERRELB==1
SADR1==BEGIN
SADR2==RESRT1
SADR3==RENTR1
SADR4==BEGIN
SADR5==BEGIN
SADR6==BEGIN
SADR7==HALT BEGIN
SADR8==HALT BEGIN
SADR9==HALT BEGIN
SADR10==HALT BEGIN
SADR11==HALT BEGIN
PAREA1==123457,,654321
PAREA2==0
PAREA3==SIXBIT/DAKBA/
PAREA4==SIXBIT/TMP/
PAREA5==0
PAREA6==0
ITERAT==1
ENDPGM==1
;MACROS

DEFINE	SETUP	(A,B)<
	AC1=<AC+1>&17
	AC2=<AC+2>&17
	AC3=<AC+3>&17
	AC4=<AC+4>&17
	AC5=<AC+5>&17
	RAN1=<AC-2>&17
	MOVEI	AC-1,.
	MOVEM	AC-1,TESTPC	;SETUP SUBTEST PC
	MOVEI	AC-1,<AC-1>&17	;INFORM ERROR ROUTINE
	MOVEM	AC-1,ERRLOP#	;WHICH AC IS USED FOR ITERATION
	MOVEI	AC-1,A		;ROUTINE WEIGHTING
	ASH	AC-1,@CMPLXT+B	;ROUTINE COMPLEXITY
	ASH	AC-1,@RTIME	;RUN TIME CONTROLLER >

DEFINE	RANDOM	(A)<
	MOVE	AC,RAN#		;GENERATE A PSEUDO RANDOM NUMBER
	ADD	AC,[142536475076]
	ROT	AC,-1		;IN BOTH AC AND
	EQVB	AC,RAN		;REGISTER RAN >

DEFINE	LOOP	(A,B)<
	SOJG	AC-1,A		;ITERATION COUNTER
	MOVE	AC,RAN		;RESTORE RANDOM NUMBER
	JUMPL	AC-1,B		;LOOP ON ERROR SWITCH >

SUBTTL	*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, SEPT 18,1979

DEFINE	S,<; *********************************************************************>

; **********************************************************************
;*DATA SWITCHES (READ FROM CONSOLE IN EXEC MODE OR TYPED IN IN USER MODE)
;*LEFT HALF SWITCHES ARE PRE-ASSIGNED FOR SUBROUTINE PACKAGE USE
;*AND CONTROL LOOPING, PRINTING (TTY OR OTHER DEVICE) AND MISC. FUNCTIONS
; **********************************************************************

ABORT==	400000			;ABORT PROGRAM ON PASS COMPLETION
RSTART==200000			;RESTART TEST, PRINT TOTALS
TOTALS==100000			;PRINT TOTALS, CONTINUE

NOPNT==	040000			;INHIBIT ALL PRINT/TYPE OUT (EXCEPT FORCED)
PNTLPT==020000			;PRINT ALL DATA ON LPT (LOGICAL DEVICE, USER MODE)
DING==	010000			;RING BELL ON ERROR

LOOPER==004000			;ENTER EXERCISE/CHECK LOOP ON ERROR
ERSTOP==002000			;HALT ON TEST ERROR
PALERS==001000			;PRINT ALL ERRORS

RELIAB==000400			;RELIABILITY MODE
TXTINH==000200			;INHIBIT ERROR TEXT
INHPAG==000100			;INHIBIT PAGING

MODDVC==000040			;MODIFY DEVICE CODE
INHCSH==000020			;INHIBIT CACHE
OPRSEL==000010			;OPERATOR SELECTION

CHAIN==	000004			;CHAIN CONTROL SWITCH

KAHZ50==000002			;KA10 50 HERTZ POWER

				;SWITCH 17 RESERVED !!!
SUBTTL	*PARAM* PROGRAM/SUBROUTINE PARAMETERS, SEPT 18,1979

; **********************************************************************
;*SPECIAL SUBPROGRAM LINKAGES
; **********************************************************************

FSELNK=	27772	;FILE SELECT LINK
FRDLNK=	27773	;FILE READ LINK
LDLNK=	27774	;LOAD LINKAGE ADDRESS
DDTLNK=	27775	;DDT LINKAGE ADDRESS
MODLNK=	27776	;OPERATIONAL MODE CHECK LINKAGE ADDRESS
SUBLNK=	27777	;SUBROUTINE LINKAGE ADDRESS

; **********************************************************************
;*SPECIAL SUBROUTINE FATAL HALTS
;*USED TO REPORT ERRORS THAT CAUSE THE SUBROUTINES TO BE UNUSABLE
; **********************************************************************

;ADDRESS   TAG	REASON
;---------------------

; 1010 	NOEXEC	;PROGRAM NOT CODED FOR EXEC MODE OPERATION
; 1011  PLERR	;FATAL PUSH LIST POINTER ERROR
; 1012  PLERR1	;INITIAL PUSH LIST POINTER ERROR
; 1013  MUOERR	;MUUO WITH LUUO HANDLER WIPED OUT
; 1014  DTEBER	;DTE20 INTERRUPT WITHOUT DOORBELL
; 1015  DTECER	;DTE20 CLOCK INTERRUPT WITHOUT FLAG SET
; 1016  CPIERR	;CPU INITIALIZATION ERROR
; 1017  EOPERR	;END OF PROGRAM ERROR
; 1020  LUOERR	;INTERRUPT WITH LUUO HANDLER WIPED OUT

; **********************************************************************
; **********************************************************************
;OPERATOR DEFINITIONS (NON-UUO'S)
; **********************************************************************

OPDEF	GO	[PUSHJ	P,]	;SUBROUTINE CALL
OPDEF	RTN	[POPJ	P,]	;SUBROUTINE RETURN
OPDEF	PUT	[PUSH	P,]	;PUT DATA ON PUSH LIST
OPDEF	GET	[POP	P,]	;GET DATA FROM PUSH LIST
OPDEF	PJRST	[JRST	]	;JRST TO ROUTINE THAT RTN'S
OPDEF	HALT	[JRST	4,]	;DEFINITION FOR DDT
OPDEF	JRSTF	[JRST	2,]	;DEFINITION FOR DDT
OPDEF	JEN	[JRST	12,]	;DEFINITION FOR DDT

; **********************************************************************
;SUBROUTINE INITIALIZATION CALL
; **********************************************************************

OPDEF	PGMINT	[JSP	0,SBINIT]	;SUBROUTINE INITIALIZATION

; **********************************************************************
;HALTING UUO'S (A MORE GRACEFUL HALT THAN SIMPLY USING THE HALT INSTRUCTION).
; **********************************************************************

OPDEF	FATAL	[37B8!15B12!4]	;FATAL PROGRAMMING HALT
OPDEF	ERRHLT	[37B8!14B12!4]	;PROGRAM ERROR HALT

; **********************************************************************
;TERMINAL INPUT UUO'S
;ALWAYS COME FROM THE CONSOLE TERMINAL IN EXEC MODE OR THE
;CONTROLLING TERMINAL (REAL TERMINAL OR PTY) IN USER MODE.
; **********************************************************************

OPDEF	TTICHR 	[37B8!0B12!3]	;TTY, INPUT ANY CHARACTER
OPDEF	TTIYES	[37B8!1B12!3]	;TTY, NORMAL RETURN Y
OPDEF	TTINO	[37B8!2B12!3]	;TTY, NORMAL RETURN N
OPDEF	TTIOCT	[37B8!3B12!3]	;TTY, INPUT OCTAL WORD
OPDEF	TTIDEC	[37B8!4B12!3]	;TTY, INPUT DECIMAL WORD
OPDEF	TTICNV	[37B8!5B12!3]	;TTY, INPUT CONVERTABLE WORD
OPDEF	TTLOOK	[37B8!6B12!3]	;TTY, KEYBOARD CHECK
OPDEF	TTALTM	[37B8!7B12!3]	;TTY, ALT-MODE CHECK
OPDEF	TTSIXB	[37B8!10B12!3]	;TTY, INPUT SIXBIT WORD
OPDEF	TTYINP	[37B8!11B12!3]	;TTY, IMAGE MODE INPUT
OPDEF	TTICLR	[37B8!12B12!3]	;TTY, CLEAR INPUT
;TERMINAL OUTPUT UUO'S.

OPDEF	PNTA	[37B8!0B12!0]	;PRINT ASCII WORD
OPDEF	PNTAF	[37B8!0B12!1]	;PRINT ASCII WORD FORCED
OPDEF	PNTAL	[37B8!17B12!0]	;PRINT ASCIZ LINE
OPDEF	PNTALF	[37B8!17B12!1]	;PRINT ASCIZ LINE FORCED
OPDEF	PSIXL	[37B8!14B12!3]	;PRINT SIXBIT'Z LINE
OPDEF	PSIXLF	[37B8!15B12!3]	;PRINT SIXBIT'Z LINE FORCED
OPDEF	PNTMSG	[37B8!0B12!0]	;PRINT MESSAGE IMMEDIATE
OPDEF	PNTMSF	[37B8!1B12!0]	;PRINT MESSAGE IMMEDIATE FORCED
OPDEF	PSIXM	[37B8!2B12!0]	;PRINT SIXBIT'Z MSG IMMEDIATE
OPDEF	PSIXMF	[37B8!4B12!0]	;PRINT SIXBIT'Z MSG IMM FORCED
OPDEF	PNTCI	[37B8!0B12!0]	;PRINT CHARACTER IMMEDIATE
OPDEF	PNTCIF	[37B8!1B12!0]	;PRINT CHARACTER IMMEDIATE FORCED
OPDEF	PNTCHR	[37B8!12B12!0]	;PRINT CHARACTER
OPDEF	PNTCHF	[37B8!12B12!1]	;PRINT CHARACTER FORCED
OPDEF	PNT1	[37B8!1B12!0]	;PRINT ONE OCTAL DIGIT
OPDEF	PNT1F	[37B8!1B12!1]	;PRINT 1 OCTAL DIGIT FORCED
OPDEF	PNT2	[37B8!2B12!0]	;PRINT TWO OCTAL DIGITS
OPDEF	PNT2F	[37B8!2B12!1]	;PRINT 2 OCTAL DIGITS FORCED
OPDEF	PNT3	[37B8!3B12!0]	;PRINT THREE OCTAL DIGITS
OPDEF	PNT3F	[37B8!3B12!1]	;PRINT THREE OCTAL DIGITS FORCED
OPDEF	PNT4	[37B8!4B12!0]	;PRINT FOUR OCTAL DIGITS
OPDEF	PNT4F	[37B8!4B12!1]	;PRINT FOUR OCTAL DIGITS FORCED
OPDEF	PNT5	[37B8!5B12!0]	;PRINT FIVE OCTAL DIGITS
OPDEF	PNT5F	[37B8!5B12!1]	;PRINT FIVE OCTAL DIGITS FORCED
OPDEF	PNT6	[37B8!6B12!0]	;PRINT SIX OCTAL DIGITS
OPDEF	PNT6F	[37B8!6B12!1]	;PRINT SIX OCTAL DIGITS FORCED
OPDEF	PNT7	[37B8!7B12!0]	;PRINT 7 OCTAL DIGITS
OPDEF	PNT7F	[37B8!7B12!1]	;PRINT 7 OCTAL DIGITS FORCED
OPDEF	PNT11	[37B8!11B12!0]	;PRINT 11 OCTAL DIGITS
OPDEF	PNT11F	[37B8!11B12!1]	;PRINT 11 OCTAL DIGITS FORCED.
OPDEF	PNTADR	[37B8!10B12!0]	;PRINT PHYSICAL ADDRESS
OPDEF	PNTADF	[37B8!10B12!1]	;PRINT PHYSICAL ADDRESS FORCED
OPDEF	PNTOCT  [37B8!14B12!0]	;PRINT FULL WORD OCTAL
OPDEF	PNTOTF	[37B8!14B12!1]	;PRINT FULL WORD OCTAL FORCED
OPDEF	PNTHW	[37B8!13B12!0]	;PRINT OCTAL HALF WORDS, 6 SP 6
OPDEF	PNTHWF	[37B8!13B12!1]	;PRINT OCTAL HALF WORDS, 6 SP 6 FORCED
OPDEF	PNTOCS	[37B8!16B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S
OPDEF	PNTOCF	[37B8!17B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S FORCED
OPDEF	PNTDEC	[37B8!15B12!0]	;PRINT DECIMAL, SUPRESS LEADING 0'S
OPDEF	PNTDCF	[37B8!15B12!1]	;PRINT DECIMAL, SUPRESS LEADING 0'S FORCED
OPDEF	PNTDS	[37B8!16B12!0]	;PRINT DECIMAL, SPACES FOR LD 0'S
OPDEF	PNTDSF	[37B8!16B12!1]	;PRINT DECIMAL, SPACES FOR LD 0'S FORCED
OPDEF	PNTNM	[37B8!4B12!2]	;PRINT PROGRAM NAME
OPDEF	PNTSIX	[37B8!0B12!2]	;PRINT SIXBIT WORD
OPDEF	PNTSXF	[37B8!1B12!2]	;PRINT SIXBIT WORD FORCED
OPDEF	DROPDV	[37B8!5B12!2]	;CLOSE LOGICAL FILE, USER MODE
OPDEF	PNTCW	[37B8!2B12!2]	;PRINT DF10 CONTROL WORD
OPDEF	PNTCWF	[37B8!3B12!2]	;PRINT DF10 CONTROL WORD FORCED
OPDEF	PCRL	[37B8!0B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED
OPDEF	PCRLF	[37B8!1B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED FORCED
OPDEF	PSP	[37B8!0B12!40]	;PRINT SPACE
OPDEF	PSPF	[37B8!1B12!40]	;PRINT SPACE FORCED
OPDEF	PCRL2	[37B8!0B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE)
OPDEF	PCRL2F	[37B8!1B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE) FORCED
OPDEF	PBELL	[37B8!1B12!7]	;PRINT TTY BELL

OPDEF	PFORCE	[37B8!1B12!26]	;PRINT FORCE, CONTROL O OVERRIDE

DEFINE	PMSG	(ARG),<
	PSIXM	[SIXBIT\ARG'_\]>

DEFINE	PMSGF	(ARG),<
	PSIXMF	[SIXBIT\ARG'_\]>

;SIXBTZ -- MACRO TO GENERATE SIXBIT DATA FOR PRINTING
;	CONSERVES CORE OVER ASCIZ

DEFINE	SIXBTZ	(ARG),<	[SIXBIT\ARG'_\]>

;CONSOLE SWITCH INPUT UUO.
;READS CONSOLE SWITCHES IF IN EXEC MODE OR ASKS FOR THEM IF
; USER MODE.

OPDEF	SWITCH	[37B8!10B12!2]	;INPUT CONSOLE SWITCHES

;CLOCK INITIALIZATION UUO - TO SET DESIRED CLOCK OPERATION
;EITHER IGNORE CLOCK, ONLY LET IT TICK OR CAUSE INTERRUPT TO OCCUR.

OPDEF	CLOKOP	[37B8!13B12!4]	;CLOCK OPERATION UUO - PDP-11 CLOCK
OPDEF	MTROP	[37B8!4B12!4]	;CLOCK OPERATION UUO - DK20 METER

;KL10 ONLY CACHE OPERATION UUO'S

OPDEF	CINVAL	[37B8!1B12!4]	;CACHE INVALIDATE
OPDEF	CFLUSH	[37B8!2B12!4]	;CACHE FLUSH
OPDEF	CWRTBI	[37B8!3B12!4]	;CACHE WRITE-BACK & INVALIDATE
;END OF PASS/PROGRAM UUOS

;PERFORMS THE END OF PASS FUNCTIONS. INCREMENT PASS COUNT,
;DECREMENT ITERATION COUNT, CHECK IF FINISHED WITH THIS PROGRAM ETC.

OPDEF	ENDUUO	[37B8!12B12!4]	;UUO TO DISPLAY LIGHTS
OPDEF	EOPUUO	[37B8!16B12!4]	;END OF PROGRAM UUO

;MEMORY MANAGEMENT UUO'S
;UUO'S TO PERFORM VARIOUS MEMORY FUNCTIONS. MAPPING, ZEROING, PAGING,
;ADDRESS CONVERSION, ETC...

OPDEF	MAPMEM	[37B8!0B12!4]	;MAP MEMORY
OPDEF	MEMZRO	[37B8!12B12!2]	;ZERO MEMORY
OPDEF	MEMSEG	[37B8!11B12!2]	;SETUP MEMORY SEGMENT
OPDEF	MAPADR	[37B8!13B12!2]	;VIRTUAL TO PHYSICAL ADR CONVERT
OPDEF	MAPCNK	[37B8!15B12!2]	;MAP MEMORY CHUNK
OPDEF	MAPSET	[37B8!14B12!2]	;SET KI10 EXEC PAGE MAP
OPDEF	MAPPNT	[37B8!17B12!2]	;PRINT MEMORY MAP

;DEVICE CODE MODIFICATION UUO
;ALLOWS THE MODIFICATION OF IOT'S TO ONE DEVICE TO BE CHANGED TO
;IOT'S TO A DIFFERENT DEVICE CODE.

OPDEF	MODPCU	[37B8!7B12!2]	;MODIFY PERHIPERAL CODE, USER
OPDEF	MODPCP	[37B8!6B12!2]	;MODIFY PERHIPERAL CODE, PROGRAM

	IFNDEF	MODDVL,<MODDVL==BEGIN>
	IFNDEF	MODDVU,<MODDVU==BEGIN>

;"DIAMON" FILE SELECTION AND READ UUOS

OPDEF	FSELECT	[37B8!5B12!4]	;FILE SELECTION
OPDEF	FREAD	[37B8!6B12!4]	;FILE READ - ASCII DATA
OPDEF	FRD36	[37B8!7B12!4]	;FILE READ - 36 BIT DATA
OPDEF	FRD8	[37B8!10B12!4]	;FILE READ - 8 BIT DATA

;KI10 ONLY UUO FOR PRINTING MARGIN VALUES

OPDEF	PNTMGN	[37B8!16B12!2]	;PRINT MARGIN VALUE

	XLIST
IFNDEF	KLOLD,<LIST
SUBTTL	ERROR HANDLING UUO DEFINITIONS, SEPT 18,1979

; **********************************************************************
;ERROR HANDLER PARAMETERS
; **********************************************************************

OPDEF	ERUUO	[36B8]		;ERROR CALL UUO
OPDEF	ERLOOP	[35B8]		;ERROR LOOP, CHECKS PC,REPT,REPT1,ERROR
OPDEF	ERLP1	[35B8!1B12]	;ERROR LOOP IF PC'S MATCH
OPDEF	ERLP2	[35B8!2B12]	;ERROR LOOP IF ANY ERROR
OPDEF	REPTUO	[34B8]		;REPEAT LOOP UUO

;THE ERROR HANDLER MACROS

;A MACRO TO REPORT AN ERROR AND LOOP

	DEFINE	ERROR	(ADR,FORMAT,CORECT,ACTUAL,F,D,ERR)<
							SALL
	ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
		   CORECT,,ACTUAL
		   [SIXBIT\D'_\],,ERR]
							XALL
	ERLOOP	ADR		;IF ERROR, LOOP TO ADR
>

;A MACRO TO REPORT AN ERROR AND NOT LOOP

	DEFINE	ERROR1	(FORMAT,CORECT,ACTUAL,F,D,ERR)<
							SALL
	ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
		   CORECT,,ACTUAL
		   [SIXBIT\D'_\],,ERR]
							XALL>

>;END OF KLOLD CONDITIONAL

	XLIST
IFDEF	$PAPER,<LIST>
SUBTTL	STANDARD PROGRAM ASSIGNMENTS

; **********************************************************************
;ACCUMULATORS
; **********************************************************************

P=	17			;PUSHDOWN POINTER AC (IF PUSH LIST USED)
REPT==	15			;ERROR HANDLER REPEAT AC
REPT1==	16			; "

; **********************************************************************
;PDP-10 STANDARD PC CONTROL FLAGS (SAVED ON PUSHJ, JSR, ETC..)
; **********************************************************************

AROV==	400000			;ARITHMETIC OVERFLOW
CRY0==	200000			;CARRY 0
CRY1==	100000			;CARRY 1
FOV==	40000			;FLOATING POINT OVERFLOW
BIS==	20000			;BYTE INTERRUPT
USERF==	10000			;USER MODE
EXIOT==	4000			;USER PRIV I/O
FXU==	100			;FLOATING POINT UNDERFLOW
DCK==	40			;DIVIDE CHECK

; **********************************************************************
;PDP-10 STANDARD ADDRESS ASSIGNMENTS
; **********************************************************************

LUUO==	40			;UUO STORAGE, UUO 1-37
LUUOI==	41			;UUO SERVICE INSTRUCTION

; **********************************************************************
;JOB DATA AREA EXTERNALS (OLD DEFINITIONS)
; **********************************************************************

JOBUUO==40
JOB41==	41
JOBREL==44
JOBDDT==74
JOBSYM==116
JOBUSY==117
JOBSA==	120
JOBFF==	121
JOBREN==124
JOBAPR==125
JOBCNI==126
JOBTPC==127
JOBOPC==130
JOBVER==137
; **********************************************************************
;JOB DATA AREA EXTERNALS (NEW DEFINITIONS)
; **********************************************************************

.JBUUO==40
.JB41==	41
.JBREL==44
.JBDDT==74
.JBSYM==116
.JBUSY==117
.JBSA==	120
.JBFF==	121
.JBREN==124
.JBAPR==125
.JBCNI==126
.JBTPC==127
.JBOPC==130
.JBVER==137

; **********************************************************************
;USER MODE APR ASSIGNMENTS (FOR "APRENB" CALL)
; **********************************************************************

PDLOVU==200000			;PUSHDOWN LIST OVERFLOW
MPVU==	20000			;MEMORY PROTECTION VIOLATION
NXMU==	10000			;NON-X-MEMORY
PARU==	4000			;PARITY ERROR
CLKU==	1000			;CLOCK
FOVU==	100			;FLOATING OVERFLOW
AROVU==	10			;ARITHMETIC OVERFLOW

; **********************************************************************
;USER MODE PRINT OUTPUT CHANNEL ASSIGNMENTS (FOR SUBROUTINE PACKAGE)
;THE USER SHOULD BE CAUTIONED NOT TO USE THESE CHANNELS WHEN
;USING THE SUBROUTINE PACKAGE AND CODING USER MODE PROGRAMS.
; **********************************************************************

$DEVCH==17			;LOGICAL DEVICE CHANNEL
$DVCH1==16			;LOGICAL DEV UPDATE INPUT CHANNEL

; **********************************************************************
;PDP-10 SPECIAL COMPATABILITY ASSIGNMENTS
; **********************************************************************

PAG==	010		;PAGING I/O DEVICE CODE, KI/KL

CCA==	014		;CACHE I/O DEVICE CODE, KL10
; **********************************************************************
;PDP-10 STANDARD APR CONO ASSIGNMENTS
; **********************************************************************

IOCLR==	200000			;CLEAR ALL I/O DEVICES
CLKDIS==4000			;DISABLE CLOCK INTERRUPTS
CLKENB==2000			;ENABLE CLOCK INTERRUPTS
CLKCLR==1000			;CLEAR CLOCK FLAG

; **********************************************************************
;PDP-10 STANDARD APR CONI ASSIGNMENTS, RIGHT HALF
; **********************************************************************

CLKENB==2000			;CLOCK INTERRUPT ENABLED
CLK==	1000			;CLOCK FLAG
ANXM==	10000			;KA10, NON-X-MEMORY
INXM==	100			;KI10

; **********************************************************************
;PDP-10 STANDARD PI CONO ASSIGNMENTS
; **********************************************************************

PWFCLR==400000			;CLEAR POWER FAIL FLAG
PARCLR==200000			;CLEAR PARITY ERROR FLAG
PARDIS==100000			;DISABLE PARITY INTERRUPTS
PARENB==40000			;ENABLE PARITY INTERRUPTS
PICLR==	10000			;CLEAR PI SYSTEM
REQSET==4000			;SET PROGRAM PI REQUEST
CHNON==	2000			;TURN ON CHANNEL
CHNOFF==1000			;TURN OFF CHANNEL
PIOFF==	400			;TURN OFF PI SYSTEM
PION==	200			;TURN ON PI SYSTEM

; **********************************************************************
;PDP-10 STANDARD PI CONI ASSIGNMENTS
; **********************************************************************

PION==	200			;PI SYSTEM ON

; **********************************************************************
;PDP-10 STANDARD PI CHANNEL ASSIGNMENTS
; **********************************************************************

PICHN1==100			;PI CHANNEL 1
PICHN2==40			;PI CHANNEL 2
PICHN3==20			;PI CHANNEL 3
PICHN4==10			;PI CHANNEL 4
PICHN5==4			;PI CHANNEL 5
PICHN6==2			;PI CHANNEL 6
PICHN7==1			;PI CHANNEL 7
PICHNA==177			;ALL PI CHANNELS, 1 THRU 7
	XLIST
	IFDEF	KA10,<
IFDEF	$PAPER,<LIST>
; **********************************************************************
;KA10 APR CHANNEL ASSIGNMENTS
; **********************************************************************

AAPRC1==1			;APR INTERRUPT CHANNEL

; **********************************************************************
;KA10 APR CONO ASSIGNMENTS
; **********************************************************************

APDCLR==400000			;CLEAR PUSHDOWN OVERFLOW
AABCLR==40000			;CLEAR ADDRESS BREAK
AMPCLR==20000			;CLEAR MEMORY PROTECTION
ANXCLR==10000			;CLEAR NON-X-MEMORY
AFODIS==400			;DISABLE FLOATING POINT OVERFLOW
AFOENB==200			;ENABLE FLOATING POINT OVERFLOW
AFOCLR==100			;CLEAR FLOATING POINT OVERFLOW
AOVDIS==40			;DISABLE OVERFLOW
AOVENB==20			;ENABLE OVERFLOW
AOVCLR==10			;CLEAR OVERFLOW

; **********************************************************************
;KA10 APR CONI ASSIGNMENTS
; **********************************************************************

APDLOV==200000			;PUSHDOWN OVERFLOW
AUSRIO==100000			;USER I/O
AADRBK==40000			;ADDRESS BREAK
AMPV==	20000			;MEMORY PROTECTION VIOLATION
ANXM==	10000			;NON-EXISTENT MEMORY
AFOENB==200			;FLT PT INTERRUPT ENABLED
AFOV==	100			;FLOATING POINT OVERFLOW
ATRPOS==40			;TRAPS OFFSET
AOVENB==20			;OVERFLOW INTERRUPT ENABLED
AOVFLO==10			;ARITHMETIC OVERFLOW

; **********************************************************************
;KA10 PI CONI ASSIGNMENTS
; **********************************************************************

APWRFL==400000			;POWER FAILURE
APARER==200000			;PARITY ERROR
APAREN==100000			;PARITY INTERRUPT ENABLED

>				;END CONDITIONAL ON KA10
	XLIST
	IFDEF	KI10,<
IFDEF	$PAPER,<LIST>
; **********************************************************************
;KI10 PC CONTROL FLAGS
; **********************************************************************

LIP==	2000			;LAST INSTRUCTION PUBLIC
TN0==	400			;TN=00, NO TRAP ;TN=01, ARITH TRAP
TN1==	200			;TN=10, PDL OV  ;TN=11, TRAP 3

; **********************************************************************
;KI10 SPECIAL EXEC MODE FLAGS
; **********************************************************************

UOLIP==	400000			;UUO OLD L.I.P.
UOUSR==	4000			;UUO OLD USER

; **********************************************************************
;KI10 APR CHANNEL ASSIGNMENTS
; **********************************************************************

IAPRC1==1			;APR CLOCK CHANNEL
IAPRE1==10			;APR ERROR CHANNEL

; **********************************************************************
;KI10 APR CONO ASSIGNMENTS
; **********************************************************************

ITMSET==400000			;SET TIME OUT TIMER
ITMDIS==100000			;DISABLE TIME OUT
ITMENB==40000			;ENABLE TIME OUT
IASRTC==20000			;CLEAR AUTO RESTART
IASRTS==10000			;SET AUTO RESTART
IIOPFC==200			;CLEAR I/O PAGE FAIL
INXCLR==100			;CLEAR NON-X-MEM

; **********************************************************************
;KI10 APR CONI ASSIGNMENTS, RIGHT HALF
; **********************************************************************

ITMOUT==400000			;TIMER TIMED OUT
IPARER==200000			;PARITY ERROR
IPAREN==100000			;PARITY ENABLED
ITMOEN==40000			;TIME OUT ENABLED
IPWRFL==20000			;POWER FAIL
IASRTE==10000			;AUTO RESTART ENABLED
IIOPFL==200			;I/O PAGE FAIL
INXM==	100			;NON-X-MEMORY
; **********************************************************************
;KI10 APR CONI ASSIGMENTS, LEFT HALF
; **********************************************************************

IMLAPD==200000			;MEMORY OVERLAP DISABLED
IFMMAN==100000			;FAST MEMORY MANUAL
IMIPGD==40000			;MI PROGRAM DISABLE
ICNSLR==20000			;CONSOLE READ ONLY
ICNSLL==10000			;CONSOLE LOCKED
IP50HZ==4000			;50 HZ POWER
IMGINM==2000			;MANUAL MARGINS
IMAINT==1000			;MAINTENANCE MODE
IPWRLO==400			;POWER LOW
IMGNLO==200			;MARGIN COMPARATOR LOW
SENSE1==40			;SENSE SWITCHES		1
SENSE2==20			;			2
SENSE3==10			;			3
SENSE4==4			;			4
SENSE5==2			;			5
SENSE6==1			;			6

; **********************************************************************
;KI10 APR DATAO ASSIGNMENTS
; **********************************************************************

IEVNPR==20000			;WRITE EVEN PARITY
ISPDOF==10000			;SPEED MARGINS OFF
ISPDON==4000			;SPEED MARGINS ON
IMGNOF==2000			;MARGINS OFF - LH
IMGNON==1000			;MARGINS ON - LH

; **********************************************************************
;KI10 PI CONO ASSIGNMENTS
; **********************************************************************

IRQCLR==20000			;CLEAR PROGRAM PI REQUEST
; **********************************************************************
;KI10 PI CONI ASSIGNMENTS
; **********************************************************************

IINSTF==400000			;ADDRESS CONDITIONS, INST FETCH
IDATAF==200000			;	    	     DATA FETCH
IWRITE==100000			;		     WRITE
IADSTP==40000			;ADDRESS STOP
IADBRK==20000			;ADDRESS BREAK
IADEXC==10000			;ADDRESS SWITCHES EXEC
IADUSR==4000			;  "	  "       USER
IPRSTP==2000			;PARITY STOP
INXSTP==1000			;NON-X-MEM STOP

; **********************************************************************
;KI10 PAG CONI ASSIGNMENTS
; **********************************************************************

EXCMEM==400			;EXEC MEMORY SPACE
AMCLRB==40			;ASSOCIATIVE MEMORY CLEAR BIT

; **********************************************************************
;KI10 PAG DATAO ASSIGNMENTS, LEFT HALF
; **********************************************************************

LDUSRB==400000			;LOAD USER BASE REGISTER
SMLUSR==40000			;SMALL USER, 32K OR UNDER
USRCMP==20000			;USER ADR COMPARE ENABLE

; **********************************************************************
;KI10 PAG DATAO ASSIGNMENTS, RIGHT HALF
; **********************************************************************

LDEXCB==400000			;LOAD EXEC BASE REGISTER
TRPENB==20000			;ENABLE TRAPS

; **********************************************************************
;KI10 PAG DATAI ASSIGNMENTS
; **********************************************************************

SMLUSR==40000			;SMALL USER
USRCMP==20000			;USER ADR COMPARE ENABLED
TRPENB==20000			;RH, TRAPS ENABLED

; **********************************************************************
;KI10 PTR DATAO ASSIGNMENTS
; **********************************************************************

				;ADDRESS CONDITIONS, ADDRESS BREAK ;AS ABOVE, PI CONI
				;ADDRESS SWITCHES, 14-35
; **********************************************************************
;KI10 EXEC PAGE MAP PAGE ASSIGNMENTS
; **********************************************************************

PGFTRP==420			;PAGE FAULT TRAP
AROVTP==421			;ARITHMETIC TRAP
PDOVTP==422			;PUSHDOWN OVERFLOW TRAP
TRP3TP==423			;TRAP 3 TRAP

; **********************************************************************
;KI10 USER PAGE MAP PAGE ASSIGNMENTS
; **********************************************************************

PGFTRP==420			;PAGE FAULT TRAP
AROVTP==421			;ARITHMETIC TRAP
PDOVTP==422			;PUSHDOWN OVERFLOW TRAP
TRP3TP==423			;TRAP 3 TRAP

MUUO==	424			;MUUO STORAGE
MUUOPC==425			;C(PC) OF MUUO STORAGE

EXCPFW==426			;EXEC PAGE FAIL WORD
USRPFW==427			;USER PAGE FAIL WORD

KNTRP==	430			;KERNAL	 	NO TRAP - NEW PC'S-
KTRP==	431			;"	 	TRAP
SNTRP==	432			;SUPERVISOR	NO TRAP
STRP==	433			;"		TRAP
CNTRP==	434			;CONCEAL 	NO TRAP
CTRP==	435			;"		TRAP
PNTRP==	436			;PUBLIC		NO TRAP
PTRP==	437			;"		TRAP

>			;END CONDITIONAL ON KI10
	XLIST
	IFDEF	KL10,<
	IFNDEF	KL10P0,<
IFDEF	$PAPER,<LIST>
;KL10 CONO APR 000 ASSIGMENTS
; **********************************************************************

LIOCLR==200000			;CLEAR ALL I/O DEVICES
LFLGEN==100000			;ENABLE SELECTED FLAG
LFLGDS==40000			;DISABLE SELECTED FLAG
LFLGCL==20000			;CLEAR SELECTED FLAG
LFLGST==10000			;SET SELECTED FLAG
LSBUSE==4000			;SBUS ERROR FLAG
LNXMER==2000			;NON-EXISTENT MEMORY FLAG
LPARER==1000			;PARITY ERROR FLAG
LIOPFE==400			;I/O PAGE FAIL FLAG
LPWRFL==100			;POWER FAIL FLAG
LCASWD==20			;CACHE SWEEP DONE FLAG
LAPRP7==7			;APR PI CHANNEL 7
LAPRP6==6			;APR PI CHANNEL 6
LAPRP5==5			;APR PI CHANNEL 5
LAPRP4==4			;APR PI CHANNEL 4
LAPRP3==3			;APR PI CHANNEL 3
LAPRP2==2			;APR PI CHANNEL 2
LAPRP1==1			;APR PI CHANNEL 1
LESBER==104000			;ENABLE SBUS ERRORS
LDSBER==044000			;DISABLE SBUS ERRORS
LCSBER==024000			;CLR SBUS ERRORS
LSSBER==014000			;SET SBUS ERROR
LENXER==102000			;ENABLE NON-EXISTENT MEMORY
LDNXER==042000			;DISABLE NON-EXISTENT MEORY
LCNXER==022000			;CLR NON-EXISTENT MEMORY
LSNXER==012000			;SET NON-EXISTENT MEMORY
LEPAER==101000			;ENABLE PARITY ERRORS
LDPAER==041000			;DISABLE PARITY ERRORS
LCPAER==021000			;CLR PARITY ERROR
LSPAER==011000			;SET PARITY ERROR
LEIOPF==100400			;ENABLE I/O PAGE FAILS
LDIOPF==040400			;DISABLE I/O PAGE FAILS
LCIOPF==020400			;CLR I/O PAGE FAIL
LSIOPF==010400			;SET I/O PAGE FAIL
LEPWRF==100100			;ENABLE POWER FAIL
LDPWRF==040100			;DISABLE POWER FAIL
LCPWRF==020100			;CLR POWER FAIL
LSPWRF==010100			;SET POWER FAIL
LECASD==100020			;ENABLE CACHE SWEEP DONE
LDCASD==040020			;DISABLE CACHE SWEEP DONE
LCCASD==020020			;CLR CACHE SWEEP DONE
LSCASD==010020			;SET CACHE SWEEP DONE
LAPRAL==127520			;CLR ALL ERROR FLAGS & ENABLE
; **********************************************************************
;KL10 CONI APR 000 ASSIGMENTS (LEFT HALF)
; **********************************************************************

LSBSEN==4000			;SBUS ERRORS ENABLED
LNXMEN==2000			;NON-EXISTENT MEMORY ERRORS ENABLED
LPAREN==1000			;PARITY ERRORS ENABLED
LIOPFE=400			;I/O PAFE FAILURES ENABLED
LPWRFE==100			;POWER FAILURES ENABLED
LCASDE==20			;CACHE SWEEP DONE ENABLED

; **********************************************************************
;KL10 CONI APR 000 ASSIGMENTS (RIGHT HALF)
; **********************************************************************

LCASWB==200000			;CACHE SWEEP BUSY
LSBUSE==4000			;SBUS ERROR FLAG
LNXMER==2000			;NON-EXISTENT MEMORY FLAG
LPARER==1000			;PARITY ERROR FLAG
LIOPFE==400			;I/O PAGE FAIL FLAG
LPWRFL==100			;POWER FAIL FLAG
LCASWD==20			;CACHE SWEEP DONE FLAG
LAPRP7==7			;APR PI CHANNEL 7
LAPRP6==6			;APR PI CHANNEL 6
LAPRP5==5			;APR PI CHANNEL 5
LAPRP4==4			;APR PI CHANNEL 4
LAPRP3==3			;APR PI CHANNEL 3
LAPRP2==2			;APR PI CHANNEL 2
LAPRP1==1			;APR PI CHANNEL 1
LINT==10			;APR INTERRUPT

; **********************************************************************
;KL10 DATAO APR 000 ASSIGMENTS (LEFT HALF)
; **********************************************************************

LINSTF==400			;ADDRESS BREAK REQUEST FOR INST. FETCH
LDATAF==200			;ADDRESS BREAK REQUEST FOR DATA FETCH
LWRITE==100			;ADDRESS BREAK REQUEST FOR DATA WRITE
LUSCMP==40			;USER ADDRESS COMPARE
LEXCMP==0			;EXEC ADDRESS COMPARE

; **********************************************************************
;KL10 DATAO APR 000 ASSIGMENTS (RIGHT HALF)
; **********************************************************************

;DATAO APR,ADDRESS SWITCHES=13-35
>
	XLIST
	IFDEF	KL10P0,<
IFDEF	$PAPER,<LIST>
;KL10 CONO APR 000 ASSIGMENTS
; **********************************************************************
LIOCLR==200000			;CLEAR ALL I/O DEVICES
LFLGEN==100000			;ENABLE SELECTED FLAG
LFLGDS==40000			;DISABLE SELECTED FLAG
LFLGCL==20000			;CLEAR SELECTED FLAG
LFLGST==10000			;SET SELECTED FLAG
LSBUSE==4000			;SBUS ERROR FLAG
LNXMER==2000			;NON-EXISTENT MEMORY FLAG
LIOPFE==1000			;I/O PAGE FAIL FLAG
LPARER==400			;MB PARITY ERROR FLAG
LCADRP==200			;CACHE ADDRESS PARITY ERROR FLAG
LSADRP==100			;S-BUS ADDRESS PARITY ERROR FLAG
LPWRFL==40			;POWER FAIL FLAG
LCASWD==20			;CACHE SWEEP DONE FLAG
LAPRP7==7			;APR PI CHANNEL 7
LAPRP6==6			;APR PI CHANNEL 6
LAPRP5==5			;APR PI CHANNEL 5
LAPRP4==4			;APR PI CHANNEL 4
LAPRP3==3			;APR PI CHANNEL 3
LAPRP2==2			;APR PI CHANNEL 2
LAPRP1==1			;APR PI CHANNEL 1
LESBER==104000			;ENABLE SBUS ERRORS
LDSBER==044000			;DISABLE SBUS ERRORS
LCSBER==024000			;CLR SBUS ERRORS
LSSBER==014000			;SET SBUS ERROR
LENXER==102000			;ENABLE NON-EXISTENT MEMORY
LDNXER==042000			;DISABLE NON-EXISTENT MEORY
LCNXER==022000			;CLR NON-EXISTENT MEMORY
LSNXER==012000			;SET NON-EXISTENT MEMORY
LEIOPF==101000			;ENABLE I/O PAGE FAILS
LDIOPF==041000			;DISABLE I/O PAGE FAILS
LCIOPF==021000			;CLR I/O PAGE FAIL
LSIOPF==011000			;SET I/O PAGE FAIL
LEPAER==100400			;ENABLE PARITY ERRORS
LDPAER==040400			;DISABLE PARITY ERRORS
LCPAER==020400			;CLR PARITY ERROR
LSPAER==010400			;SET PARITY ERROR
LECAER==100200			;ENABLE CACHE ADR PARITY ERRORS
LDCAER==040200			; " DISABLE
LCCAER==020200			; " CLR
LSCAER==010200			; " SET
LESAER==100100			;ENABLE S-BUS ADR PARITY ERRORS
LDSAER==040100			; " DISABLE
LCSAER==020100			; " CLR
LSSAER==010100			; " SET
LEPWRF==100040			;ENABLE POWER FAIL
LDPWRF==040400			;DISABLE POWER FAIL
LCPWRF==020040			;CLR POWER FAIL
LSPWRF==010040			;SET POWER FAIL
LECASD==100020			;ENABLE CACHE SWEEP DONE
LDCASD==040020			;DISABLE CACHE SWEEP DONE
LCCASD==020020			;CLR CACHE SWEEP DONE
LSCASD==010020			;SET CACHE SWEEP DONE
LAPRAL==127760			;CLR ALL ERROR FLAGS & ENABLE
; **********************************************************************
;KL10 CONI APR 000 ASSIGMENTS (LEFT HALF)
; **********************************************************************

LSBSEN==4000			;SBUS ERRORS ENABLED
LNXMEN==2000			;NON-EXISTENT MEMORY ERRORS ENABLED
LIOPFE==1000			;I/O PAGE FAILURES ENABLED
LPAREN==400			;PARITY ERRORS ENABLED
LCADEN==200			;CACHE ADR PARITY ERRORS ENABLED
LSADEN==100			;S-BUS ADR PARITY ERRORS ENABLED
LPWRFE==40			;POWER FAILURES ENABLED
LCASDE==20			;CACHE SWEEP DONE ENABLED

; **********************************************************************
;KL10 CONI APR 000 ASSIGMENTS (RIGHT HALF)
; **********************************************************************

LCASWB==200000			;CACHE SWEEP BUSY
LSBUSE==4000			;SBUS ERROR FLAG
LNXMER==2000			;NON-EXISTENT MEMORY FLAG
LIOPFE==1000			;I/O PAGE FAIL FLAG
LPARER==400			;PARITY ERROR FLAG
LCADRP==200			;CACHE ADR PARITY ERROR FLAG
LSADRP==100			;S-BUS ADR PARITY ERROR FLAG
LPWRFL==40			;POWER FAIL FLAG
LCASWD==20			;CACHE SWEEP DONE FLAG
LAPRP7==7			;APR PI CHANNEL 7
LAPRP6==6			;APR PI CHANNEL 6
LAPRP5==5			;APR PI CHANNEL 5
LAPRP4==4			;APR PI CHANNEL 4
LAPRP3==3			;APR PI CHANNEL 3
LAPRP2==2			;APR PI CHANNEL 2
LAPRP1==1			;APR PI CHANNEL 1
LINT==10			;APR INTERRUPT

; **********************************************************************
;KL10 DATAO APR 000 ASSIGMENTS (LEFT HALF)
; **********************************************************************

LINSTF==400			;ADDRESS BREAK REQUEST FOR INST. FETCH
LDATAF==200			;ADDRESS BREAK REQUEST FOR DATA FETCH
LWRITE==100			;ADDRESS BREAK REQUEST FOR DATA WRITE
LUSCMP==40			;USER ADDRESS COMPARE
LEXCMP==0			;EXEC ADDRESS COMPARE

; **********************************************************************
;KL10 DATAO APR 000 ASSIGMENTS (RIGHT HALF)
; **********************************************************************

;DATAO APR,ADDRESS SWITCHES=13-35
>
	XLIST
IFDEF	$PAPER,<LIST>
; **********************************************************************
;KL10 DATAI APR 000 ASSIGMENTS (LEFT HALF)
; **********************************************************************

LINSTF==400			;ADDRESS BREAK REQUEST FOR INST. FETCH
LDATAF==200			;ADDRESS BREAK REQUEST FOR DATA FETCH
LWRITE==100			;ADDRESS BREAK REQUEST FOR DATA WRITE
LUSCMP==40			;USER ADDRESS COMPARE
LEXCMP==0			;EXEC ADDRESS COMPARE

; **********************************************************************
;KL10 DATAI APR 000 ASSIGMENTS (RIGHT HALF)
; **********************************************************************

;DATAI APR,ADDRESS SWITCHES=13-35

; **********************************************************************
;KL10 BLKO APR 000 ASSIGMENTS (IMMEDIATE MODE)
; **********************************************************************

;REFILL ALGORITHM BITS 18-20
;REFILL ALGORITHM ADDRESS 27-33

; **********************************************************************
;KL10 BLKI APR 000 ASSIGMENTS
; **********************************************************************

;MICRO-CODE OPTIONS = 0-8
;MICRO-CODE VERSION NUMBER = 9-17
;HARDWARE OPTIONS =18-23
;PROCESSOR SERIAL NUMBER = 24-35
; **********************************************************************
;KL10 CONO PI 004 ASSIGMENTS
; **********************************************************************

LEVNPA==400000			;WRITE EVEN PARITY ADDRESS
LEVNPD==200000			;WRITE EVEN PARITY DATA
LEVNCD==100000			;WRITE EVEN CACHE DIRECTORY PARITY *P0
LRQCLR==20000			;DROP INTERRUPT ON SELECTED CHANNEL
LPICLR==10000			;CLEAR PI SYSTEM
LREQSE==4000			;REQUEST INTERRUPT ON SELECTED CHANNEL
LCHNON=2000			;TURN ON SELECTED CHANNEL
LCHNOF==1000			;TURN OFF SELECTED CHANNEL
LPIOFF==400			;TURN PI SYSTEM OFF
LPION==200			;TURN PI SYSTEM ON
LPICH1==100			;PI CHANNEL 1
LPICH2==40			;PI CHANNEL 2
LPICH3==20			;PI CHANNEL 3
LPICH4==10			;PI CHANNEL 4
LPICH5==4			;PI CHANNEL 5
LPICH6==2			;PI CHANNEL 6
LPICH7==1			;PI CHANNEL 7
LPICHA==177			;ALL PI CHANNELS

; **********************************************************************
;KL10 CONI PI 004 ASSIGMENTS (LEFT HALF)
; **********************************************************************

LPRCH1==100			;PROGRAM REQUEST ON CHANNEL 1
LPRCH2==40			;PROGRAM REQUEST ON CHANNEL 2
LPRCH3==20			;PROGRAM REQUEST ON CHANNEL 3
LPRCH4==10			;PROGRAM REQUEST ON CHANNEL 4
LPRCH5==4			;PROGRAM REQUEST ON CHANNEL 5
LPRCH6==2			;PROGRAM REQUEST ON CHANNEL 6
LPRCH7==1			;PROGRAM REQUEST ON CHANNEL 7
; **********************************************************************
;KL10 CONI PI 004 ASSIGMENTS (RIGHT HALF)
; **********************************************************************

LEVNPA==400000			;WRITE EVEN PARITY ADDRESS
LEVNPD==200000			;WRITE EVEN PARITY DATA
LEVNCD==100000			;WRITE EVEN CACHE DIRECTORY PARITY *P0
LPIIP1==40000			;PI IN PROGRESS ON CHANNEL 1
LPIIP2==20000			;PI IN PROGRESS ON CHANNEL 2
LPIIP3==10000			;PI IN PROGRESS ON CHANNEL 3
LPIIP4==4000			;PI IN PROGRESS ON CHANNEL 4
LPIIP5==2000			;PI IN PROGRESS ON CHANNEL 5
LPIIP6==1000			;PI IN PROGRESS ON CHANNEL 6
LPIIP7==400			;PI IN PROGRESS ON CHANNEL 7
LPION==200			;PI SYSTEM ON
LPICH1==100			;PI CHANNEL 1 ON
LPICH2==40			;PI CHANNEL 2 ON
LPICH3==20			;PI CHANNEL 3 ON
LPICH4==10			;PI CHANNEL 4 ON
LPICH5==4			;PI CHANNEL 5 ON
LPICH6==2			;PI CHANNEL 6 ON
LPICH7==1			;PI CHANNEL 7 ON
; **********************************************************************
;KL10 DATAO PAG 010 ASSIGMENTS (LEFT HALF)
; **********************************************************************

LLACBL==400000			;LOAD AC BLOCKS
LLPRCN==200000			;LOAD PREVIOUS CONTEXT SECTION
LLDUSB==100000			;LOAD USER BASE REGISTER
LCWSX==40			;

;CURRENT AC BLOCKS BITS 6 - 8
;PREVIOUS AC BLOCKS BITS 9 - 11
;PREVIOUS CONTEXT SECTION BITS 13 - 17

; **********************************************************************
;KL10 DATAO PAG 010 ASSIGMENTS (RIGHT HALF)
; **********************************************************************

;USER BASE REGISTER BITS 23 - 35

; **********************************************************************
;KL10 DATAI PAG 010 ASSIGMENTS (LEFT HALF)
; **********************************************************************

LLACBL==400000			;LOAD AC BLOCKS
LLPRCN==200000			;LOAD PREVIOUS CONTEXT SECTION
LLDUSB==100000			;LOAD USER BASE REGISTER
LCWSX==40			;

;CURRENT AC BLOCKS BITS 6 - 8
;PREVIOUS AC BLOCKS BITS 9 - 11
;PREVIOUS CONTEXT SECTION BITS 13 - 17

; **********************************************************************
;KL10 DATAI PAG 010 ASSIGMENTS (RIGHT HALF)
; **********************************************************************

;USER BASE REGISTER BITS 23 - 35
; **********************************************************************
;KL10 CONO PAG 010 ASSIGMENTS
; **********************************************************************

LCASLO==400000			;CACHE STRATEGY LOOK
LCASLD==200000			;CACHE STRATEGY LOAD
LSMODE==40000			;SECTION MODE
LTRPEN==20000			;TRAP AND PAGE ENABLE

;EXEC BASE REGISTER = 23-35

; **********************************************************************
;KL10 CONI PAG 010 ASSIGMENTS
; **********************************************************************


LCSLOO==400000			;CACHE STRATEGY LOOK
LCSLOA==200000			;CACHE STRATEGY LOAD
LSECMO==40000			;SECTION MODE
LTRPAE==20000			;TRAP AND PAGE ENABLE

;EXEC BASE REGISTER = 23-35

; **********************************************************************
;KL10 BLKO PAG 010 ASSIGMENTS (IMMEDIATE MODE)
; **********************************************************************

	XLIST
	IFNDEF	KL10P0,<
IFDEF	$PAPER,<LIST>
; **********************************************************************
;KL10 EXEC PAGE MAP PAGE ASSIGNMENTS
; **********************************************************************

LAROVT==421			;ARITHMETIC TRAP
LPDOVT==422			;PUSHDOWN OVERFLOW TRAP
LTRP3T==423			;TRAP 3 TRAP

; **********************************************************************
;KL10 USER PAGE MAP PAGE ASSIGNMENTS
; **********************************************************************

LEUPFW==420			;EXEC & USER PAGE FAIL WORD
LAROVT==421			;ARITHMETIC TRAP
LPDOVT==422			;PUSHDOWN OVERFLOW TRAP
LTRP3T==423			;TRAP 3 TRAP

LMUUO==	424			;MUUO STORAGE
LMUUOP==425			;C(PC) OF MUUO STORAGE

LPFWPC==426			;C(PC) OF PAGE FAIL WORD
LPGFTR==427			;PAGE FAIL NEW PC TRAP

LKNTRP==430			;KERNAL	 	NO TRAP - NEW PC'S-
LKTRP==	431			;"	 	TRAP
LSNTRP==432			;SUPERVISOR	NO TRAP
LSTRP==	433			;"		TRAP
LCNTRP==434			;CONCEAL 	NO TRAP
LCTRP==	435			;"		TRAP
LPNTRP==436			;PUBLIC		NO TRAP
LPTRP==	437			;"		TRAP

>
	XLIST
	IFDEF	KL10P0,<
IFDEF	$PAPER,<LIST>
; **********************************************************************
;KL10 EXEC PAGE MAP PAGE ASSIGNMENTS
; **********************************************************************

LAROVT==421			;ARITHMETIC TRAP
LPDOVT==422			;PUSHDOWN OVERFLOW TRAP
LTRP3T==423			;TRAP 3 TRAP

LTBASH==510			;TIME-BASE, HI
LTBASL==511			;TIME-BASE, LO
LPRFMH==512			;PERFORMANCE ANAYLYSIS, HI
LPRFML==513			;PERFORMANCE ANAYLYSIS, LO

; **********************************************************************
;KL10 USER PAGE MAP PAGE ASSIGNMENTS
; **********************************************************************

LAROVT==421			;ARITHMETIC TRAP
LPDOVT==422			;PUSHDOWN OVERFLOW TRAP
LTRP3T==423			;TRAP 3 TRAP

LMUUO==	424			;MUUO STORAGE
LMUUOP==425			;C(PC) OF MUUO STORAGE
LCNTXT==426			;PROCESS CONTEXT WORD

LKNTRP==430			;KERNAL	 	NO TRAP - NEW PC'S-
LKTRP==	431			;"	 	TRAP
LSNTRP==432			;SUPERVISOR	NO TRAP
LSTRP==	433			;"		TRAP
LCNTRP==434			;CONCEAL 	NO TRAP
LCTRP==	435			;"		TRAP
LPNTRP==436			;PUBLIC		NO TRAP
LPTRP==	437			;"		TRAP

LEUPFW==500			;EXEC & USER PAGE FAIL WORD
LPFWPC==501			;C(PC) OF PAGE FAIL WORD
LPGFTR==502			;PAGE FAIL NEW PC

LEBXMH==504			;E-BOX CLOCK TICK METER, HI
LEBXML==505			;E-BOX CLOCK TICK METER, LO
LMBXMH==506			;M-BOX CYCLE METER, HI
LMBXML==507			;M-BOX CYCLE METER, LO

>>				;END CONDITIONAL ON KL10
	LIST

SUBTTL	*FIXED* FIXED CONTROL AND DISPATCH STORAGE, SEPT 18,1979

	LOC	30000

; **********************************************************************
;PROGRAM STARTING ADDRESSES
;THESE ADDRESSES CALL VARIOUS SPECIAL START ROUTINES AND OR OPTIONS
;NORMAL START ADDRESS IS 30000 ALL OTHERS ARE SPECIAL. INVOKED BECAUSE
;OF END OF PASS, POWER FAILURE, DDT START, RE-ENTERING(TYPICALLY USER
;MODE), OR ANY NUMBER OF SPECIAL FEATURE TESTS.
; **********************************************************************

BEGIN:	JRST	@MODLNK		;STAND-ALONE START
$START:	JRST	START		;MODE CHECK STARTING ADDRESS

DIAGMN:	JRST	@LDLNK		;DIAGNOSTIC MONITOR START

SYSEXR:	JRST	@LDLNK		;SYSTEM EXERCISER START

SFSTRT:	JRST	SADR1		;SPECIAL FEATURE START

PFSTRT:	JRST	SADR2		;POWER FAIL RESTART

REENTR:	JRST	SADR3		;REENTER START(USUALLY USER MODE ONLY)

SRTDDT:				;COMMONLY MISTAKEN NAME FOR "DDTSRT"
DDTSRT:	JRST	@DDTLNK		;DDT START

BEGIN1:	JRST	STARTA		;LOOP START(END OF PASS COMES HERE)
SBINIT:	JRST	@SUBLNK		;PMGINT LINKAGE
RETURN:	0			;RETURN ADDRESS STORAGE

START1:	SADR7			;OPTIONAL STARTING ADR/INSTRUCTIONS
START2:	SADR8			; "
START3:	SADR9			; "
START4:	SADR10			; "
START5:	SADR11			; "
; **********************************************************************
;PROGRAM FIXED PARAMETER AREA
; **********************************************************************

PNTNAM:	PAREA3		;SIXBIT PROGRAM NAME
PNTEXT:	PAREA4		;SIXBIT PROGRAM EXTENSION
RANDBS:	PAREA1		;RANDOM BASE NUMBER
SWTEXR:	PAREA2		;SYSTEM EXERCISER SWITCHES
ITRCNT:	ITERAT		;PROGRAM ITERATIONS
$PNAME:	PGMNAM		;POINTER TO PROGRAMS NAME
$PVER:	MCNVER,,DECVER	;MCN & DEC VERSION LEVEL
$MODVL:	MODDVL		;DEVICE CODE CHANGE LOWER LIMIT
$MODVU:	MODDVU		;DEVICE CODE CHANGE UPPER LIMIT
$EMODE:	IFNDEF EXCASB,<0> IFDEF EXCASB,<-1>	;EXEC ALLOWED
$UMODE:	IFNDEF USRASB,<0> IFDEF USRASB,<-1>	;USER ALLOWED
$DSKUP:	IFNDEF DSKUPD,<0> IFDEF DSKUPD,<-1>	;DISK UPDATE MODE
$MMAP:	IFNDEF MEMMAP,<0> IFDEF MEMMAP,<-1>	;ALLOW MEMORY RTNS
PAREA7:	PAREA5		;OPTIONAL PARAMETER
PAREA8:	PAREA6		;OPTIONAL PARAMETER

; **********************************************************************
;PROGRAM VARIABLE PARAMETER AREA
; **********************************************************************

USER:	0		; 0 = EXEC, -1 = USER MODE FLAG
KAIFLG:	0		;PROCESSOR TYPE, 0 = KA10, -1 = KI10
KLFLG:	0		;PROCESSOR TYPE, 0 = KA/KI, -1 = KL10
MONFLG:	-1		;DIAG MONITOR SPECIAL USER FLAG
MONCTL:	0		;DIAG MON/SYS EXR FLAG
MONTEN:	0		;-1= LOADED BY 10
CLOCKF:	0		;CLOCK TICKED FLAG
CONSW:	0		;CONSOLE SWITCH SETTINGS
PASCNT:	0		;PROGRAM PASS COUNT
RUNFLG:	0		;PROGRAM RUN FLAG
TESTPC:	0		;SUBTEST PC
ERRPC:	0		;ERROR PC
ERRTLS:	0		;ERROR TOTALS
TICKS:	0		;PROGRAM RUNNING TIME
MARGIN:	0		;KI10 MARGIN WORD VALUE
$ONETM:	0		;SUBROUTINE INITIALIZATION FLAG
; **********************************************************************
;SPECIAL PROGRAM DISPATCH ADDRESSES
; **********************************************************************

BEGEND:	ENDUUO		;END OF PASS
$BEND1:	JRST	BEGIN1	;KEEP RUNNING PROGRAM
$BEND2:	EOPUUO		;END OF PROGRAM - NO RETURN
CNTLC:	SADR5		;CONTROL C XFER ADDRESS
ALTMGO:	SADR6		;ALTMODE XFER ADDRESS
CPOPJ1:			;SKIP RETURN
UUOSKP:	AOS	(P)	;SKIP RETURN FROM UUO
CPOPJ:			;NON-SKIP REGULAR RETURN
UUOEXT:	RTN		;UUO RETURN
UUORTN:	JFCL		;ADDITIONAL USERS UUO ROUTINE
$UORTX:	JFCL		;ADDITIONAL UUO LINKAGE
$UUOER:	JFCL		;INITED AS (JRST $UOERX)
$ITRHL:	JFCL		;ADDITIONAL INTERRUPT LINKAGE
$ITRX1:	JFCL		; "
$USRHL:	JFCL		; "
$RSRTX:	JFCL		;ADDITIONAL POWER FAIL LINKAGE
$RSRTY:	JFCL		; "
RESRT1:	JFCL		; INITED AS (JRST RESRTX)
RESRT2:	JFCL		; "
$PARER:	JFCL		;ADDITIONAL PARITY ERROR LINKAGE
ERMORE:	JFCL		;ADDITIONAL ERROR HANDLER LINKAGE
	HALT	.	;IMPROPER TRANSFER HALT

$PSHER:	0		;INITED AS (JRST PSHERR)
ITRCH1:	0		;PC & FLAGS OF CURRENT INTERRUPT
	0		;INITED AS (JRST $ITRC1)

; **********************************************************************
;PROCESSOR CONTROL STORAGE
; **********************************************************************

$ACC0:	0		;INTERRUPT SAVED AC0
$SVPI:	0		;INTERRUPT SAVED PI
$SVAPR:	0		;INTERRUPT SAVED APR
$SVPAG:	0		;INTERRUPT SAVED PAG (DATAI)
$SPAG1:	0		;INTERRUPT SAVED PAG (CONI)

$SVUUO:	0		;CURRENT USERS UUO
$SVUPC:	0		;PC OF CURRENT USERS UUO

REPTU:	0		;REPEAT UUO ITERATIONS
SCOPE:	0		;ERROR HANDLER SCOPE LOOP FLAG
%CORFLG:0		; " CORRECT FLAG
%COREC:	0		; " CORRECT DATA
%ACTFL:	0		; " ACTUAL FLAG
%ACTUL:	0		; " ACTUAL DATA
%DISCR:	0		; " DISCREPENCY DATA
; **********************************************************************
;UUO DISPATCH TABLE
; **********************************************************************
	XLIST
IFNDEF	LUUO1,<LUUO1=$UUOER>
IFNDEF	LUUO2,<LUUO2=$UUOER>
IFNDEF	LUUO3,<LUUO3=$UUOER>
IFNDEF	LUUO4,<LUUO4=$UUOER>
IFNDEF	LUUO5,<LUUO5=$UUOER>
IFNDEF	LUUO6,<LUUO6=$UUOER>
IFNDEF	LUUO7,<LUUO7=$UUOER>
IFNDEF	LUUO10,<LUUO10=$UUOER>
IFNDEF	LUUO11,<LUUO11=$UUOER>
IFNDEF	LUUO12,<LUUO12=$UUOER>
IFNDEF	LUUO13,<LUUO13=$UUOER>
IFNDEF	LUUO14,<LUUO14=$UUOER>
IFNDEF	LUUO15,<LUUO15=$UUOER>
IFNDEF	LUUO16,<LUUO16=$UUOER>
IFNDEF	LUUO17,<LUUO17=$UUOER>
IFNDEF	LUUO20,<LUUO20=$UUOER>
IFNDEF	LUUO21,<LUUO21=$UUOER>
IFNDEF	LUUO22,<LUUO22=$UUOER>
IFNDEF	LUUO23,<LUUO23=$UUOER>
IFNDEF	LUUO24,<LUUO24=$UUOER>
IFNDEF	LUUO25,<LUUO25=$UUOER>
IFNDEF	LUUO26,<LUUO26=$UUOER>
IFNDEF	LUUO27,<LUUO27=$UUOER>
IFNDEF	LUUO30,<LUUO30=$UUOER>
IFNDEF	LUUO31,<LUUO31=$UUOER>
IFNDEF	LUUO32,<LUUO32=$UUOER>
IFNDEF	LUUO33,<LUUO33=$UUOER>
	LIST
UUODIS:	LUUO1,,$UUOER
	LUUO3,,LUUO2
	LUUO5,,LUUO4
	LUUO7,,LUUO6
	LUUO11,,LUUO10
	LUUO13,,LUUO12
	LUUO15,,LUUO14
	LUUO17,,LUUO16
	LUUO21,,LUUO20
	LUUO23,,LUUO22
	LUUO25,,LUUO24
	LUUO27,,LUUO26
	LUUO31,,LUUO30
	LUUO33,,LUUO32

; **********************************************************************
;MEMORY MANAGMENT STORAGE
; **********************************************************************

DF22F:	0		;DF10 CONTROL FLAG, 0 = 18, -1 = 22 BIT
MAPNEW:	0		;MEMORY MAPPING CONTROL FLAG, -1 = 4096K MAPPING
MEMTOT:	0		;TOTAL MEMORY SIZE IN K (1024.)
MEMLOW:	0		;LOWEST USABLE MEMORY
MEMSIZ:	BLOCK ^D41	;MEMORY SEGMENT POINTER TABLE

; **********************************************************************
;PRINT CONTROL STORAGE
; **********************************************************************

PNTFLG:	0		;PRINT FLAG, -1 WHILE IN PRINT ROUTINE
PNTENB:	0		;PRINT ENABLE
PDISF:	0		;PRINT DISABLED FLAG
PNTINH:	0		;INHIBIT PRINT INPUT CHECKS
PNTSPC:	0		;PRINT SPACE CONTROL
OPTIME:	0		;TYPE-IN WAIT TIME
$TWCNT:	0		;TIME WAITED
$DVOFF:	0		;LOGICAL DEVICE INITED FLAG
TTYFIL:	0		;TTY EXEC FILLERS FLAG
TTYSPD:	0		;TTY EXEC BAUD RATE
$TTCHR:	0		;ACTUAL TYPED IN CHAR
$CHRIN:	0		;UPPER CASED & PARITY STRIPPED CHAR
$TYPNB:	0		;TYPED IN NUMBER
$CRLF:	0		;FREE CR/LF FLAG
$TABF:	0		;TAB CONVERSION FLAG
$FFF:	0		;FORM FEED CONVERSION FLAG
$VTF:	0		;VERTICAL TAB CONVERSION FLAG
USRLFF:	0		;USER LF FILLERS
USRCRF:	0		;USER CR FILLERS
; **********************************************************************
;THE FOLLOWING MISCELLANEOUS PRINT CHARACTERS ARE INCLUDED
;TO FACILITATE PRINTING AND ARE CALLED AS FOLLOWS:
;	MOVEI	NAME
;	PNTA		;OR PNTAF
; **********************************************************************

CRLF:	ASCII/
/
CRLF2:	ASCII/

/
COMMA:	ASCII/,/
PERIOD:	ASCII/./
SPACE:	ASCII/ /
TAB:	ASCII/	/
MINUS:
HYPEN:	ASCII/-/
PLUS:	ASCII/+/
AST:	ASCII/*/
ATSIN:	ASCII/@/
LFP:	ASCII/(/
RTP:	ASCII/)/
BELL:	BYTE (7) 007
QUEST:	ASCII/?/
SLASH:	ASCII!/!
DOLLAR:	ASCII/$/
RADIX:	^D10			;DECIMAL PRINT RADIX
RADLSP:	40			;DECIMAL PRINT LEADING CHAR
RADLSC:	^D10			;DECIMAL PRINT LEADING CHAR COUNT

; **********************************************************************
;USER MODE OUTPUT FILE INFORMATION
; **********************************************************************

$OBUF:	BLOCK	3		;LOGICAL FILE OUTPUT BUFFER HEADER
$OUTNM:	SIXBIT	/PRINT/		;FILE NAME
$OUTEX:	SIXBIT	/PNT/		;FILE NAME EXTENSION
	BLOCK	2

; **********************************************************************
;DISK UPDATE MODE FILE INFORMATION
; **********************************************************************

$IBUF:	BLOCK	3
$INNM:	SIXBIT	/PRINT/
$INEXT:	SIXBIT	/PNT/
	BLOCK	2
; **********************************************************************
;PUSHDOWN LIST CONTROL INFORMATION
; **********************************************************************

PLIST:	PLIST-PLISTE,,PLIST
PLISTS:	BLOCK	200
PLISTE:	0		;END OF PUSHDOWN LIST

; **********************************************************************
;POWER LINE CLOCK FREQUENCY FLAG
; **********************************************************************

CYCL60:	0	;0 = 60, -1 = 50 CYCLE

; **********************************************************************
;KL10 CACHE CONTROL FLAGS
; **********************************************************************

CSHFLG:	0	;ALLOW CACHE IF 0
CSHMEM:	0	;CACHE MEMORY SEGMENTS IF 0

; **********************************************************************
;NUMBER INPUT DIGIT FLAG
; **********************************************************************

TTNBRF:	0	;-1 IF ANY DIGIT TYPED

; **********************************************************************
;KL10 & KI10 "INHPAG" SWITCH PAGING PREVENTION
; **********************************************************************

PVPAGI:	0	;IF NON-ZERO, OVERRIDE "INHPAG" SWITCH ACTION

; **********************************************************************
;ERROR REPORTING ROUTINE ADDITIONAL USERS CONTROL INSTRUCTIONS
; **********************************************************************

%ERHI1:	0	;IF NON-ZERO, XCT'D AT START OF %ERUUO
%ERHI2:	0	;IF NON-ZERO, XCT'D AT END OF %ERUUO
%ERHI3:	0	;IF NON-ZERO, XCT'D AFTER "PC" OF %ERUUO

; **********************************************************************
;SPECIAL USERS UUO INTERCEPT INSTRUCTION
; **********************************************************************

$$UUO:	0	;IF NON-ZERO, XCT'D AT START OF $UORTN
; **********************************************************************
;USER MODE MONITOR TYPE FLAG
; **********************************************************************

MONTYP:	0	;0 = TOPS10, -1 = TOPS20

;*********************************************************************^
;*KL10 PROCESSOR TYPE FLAG, 0=P0, 1=BBD NEW, 2=BBD OLD
;*********************************************************************^

KLTYP:	0

; **********************************************************************
;SPECIAL USERS MUUO INTERCEPT INSTRUCTION
; **********************************************************************

$$MUUO:	0	;IF NON-ZERO, XCT'D AT START OF MUUOER

; **********************************************************************
;SPECIAL USERS USER MODE OUTPUT ERROR INTERCEPT INSTUCTION
; **********************************************************************

$$OUTER:0	;IF NON-ZERO, XCT'D AT END OF USER MODE ERROR

; **********************************************************************
;"SWITCH" CALL USAGE CONTROL
; **********************************************************************

$$TOGGLE:0	;IF NON-ZERO, USE C(CONSW) FOR SWITCHES

; **********************************************************************
;SPECIAL USERS ALTMODE SWITCH CALL INTERCEPT INSTRUCTIONS
; **********************************************************************

$$TAX1:	0	;IF NON-ZERO, XCT'D AT START OF ALTMODE SWITCH CALL
$$TAX2:	0	;IF NON-ZERO, XCT'D AT END OF ALTMODE SWITCH CALL

; **********************************************************************
;SM10 (KS-10) PROCESSOR TYPE FLAG
; **********************************************************************

SM10:	0	;IF -1 THIS IS A KS-10

; **********************************************************************
;RIGHT HALF SWITCHES PROMPT TABLE ADDRESS
; **********************************************************************

SWPTAB:	0	;0 = NO PROMPT, ADR = ADR OF SIXBIT PROMPT TABLE

; **********************************************************************
;SPECIAL FUTURE EXPANSION ROOM
; **********************************************************************

; **********************************************************************
;END OF FIXED STORAGE
; **********************************************************************

	LOC	30577
ENDFIX:	0		;END OF FIXED STORAGE

;INITIALIZE UUO HANDLER

START:	;PGMINT			;INITIALIZE SUBROUTINES
	MOVE	0,RANDBS	;EXEC, SETUP RANDOM BASE
	SKIPE	USER		;USER, USE TIME OF DAY IN JIFFIES
	;CALL	0,[SIXBIT/TIMER/]
	MOVEM	0,RAN		;SETUP RANDOM BASE

;INITIALIZE COMPLEXITY TABLE
	A=0
STARTA:	SETZM	CMPLXT		;STORE A TABLE OF POWERS OF 2
	MOVEI	1,1		;OR 0.
	;SWITCH
	TLNN	RELIAB		;FAST CYCLE SWITCH SET ?
	SETZM	1		;YES, STORE ZERO'S
	REPEAT	7,
<	MOVEM	1,CMPLXT+1+A
	LSH	1,1
	A=A+1>
;INITIALIZE RUN TIME

	MOVEI	1,1
	TLNE	RELIAB		;FAST CYCLE SWITCH SET ?
	MOVEI	1,7		;NO, MULTIPLY RUNNING TIME
	MOVEM	1,RTIME		;STORE IN RTIME

	JRST	CAM1		;GO PERFORM DIAGNOSTIC

RENTR1:	;DROPDV			;CLOSE LOGICAL OUTPUT FILE
	;CALL	[SIXBIT .EXIT.]

PGMNAM:	ASCIZ/
PDP-10  KA10 BASIC INSTRUCTION RELIABILITY TEST 1 (DAKBA)
(COMPARES, SKIPS, EXCHANGES, BOOLE, ROTATES, TESTS, ETC.)
/
;CONSTANTS

RTIME:	0
CMPLXT:	BLOCK	20
SUBTTL	DIAGNOSTIC SECTION
	LALL

;TEST CAMN,CAME (SIMPLE)
;THE CONTENTS OF THE AC IS COMPARED WITH ITSELF
;AN ERROR WILL OCCUR IF CAMN SKIPS OR CAME FAILS TO SKIP
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)
;15 ACS ARE USED IN THE TEST

	AC=2
CAM1:	SETUP 20,0
	RANDOM
CAMNE1:	REPEAT ^D10,
<	MOVE	AC,RAN
	CAMN	AC,AC		;C(AC) = C(AC)
	CAME	AC,AC
	ERROR	AC,AC		;CHECK CAME,CAMN
	AC=<AC+1>&17
>
	AC=2
	LOOP CAMNE1-3,CAMNE1


;TEST MOVE TO AC,FURTHER TEST OF CAME
;THE C(AC) IS COMPARED WITH THE CONTENTS OF THE RANDOM
;NUMBER GENERATOR. 15 ACS ARE USED IN THE TEST
;ERRORS ARE PRINTED IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
MOVAC:	SETUP 20,0
	RANDOM
MOVAC1:	REPEAT ^D10,
<	MOVE AC,RAN		;MOVE RAN INTO AC.
	CAME AC,RAN		;RANDOM SHOULD EQUAL AC
	ERROR AC,RAN		;IF NOT MOVE FAILED
	CAME AC,RAN#		;IF  AC=RAN CAME FAILED
	ERROR AC,RAN#		;IF PREVIOUS WORKED,INHIBIT STORE
	AC=<AC+1>&17		;AC ON CAME FAILED
>
	AC=2
	LOOP MOVAC1-3,MOVAC1

;TEST THE SKIP INST FOR NO SKIP,ABILITY TO LOAD
;AN AC,AC SELECTION,AND AC0 LOGIC(NOT LOADING 0)
;ERRORS ARE PRESENTED IN THE FORM(PC,AC,C(AC),CORRECT)

	AC=5
SKP:	SETUP 30,0
	RANDOM
SKP1:	MOVE [0]		;DO NOT USE AC0 FOR SKIP
	REPEAT ^D8,
<	SKIP AC1,RAN#		;STORE IN AC,DO NOT SKIP,CHECK
	CAME AC1,AC		;NEW AC AGAINST PREVIOUSLY
	ERROR AC1,AC		;STORED AC. IF AC=AC+1(SKIP LOGIC)
	CAME [0]		;IF NOT= STORE CYCLE
	ERROR [0]		;IF 0 NONE ZERO ADDR/STORE
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=5
	LOOP SKP1-4,SKP1

;TEST SKIPA INST FOR PC INCREMENT,ABILITY TO LOAD AN AC,
;AC SELECTION AND AC0 LOGIC(NOT LOADING 0).ERRORS ARE
;PRESENTED IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=5
SKPA:	SETUP 30,0
	RANDOM
SKPA1:	MOVE [0]		;DO NOT USE AC0 FOR SKIPA
	REPEAT ^D8,
<	SKIPA AC1,AC		;LOAD AC1 AND SKIP
	ER AC,[ASCII /SKP/]	;FAILED TO SKIP.
	CAME AC,RAN		;C(E) GET CHANGED?
	ERROR AC,RAN		;YES.
	CAME AC1,RAN		;AC GET LOADED WITH RAN?
	ERROR AC1,RAN		;NO.
	CAME 0,[0]		;C(AC0) STILL = 0?
	ERROR [0]		;CHECK STORE CYCLE,AC ADDRESS
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=5
	LOOP SKPA1-4,SKPA1


;TEST EXCH. BOTH AC AND E ARE AC'S. CHECK FOR
;CORRECT DATA IN AC AND C(E).
;C(E) = -1, C(AC) = RAN NUM.

	AC=5
EXCH1:	SETUP 200,0
EXCH2:	RANDOM
EXCH3:	SETOB	AC1,RAN1	;MAKE C(E) = -1.
	EXCH	AC,AC1		;DO THE EXCH.
	CAME	AC,RAN1		;THE C(AC) SHOULD = ORIG C(E).
	ERR	RAN1,RAN
	CAME	AC1,RAN		;THE C(E) SHOULD = ORIG C(AC).
	ERR	RAN1,RAN
	LOOP	EXCH2,EXCH3


;TEST SETCA FOR COMPLEMENT AC AND NOT STORING IN C(E)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)
;SETCA DOES NOT NORMALLY CHANGE THE CONTENTS OF "E"

	AC=10
BOLCA:	REPEAT 2,
<	SETUP 100,2
	RANDOM
	MOVE AC2,[0]		;CLEAR AC2, USED TO INSURE
	SETCA AC,AC2		;SETCA DOES NOT STORE IN C(E)
	CAMN AC,RAN#		;IF AC UNCHANGED CNTL PULSES
	ERROR AC,RAN		;FOR INST SETCA FAILED
	REPEAT 3,
<	SETCA AC,AC2>
	CAME AC,RAN#		;A TOTAL OF 4 COMPLEMENTS
	ERROR AC,RAN		;SHOULD PRODUCE ORIGINAL NUM
	CAME AC2,[0]		;IF SETCA STORED C(E)
	ERROR AC2,[0]		;C(AC2) WILL NO LONGER BE 0.
	LOOP .-16,.-15
	AC=AC+17
>

;TEST SETCAI ABILITY TO COMPLEMENT AC AND FAILURE TO FETCH C(E)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT
;SETCA IS INDEXED FOR NOISE PURPOSES

	AC=5
BOLCAI:	SETUP 40,0
BOLCA1:	RANDOM
BOLCA2:	REPEAT 4,
<	MOVE AC1,AC		;MOVE RANDOM TO AN AC
	SETCAI AC1,-1(AC)	;TWO COMP SHOULD PRODUCE
	SETCAI AC1,777000(AC)	;ORIGINAL NUMBER
	CAME AC1,AC		;SETCAI FAILED
	ERROR AC1,AC
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=5
	LOOP BOLCA1,BOLCA2


;TEST XOR TO ZERO,XOR 0 TO N,N TO N,-1 TO N
;THREE ACS ARE USED IN THE TEST
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT

	AC=1
BOLX:	REPEAT 3,
<	SETUP 200,0
	RANDOM
	MOVE AC,[0]		;CLEAR THE AC
	XOR AC,RAN		;0 EXCLUSIVE ORED WITH
	CAME AC,RAN		;RANDOM SHOULD = RANDOM
	ERROR AC,RAN		;XOR FAILED
	XOR AC,[0]		;ANY NUMBER XORED
	CAME AC,RAN		;WITH THE NUMBER 0
	ERROR AC,RAN		;SHOULD  REMAIN UNCHANGED
	XOR AC,RAN		;ANY NUMBER XORED
	CAME AC,[0]		;WITH ITSELF SHOULD
	ERROR AC,[0]		;EQUAL 0
	XOR AC,[-1]		;SET AC TO ALL ONES
	XOR AC,RAN		;AC SHOULD CONTAIN COMP OF RAN
	XOR AC,[-1]		;RECOMPLEMENT AC TO ORIG
	CAME AC,RAN		;CHECK FOR RANDOM
	ERROR AC,RAN		;XOR FAILED
	LOOP .-22,.-21
	AC=AC+1
>


;TEST SETZI AND IOR. SETZI ABILITY TO CLEAR,IOR RAN TO 0,
;RANDOM TO RANDOM,RANDOM TO COMP RANDOM,0 TO RANDOM
;ERROR IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=5
BOLZI:	SETUP 100,0
	RANDOM
BOLZI1:	REPEAT 2,
<	MOVE AC,RAN#		;LOAD THE AC THEN
	SETZI AC,(AC)		;TRY TO CLEAR IT,INDEX REDUNDANT
	CAME AC,[0]		;IF NOT 0
	ERROR AC,[0]		;SETZI FAILED
	IOR AC,RAN		;INCLUSIVE OR OF A
	CAME AC,RAN		;NUMBER TO 0 SHOULD PRODUCE
	ERROR AC,RAN		;THE NUMBER
	IOR AC,RAN		;IOR SAME NUMBERS
	CAME AC,RAN		;SHOULD HAVE NO EFFECT
	ERROR AC,RAN		;ON AC.IOR FAILED
	IOR AC,[0]		;IOR OF NO BITS SHOULD DO NOTHING
	CAME AC,RAN
	ERROR AC,RAN		;IOR FAILED
	SETCA AC,0
	IOR AC,RAN		;INCLUSIVE OR OF COMP NUMBERS
	CAME AC,[-1]		;SHOULD SET ALL BITS
	ERROR AC,[-1]		;IOR FAILED
	IOR AC,[-1]		;ALL BITS TO ALL BITS
	CAME AC,[-1]		;PRODUCE ALL BITS
	ERROR AC,[-1]
	AC=<AC+1>&17
>
	AC=5
	LOOP BOLZI1-4,BOLZI1

;TEST AND FOR 0 TO 0,1 TO 1,0 TO 1,1 TO 0
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BOLA:	SETUP 400,0
	RANDOM
BOLA1:	AND AC,RAN		;NUMBER AND NUMBeR
	CAME AC,RAN		;SHOULD EQUAL NUMBER
	ERROR AC,RAN		;IF NOT, "AND" FAILED.
	AND AC,[-1]		;"AND" OF ALL BITS WITH
	CAME AC,RAN		;ANY NUMBER SHOULD
	ERROR AC,RAN		;LEAVE THE NUMBER UNCHANGED
	SETCA AC,
	AND AC,RAN		;"AND" OF A NUMBER WITH ITS
	CAME AC,[0]		;COMPLEMENT SHOULD
	ERROR AC,[0]		;PRODUCE 0
	LOOP BOLA1-4,BOLA1

;TEST ORCA AND SETO. 1 TO 0,1 TO 1, 0 TO 0, 1 TO 0,0 TO 1
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)
;ONE AC IS USED FOR TESTING

	AC=12
BOLOS:	SETUP 300,0
	RANDOM
BOLOS1:	SETO AC,.		;WILL CHANGE THIS INST IF FETCH/STORE C(E).
	CAME AC,[-1]		;CHECK FOR ALL BITS SET
	ERROR AC,[-1]		;SETO FAILED
	ORCA AC,RAN		;-1 ORED TO RANDOM
	CAME AC,RAN		;SHOULD PRODUCE RANDOM
	ERROR AC,RAN		;IF AC COMP PROBELY
	ORCA AC,RAN		;RANDOM TO RANDOM SHOULD
	CAME AC,[-1]		;PRODUCE -1
	ERROR AC,[-1]		;IF AC COMPLEMENTED PROPERLY
	ORCA  AC,[0]		;WITH NO BITS EFFECT IC COMP AC
	ORCA AC,RAN
	CAME AC,[-1]		;NO BITS COMPLEMENTS TO PRODUCE
	ERROR AC,[-1]		;ALL ONES
	LOOP BOLOS1-4,BOLOS1


;TEST ANDCA.1 TO 1,0 TO 0, 0 TO 1,0 TO 0,1 TO 1,1 TO 0
;ERRORS ARE IN THE FORM(PC,AC,C(AC),CORRECT
;ONE AC IS USED

	AC=13
BOLAC:	SETUP 200,1
	RANDOM
BOLAC1:	ANDCA AC,RAN		;ANDCA OF LIKE NUMBERS
	CAME AC,[0]		;SHOULD PRODUCE 0
	ERROR AC,[0]		;ANDCA FAILED
	ANDCA AC,RAN
	CAME AC,RAN		;ANDCA OF ZERO AND NUMBER
	ERROR AC,RAN		;SHOULD PRODUCE NUMBER
	SETO AC,.		;SET ALL BITS
	ANDCA AC,RAN
	CAME AC,[0]		;ANDCA OF ALL BITS WITH NUMBER
	ERROR AC,[0]		;SHOULD PRODUCE 0
	LOOP BOLAC1-4,BOLAC1


;TEST EQV,1 TO 1,0 TO 0,1 TO 0,0 TO 1. EQV =(SET ALL LIKE BITS)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=14
BOLEQ:	SETUP 200,2
	RANDOM
BOLEQ1:	EQV AC,RAN		;WHEN NUMBERS ARE EQUAL
	CAME AC,[-1]		;EQV SHOULD PRODUCE ALL
	ERROR AC,[-1]		;BITS SET.EQV FAILED
	EQV AC,RAN#
	CAME AC,RAN		;WITH AC SET,EQV SHOULD
	ERROR AC,RAN		;PRODUCE C(E) IN THE AC
	SETZI AC,-1
	EQV AC,RAN		;WHEN AC=0 EQV SHOULD
	SETCA AC,.		;PRODUCE COMPLEMENT OF
	CAME AC,RAN		;C(E)
	ERROR AC,RAN		;EQV FAILED
	LOOP BOLEQ1-3,BOLEQ1


;TEST SETM. SET THE CONTENTS OF MEMORY TO THE AC
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BOLSM:	SETUP 100,0
	RANDOM
BOLSM1:	REPEAT 2,
<	SETM AC1,RAN		;THE NET RESULT OF SETM
	CAME AC1,AC		;IS THE SAME AS MOVE
	ERROR AC1,RAN		;SETM FAILED
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=10
	LOOP BOLSM1-4,BOLSM1

;TEST SETCM. (MOVE THE COMPLEMENT OF MEMORY TO AC)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=14
BOLCM:	SETUP 100,0
	RANDOM
BOLCM1:	SETCM AC1,RAN		;COMP OF RANDOM TO AC
	SETCM AC2,AC1		;RECOMP TO AC2
	CAME AC2,RAN
	ERROR AC2,RAN		;SETCM 1 OR 2 FAILED
	LOOP BOLCM1-3,BOLCM1


;TEST ORCM. (INCLUSIVE OR THE CONTENTS OF COMPLEMENTED MEMORY
;TO THE CONTENTS OF AC.) ERRORS ARE IN THE FORM (PC,AC,
;C(AC),CORRECT

	AC=5
BOLOC:	SETUP 140,0
	RANDOM
BOLOC1:	ORCM AC,RAN		;LIKE NUMBERS SHOULD PRODUCE
	CAME AC,[-1]		;ALL BITS SET
	ERROR AC,[-1]
	ORCM AC,RAN		;ANY NUMBER ORED WITH ALL
	CAME AC,[-1]		;ONES SHOULD PRODUCE
	ERROR AC,[-1]		;ALL ONES
	SETZI AC,-1
	ORCM AC,RAN		;THE RANDOM NUMBER IS
	SETCA AC,.		;ORED TO 0. THIS SHOULD
	CAME AC,RAN		;PRODUCE THE  COMPLEMENT
	ERROR AC,RAN		;OF RANDOM
	ORCM AC,[-1]
	CAME AC,RAN		;ORING -1 SHOULD LEAVE
	ERROR AC,RAN		;AC UNCHANGED
	LOOP BOLOC1-3,BOLOC1


;TEST ANDCM (AND WITH THE COMP OF MEMORY)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BOLAX:	SETUP 140,0
	RANDOM
BOLAX1:	ANDCM AC,RAN		;LIKE NUMBERS SHOULD
	CAME AC,[0]		;PRODUCE 0
	ERROR AC,[0]		;ANDCM FAILED
	ANDCM AC,RAN		;ANYTHING ANDED TO
	CAME AC,[0]		;ZERO SHOULD = 0
	ERROR AC,[0]
	SETO	AC,
	ANDCM AC,RAN		;AC SHOULD - COMP OF MEMORY
	ANDCM AC,[0]		;AC SHOULD REMAIN UNCHANGED
	XOR AC,[-1]		;COMP AC
	CAME AC,RAN		;AFTER COMP SHOULD EQUAL
	ERROR AC,RAN		;RANDOM. ANDCM FAILED
	LOOP BOLAX1-3,BOLAX1


;TEST ORCB (INCLUSIVE OR THE COMPLEMENT OF AC AND C(E))
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=1
BOLOB:	SETUP 140,0
	RANDOM
BOLOB1:	ORCB AC,RAN		;PRODUCE COMP OF RAN
	ORCB AC,[-1]		;COMP AC
	CAME AC,RAN		;CHECK ORCB
	ERROR AC,RAN
	ORCB AC,[-1]		;COMP AC
	ORCB AC,RAN		;ANY TWO COMPLEMENTED NUMBERS
	CAME AC,[-1]		;SHOULD PRODUCE ALL ONES
	ERROR AC,[-1]
	ORCB AC,[0]		;AC COMPLEMENTS TO 0
	CAME AC,[-1]
	ERROR AC,[-1]		;ORCB FAILED
	LOOP BOLOB1-4,BOLOB1


;TEST ANDCB (AND WITH BOTH OPERANDS COMPLEMENTED)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
BOLAB:	SETUP 140,0
	RANDOM
BOLAB1:	ANDCB AC,RAN		;PRODUCE COMP OF RAN
	ANDCB AC,[0]		;COMP AC
	CAME AC,RAN		;CHECK FOR ORIGIONAL NUMBER
	ERROR AC,RAN		;ANDCB FAILED
	ANDCB AC,[0]		;COMPLEMENT AC
	ANDCB AC,[0]		;RECOMPLEMENT AC
	CAME AC,RAN		;SHOULD PRODUCE ORIGIONAL
	ERROR AC,RAN		;ANDCB FAILED
	ANDCB AC,[-1]		;RESULT SHOULD BE 0 IF
	CAME AC,[0]		;CONTENTS OF E
	ERROR AC,[0]		;CONTAINS NO BITS AFTER COMP
	ANDCB AC,RAN		;AC SHOULD EQUAL COMP OF RAN
	ANDCB AC,[0]		;COMP AC
	CAME AC,RAN		;THE AND TO 0
	ERROR AC,RAN		;FAILED
	LOOP BOLAB1-3,BOLAB1


;TEST SETA (EFFECTIVELY A NO OPERATION IN THIS MODE)
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=3
BOLSA:	SETUP 100,0
	RANDOM
		;DO 7 SETA'S.
BOLSA1:	REPEAT 7,<
	SETA AC,.>
	CAME AC,RAN		;C(AC) SHOULD = ORIG. C(AC)
	ERROR AC,RAN
	LOOP BOLSA1-3,BOLSA1


;TEST IORM, WHERE E IS AN AC. THE INST IS TESTED
;FOR NOT STORING IN AC AS WELL AS STORING PROPERLY
;IN E.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=11
BMIOR:	SETUP 100,1
BMIOR1:	RANDOM
BMIOR2:	MOVS AC1,AC		;AC=C(E) ORIG
	CAMN AC,AC1		;HALVES SAME?
	JRST BMIOR1		;YES. REJECT.
	SETCM AC		;SIM AN
	AND AC1			;IOR
	XOR	AC		;INST
	IORM AC,AC1		;RESULT TO AC1
	CAMN AC,AC1		;BOTH SAME?
	ERROR AC,AC1		;YES. STORED IN AC.
	CAME AC1,0		;C(E) = SIM. ANS?
	ERROR AC,0		;NO. IORM FAILED.
	LOOP BMIOR1,BMIOR2


;TEST ORCAM, WHERE E IS AN AC. THE INSTRUCTION IS TESTED
;FOR NOT STORING IN AC AS WELL AS STORING PROPERLY IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=12
BMICA:	SETUP 100,1
BMICA1:	RANDOM
BMICA2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETCM AC2,AC1		;MOVE COMPLEMENT OF NUMBER
	SETCM	AC		;SIMULATE
	AND	AC2		;THE INSTRUCTION
	XOR	AC		;IN AC0.
	ORCAM AC1,AC		;RESULT TO C(E)
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. STORED IN AC.
	CAME AC,0		;C(E) = SIM. ANS?
	ERROR AC,0		;NO. ORCAM FAILED.
	LOOP BMICA1,BMICA2


;TEST ORCMM, WHERE E IS AN AC. THE INSTRUCTION
;IS TESTED FOR NOT STORING IN AC AS WELL AS THE
;CORRECT ANSWER IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=13
BMICM:	SETUP 100,0
BMICM1:	RANDOM
BMICM2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETCM AC2,AC		;SIMULATE
	SETCM	AC1		;THE
	AND	AC2		;INSTRUCTION
	XOR	AC1		;IN AC0
	CAMN	0,AC1		;IS SIMULATED ANS
	JRST	BMICM1		;= C(AC)?...REJECT.
	ORCMM AC1,AC		;IF AC1 = AC, STORE INHIBIT
	CAMN AC1,AC
	ERROR AC1,AC		;FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;ORCMM FAILED.
	LOOP BMICM1,BMICM2


;TEST ORCBM, WHERE E IS AN AC. THE INSTRUCTION
;IS TESTED FOR NOT STORING IN AC AS WELL AS THE
;CORRECT ANSWER IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=14
BMICB:	SETUP 200,0
BMICB1:	RANDOM
BMICB2:	MOVS AC1,AC		;AC1= 0101,0011
	SETCM AC2,AC		;AC2= 1100,1010
	SETCM	AC2		;AC0 = 0011,0101
	ANDCM	AC1		;AC0 = 0010,0100
	XOR	AC2		;AC0 = 1110,1110
	ORCBM AC1,AC		;SHOULD PRODUCE SAME LOGIC
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;ORCBM FAILED.
	LOOP BMICB1,BMICB2


;TEST XORM, WHERE E IS AN AC. THE INSTRUCTION IS
;TESTED FOR NOT STORING AC AS WELL AS CONTENTS
;OF E CORRECTNESS.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BMX:	SETUP 200,1
BMX1:	RANDOM
BMX2:	JUMPE AC,BMX1		;REJECT IF RAN = 0.
	MOVS AC1,AC		;SECOND RANDOM NUMBER.
	SETCM	AC
	ANDCA	AC1		;PERFORM
	MOVE AC2,AC		;A PSEUDO
	IOR AC2,AC1		;EXCLUSIVE
	ANDCA	AC2		;OR INSTRUCTION
	XORM AC1,AC		;DO THE XOR
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;XORM FAILED.
	LOOP BMX1,BMX2


;TEST EQVM, WHERE E IS AN AC. THE INSTRUCTION
;IS TESTED FOR NOT STORING AC AS WELL AS
;CORRECTNESS OF C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BMEQ:	SETUP 100,0
BMEQ1:	RANDOM
BMEQ2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETCM AC1		;EQV IS SAME LOGIC
	XOR AC			;AS XOR WITH COMP AC
	EQVM AC1,AC		;EQV SETS ALL LIKE BITS
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;EQVM FAILED.
	LOOP BMEQ1,BMEQ2



;TEST ANDM, WHERE E IS AN AC. THE INSTRUCTION IS
;TESTED FOR NOT STORING IN AC AS WELL AS STORING
;PROPERLY IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=3
BMAN:	SETUP 100,0
BMAN1:	RANDOM
BMAN2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	MOVE	AC		;SIMULATE
	IOR	AC1		;AN "AND"
	XOR	AC1		;INSTRUCTION.
	XOR AC			;IN AC0
	CAMN AC1,AC		;REJECT THE NUMBER
	JRST BMAN1		;IF EQUAL.
	ANDM AC1,AC		;THE INSTRUCTION
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;AND FAILED.
	LOOP BMAN1,BMAN2



;TEST ANDCAM, WHERE E IS AN AC. THE INSTRUCTION IS
;TESTED FOR NOT STORING IN AN AC AS WELL AS
;STORING C(E) PROPERLY.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=4
BMACA:	SETUP 100,0
BMACA1:	RANDOM
BMACA2:	JUMPE AC,BMACA1		;REJECT IF RAN = 0.
	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETM	AC		;SIMULATE
	ORCA	AC1		;ANDCA
	SETCA			;LOGIC
	ANDCAM AC1,AC		;THE INSTRUCTION
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;ANDCA FAILED.
	LOOP BMACA1,BMACA2


;TEST ANDCMM, WHERE E IS AN AC. THE INSTRUCTION IS
;TESTED FOR NOT STORING IN AN AC AS WELL AS
;STORING C(E) PROPERLY.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=5
BMACM:	SETUP 100,0
BMACM1:	RANDOM
BMACM2:	JUMPE AC,BMACM1		;REJECT IF RAN = 0.
	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETAM AC1,0		;AC1 TO AC0.
	IOR	AC		;SIMULATE
	XOR	AC		;THE INSTUCTION
	CAMN	0,AC1		;SIM ANS = C(AC)?
	JRST	BMACM1		;YES. REJECT.
	ANDCMM AC1,AC		;DO AN ANDCMM INSTRUCTION.
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;ANDCMM FAILED.
	LOOP BMACM1,BMACM2


;TEST ANDCBM, WHERE E IS AN AC. THE INSTRUCTION
;IS TESTED FOR NOT STORING IN AC AS WELL AS STORING
;PROPERLY IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=7
BMACB:	SETUP 100,0
BMACB1:	RANDOM
BMACB2:	MOVS AC1,AC		;SECOND RANDOM NUMBER.
	SETCM	AC1		;SIMULATE
	SETCM 1,AC		;AN
	AND	1		;ANDCBM INST.
	ANDCBM	AC1,AC		;DO AN ANDCBM.
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;ANDCBM FAILED.
	LOOP BMACB1,BMACB2


;TEST SETCAM, WHERE E IS AN AC. THE INSTRUCTION
;IS TESTED FOR NOT STORING IN AC AS WELL AS
;PROPER C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BMCMM:	SETUP 200,0
BMCMM1:	RANDOM
BMCMM2:	MOVS AC1,AC		;CHECK FOR NO CHANGE
	CAMN	AC1,AC		;IN 8 COMPLEMENTS
	JRST BMCMM1		;REJECT IF HALF SAME.

	REPEAT 10,<
	SETCMM AC1,AC>
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,RAN		;C(E) SHOULD = ORIG. C(E).
	ERROR AC,RAN		;SETCMM FAILED.
	LOOP BMCMM1,BMCMM2


 ;TEST SETCAM, WHERE E IS AN AC. TEST FOR NOT
;STORING IN AC AS WELL AS PROPER STORAGE IN C(E).
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=11
BMCAM:	SETUP 100,0
BMCAM1:	RANDOM
BMCAM2:	MOVS AC1,AC		;SECOND RANDOM NUMBER.
	SETCM	AC1		;SIMULATE SETCAM.
	SETCAM AC1,AC		;DO SETCAM.
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,0		;C(E) SHOULD = SIM. ANS.
	ERROR AC,0		;SETCAM FAILED.
	LOOP BMCAM1,BMACM2


;TEST SETAM, WHERE E IS AN AC.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BMSA:	SETUP 100,0
BMSA1:	RANDOM
BMSA2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	CAMN AC1,AC
	JRST BMSA1		;REJECT IF SAME.
	SETAM AC,AC1		;C(AC) TO C(AC1)
	CAME AC,AC1		;EQUAL?
	ERROR AC,AC1		;NO.
	CAME AC1,RAN		;C(E) SHOULD = ORIG C(AC).
	ERROR AC1,RAN		;SETAM FAILED.
	LOOP BMSA1,BMSA2


;TEST SETOM, WHERE E IS AN AC.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
BMSM:	SETUP 100,0
BMSM1:	RANDOM
BMSM2:	MOVS AC1,AC		;SECOND RANDOM NUMBER
	SETOM AC1,AC		;DO SETOM INST.
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,[-1]		;C(E) SHOULD = A -1.
	ERROR AC,[-1]		;SETOM FAILED.
	LOOP BMSM1,BMSM2


;TEST SETMM, WHERE E IS AN AC.
;ERRORS ARE IN THE FORM (PC, AC,C(AC),CORRECT)

	AC=10
BMSMM:	SETUP 100,0
BMSMM1:	RANDOM
BMSMM2:	MOVS AC1,AC		;A SECOND RANDOM NUMBER
	CAMN AC,AC1		;REJECT IF
	JRST BMSMM1		;HALF SAME
		;DO 8 SETMM...SHOULD NOT CHANGE C(E).
	REPEAT 10,<
	SETMM AC1,AC>
	CAMN AC1,AC		;EQUAL?
	ERROR AC1,AC		;YES. INHIBIT STORE AC FAILED.
	CAME AC,RAN		;C(E) SHOULD = ORIG. C(E).
	ERROR AC,RAN		;SETMM FAILED.
	LOOP BMSMM1,BMSMM2


;TEST SETZM, WHERE E IS AN AC. TESTS FOR NOT STORING
;IN AC AS WELL AS STORING IN C(E) PROPERLY.

	AC=10
SETZM1:	SETUP 40,0
SETZM2:	RANDOM
SETZM3:	JUMPE AC,SETZM2		;REJECT IF C(AC) = 0.
	SETOB AC1,RAN1		;SET C(AC) TO ALL ONES.
	SETZM AC1,AC		;DO SETZM
	CAME AC,[0]		;DID AC GET CLEARED?
	EERR	,RAN1		;NO.
	CAME AC1,[-1]		;DOES C(AC1) STILL = -1?
	EERR	,RAN1		;NO.
	LOOP SETZM2,SETZM3


;TEST ROT LEFT 3X(2X18). CHECKING FOR AC1 NOT CHANGED
;AS WELL AS C(AC) BEING THE PROPER NUMBER.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
ROTL2:	SETUP 200,2
ROTL2A:	RANDOM
ROTL2B:	SETOB AC1,RAN1		;SET AC+1 TO ALL ONES.
		;DO 6 X (ROT LEFT 18 PLACES).
	REPEAT 3,<
	ROT AC,22
	ROT AC,22>
	CAME AC,RAN		;C(AC)SHOULD = C(AC) BEFORE ROT.
	EERRI	,22
	CAME AC1,[-1]		;AC1 SHOULD NOT HAVE CHANGED.
	ERR	RAN1,22
	LOOP ROTL2A,ROTL2B

;TEST ROT RIGHT 3X(2X18)..CHECKING FOR AC1 NOT
;CHANGED AS WELL AS C(AC) ENDING UP BEING
;THE SAME AS IT WAS BEFORE THE ROT.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=10
ROTR2:	SETUP 300,2
ROTR2A:	RANDOM
ROTR2B:	SETOB AC1,RAN1		;SET AC+1 TO ALL ONES.
		;DO 6 X (ROT RIGHT 18 PLACES).
	REPEAT 3,<
	ROT AC,-22
	ROT AC,-22>
	CAME AC,RAN		;C(AC) SHOULD = C(AC) BEFORE ROT.
	EERR	,-22
	CAME AC1,[-1]		;C(AC1) SHOULD STILL = -1.
	ERRI	RAN1,-22
	LOOP ROTR2A,ROTR2B


;TEST ROT LEFT 3X36. CHECKING FOR AC1 NOT
;CHANGED AND C(AC) = WHAT IT WAS BEFORE
;ROT.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
RTL36:	SETUP 300,2
RTL36A:	RANDOM
RTL36B:	SETOB	AC1,RAN1	;SET AC+1 TO ALL ONES.
		;DO 3 X (ROT LEFT 36 PLACES).
	REPEAT 3,<
	ROT AC,44>
	CAME AC,RAN		;C(AC) SHOULD = C(AC) BEFORE ROT.
	EERRI	,44
	CAME AC1,[-1]		;C(AC1) SHOULD STILL = -1.
	ERRI	RAN1,44
	LOOP RTL36A,RTL36B


;TEST ROT RIGHT 3X36. CHECKING FOR AC1 NOT
;CHANGED AND C(AC) = WHAT IT DID BEFORE ROT.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
RTR36:	SETUP 300,2
RTR36A:	RANDOM
RTR36B:	SETOB AC1,RAN1		;SET AC+1 TO ALL ONES.
		;DO 3 X (ROT RIGHT 36 PLACES).
	REPEAT 3,<
	ROT AC,-44>
	CAME AC,RAN		;C(AC) SHOULD = RAN.
	EERRI	,-44
	CAME AC1,[-1]		;C(AC1) SHOULD STILL = -1.
	ERRI	RAN1,-44
	LOOP RTR36A,RTR36B


;TEST ROTC LEFT 3X36 THROUGH ALL AC'S CHECKING
;FOR C(AC) AND C(AC1) BEING EXCHANGED
;AFTER THE ROTC.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
RTCL:	SETUP 100,2
RTCLA:	RANDOM

RTCLB:	REPEAT ^D10,<
	MOVE AC,RAN		;MOVE A RAN NUM INTO AN AC.
	SETOB	AC1,RAN1	;SET AC+1 TO ALL ONES.
		;DO 3 X (ROTC LEFT 36 PLACES).
	REPEAT 3,<
	ROTC AC,44>
	CAME AC1,RAN		;C(AC1) SHOULD = RAN.
	EERRI	,44
	CAME AC,[-1]		;C(AC) SHOULD = A -1.
	ERRI	RAN1,44
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=2
	LOOP RTCLA,RTCLB


;TEST ROTC RIGHT 3X36 THROUGH ALL AC'S. CHECKING
;FOR C(AC) AND C(AC1) BEING EXCHANGED.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
RTCR:	SETUP 100,2
RTCRA:	RANDOM

RTCRB:	REPEAT ^D10,<
	MOVE AC,RAN		;MOVE A RAN NUM INTO AN AC.
	SETOB AC1,RAN1		;SET AC+1 TO ALL ONES.
		;DO 3 X (ROTC RIGHT 36 PLACES).
	REPEAT 3,<
	ROTC AC,-44>
	CAME AC1,RAN		;C(AC1) SHOULD = C(AC) BEFORE ROTC.
	EERRI	,-44
	CAME AC,[-1]		;C(AC) SHOULD = C(AC1) BEFORE ROTC.
	ERRI	RAN1,-44
	AC=<AC+1>&17
	AC1=<AC+1>&17
>
	AC=2
	LOOP RTCRA,RTCRB


;TEST ROT. ROT A RANDOM NUMBER A RANDOM NUMBER OF TIMES
;IN ONE DIRECTION AND THEN THE SAME NUMBER OF TIMES
;IN THE OPPOSITE DIRECTION.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT).

	AC=2
ROTLR:	SETUP 100,4
ROTLR1:	RANDOM
	MOVE AC3,RAN		;CHECK TO SEE
	AND AC3,[377]		;THAT THE RIGHT MOST 8 BITS
	JUMPE AC3,ROTLR1	;DO NOT = 0..REJECT IF THEY DO.
ROTLR2:	MOVN AC2,RAN		;PUT 2'S COMP OF RAN INTO AC2.
	SETOB AC1,RAN1		;SET AC+1 TO ALL ONES.
	ROT AC,(AC)		;ROT AC A RANDOM NUMBER OF TIMES.
	ROT AC,(AC2)		;ROT AC THE SAME NUM OF TIMES
				;IN THE OPPOSITE DIRECTION.
	CAME AC,RAN		;C(AC) SHOULD STILL = C(RAN).
	ERROR AC,RAN
	CAME AC1,[-1]		;C(AC1) SHOULD STILL = -1.
	ERROR AC1,[-1]
	LOOP ROTLR1,ROTLR2


;TEST ROTC. DO A ROTC WITH A RANDOM NUMBER A RANDOM
;NUMBER OF TIMES IN ONE DIRECTION AND THEN THE SAME
;NUMBER OF TIMES IN THE OPPOSITE DIRECTION.
;REPEAT THIS TEST FOR ALL AC'S.
;ERRORS ARE IN THE FORM (PC,AC,C(AC),CORRECT)

	AC=2
RTCLR:	SETUP 200,3
RTCLR1:	RANDOM
	MOVE AC3,RAN		;CHECK TO SEE
	AND AC3,[377]		;THAT THE RIGHT MOST 8 BITS
	JUMPE AC3,RTCLR1	;DO NOT = 0..REJECT IF THEY DO.

RTCLR2:	REPEAT ^D10,<
	MOVE AC,RAN		;MOVE A RAN NUM INTO AN AC.
	MOVN AC2,RAN		;MOVE THE 2'S COMP INTO ANOTHER AC.
	SETO AC1,		;SET AC1 TO ALL ONES.
	ROTC AC,(AC)		;ROTC AC A RANDOM NUMBER OF
				;TIMES IN ONE DIRECTION.
	ROTC AC,(AC2)		;ROTC AC THE SAME NUMBER OF
				;TIMES IN THE OPPOSITE DIRECTION.
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN.
	ERROR AC,RAN
	CAME AC1,[-1]		;C(AC1) SHOULD STILL =-1
	ERROR AC1,[-1]
	AC=<AC+1>&17
	AC1=<AC+1>&17
	AC2=<AC+2>&17

>
	AC=2
	LOOP RTCLR1,RTCLR2


;TEST OVERFLOW ON A ROT LEFT...AROV SHOULD NOT COME UP.

	AC=2
ROTOV:	SETUP 20,0
ROTOV1:	RANDOM
ROTOV2:	JUMPE AC,ROTOV1		;REJECT IF RAN = 0.
	CAMN AC,[-1]		;ALSO REJECT IF RAN = -1.
	JRST ROTOV1
	JFCL 10,.+1		;CLEAR OV FLAG.
	ROT AC,256		;ROT C(AC) 256 TIMES.
	JFCL 10,.+2		;OV FLAG GET SET?
	JRST .+2		;NO.
	ER AC,[ASCII /OV/]	;YES. SHOULD NOT SET ON A ROT.
	LOOP ROTOV1,ROTOV2


;TEST OVERFLOW FLAG ON A ROT RIGHT...SHOULD NEVER GET SET.

	AC=3
RTROV:	SETUP 20,0
RTROV1:	RANDOM
RTROV2:	JUMPE AC,RTROV1		;REJECT IF RAN = 0.
	CAMN AC,[-1]		;ALSO REJECT IF RAN = -1.
	JRST RTROV1
	JFCL 10,.+1		;CLEAR OVERFLOW FLAG.
	ROT AC,-256		;ROT AC RIGHT 256 TIMES.
	JFCL 10,.+2		;OVERFLOW FALG GET SET?
	JRST .+2		;NO.
	ER AC,[ASCII /OV/]
	LOOP RTROV1,RTROV2


;TEST MOVEM. AFTER <MOVEM AC,AC1> FOLLOWED BY
;<MOVEM AC1,AC>, C(AC) SHOULD = ORIG C(AC).
;RAN TO RAN1.

	AC=2
MVEM1:	SETUP 30,0
MVEM2:	RANDOM
		;DO 3 SETS OF MOVEM'S.
MVEM3:	REPEAT 3,<
	MOVEM AC,AC1
	MOVEM AC1,AC>
	CAME	AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERROR	AC,RAN
	CAME AC1,RAN		;C(AC1) SHOULD ALSO = ORIG. C(AC).
	ERROR AC1,RAN
	LOOP MVEM2,MVEM3


;TEST MOVES. AFTER 6 MOVES IN A ROW, THE C(E)
;SHOULD = ORIG C(E).

	AC=2
MVES1:	SETUP 200,1
MVES2:	RANDOM
		;DO 6 MOVE INSTRUCTIONS.
MVES3:	REPEAT 3,<
	MOVES	AC1,AC
	MOVES	AC1,AC>
	CAME	AC1,AC		;C(AC) SHOULD = C(E).
	ERROR	AC1,AC
	CAME	AC,RAN		;C(E) SHOULD = ORIG C(E).
	ERROR	AC,RAN
	LOOP MVES2,MVES3


;TEST MOVS INSTRUCTION...TWO MOVS SHOULD GIVE SAME NUMBER.

	AC=4
MOVSA:	SETUP 200,2
MOVSB:	RANDOM
		;DO 6 MOVS INSTRUCTIONS.
MOVSC:	REPEAT 3,<
	MOVS AC,AC
	MOVS AC,AC>
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN.
	EERR	,RAN
	LOOP MOVSB,MOVSC


;TEST MOVS INSTRUCTION...MOVS FOLLOWED BY ROT SHOULD GIVE
;SAME NUMBER.

	AC=5
MOVS1:	SETUP 200,1
MOVS2:	RANDOM
MOVS3:	MOVS AC,AC		;DO MOVS INSTRUCTION.
	ROT AC,22		;ROT LEFT 18 PLACES.
	CAME AC,RAN		;C(AC) SHOULD NOW = RAN.
	EERR	,RAN
	LOOP MOVS2,MOVS3


;TEST MOVSM....TWO MOVSM SHOULD GIVE THE ORIG. NUM.

	AC=6
MOVSMA:	SETUP 300,1
MOVSMB:	RANDOM

MOVSMC:	REPEAT 3,<
	MOVSM AC,AC1
	MOVSM AC1,AC>
	CAME AC,RAN		;C(AC) SHOULD NOW BE = TO RAN.
	ERROR AC,RAN
	LOOP MOVSMB,MOVSMC


;TEST MOVSS...TWO MOVSS SHOULD GIVE THE ORIGINAL NUMBER.

	AC=7
MOVSSA:	SETUP 200,0
MOVSSB:	RANDOM
MOVSSC:	SETZB 0,RAN1		;CLEAR AC0.

	REPEAT 3,<
	MOVSS	AC
	MOVSS	AC>
	CAME AC,RAN		;C(AC) SHOULD NOW BE = TO RAN.
	EERR	,RAN1
	CAME	[0]		;C(AC0) SHOULD STILL = 0.
	EERR	,RAN1
	LOOP MOVSSB,MOVSSC


;TEST MOVSI.

	AC=10
MOVSIA:	SETUP 100,0
MOVSIB:	RANDOM
	MOVE AC2,RAN		;PUT RAN INTO AN AC.
MOVSIC:	ANDI AC,-1		;SIMULATE
	ROT AC,22		;A MOVSI INST.
	MOVSI AC1,(AC2)		;DO MOVSI.
	CAME AC1,AC		;C(AC1) SHOULD = SIM. ANS.
	ERROR AC1,AC
	LOOP MOVSIB,MOVSIC


;TEST LSH. SIMULATE A LSH 18 PLACES WITH A MOVSI.

	AC=11
LSHA:	SETUP 200,1
LSHB:	RANDOM
LSHC:	SETO	AC1,		;SET AC+1 TO ALL ONES.
	MOVSI AC2,(AC)		;SIMULATE LSH 18 PLACES.
	LSH AC,22		;DO LSH
	CAME AC,AC2		;C(AC) SHOULD = SIM. ANS.
	ERROR AC,AC2
	CAME AC1,[-1]		;AC1 GET CHANGED?
	ERROR AC1,[-1]		;YES.
	LOOP LSHB,LSHC


;TEST LSH RIGHT 18 PLACES.

	AC=10
LSH1:	SETUP 200,1
LSH2:	RANDOM
LSH3:	SETOB AC1,RAN1		;SET C(AC+1) TO ALL ONES.
	LSH AC,-22		;DO LSH RIGHT 18 PLACES.
	MOVS AC2,RAN		;SIMULATE
	ANDI AC2,-1		;LSH.
	CAME AC,AC2		;C(AC) SHOULD = SIM. ANS.
	EERRI	,-22
	CAME AC1,[-1]		;C(AC+1) GET CHANGED?
	ERRI	RAN1,-22
	LOOP LSH2,LSH3


;TEST ASH ABILITY TO SET OR NOT SET OVERFLOW FLAG.

	AC=10
ASHOV:	SETUP 30,0
ASHOV1:	SETO	AC,		;SET AC TO ALL ONES..1,1 CONDITION.
	JFCL	10,.+1		;CLEAR OV FLAG.
	ASH AC,1		;DO ASH.
	JFCL 10,.+2		;OVERFLOW FLAG GET SET?
	JRST .+2		;NO.
	ER AC,[ASCII /OV/]	;YES. 1,1 CONDITION SHOULD NOT SET IT.
	JFCL 10,.+1		;CLEAR OV FLAG.
	SETZ AC,		;CLEAR AC...0,0 CONDITION.
	ASH AC,1		;DO ASH.
	JFCL 10,.+2		;OVERFLOW FLAG GET SET?
	JRST .+2		;NO.
	ER AC,[ASCII /OV/]	;YES. 0,0 COND. SHOULDN'T SET IT.
	JFCL 10,.+1		;CLEAR OV FLAG.
	MOVSI AC,377777		;SET AC FOR 0,1 CONDITION.
	ASH AC,1		;DO ASH.
	JFCL 10,.+2		;OVERFLOW FLAG GET SET?
	ER AC,[ASCII /OV/]	;NO. 0,1 COND. SHOULD SET IT.
	JFCL 10,.+1		;CLEAR OV FLAG.
	MOVSI AC,400000		;SET AC FOR 1,0 CONDITION.
	ASH AC,1		;DO ASH.
	JFCL 10,.+2		;OV FLAG GET SET?
	ER AC,[ASCII /OV/]	;NO. 1,0 COND. SHOULD SET IT.
	LOOP ASHOV1,ASHOV1


;TEST ASH. DO ASH RIGHT 36 PLACES WITH ORIG.
;C(AC) = 400000000000. AFTER ASH THE C(AC) SHOULD = A -1.

	AC=10
ASH1:	SETUP 20,0
ASH2:	MOVE AC,[XWD 400000,0]	;MAKE C(AC) = ALL 0'S WITH SIGN BIT SET.
	ASH AC,-44		;DO ASH RIGHT 36 PLACES...SIGN
	CAME AC,[-1]		;BIT SHOULD HAVE SET ALL BITS TO A ONE.
	ERROR AC,[-1]
	LOOP ASH2,ASH2


;TEST ASH. DO ASH LEFT 36 PLACES WITH ORIG. C(AC) =
;TO A -1. AFTER ASH THE C(AC) SHOULD = THE SIGN
;BIT SET AND THE REST ZEROS.

	AC=11
ASH3:	SETUP 20,0
ASH4:	MOVE AC,[-1]		;MAKE C(AC) = A -1.
	ASH AC,44		;DO ASH LEFT 36 PLACES..0'S GOING
	CAME AC,[XWD 400000,0]	;INTO BIT 35 SHOULD JUST LEAVE SIGN BIT SET.
	ERROR AC,[0]
	LOOP ASH4,ASH4


;TEST ADD. RAN TO 0 CONDITION.

	AC=10
ADD1:	SETUP 100,0
ADD2:	RANDOM
ADD3:	SETZ AC,		;CLEAR AC.
	ADD AC,RAN		;ADD RAN TO 0.
	CAME AC,RAN		;C(AC) SHOULD = RAN NUM.
	ERROR AC,RAN
	LOOP ADD2,ADD3


; TEST ADD. 0 TO RAN CONDITION.

	AC=10
ADD1A:	SETUP 100,0
ADD2A:	RANDOM
		;ADD A CONSTANT 0 TO RAN 5 TIMES.
ADD3A:	REPEAT 5,<
	ADD AC,[0]>
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN NUM.
	ERROR AC,RAN
	LOOP ADD2A,ADD3A


;TEST ADD. ADD 1'S COMP OF RAN TO RAN.
;SHOULD GET A -1.

	AC=10
ADD1B:	SETUP 100,0
ADD2B:	RANDOM
ADD3B:	SETCM AC1,RAN		;1'S COMP OF RAN TO AC1.
	ADD AC,AC1		;ADD IT TO RAN.
	CAME AC,[-1]		;C(AC) SHOULD = -1.
	ERROR AC,[-1]
	LOOP ADD2B,ADD3B


;TEST ADD. CHECK CRY0,CRY1,AND OV FLAGS.
;ADD, TO A RANDOM NUMBER, A -1 AND THEN A +1.
;CRY0 AND CRY1 SHOULD BOTH GET SET AND AROV SHOULD NOT GET SET.

	AC=10
ADD1C:	SETUP 400,2
ADD2C:	RANDOM
ADD3C:	JFCL 17,.+1		;CLEAR ALL FLAGS.
	ADD AC,[-1]		;ADD A -1 TO RAN.
	ADD AC,[1]		;ADD A +1 TO ANS OF ADDITION OF RAN AND A -1.
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERROR AC,RAN
	JFCL 4,CRY0A
	JFCL 2,.+2
	JRST	BOTHF
	ER	AC,[ASCII /CRY0/];CRY0 FAILED TO GET SET.
CRY0A:	JFCL	2,.+2
	ER	AC,[ASCII /CRY1/];CRY1 FAILED TO GET SET.
	JRST	AROVA
BOTHF:	ER	AC,[ASCII /CRY01/];BOTH CRY0 + CRY1 FAILED TO GET SET.
AROVA:	JFCL	10,.+2
	JRST	ADD4C
	ER	AC,[ASCII /OV/]	;AROV GOT SET.
ADD4C:	LOOP ADD2C,ADD3C


;TEST ADDM. WHERE E IS AN AC.
;RAN TO 0 CONDITION.

	AC=4
ADDM1:	SETUP 100,0
ADDM2:	RANDOM
	MOVE AC2,RAN		;SAVE RAN IN AN AC.
ADDM3:	SETZB AC1,RAN1		;MAKE C(E) = 0.
	ADDM AC,AC1		;DO ADDM.
	CAME AC2,AC1		;C(E) SHOULD =ORIG C(AC).
	ERRM RAN1,RAN
	LOOP ADDM2,ADDM3


;TEST ADDM. WHERE E IS AN AC.
;0 TO RAN CONDITION.

	AC=5
ADDM1A:	SETUP 100,0
ADDM2A:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
ADDM3A:	SETZB AC1,RAN1		;MAKE C(AC) = 0.
	ADDM AC1,AC		;DO ADDM.
	CAME AC2,AC		;C(E) SHOULD = ORIG C(E).
	EERRM	,RAN1
	LOOP ADDM2A,ADDM3A


;TEST ADDM. WHERE E IS AN AC.
;1'S COMP RAN TO RAN.

	AC=6
ADDM1B:	SETUP 100,0
ADDM2B:	RANDOM
ADDM3B:	SETCM AC1,AC		;MAKE C(AC) = 1'S COMP OF C(E).
	MOVE RAN1,AC1		;SAVE C(AC) IN CASE OF ERROR.
	ADDM AC1,AC		;DO ADDM.
	CAME AC,[-1]		;C(E) SHOULD = A -1.
	EERRM	,RAN1
	LOOP ADDM2B,ADDM3B


;TEST ADDI. CHECK C(AC) FOR CORRECT DATA.
;0 TO RAN CONDITION.

	AC=2
ADDI1:	SETUP 20,0
ADDI2:	RANDOM
ADDI3:	ADDI AC,0		;DO ADDI.
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	EERRI	,0
	LOOP ADDI2,ADDI3


;TEST ADDI. CHECK FOR CORRECT DATA IN AC.
;RAN TO 0 CONDITION.

	AC=2
ADDI1A:	SETUP 100,0
ADDI2A:	RANDOM
ADDI3A:	SETZB AC1,RAN1		;CLEAR C(AC).
	MOVEI AC2,(AC)		;SIMULATE ADDI.
	ADDI AC1,(AC)		;DO ADDI.
	CAME AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,(AC)
	LOOP ADDI2A,ADDI3A


;TEST ADDI. CHECK FOR CORRECT DATA IN AC.
;1'S COMP RAN TO RAN.

	AC=3
ADDI1B:	SETUP 40,0
ADDI2B:	RANDOM
ADDI3B:	SETCM AC1,AC		;MAKE C(AC) = 1'S COMP OF E.
	MOVE AC2,AC1		;SIMULATE
	IORI AC2,-1		;ADDI INST.
	MOVE RAN1,AC1		;SAVE C(AC) IN CASE OF ERROR.
	ADDI AC1,(AC)		;DO ADDI.
	CAME AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	ERRI RAN1,(AC)
	LOOP ADDI2B,ADDI3B


;TEST ADDB. CHECK FOR C(AC) = C(E), AND CORRECT
;DATA IN AC FOR 0 TO RAN CONDITION.

	AC=4
ADDB1:	SETUP 100,0
ADDB2:	RANDOM
ADDB3:	SETZB AC1,RAN1		;CLEAR C(E).
	ADDB AC,AC1		;DO ADDB.
	CAME AC,AC1		;C(AC) SHOULLD = C(E).
	ERR RAN1,RAN
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR RAN1,RAN
	LOOP ADDB2,ADDB3


;TEST ADDB. CHECK FOR C(AC) = C(E), AND CORRECT
;DATA IN AC FOR RAN TO 0 CONDITION.

	AC=5
ADDB1A:	SETUP 100,0
ADDB2A:	RANDOM
ADDB3A:	SETZB AC1,RAN1		;CLEAR C(AC).
	ADDB AC1,AC		;DO ADDB.
	CAME AC1,AC		;C(AC) SHOULD = C(E).
	EERR	,RAN1
	CAME AC1,RAN		;C(AC) SHOULD = ORIG C(E).
	EERR	,RAN1
	LOOP ADDB2A,ADDB3A


;TEST ADDB. CHECK FOR C(AC) = C(E), AND CORRECT DATA
;IN AC FOR NOT RAN TO RAN CONDITION.

	AC=6
ADDB1B:	SETUP 100,0
ADDB2B:	RANDOM
ADDB3B:	SETCM AC1,AC		;MAKE C(E) = 1'S COMP OF C(AC).
	MOVE RAN1,AC1		;SAVE C(E) IN CASE OF ERROR.
	ADDB AC,AC1		;DO ADDB.
	CAME AC,AC1		;C(AC) SHOULD = C(E).
	ERR	RAN1,RAN
	CAME AC,[-1]		;C(AC) SHOULD = A -1.
	ERR RAN1,RAN
	LOOP ADDB2B,ADDB3B


;TEST SUB. CHECK C(AC) FOR CORRECT DATA.
;0 TO RAN CONDITION.

	AC=2
SUB1:	SETUP 100,0
SUB2:	RANDOM
SUB3:	SETZB AC1,RAN1		;CLEAR C(E).

	REPEAT 3,<
	SUB AC,AC1>
	CAME AC,RAN		;C(AC) SHOULD STILL = ORIG C(AC).
	ERR RAN1,RAN
	LOOP SUB2,SUB3


;TEST SUB. CHECK C(AC) FOR CORRECT DATA.
;RAN TO 0 CONDITION.

	AC=2
SUB1A:	SETUP 100,0
SUB1B:	RANDOM
SUB1C:	SETZB AC1,RAN1		;CLEAR C(AC).
	MOVN AC2,RAN		;ANY NUM FROM 0 = 2'S COMP OF THAT NUM.
	SUB AC1,AC		;SUBTRACT RAN FROM 0.
	CAME AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	EERR	,RAN1
	LOOP SUB1B,SUB1C


;TEST SUB. CHECK C(AC) FOR CORRECT DATA.
;SUB RAN FROM RAN.

	AC=2
SUB2A:	SETUP 100,0
SUB2B:	RANDOM
SUB2C:	MOVE AC1,AC		;MAKE C(E) = C(AC).
	SUB AC,AC1		;SUB RAN FROM RAN.
	CAME AC,[0]		;C(AC) SHOULD = 0.
	EERR	,RAN
	LOOP SUB2B,SUB2C


;TEST SUBM. WHERE E IS AN AC.
;RAN TO 0 CONDITION.

	AC=7
SUBM1:	SETUP 100,0
SUBM2:	RANDOM
SUBM3:	SETZB AC1,RAN1		;CLEAR C(AC).
	MOVN AC2,AC		;SIM SUB..RAN FROM 0 = 2'S COMP RAN.
	SUBM AC1,AC		;DO SUBM.
	CAME AC2,AC		;C(E) SHOULD = SIM. ANS.
	EERRM	,RAN1
	LOOP SUBM2,SUBM3

;TEST SUBM. SHERE E IS AN AC.
;0 TO RAN CONDITION.

	AC=10
SUBM1A:	SETUP 100,0
SUBM2A:	RANDOM
	MOVE AC2,RAN		;SAVE RAN IN AN AC.
SUBM3A:	SETZB AC1,RAN1		;CLEAR C(E).
	SUBM AC,AC1		;DO SUBM...0 FROM RAN = RAN.
	CAME AC2,AC1		;C(E) SHOULD = ORIG C(AC).
	ERRM RAN1,RAN
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERRM RAN1,RAN
	LOOP SUBM2A,SUBM3A


;TEST SUBM. WHERE E IS AN AC.
;RAN TO RAN CONDITION.

	AC=11
SUBM1B:	SETUP 100,0
SUBM2B:	RANDOM
SUBM3B:	MOVE AC1,AC		;MAKE C(E) = C(AC).
	SUBM AC,AC1		;DO SUBM.
	CAME AC1,[0]		;C(E) SHOULD = 0.
	EERRM	,RAN
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	EERRM	,RAN
	LOOP SUBM2B,SUBM3B


;TEST SUBI. CHECK C(AC) FOR CORRECT DATA.
;0 TO RAN CONDITION.

	AC=10
SUBI1:	SETUP 20,0
SUBI2:	RANDOM
SUBI3:	SUBI	AC,0		;DO SUBI..0 FROM RAN = RAN.
	CAME	AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	EERRI	,0
	LOOP	SUBI2,SUBI3


;TEST SUBI. CHECK C(AC) FOR CORRECT DATA.
;RAN TO 0 CONDITION.

	AC=10
SUBI1A:	SETUP 20,0
SUBI2A:	RANDOM
SUBI3A:	SETZB	AC1,RAN1	;CLEAR C(AC).
	MOVNI	AC2,(AC)	;SIM SUB..RAN FROM 0 = 2'S COMP RAN.
	SUBI	AC1,(AC)	;DO SUBI.
	CAME	AC1,AC2		;C(AC) SHOULD = SIM ANS.
	ERRI	RAN1,(AC)
	LOOP	SUBI2A,SUBI3A


;TEST SUBI. CHECK C(AC) FOR CORRECT DATA.
;RAN TO RAN CONDITION.

	AC=10
SUBI1B:	SETUP 20,0
SUBI2B:	RANDOM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
SUBI3B:	MOVE	AC1,AC		;SIMULATE A
	AND	AC1,[XWD -1,0]	;SUBI RAN FROM RAN.
	SUBI	AC,(AC)		;DO SUBI.
	CAME	AC,AC1		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,(RAN1)
	LOOP	SUBI2B,SUBI3B


;TEST SUBB. CHECK THAT C(AC) = C(E) AND C(AC)
;= CORRECT DATA.
;0 TO RAN.

	AC=10
SUBB1:	SETUP 20,0
SUBB2:	RANDOM
SUBB3:	SETZB	AC1,RAN1	;CLEAR C(E).
	SUBB	AC,AC1		;DO SUBB..0 FROM RAN = RAN.
	CAME	AC,AC1		;C(AC) SHOULD = C(E).
	ERR	RAN1,RAN
	CAME	AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR	RAN1,RAN
	LOOP	SUBB2,SUBB3


;TEST SUBB. CHECK C(AC) = C(E) AND C(AC) FOR
;CORRECT DATA.
;RAN TO 0 CONDITION.

	AC=10
SUBB1A:	SETUP 20,0
SUBB2A:	RANDOM
SUBB3A:	SETZB	AC1,RAN1	;CLEAR C(AC).
	MOVN	AC2,AC		;SIMULATE SUB...RAN FROM 0 = 2'S COMP RAN.
	SUBB	AC1,AC		;DO SUBB.
	CAME	AC1,AC		;C(AC) SHOULD = C(E).
	EERR	,RAN1
	CAME	AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	EERR	,RAN1
	LOOP	SUBB2A,SUBB3A


;TEST SUBB. CHECK C(AC) = C(E) AND FOR
;CORRECT DATA IN AC.
;RAN TO RAN CONDITION.

	AC=10
SUBB1B:	SETUP 40,0
SUBB2B:	RANDOM
SUBB3B:	MOVE	AC1,AC		;MAKE C(E) = C(AC).
	SUBB	AC,AC1		;DO SUBB..RAN FROM RAN = 0.
	CAME	AC,AC1		;C(AC) SHOULD = C(E).
	EERR	,RAN
	CAME	AC,[0]		;C(AC) SHOULD = 0.
	EERR	,RAN
	LOOP	SUBB2B,SUBB3B



;TEST MOVEI. CHECK C(AC) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=2
MVEI1:	SETUP 20,0
MVEI2:	RANDOM
	MOVE AC2,RAN		;SAVE RAN IN AN AC.
MVEI3:	MOVSS RAN1,AC		;MAKE C(AC) = SEC RAN NUM.
	MOVE AC1,RAN		;SIMULATE
	LSH AC1,22		;A
	LSH AC1,-22		;MOVEI.
	MOVEI AC,(AC2)		;DO A MOVEI.
	CAME AC,AC1		;C(AC) SHOULD = SIM. ANS.
	ERRI RAN1,(AC2)
	LOOP MVEI2,MVEI3


;TEST MOVN. TWO MOVN INSTRUCTIONS SHOULD NOT CHANGE C(AC).

	AC=2
MOVN1:	SETUP 200,0
MOVN2:	RANDOM
		;DO 6 X (MOVN RAN TO RAN).
MOVN3:	REPEAT 3,<
	MOVN AC,AC
	MOVN AC,AC>
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN NUM.
	ERROR AC,RAN
	LOOP MOVN2,MOVN3


;TEST MOVNI. CHECK C(AC) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=2
MVNI1:	SETUP 40,0
MVNI2:	RANDOM
	MOVE AC2,RAN		;SAVE RAN IN AN AC.
MVNI3:	MOVSS RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	SETCA AC1,		;A
	ADD AC1,[1]		;MOVNI INST.
	MOVNI AC,(AC2)		;DO A MOVNI.
	CAME AC,AC1		;C(AC) SHOULD = SIM. ANS.
	ERRI RAN1,(AC2)
	LOOP MVNI2,MVNI3


;TEST MOVNM. WHERE E IS AN AC.
;CHECK C(E) FOR CORRECT DATA.
;RAN TO RAN.

	AC=2
MVNM1:	SETUP 100,0
MVNM2:	RANDOM
	MOVE RAN1,RAN		;SAVE RAN IN AN AC.
MVNM3:	MOVE AC1,AC		;MAKE C(E) = C(AC).
		;DO 3 X 2(MOVNM).
	REPEAT 3,<
	MOVNM AC,AC1
	MOVNM AC1,AC>
	CAME RAN1,AC		;C(E) SHOULD = ORIG C(E).
	EERRM	,RAN
	LOOP MVNM2,MVNM3


;TEST MOVNS. WHERE E IS AN AC.
;CHECK PROPER STORING OF C(E) INTO AC.
;TWO MOVNS = ORIG NUMBER.
;C(E) = RAN.

	AC=3
MVNS1:	SETUP 100,0
MVNS2:	RANDOM
	MOVE AC2,RAN		;PUT C(RAN) INTO AC2 FOR FUTURE COMPARE.
MVNS3:	SETOB AC1,RAN1		;MAKE C(AC) = -1.
		;DO 3 X 2(MOVNS).
	REPEAT 3,<
	MOVNS AC1,AC
	MOVNS AC1,AC>
	CAME AC1,AC		;C(AC) SHOULD = C(E).
	EERRM	,RAN1
	CAME AC2,AC		;C(E) SHOULD = ORIG. C(E).
	EERRM	,RAN1
	LOOP MVNS2,MVNS3


;TEST MOVNS. WHERE E IS AN AC.
;CHECK FOR NOT LOADING C(E) INTO AC WHEN AC= 0.
;TWO MOVNS = ORIGINAL NUM.
;C(E) = RAN.

	AC=10
MVNSA:	SETUP 40,0
MVNSB:	RANDOM
	MOVE AC2,RAN		;SAVE RAN IN AN AC.
MVNSC:	SETOB RAN1		;MAKE C(AC) = -1.
		;DO 3 X 2(MOVNS).
	REPEAT 3,<
	MOVNS AC
	MOVNS AC>
	CAMN AC		;C(AC) SHOULD NOT = C(E).
	EERRM	,RAN1
	CAME AC2,AC		;C(AC) SHOULD = ORIG C(AC).
	EERRM	,RAN1
	LOOP MVNSB, MVNSC


;TEST MOVM. CHECK F(AC) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=7
MVM1:	SETUP 40,0
MVM2:	RANDOM
MVM3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E) = 1ST RAN NUM.
	SETCM	AC2,AC1		;SIMULATE
	TLNN	AC1,400000	;A
	MOVE	AC2,AC1		;MOVM
	TLNE	AC1,400000	;INST.
	ADD	AC2,[1]
	MOVM	AC,AC1		;DO A MOVM.
	CAME	AC,AC2		;C(AC) SHOULD = SIM. ANS.
	EERR	,RAN1
	LOOP	MVM2, MVM3


;TEST MOVMI. CHECK C(AC) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=10
MVMI1:	SETUP 40,0
MVMI2:	RANDOM
MVMI3:	MOVEI	AC1,AC		;SIMULATE A MOVMI INST...MOVEI.
	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVMI	AC,(AC1)	;DO MOVMI.
	CAME	AC,AC1		;C(AC) SHOULD = SIM ANS.
	ERRI	RAN1,(AC1)
	LOOP	MVMI2, MVMI3


;TEST MOVMM. CHECK C(AC) + C(E) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=11
MVMM1:	SETUP 200,0
MVMM2:	RANDOM
MVMM3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E) = RAN.
	SETCM	AC2,AC		;SIMULATE
	TLNN	AC,400000	;A
	MOVE	AC2,AC		;MOVMM
	TLNE	AC,400000	;INST
	ADD	AC2,[1]
	MOVMM	AC,AC1		;DO A MOVMM INST.
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	EERRM	,RAN1
	CAME	AC1,AC2		;C(E) SHOULD = SIM. ANS.
	EERRM	,RAN1
	LOOP	MVMM2, MVMM3


;TEST MOVMS. CHECK C(E) FOR CORRECT DATA.
;RAN TO RAN1.

	AC=10
MVMS1:	SETUP 200,0
MVMS2:	RANDOM
MVMS3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E) = RAN.
	SETCM	AC2,RAN		;SIMULATE
	TLNN	AC1,400000	;A
	MOVE	AC2,AC1		;MOVMS
	TLNE	AC1,400000	;INST.
	ADD	AC2,[1]
	MOVMS	AC,AC1		;DO A MOVMS.
	CAME	AC,AC1		;C(AC) SHOULD = C(E).
	EERRM	,RAN1
	CAME	AC1,AC2		;C(E) SHOULD = SIM. ANS.
	EERRM	,RAN1
	LOOP	MVMS2, MVMS3


;TEST LSH. A LSH LEFT AND A LSH RIGHT SHOULD
;GIVE THE SAME NUMBER WITH A ZERO SIGN BIT.

	AC=2
LSH1P:	SETUP 40,0
LSH1PA:	RANDOM
LSH1PB:	AND AC,[XWD 377777,-1]	;SIMULATE A LSH LEFT THEN RIGHT.
	MOVE AC1,RAN		;MOVE RANDOM NUM INTO AN AC
		;AND DO 3(LSH LEFT 1 PLACE THEN RIGHT 1 PLACE).
	REPEAT 3,<
	LSH AC1,1
	LSH AC1,-1>
	CAME AC1,AC		;C(AC1) = SIM. ANS?
	ERROR AC1,AC		;NO. LSH FAILED.
	LOOP LSH1PA,LSH1PB


;TEST TDN,TDNA. CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN1 TO RAN CONDITION.

	AC=2
TDN1:	SETUP 100,0
TDN2:	RANDOM
TDN3:	MOVS AC1,AC		;PUT SECOND RAN. NUM. INTO "E".
	TDN AC,AC1		;NO SKIP, NO DATA CHANGE.
	JRST	.+2		;HERE..GO AROUND ERR UUO.
	ER	AC,[ASCII /TST/];TDN SKIPPED.
	TDNA AC,AC1		;SKIP, NO DATA CHANGE.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR	AC1,RAN
	LOOP TDN2,TDN3


;TEST TDNN,TDNE. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO 0 CONDITION.

	AC=3
TDNE1A:	SETUP 100,0
TDNE2A:	RANDOM
TDNE3A:	SETZB AC1,RAN1		;CLEAR C(AC).
	TDNN AC1,AC		;C(E) + C(AC) =0..NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDNN SKIPPED.
	TDNE AC1,AC		;C(E) + C(AC) = 0. SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,[0]		;C(AC) SHOULD STILL = 0.
	ERR	AC,RAN1
	LOOP TDNE2A,TDNE3A


;TEST TDNN,TDNE. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE FOR 0 TO RAN CONDITION.

	AC=4
TDNE1B:	SETUP 40,0
TDNE2B:	RANDOM
TDNE3B:	SETZ AC1,		;CLEAR C(E).
	TDNN AC,AC1		;C(E) + C(AC) = 0. NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDNN SKIPPED.
	TDNE AC,AC1		;C(E) + C(AC) = 0. SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR	AC1,RAN
	LOOP TDNE2B,TDNE3B


;TEST TDNN,TDNE. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO -1 CONDITION.

	AC=5
TDNE1C:	SETUP 40,0
TDNE2C:	RANDOM
	JUMPE AC,TDNE2C		;REJECT IF RAN = 0.
TDNE3C:	SETOB AC1,RAN1		;SET C(AC) TO ALL ONES.
	TDNE AC1,AC		;C(E) + C(AC) NOT = 0..NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDNE SKIPPED.
	TDNN AC1,AC		;C(E) + C(AC) NOT = 0..SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,[-1]		;C(AC) SHOULD = ORIG C(AC).
	ERR AC,RAN1
	LOOP TDNE2C,TDNE3C


;TEST TDNE,TDNN. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE IN AC FOR -1 TO RAN CONDITION.

	AC=6
TDNE1D:	SETUP 40,0
TDNE2D:	RANDOM
	JUMPE AC,TDNE2D		;REJECT IF RAN = 0.
TDNE3D:	SETO AC1,		;SET C(E) TO ALL ONES.
	TDNE AC,AC1		;C(E) + C(AC) NOT = 0..NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDNE SKIPPED.
	TDNN AC,AC1		;C(E) + C(AC) NOT = 0..SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR AC1,RAN
	LOOP TDNE2D,TDNE3D


;TEST TDNE,TDNN. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO RAN CONDITION.

	AC=7
TDNE1E:	SETUP 20,0
TDNE2E:	RANDOM
	JUMPE AC,TDNE2E		;REJECT IF RAN = 0.
TDNE3E:	MOVE AC1,AC		;MAKE C(E) = C(AC).
	TDNE AC,AC1		;C(E) + C(AC) NOT = 0..NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDNE SKIPPED.
	TDNN AC,AC1		;C(E) + C(AC) NOT = 0. SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR AC1,RAN
	LOOP TDNE2E,TDNE3E


;TEST TDNE,TDNN. CHECK FOR SKIP/ NO SKIP AND
;NO DATA CHANGE IN AC FOR NOT RAN TO RAN CONDITON.

	AC=10
TDNE1F:	SETUP 20,0
TDNE2F:	RANDOM
TDNE3F:	SETCM AC1,AC		;MAKE C(E) = 1'S COMP OF C(AC).
	TDNN AC,AC1		;C(E) + C(AC) = 0..NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDNN SKIPPED.
	TDNE AC,AC1		;C(E) + C(AC) = 0..SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR AC1,RAN
	LOOP TDNE2F,TDNE3F


;TEST TDZ,TDZA. CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION.

	AC=11
TDZA1:	SETUP 100,0
TDZA2:	RANDOM
TDZA3:	SETCM AC1,AC		;MAKE C(E) 1'S COMP OF C(AC).
	TDZ AC,AC1		;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII/TST/]	;TDZ SKIPPED.
	TDZA AC,AC1		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN NUM.
	ERR AC1,RAN
	CAMN AC1,RAN		;C(E) SHOULD NOT = RAN.
	ERR AC1,RAN
	LOOP TDZA2,TDZA3


;TEST TDZ,TDZA. CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION.

	AC=10
TDZAA:	SETUP 100,1
TDZAB:	RANDOM
TDZAC:	TDZ AC,AC		;SHOULD NOT SKIP.
	CAME AC,[0]		;SHOULD CLEAR C(AC).
	EERR	,RAN
	MOVE AC,RAN		;RESTORE AC.
	TDZA AC,AC		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,[0]		;C(AC) SHOULD BE CLEARED.
	EERR	,RAN
	LOOP TDZAB,TDZAC



;TEST TDZ,TDZA. CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION.

	AC=10
TDZB1:	SETUP 100,0
TDZB2:	RANDOM
TDZB3:	MOVS AC1,AC		;MAKE C(E) A DIFF. RAN. NUM.
	MOVE AC2,AC1		;SIMULATE
	XOR AC2,AC		;A
	AND AC2,AC		;TDZ.
	TDZ AC,AC1		;TDZ SHOULD NOT SKIP.
	CAME AC,AC2		;C(AC) SHOULD = SIM. ANS.
	ERR AC1,RAN
	MOVE AC,RAN		;RESTORE AC.
	TDZA AC,AC1		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;C(AC) SHOULD = SIM. ANS.
	ERR AC1,RAN
	LOOP TDZB2,TDZB3

;TEST TDZE, TDZN. CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR FLOATING ONE IN C(E) AND
;THAT BIT CLEARED IN RANDOM NUM. IN AC.

	AC=10
TDZE1:	SETUP 100,0
	MOVEI AC1,1		;SETUP AC1 TO CONTAIN A MASK BIT.
TDZE2:	RANDOM
	ROT AC1,1		;ROT TO TEST NEXT BIT.
TDZE3:	ANDCM AC,AC1		;CLEAR MASK BIT IN AC.
	MOVE AC2,AC		;SAVE FOR FUTURE COMPARE.
	TDZN AC,AC1		;C(E) + C(AC) = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/]	;TDZN SKIPPED.
	TDZE AC,AC1		;C(E) + C(AC) = 0...SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;C(AC) SHOULD = ORIG C(AC).
	ERR AC1,AC2
	LOOP TDZE2,TDZE3


;TEST TDZE, TDZN. CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR FLOATING ONE IN C(E)
;AND THAT BIT SET IN RAN. NUM. IN C(AC).

	AC=10
TDZEA:	SETUP 100,0
	MOVEI AC1,1		;SET MASK BIT IN C(E).
TDZEB:	RANDOM
	ROT AC1,1		;ROT MASK BIT TO TEST NEXT BIT.
TDZEC:	IOR AC,AC1		;SET MASK BIT IN AC.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVE AC2,AC		;SIMULATE
	ANDCM AC2,AC1		;A TDZ.
	TDZE AC,AC1		;C(E) + C(AC) NOT = 0...NO SKIP.
	CAME AC,AC2		;C(AC) SHOULD = SIM. ANS.
	ERR AC1,RAN1
	IOR AC,AC1		;RESET MASK BIT IN AC.
	TDZN AC,AC1		;C(E) + C(AC) NOT = 0...SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;AND C(AC) SHOULD = SIM. ANS.
	ERR AC1,RAN1
	LOOP TDZEB,TDZEC


;TEST TDZE,TDZN. SET AND ROT A MASK BIT IN AC
;AND CHECK SKIP/NO SKIP AND PROPER C(AC)
;FOR MASK BIT IN AC ANS RANDOM NUMBER IN E.

	AC=10
TDZNA:	SETUP 100,0
	MOVEI AC1,1		;SETUP AC1 FOR MASK BIT.
TDZNB:	RANDOM
	ROT AC1,1		;ROT AC1 TO TEST NEXT BIT.
	MOVE AC2,AC1		;SAVE MASK BIT.
TDZNC:	MOVE AC1,AC2		;RESTORE MASK BIT IF ERROR.
	ANDCM AC,AC1		;CLEAR MASK BIT IN RAN NUM.
	TDZN AC1,AC		;C(E) + C(AC) =0..SHOULDN'T SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDZN SKIPPED.
	TDZE AC1,AC		;C(E) + C(AC) = 0..SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,AC2		;C(AC1) SHOULD NOT HAVE CHANGED.
	ERR AC,AC2
	LOOP TDZNB,TDZNC


;TEST TDZE,TDZN. SET AND ROT A MASK BIT IN AC
;AND CHECK SKIP/NO SKIP AND PROPER C(AC)
;FOR MASK BIT IN AC AND RANDOM NUMBER IN E.
;RANDOM NUMBER HAS MASK BIT SET.

	AC=10
TDZN1:	SETUP 40,0
	MOVEI AC1,1		;SETUP AC1 FOR MASK BIT.
TDZN2:	RANDOM
	ROT AC1,1		;ROT AC1 TO TEST NEXT BIT.
TDZN3:	MOVE AC2,AC1		;SAVE MASK BIT.
	IOR AC,AC1		;SET MASK BIT IN RAN.
	TDZE AC1,AC		;C(E) + C(AC) NOT = 0...NO SKIP.
	CAME AC1,[0]		;C(AC) SHOULD = 0.
	ERR AC,AC2
	MOVE AC1,AC2		;RESTORE MASK BIT.
	TDZN AC1,AC		;C(E) + C(AC) NOT = 0...SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,[0]		;AC1 SHOULD HAVE GOTTEN CLEARED OUT.
	ERR AC,AC2
	MOVE AC1,AC2		;RESTORE MASK BIT.
	LOOP TDZN2,TDZN3


;TEST TDO TDOA. CHECK FOR SKIP/NO SKIP ANS CORRECT DATA
;IN AC FOR RAN TO NOT RAN.

	AC=10
TDOA1:	SETUP 100,0
TDOA2:	RANDOM
TDOA3:	SETCM AC1,AC		;MAKE "C(E)" = COMP OF RAN.
	TDO AC,AC1		;SHOULD NOT SKIP.
	CAME AC,[-1]		;AC SHOULD HAVE ALL BITS SET.
	ERR AC1,RAN
	MOVE AC,RAN		;RESTORE AC.
	TDOA AC,AC1		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,[-1]		;AC SHOULD HAVE ALL BITS SET.
	ERR AC1,RAN
	LOOP TDOA2,TDOA3


;TEST TDO,TDOA. CHECK SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION.

	AC=2
TDOAA:	SETUP 40,0
TDOAB:	RANDOM
TDOAC:	TDO AC,AC		;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/] ;TDO SKIPPED.
	TDOA AC,AC		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD NOT HAVE CHANGED.
	EERR	,RAN
	LOOP TDOAB,TDOAC


;TEST TDO, TDOA. CHECK FOR SKIP/NO SKIP
;AND CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION.

	AC=2
TDOB1:	SETUP 400,3
TDOB2:	RANDOM
TDOB3:	MOVS AC1,AC		;MAKE AC1 ANOTHER RAN NUM.
	MOVE AC2,AC		;SIMULATE
	XOR AC2,AC1		;A
	IOR AC2,AC		;TDO INST.
	TDO AC,AC1		;SHOULD NOT SKIP.
	CAME AC,AC2		;C(AC) = SIM. ANS?
	ERR AC1,RAN		;NO.
	MOVE AC,RAN		;RESTORE AC.
	TDOA AC,AC1		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;C(AC) = SIM ANS?
	ERR AC1,RAN		;NO.
	LOOP TDOB2,TDOB3


;TEST TDOE,TDON. ROT A MASK BIT IN E AND SET THAT
;BIT IN AC BEFORE TDO. CHECK FOR SKIP/NO SKIP
;AND PROPER DATA IN AC.

	AC=2
TDOE1:	SETUP 40,0
	MOVEI AC1,1		;SETUP A MASK BIT IN "E".
TDOE2:	RANDOM
	ROT AC1,		;ROT MASK BIT TO TEST NEXT BIT.
TDOE3:	IOR AC,AC1		;SET MASK BIT IN AC.
	MOVE AC2,AC		;SAVE AC IN AC2.
	TDOE AC,AC1		;C(E) + C(AC) NOT = 0. NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDOE SKIPPED.
	TDON AC,AC1		;C(E) + C(AC) NOT = 0..SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;C(AC) SHOULD NOT CHANGE.
	ERR AC1,AC2
	LOOP TDOE2,TDOE3


;TEST TDOE,TDON. ROT A MASK BIT IN E AND CLEAR THAT
;BIT IN AC BEFORE TDO. CHECK FOR SKIP/NO SKIP
;AND PROPER DATA IN AC.

	AC=3
TDOEA:	SETUP 40,0
	MOVEI AC1,1		;SETUP MASK BIT IN"E".
TDOEB:	RANDOM
	ROT AC1,1		;ROT MASK BIT TO TEST NEXT BIT.
TDOEC:	ANDCM AC,AC1		;CLEAR MASK BIT IN AC.
	MOVE RAN1,AC		;SAVE AC.
	MOVE AC2,AC		;SIMULATE
	IOR AC2,AC1		;A TDO.
	TDOE AC,AC1		;C(E) + C(AC) = 0. SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,AC2		;C(AC) = SIM ANS?
	ERR AC1,RAN1		;NO.
	MOVE AC,RAN1		;RESTORE AC.
	TDON AC,AC1		;C(E) + C(AC) = 0..NO SKIP.
 	CAME AC,AC2		;C(AC) = SIM. ANS?
	ERR AC1,RAN1		;NO.
	LOOP TDOEB,TDOEC


;TEST TDOE,TDON. ROT A MASK BIT IN AC AND CLEAR THAT
;BIT IN E BEFORE TDO. CHECK FOR SKIP/NO SKIP
;AND PROPER DATA IN AC.

	AC=4
TDONA:	SETUP 40,0
	MOVEI AC1,1		;SETUP  A MASK BIT IN AC.
TDONB:	RANDOM
	ROT AC1,1		;ROT BIT TO TEST NEXT BIT.
	MOVE AC2,AC1		;SAVE MASK BIT SO IN CASE
TDONC:	MOVE AC1,AC2		;OF ERROR IT CAN BE RESTORED.
	ANDCM AC,AC1		;CLEAR MASK BIT IN E.
	JUMPE AC,TDONB		;REJECT IF C(AC) = 0.
	MOVE AC3,AC		;SIMULATE
	IOR AC3,AC1		;TDO.
	TDOE AC1,AC		;C(E) + C(AC) = 0...SKIP.
	ER	AC1,[ASCII /TST/];TDOE DID NOT SKIP.
	CAME	AC1,AC3		;C(AC) SHOULD = SIM. ANS.
	ERR	AC,AC2
	TDON AC1,AC		;C(E) + C(AC) NOT = 0...SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,AC3		;C(AC) SHOULD = SIM. ANS.
	ERR AC,AC2
	MOVE AC1,AC2		;RESTORE AC.
	LOOP TDONB,TDONC


;TEST TDOE,TDON. ROT A MASK BIT IN AC  AND SET
;THAT BIT IN E BEFORE TDO. CHECK FOR SKIP/ NO SKIP
;AND CORRECT DATA IN AC.

	AC=5
TDON1:	SETUP 40,0
	MOVEI AC1,1		;SETUP AC TO CONTAIN A MASK BIT.
TDON2:	RANDOM
	ROT AC1,1		;ROT TO TEST NEXT BIT.
	MOVE AC2,AC1		;SAVE C(AC) SO IT CAN BE
TDON3:	MOVE AC1,AC2		;RESTORED IN CASE OF ERROR.
	IOR AC,AC1		;SET MASK BIT IN E.
	TDOE AC1,AC		;C(E) + C(AC) NOT = 0...NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDOE SKIPPED.
	TDON AC1,AC		;C(E) + C(AC) NOT = 0...SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,AC		;C(AC) SHOULD = C(E).
	ERR AC,AC2
	MOVE AC1,AC2		;RESTORE AC.
	LOOP TDON2,TDON3


;TEST TDC. CHECK FOR SKIP/NO SKIP AND CORRECT
;DATA FOR NOT RAN TO RAN CONDITION.

	AC=6
TDC1:	SETUP 100,0
TDC2:	RANDOM
TDC3:	SETCM AC1,RAN		;MAKE C("E") = COMP. OF RAN.
	TDC AC,AC1		;NO SKIP.
	CAME AC,[-1]		;C(AC) SHOULD = A -1.
	ERR AC1,RAN
	SETO RAN1,		;SET RAN1 FOR ERROR MESSAGE.
	TDC AC,AC1		;NO SKIP.
	CAME AC,RAN		;C(AC) SHOULD = RAN AGAIN.
	ERR AC1,RAN1
	LOOP TDC2,TDC3


;TEST TDCA. CHECKING FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION.

	AC=10
TDCA1:	SETUP 100,0
TDCA2:	RANDOM
TDCA3:	SETCM AC1,RAN		;MAKE C("E") = COMP OF RAN.
	TDC AC,AC1		;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDC SKIPPED.
	TDCA AC,AC1		;SHOULD SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;TWO TDC'S SHOULD RETURN C(AC)
				;TO IT'S ORIGINAL VALUE.
	ERR AC1,RAN
	LOOP TDCA2,TDCA3


;TEST TDCE. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION.

	AC=11
TDCE1:	SETUP 100,0
TDCE2:	RANDOM
TDCE3:	SETZB AC1,RAN1		;CLEAR BOTH AC AND RAN1.
	TDCE AC1,AC		;C(E) + C(AC) = 0. SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,RAN		;C(AC) SHOULD = RAN.
	EERR	,RAN1
	LOOP TDCE2,TDCE3


;TEST TDCE,TDCN. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION.

	AC=11
TDCEA:	SETUP 100,0
TDCEB:	RANDOM
TDCEC:	SETZ AC1,		;CLEAR C(E).
	TDCN AC,AC1		;C(E) + C(AC) = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDCN SKIPPED.
	TDCE AC,AC1		;C(E) + C(AC) = 0. SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD STILL = RAN.
	ERR AC1,RAN
	LOOP TDCEB,TDCEC


;TEST TDCE. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION.

	AC=10
TDCE4:	SETUP 100,0
TDCE5:	RANDOM
	JUMPE AC,TDCE5		;REJECT IF RAN = 0.
TDCE6:	SETOB AC1,RAN1		;SET C(AC) TO ALL ONES.
	SETCM AC2,AC		;SIMULATE A TDC.
	TDCE AC1,AC		;C(E) + C(AC) NOT = 0. NO SKIP.
	CAME  AC1,AC2		;C(AC) = SIM.. ANS?
	ERR AC,RAN1		;NO.
	LOOP TDCE5,TDCE6


;TEST TDCE,TDCN. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION.

	AC=10
TDCED:	SETUP 100,0
TDCEE:	RANDOM
	JUMPE AC,TDCEE		;REJECT IF RAN = 0.
	CAMN AC,[-1]		;C(AC) = -1?
	JRST	TDCEE		;YES. REJECT.
TDCEF:	SETOB AC1,RAN1		;SET C(E) TO ALL ONES.
	TDCE AC,AC1		;C(E) + C(AC) NOT = 0. NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDCE SKIPPED.
	TDCN AC,AC1		;C(E) + C(AC) NOT = 0..SKIP.
	ER AC,[ASCII /TST/]
	CAME AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	ERR RAN1,RAN
	LOOP TDCEE,TDCEF


;TEST TDCE. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION.

	AC=10
TDCE7:	SETUP 100,0
TDCE8:	RANDOM
	JUMPE AC,TDCE8		;REJECT IF RAN = 0.
TDCE9:	MOVE AC1,RAN		;MAKE C("AC") = C("E").
	TDCE AC1,AC		;C(E) + C(AC) NOT = 0. NO SKIP.
	CAME AC1,[0]		;C(AC) SHOULD = 0.
	ERR AC,AC
	LOOP TDCE8,TDCE9


;TEST TDCE. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO NOT RAN.

	AC=10
TDCEG:	SETUP 100,0
TDCEH:	RANDOM
TDCEI:	SETCM AC1,AC		;MAKE C("AC") = TO COMP OF RAN.
	MOVE RAN1,AC1		;SAVE C(AC) IN CASE OF ERROR.
	TDCE AC1,AC		;C(E) + C(AC) = 0. SKIP.
	ER AC1,[ASCII /TST/]
	CAME AC1,[-1]		;C(AC) SHOULD = -1.
	ERR AC,RAN1
	LOOP TDCEH,TDCEI



	;JRST	BEGEND		;REPEAT TEST

SUBTTL	*UUOERR* OLD-UUO ERROR HANDLER SUBROUTINE, V75B, APR 22,1975

;THIS SUBROUTINE PROVIDES ERROR REPORTING THRU THE USE OF UUO'S.

ERRMES:	MOVEM	0,%ERAC0#	;SAVE AC0
	IFDEF	EXCASB,<IFDEF	KI10,<
	SKIPN	KAIFLG
	JRST	.+5
	SKIPE	USER		;USER MODE ?
	JRST	.+3
	SKIPE	MARGIN
	DATAO	APR,[IMGNOF,,ISPDOF] ;CLR MARGINS >>
	MOVEM	1,%ERAC1#	;SAVE AC1
	MOVEM	2,%ERAC2#	;SAVE AC2
	AOS	ERRTLS		;INCREMENT ERROR TOTALS
	HRRZ	0,$SVUPC	;GET PC OF UUO
	CAMN	0,ERRPC		;PC = PC OF LAST ERROR ?
	AOS	MICNT#		;YES, ADD 1 TO ERROR COUNT
	MOVE	0,MICNT
	HRL	0,$SVUPC
	SKIPN	KLFLG		;NOT KL10
	SKIPE	USER		;AND NOT USER?
	JRST	.+2
	DATAO	PI,0		;YES, DISPLAY ERROR PC,ERROR COUNT
	SETZM	PROCED#		;CLEAR PROCEED FLAG
	SWITCH
	TLNE	NOPNT		;PRINTOUT ?
	JRST	%ERRS1		;NO, RESTORE AC'S AND RETURN
	MOVE	1,$SVUUO
	LSH	1,-^D27
	MOVEM	1,%ACS1A#	;SAVE UUO NUMBER
	MOVE	0,%ERAC0
	MOVE	1,%ERAC1
	SKIPGE	@ERRLOP		;ERR LOOP AC > OR = 0 ?
	JRST	%ERRS4		;NO, SEE IF PRINT ALL
%ERMS1:	SETZM	MICNT		;CLEAR ERROR COUNT
	SKIPL	MONCTL		;DIAG MON OR SYS EXER ?
	JRST	.+4		;NO, DON'T NEED TITLE
	SKIPN	%ERFST#		;FIRST ERROR ?
	PNTNM			;YES, PRINT PROGRAM TITLE
	SETOM	%ERFST
	SKIPN	PASCNT		;FIRST PASS ?
	JRST	.+4		;YES
	PMSG	<^TEST PASS COUNT = >
	MOVE	PASCNT
	PNTDEC
	PMSG	<^PC =   >
	HRRZ	0,$SVUPC	;GET PC OF UUO
	MOVEM	0,ERRPC		;SAVE FOR COMPARE
	PNT6			;PRINT UUO ADDRESS
	XLIST
	IFDEF	ERDIAG,<LIST
;DIAGNOSTIC FORMAT ERROR PRINTER

;PRINT RESULT

%ERMS2:	PMSG	<^RESULT  = >
	MOVE	1,$SVUUO	;GET AC # OF UUO
	LSH	1,-27
	ANDI	1,17
	MOVE	0,(1)		;GET C(AC)
	CAIG	1,1		;IS AC # = TO SAVE AC ?
	MOVE	0,%ERAC0(1)	;YES, GET SAVED AC
	PNTHW			;PRINT C(AC)

	MOVE	CONSW
	TLNE	TXTINH		;PRINT FAILURE DES AND FLT NBR ?
	JRST	%ERMORE		;NO, RESTORE AC'S ETC.

;PRINT FAILURE DESCRIPTOR

	MOVE	1,%ACS1A	;GET UUO NUMBER
	CAIG	1,1		;PRINT DESCRIPTOR ?
	JRST	%ERMS3		;NO, JUST PRINT FAULT NUMBER
	PCRL
	MOVE	%FLTTB(1)
	PNTAL			;PRINT FAULT DESCRIPTOR

;PRINT FAULT NUMBER

%ERMS3:	PMSG	<^FAULT NUMBER = >
	MOVEI	TLET
	PNTA			;PRINT TEST LETTER

	HRRZ	$SVUUO
	TRNE	700000
	JRST	%ER6X
	TRNE	070000
	JRST	%ER5X
	TRNE	007000
	JRST	%ER4X
	PNT3			;PRINT FAULT NUMBER
%ER7X:	PCRL
	JRST	%ERMORE

%ER4X:	PNT4
	JRST	%ER7X
%ER5X:	PNT5
	JRST	%ER7X
%ER6X:	PNT6
	JRST	%ER7X

;FAILURE DESCRIPTORS

TLET:	0			;TEST LETTER
%FLTTB:	0			;DESCRIPTOR TABLE
%NODES:	[0]			;NO DESCRIPTOR
SPDES:	[0]			;SPECIAL USER FAILURE DESCRIPTOR
$ACF:	[ASCIZ/C(AC) FAILED/]
%AC1F:	[ASCIZ/C(AC+1) FAILED/]
%EF:	[ASCIZ/C(E) FAILED/]
%E1F:	[ASCIZ/C(E+1) FAILED/]
%ARF:	[ASCIZ/C(C(ACR)) FAILED/]
%AR1F:	[ASCIZ/C(C(ACR+1)) FAILED/]
%ALF:	[ASCIZ/C(C(ACL)) FAILED/]
%EEF:	[ASCIZ/C(C(E)) FAILED/]
%FF:	[ASCIZ/FLAG FAILED/]
>
	XLIST
	IFDEF	ERRELB,<
	LIST
;RELIABILITY FORMAT ERROR PRINTER

%ERMS2:	SETZM	%RAND#		;CLEAR PNT C(RAN) FLAG
	MOVE	1,%ACS1A
	CAIL	1,11		;UUO # 11-13
	SETOM	%RAND		;YES, SET PNT C(RAN) FLAG
	TRZ	1,10		;MAKE UUO # 1-7
	MOVEM	1,%ACS1A
	MOVE	2,ERRPC		;GET UUO ADDRESS
	MOVE	2,-1(2)		;GET INST IN UUO-1
	CAIL	1,4		;UUO # < THAN 4 ?
	MOVE	2,$SVUUO	;YES, GET UUO
	MOVEM	2,%CNTE#	;SAVE E ADDRESS
	MOVE	2,%ERAC2
	MOVE	1,%ERAC1
	MOVE	0,%ERAC0
	MOVEI	1,@%CNTE	;GET ADRS FIELD OF UUO OR UUO-1
	MOVEM	1,%EE1#
	MOVE	1,%ERAC1
	MOVE	1,@%EE1		;GET C(E)
	MOVEM	1,%EE1A#
	MOVE	1,%ERAC1
	MOVEI	1,@$SVUUO	;GET ADDRESS FIELD OF UUO
	MOVEM	1,%EE2#
	MOVE	1,%ACS1A
	CAIN	1,3		;UUO # 3 ?
	JRST	.+4		;YES
	MOVE	1,%ERAC1
	MOVE	1,@%EE2		;GET C(E) OF UUO
	MOVEM	1,%EE2A#
	MOVE	2,%ACS1A	;GET UUO #
	MOVE	1,%CNTE
	LSH	1,-27		;GET AC NUMBER
	ANDI	1,17
	CAIG	2,5		;UUO # 6,7 OR 2
	CAIN	2,2
	JRST	%ERR2		;YES, GO PNT E AND C(E)
;PRINT ERROR AC

	PMSG	<^AC =   >
	MOVE	0,1
	PNT2			;PRINT AC NUMBER
	PMSG	<^C(AC)= >
	MOVE	0,(1)		;GET C(AC)
	CAIG	1,2		;IS AC # = SAVED AC ?
	MOVE	0,%ERAC0(1)	;YES, GET SAVED AC
%ERRB:	PNTHW			;PRINT C(AC) OR UUO2 (E)

;PRINT ERROR INFO

	CAIN	2,5		;UUO # 5
	JRST	%ERR4		;YES, GO PNT 'TST','SKP', OR ETC.

	PMSG	<^COR =  >
	MOVE	0,(1)		;GET C(AC)
	CAIG	1,2		;IS AC # = SAVED AC ?
	MOVE	0,%ERAC0(1)	;YES, GET SAVED AC
	CAIE	2,2
	MOVE	0,%EE1A		;UUO # 2, GET C(E)
	PNTHW			;PRINT C(E) OR UUO2 C(AC)
	CAIL	2,4		;UUO # >3 ?
	JRST	%ERRC		;YES, RESTORE AC'S AND RETURN

	PMSG	<^    ORIGINAL>
%ERRB1:	MOVE	1,$SVUUO
	LSH	1,-27		;GET AC # OF UUO
	ANDI	1,17
	PMSG	<^C(AC)= >
	MOVE	0,(1)		;GET C(AC)
	CAIG	1,2		;IS AC # = SAVED AC ?
	MOVE	0,%ERAC0(1)	;YES, GET SAVED AC
	SKIPE	%RAND		;PRINT C(RAN) FLAG SET ?
	MOVE	0,RAN#		;YES
	PNTHW			;PRINT C(AC) OR C(RAN)
	CAIN	2,3		;UUO # 3 ?
	JRST	%ERR2		;YES, PRINT E, RESTORE AC'S AND RETURN
	CAIN	2,7		;UUO # 7 ?
	JRST	%ERRC		;YES, BYPASS PRINTING C(E)
	PMSG	<^C(E) = >
	MOVE	0,%EE2A
	PNTHW			;PRINT C(E)
	JRST	%ERRC

%ERR2:	PMSG	<^E =    >
	MOVE	0,%EE2
	CAIN	2,2		;UUO # 2 ?
	MOVE	0,%EE1
	PNT6			;PRINT E OF UUO OR UUO-1
	CAIL	2,6		;UUO 6 OR 7 ?
	JRST	%ERRB1		;YES, GO PNT C(AC), C(E) AND RETURN
	CAIN	2,3		;UUO # 3 ?
	JRST	%ERRC		;YES, RESTORE AC'S AND RETURN

	PMSG	<^C(E) = >
	MOVE	0,%EE1A		;GET C(E)
	JRST	%ERRB
;PRINT ASCII COMMENT

%ERR4:	HRRZI	0,@$SVUUO
	PNTA			;PRINT 'TST','SKP', OR ETC.
	JRST	%ERRC

;COMPLETE PRINTOUT

%ERRC:	PCRL

	XLIST
	IFDEF	UUOTXT,<
	LIST
	MOVE	0,CONSW
	TLNN	TXTINH		;PRINT DIAGNOSTIC COMMENT ?
	CAIE	2,7		;UUO # 7 ?
	JRST	%ERMORE		;NO, RESTORE AC'S AND RETURN
	MOVE	0,%EE2		;YES
	PNTAL			;PRINT DIAGNOSTIC COMMENT
	PCRL
>
	LIST
	JRST	%ERMORE

>
	LIST
;RESTORE AC'S AND RETURN OR HALT

%ERMORE:XCT	ERMORE
	PNTMGN			;PRINT MARGINS
	SWITCH

%ERRS1:	TTALTM			;ALTMODE CHECK
	JRST	.+4		;NONE
	MOVEI	.+3		;SAVE CONT ADDRESS
	MOVEM	JOBOPC
	JRST	@ALTMGO		;PERFORM TRANSFER
	MOVE	CONSW
	TLNE	0,ERSTOP	;HALT ON ERROR SWITCH SET ?
	ERRHLT			;YES
	TLNN	0,LOOPER	;LOOP ON ERROR SWITCH SET ?
	SETOM	PROCED		;NO, SET THE PROCEED FLAG
	TLNE	0,DING		;RING BELL SWITCH SET ?
	PBELL			;YES, GO RING BELL

%ERRS2:	MOVE	2,%ERAC2	;RESTORE AC'S
	MOVE	1,%ERAC1
	SETOM	@ERRLOP		;SET C(ERR LOOP AC) TO -1
	SKIPN	PROCED		;LOOP ON ERROR ?
	JRST	%ERRS5		;YES
	AOS	@ERRLOP		;NO, INC C(ERR LOOP AC)
	AOS	@ERRLOP		;SO IT ='S 1
	SKIPL	MONCTL		;UNDER DIAGNOSTIC MONITOR ?
	JRST	%ERRS5		;NO, CONTINUE PROGRAM
	MOVE	0,ERRTLS	;YES
	CAIL	0,5		;PRINTED ALLOWED ERRORS ?
	JRST	$BEND2

%ERRS5:	MOVE	0,%ERAC0	;NO, CONTINUE PROGRAM
	IFDEF	EXCASB,<IFDEF KI10,<
	SKIPN	KAIFLG
	JRST	.+5
	SKIPE	USER
	JRST	.+3
	SKIPE	MARGIN
	DATAO	APR,MARGIN	;RESET MARGIN SYSTEM >>
	JRST	UUOEXT

%ERRS4:	MOVE	0,CONSW
	TLNN	PALERS		;PRINT ALL ERRORS ?
	JRST	%ERRS1		;NO
	JRST	%ERMS1		;YES

SUBTTL	*STOR* RESERVED STORAGE, JULY 19,1977

;PROGRAM LITERALS

	XLIST
IFNDEF	$LPAPER,<LIST>
	LIT
	LIST
ENDSLD:	0

IFDEF	DEBUG,<
PATCH:	BLOCK DEBUG		;PATCHING AREA
>

;PROGRAM VARIABLES
	VAR

IFDEF	PGMEND,<
END:	0
	END	START	>

