DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 1
DAKAGT	MAC	19-JAN-77 16:54		DIAGNOSTIC PARAMETERS                                                              SEQ 0007

     1					;DAKAG
     2
     3
     4
     5			000002			DECVER==2
     6			000000			MCNVER==0
     7
     8						XLIST
     9						LIST
    10						LALL
    11						NAME	\MCNVER,\DECVER^
    12
    13					TITLE	DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2
    14					^
    15
    16					;TEST DESIGNED FOR INITIAL DEBUGGING OF PROCESSOR HARDWARE
    17					;AND TO DETECT (SOLID) FAILURES IN THE FIELD.
    18
    19					;COPYRIGHT 1972,1977
    20					;DIGITAL EQUIPMENT CORPORATION
    21					;MARLBORO, MASS. 01752
    22
    23					;JOHN R. KIRCHOFF
    24					;DICK MALISKA
    25
    26	000137					LOC	137
    27	000137	000000	000002			MCNVER,,DECVER
    28
    29						NOSYM
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 2
DAKAGT	MAC	19-JAN-77 16:54		DIAGNOSTIC PARAMETERS                                                              SEQ 0008

    30					SUBTTL	DIAGNOSTIC PARAMETERS
    31
    32					;PARAMETER DEFINITIONS
    33			000001		EXCASB==1
    34			000001		USRASB==1
    35			000001		PGMEND==1
    36			000100		DEBUG==100
    37
    38					;FLAG DEFINITIONS
    39			010000		USERF=10000		;USER MODE FLAG
    40
    41
    42					;MACROS
    43
    44					;SPECIAL FEATURE PARAMETERS
    45
    46			030712		SADR1=START
    47			030712		SADR2=START
    48			030712		SADR3=START
    49			030712		SADR4=START
    50		254000	030712		SADR5=JRST START
    51		254000	030712		SADR6=JRST START
    52		254000	030712		SADR7=JRST START
    53		254000	030712		SADR8=JRST START
    54		254000	030712		SADR9=JRST START
    55		254000	030712		SADR10=JRST START
    56		254000	030712		SADR11=JRST START
    57
    58			000000		PAREA0=0
    59			000000		PAREA1=0
    60			000000		PAREA2=0
    61		444153	414700		PAREA3=SIXBIT/DAKAG/
    62		645560	000000		PAREA4=SIXBIT/TMP/
    63			000000		PAREA5=0
    64			000000		PAREA6=0
    65			001000		ITERAT==1000
    66			000001		PGMEND==1
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 3
DAKAGT	MAC	19-JAN-77 16:54		DIAGNOSTIC PARAMETERS                                                              SEQ 0009

    67					SUBTTL	DIAGNOSTIC PARAMETERS
    68
    69					;ACCUMULATOR ASSIGNMENTS
    70
    71					;CONTROL WORDS
    72
    73			400000		AROV=400000		;ARITHMETIC OVERFLOW
    74			200000		CRY0=200000		;CARRY 0
    75			100000		CRY1=100000		;CARRY 1
    76			040000		FOV=40000		;FLOATING OVERFLOW
    77			020000		BIS=20000		;BYTE INTERRUPT
    78			010000		USERF=10000		;USER MODE FLAG
    79			004000		EXIOT=4000		;USER PRIV I/O FLAG
    80			000100		FXU=100			;FLOATING UNDERFLOW
    81			000040		DCK=40			;DIVIDE CHECK
    82
    83
    84					;MACROS
    85
    86					; STOP - USED FOR SCOPE LOOP, IF INSTRUCTION FAILS, CHANGE (JUMPA .+1)
    87					;	 TO A (JUMPA X) TO CYCLE ON FAILING INSTRUCTION
    88
    89					DEFINE	STOP	(A)<
    90						HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
    91						JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
    92									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
    93									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
    94									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1>
    95
    96					; SFLAG - USED TO CLEAR ALL FLAGS THEN TO SET REQUESTED FLAG
    97
    98					DEFINE	SFLAG	(A)<
    99						MOVSI	1,A
   100						JFCL	17,.+1		;RESET ALL FLAGS
   101						JRST	2,.+1(1)	;SET A FLAG>
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 1
PARAM	KLM	18-JAN-77 11:38		*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, JAN 18,1977                               SEQ 0010

   102					SUBTTL	*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, JAN 18,1977
   103
   104					DEFINE	S,<;*********************************************************************>
   105
   106					S^;*********************************************************************^
   107					;*DATA SWITCHES (READ FROM CONSOLE IN EXEC MODE OR TYPED IN IN USER MODE)
   108					;*LEFT HALF SWITCHES ARE PRE-ASSIGNED FOR SUBROUTINE PACKAGE USE
   109					;*AND CONTROL LOOPING, PRINTING (TTY OR OTHER DEVICE) AND MISC. FUNCTIONS
   110					S^;*********************************************************************^
   111
   112			400000		ABORT==	400000			;ABORT PROGRAM ON PASS COMPLETION
   113			200000		RSTART==200000			;RESTART TEST, PRINT TOTALS
   114			100000		TOTALS==100000			;PRINT TOTALS, CONTINUE
   115
   116			040000		NOPNT==	040000			;INHIBIT ALL PRINT/TYPE OUT (EXCEPT FORCED)
   117			020000		PNTLPT==020000			;PRINT ALL DATA ON LPT (LOGICAL DEVICE, USER MODE)
   118			010000		DING==	010000			;RING BELL ON ERROR
   119
   120			004000		LOOPER==004000			;ENTER EXERCISE/CHECK LOOP ON ERROR
   121			002000		ERSTOP==002000			;HALT ON TEST ERROR
   122			001000		PALERS==001000			;PRINT ALL ERRORS
   123
   124			000400		RELIAB==000400			;RELIABILITY MODE
   125			000200		TXTINH==000200			;INHIBIT ERROR TEXT
   126			000100		INHPAG==000100			;INHIBIT PAGING
   127
   128			000040		MODDVC==000040			;MODIFY DEVICE CODE
   129			000020		INHCSH==000020			;INHIBIT CACHE
   130			000010		OPRSEL==000010			;OPERATOR SELECTION
   131
   132			000004		CHAIN==	000004			;CHAIN CONTROL SWITCH
   133
   134			000002		KAHZ50==000002			;KA10 50 HERTZ POWER
   135
   136									;SWITCH 17 RESERVED !!!
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 2
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0011

   137					SUBTTL	*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977
   138
   139					S^;*********************************************************************^
   140					;*SPECIAL SUBPROGRAM LINKAGES
   141					S^;*********************************************************************^
   142
   143			027772		FSELNK=	27772	;FILE SELECT LINK
   144			027773		FRDLNK=	27773	;FILE READ LINK
   145			027774		LDLNK=	27774	;LOAD LINKAGE ADDRESS
   146			027775		DDTLNK=	27775	;DDT LINKAGE ADDRESS
   147			027776		MODLNK=	27776	;OPERATIONAL MODE CHECK LINKAGE ADDRESS
   148			027777		SUBLNK=	27777	;SUBROUTINE LINKAGE ADDRESS
   149
   150					S^;*********************************************************************^
   151					;*SPECIAL SUBROUTINE FATAL HALTS
   152					;*USED TO REPORT ERRORS THAT CAUSE THE SUBROUTINES TO BE UNUSABLE
   153					S^;*********************************************************************^
   154
   155					;ADDRESS   TAG	REASON
   156					;---------------------
   157
   158					; 1010 	NOEXEC	;PROGRAM NOT CODED FOR EXEC MODE OPERATION
   159					; 1011  PLERR	;FATAL PUSH LIST POINTER ERROR
   160					; 1012  PLERR1	;INITIAL PUSH LIST POINTER ERROR
   161					; 1013  MUOERR	;MUUO WITH LUUO HANDLER WIPED OUT
   162					; 1014  DTEBER	;DTE20 INTERRUPT WITHOUT DOORBELL
   163					; 1015  DTECER	;DTE20 CLOCK INTERRUPT WITHOUT FLAG SET
   164					; 1016  CPIERR	;CPU INITIALIZATION ERROR
   165					; 1017  EOPERR	;END OF PROGRAM ERROR
   166					; 1020  LUOERR	;INTERRUPT WITH LUUO HANDLER WIPED OUT
   167
   168					S^;*********************************************************************^
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 3
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0012

   169					S^;*********************************************************************^
   170					;OPERATOR DEFINITIONS (NON-UUO'S)
   171					S^;*********************************************************************^
   172
   173		260740	000000		OPDEF	GO	[PUSHJ	P,]	;SUBROUTINE CALL
   174		263740	000000		OPDEF	RTN	[POPJ	P,]	;SUBROUTINE RETURN
   175		261740	000000		OPDEF	PUT	[PUSH	P,]	;PUT DATA ON PUSH LIST
   176		262740	000000		OPDEF	GET	[POP	P,]	;GET DATA FROM PUSH LIST
   177		254000	000000		OPDEF	PJRST	[JRST	]	;JRST TO ROUTINE THAT RTN'S
   178		254200	000000		OPDEF	HALT	[JRST	4,]	;DEFINITION FOR DDT
   179		254100	000000		OPDEF	JRSTF	[JRST	2,]	;DEFINITION FOR DDT
   180		254500	000000		OPDEF	JEN	[JRST	12,]	;DEFINITION FOR DDT
   181
   182					S^;*********************************************************************^
   183					;*SUBROUTINE INITIALIZATION CALL
   184					S^;*********************************************************************^
   185
   186		265000	030011		OPDEF	PGMINT	[JSP	0,SBINIT]	;SUBROUTINE INITIALIZATION
   187
   188					S^;*********************************************************************^
   189					;*HALTING UUO'S (A MORE GRACEFUL HALT THAN SIMPLY USING THE HALT INSTRUCTION).
   190					S^;*********************************************************************^
   191
   192		037640	000004		OPDEF	FATAL	[37B8!15B12!4]	;FATAL PROGRAMMING HALT
   193		037600	000004		OPDEF	ERRHLT	[37B8!14B12!4]	;PROGRAM ERROR HALT
   194
   195					S^;*********************************************************************^
   196					;*TERMINAL INPUT UUO'S
   197					;*ALWAYS COME FROM THE CONSOLE TERMINAL IN EXEC MODE OR THE
   198					;*CONTROLLING TERMINAL (REAL TERMINAL OR PTY) IN USER MODE.
   199					S^;*********************************************************************^
   200
   201		037000	000003		OPDEF	TTICHR 	[37B8!0B12!3]	;TTY, INPUT ANY CHARACTER
   202		037040	000003		OPDEF	TTIYES	[37B8!1B12!3]	;TTY, NORMAL RETURN Y
   203		037100	000003		OPDEF	TTINO	[37B8!2B12!3]	;TTY, NORMAL RETURN N
   204		037140	000003		OPDEF	TTIOCT	[37B8!3B12!3]	;TTY, INPUT OCTAL WORD
   205		037200	000003		OPDEF	TTIDEC	[37B8!4B12!3]	;TTY, INPUT DECIMAL WORD
   206		037240	000003		OPDEF	TTICNV	[37B8!5B12!3]	;TTY, INPUT CONVERTABLE WORD
   207		037300	000003		OPDEF	TTLOOK	[37B8!6B12!3]	;TTY, KEYBOARD CHECK
   208		037340	000003		OPDEF	TTALTM	[37B8!7B12!3]	;TTY, ALT-MODE CHECK
   209		037400	000003		OPDEF	TTSIXB	[37B8!10B12!3]	;TTY, INPUT SIXBIT WORD
   210		037440	000003		OPDEF	TTYINP	[37B8!11B12!3]	;TTY, IMAGE MODE INPUT
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 4
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0013

   211					;*TERMINAL OUTPUT UUO'S.
   212
   213		037000	000000		OPDEF	PNTA	[37B8!0B12!0]	;PRINT ASCII WORD
   214		037000	000001		OPDEF	PNTAF	[37B8!0B12!1]	;PRINT ASCII WORD FORCED
   215		037740	000000		OPDEF	PNTAL	[37B8!17B12!0]	;PRINT ASCIZ LINE
   216		037740	000001		OPDEF	PNTALF	[37B8!17B12!1]	;PRINT ASCIZ LINE FORCED
   217		037600	000003		OPDEF	PSIXL	[37B8!14B12!3]	;PRINT SIXBIT'Z LINE
   218		037640	000003		OPDEF	PSIXLF	[37B8!15B12!3]	;PRINT SIXBIT'Z LINE FORCED
   219		037000	000000		OPDEF	PNTMSG	[37B8!0B12!0]	;PRINT MESSAGE IMMEDIATE
   220		037040	000000		OPDEF	PNTMSF	[37B8!1B12!0]	;PRINT MESSAGE IMMEDIATE FORCED
   221		037100	000000		OPDEF	PSIXM	[37B8!2B12!0]	;PRINT SIXBIT'Z MSG IMMEDIATE
   222		037200	000000		OPDEF	PSIXMF	[37B8!4B12!0]	;PRINT SIXBIT'Z MSG IMM FORCED
   223		037000	000000		OPDEF	PNTCI	[37B8!0B12!0]	;PRINT CHARACTER IMMEDIATE
   224		037040	000000		OPDEF	PNTCIF	[37B8!1B12!0]	;PRINT CHARACTER IMMEDIATE FORCED
   225		037500	000000		OPDEF	PNTCHR	[37B8!12B12!0]	;PRINT CHARACTER
   226		037500	000001		OPDEF	PNTCHF	[37B8!12B12!1]	;PRINT CHARACTER FORCED
   227		037040	000000		OPDEF	PNT1	[37B8!1B12!0]	;PRINT ONE OCTAL DIGIT
   228		037040	000001		OPDEF	PNT1F	[37B8!1B12!1]	;PRINT 1 OCTAL DIGIT FORCED
   229		037100	000000		OPDEF	PNT2	[37B8!2B12!0]	;PRINT TWO OCTAL DIGITS
   230		037100	000001		OPDEF	PNT2F	[37B8!2B12!1]	;PRINT 2 OCTAL DIGITS FORCED
   231		037140	000000		OPDEF	PNT3	[37B8!3B12!0]	;PRINT THREE OCTAL DIGITS
   232		037140	000001		OPDEF	PNT3F	[37B8!3B12!1]	;PRINT THREE OCTAL DIGITS FORCED
   233		037200	000000		OPDEF	PNT4	[37B8!4B12!0]	;PRINT FOUR OCTAL DIGITS
   234		037200	000001		OPDEF	PNT4F	[37B8!4B12!1]	;PRINT FOUR OCTAL DIGITS FORCED
   235		037240	000000		OPDEF	PNT5	[37B8!5B12!0]	;PRINT FIVE OCTAL DIGITS
   236		037240	000001		OPDEF	PNT5F	[37B8!5B12!1]	;PRINT FIVE OCTAL DIGITS FORCED
   237		037300	000000		OPDEF	PNT6	[37B8!6B12!0]	;PRINT SIX OCTAL DIGITS
   238		037300	000001		OPDEF	PNT6F	[37B8!6B12!1]	;PRINT SIX OCTAL DIGITS FORCED
   239		037340	000000		OPDEF	PNT7	[37B8!7B12!0]	;PRINT 7 OCTAL DIGITS
   240		037340	000001		OPDEF	PNT7F	[37B8!7B12!1]	;PRINT 7 OCTAL DIGITS FORCED
   241		037440	000000		OPDEF	PNT11	[37B8!11B12!0]	;PRINT 11 OCTAL DIGITS
   242		037440	000001		OPDEF	PNT11F	[37B8!11B12!1]	;PRINT 11 OCTAL DIGITS FORCED.
   243		037400	000000		OPDEF	PNTADR	[37B8!10B12!0]	;PRINT PHYSICAL ADDRESS
   244		037400	000001		OPDEF	PNTADF	[37B8!10B12!1]	;PRINT PHYSICAL ADDRESS FORCED
   245		037600	000000		OPDEF	PNTOCT  [37B8!14B12!0]	;PRINT FULL WORD OCTAL
   246		037600	000001		OPDEF	PNTOTF	[37B8!14B12!1]	;PRINT FULL WORD OCTAL FORCED
   247		037540	000000		OPDEF	PNTHW	[37B8!13B12!0]	;PRINT OCTAL HALF WORDS, 6 SP 6
   248		037540	000001		OPDEF	PNTHWF	[37B8!13B12!1]	;PRINT OCTAL HALF WORDS, 6 SP 6 FORCED
   249		037700	000003		OPDEF	PNTOCS	[37B8!16B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S
   250		037740	000003		OPDEF	PNTOCF	[37B8!17B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S FORCED
   251		037640	000000		OPDEF	PNTDEC	[37B8!15B12!0]	;PRINT DECIMAL, SUPRESS LEADING 0'S
   252		037640	000001		OPDEF	PNTDCF	[37B8!15B12!1]	;PRINT DECIMAL, SUPRESS LEADING 0'S FORCED
   253		037700	000000		OPDEF	PNTDS	[37B8!16B12!0]	;PRINT DECIMAL, SPACES FOR LD 0'S
   254		037700	000001		OPDEF	PNTDSF	[37B8!16B12!1]	;PRINT DECIMAL, SPACES FOR LD 0'S FORCED
   255		037200	000002		OPDEF	PNTNM	[37B8!4B12!2]	;PRINT PROGRAM NAME
   256		037000	000002		OPDEF	PNTSIX	[37B8!0B12!2]	;PRINT SIXBIT WORD
   257		037040	000002		OPDEF	PNTSXF	[37B8!1B12!2]	;PRINT SIXBIT WORD FORCED
   258		037240	000002		OPDEF	DROPDV	[37B8!5B12!2]	;CLOSE LOGICAL FILE, USER MODE
   259		037100	000002		OPDEF	PNTCW	[37B8!2B12!2]	;PRINT DF10 CONTROL WORD
   260		037140	000002		OPDEF	PNTCWF	[37B8!3B12!2]	;PRINT DF10 CONTROL WORD FORCED
   261		037000	030242		OPDEF	PCRL	[37B8!0B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED
   262		037040	030242		OPDEF	PCRLF	[37B8!1B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED FORCED
   263		037000	000040		OPDEF	PSP	[37B8!0B12!40]	;PRINT SPACE
   264		037040	000040		OPDEF	PSPF	[37B8!1B12!40]	;PRINT SPACE FORCED
   265		037000	030243		OPDEF	PCRL2	[37B8!0B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE)
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 4-1
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0014

   266		037040	030243		OPDEF	PCRL2F	[37B8!1B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE) FORCED
   267		037040	000007		OPDEF	PBELL	[37B8!1B12!7]	;PRINT TTY BELL
   268
   269		037040	000026		OPDEF	PFORCE	[37B8!1B12!26]	;PRINT FORCE, CONTROL O OVERRIDE
   270
   271					DEFINE	PMSG	(ARG),<
   272						PSIXM	[SIXBIT\ARG'_\]>
   273
   274					DEFINE	PMSGF	(ARG),<
   275						PSIXMF	[SIXBIT\ARG'_\]>
   276
   277					;*SIXBTZ -- MACRO TO GENERATE SIXBIT DATA FOR PRINTING
   278					;*	CONSERVES CORE OVER ASCIZ
   279
   280					DEFINE	SIXBTZ	(ARG),<	[SIXBIT\ARG'_\]>
   281
   282					;*CONSOLE SWITCH INPUT UUO.
   283					;*READS CONSOLE SWITCHES IF IN EXEC MODE OR ASKS FOR THEM IF
   284					;* USER MODE.
   285
   286		037400	000002		OPDEF	SWITCH	[37B8!10B12!2]	;INPUT CONSOLE SWITCHES
   287
   288					;*CLOCK INITIALIZATION UUO - TO SET DESIRED CLOCK OPERATION
   289					;*EITHER IGNORE CLOCK, ONLY LET IT TICK OR CAUSE INTERRUPT TO OCCUR.
   290
   291		037540	000004		OPDEF	CLOKOP	[37B8!13B12!4]	;CLOCK OPERATION UUO - PDP-11 CLOCK
   292		037200	000004		OPDEF	MTROP	[37B8!4B12!4]	;CLOCK OPERATION UUO - DK20 METER
   293
   294					;*KL10 ONLY CACHE OPERATION UUO'S
   295
   296		037040	000004		OPDEF	CINVAL	[37B8!1B12!4]	;CACHE INVALIDATE
   297		037100	000004		OPDEF	CFLUSH	[37B8!2B12!4]	;CACHE FLUSH
   298		037140	000004		OPDEF	CWRTBI	[37B8!3B12!4]	;CACHE WRITE-BACK & INVALIDATE
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 5
PARAM	KLM	18-JAN-77 11:38		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, JAN 18,1977                                 SEQ 0015

   299					;*END OF PASS/PROGRAM UUOS
   300
   301					;PERFORMS THE END OF PASS FUNCTIONS. INCREMENT PASS COUNT,
   302					;*DECREMENT ITERATION COUNT, CHECK IF FINISHED WITH THIS PROGRAM ETC.
   303
   304		037500	000004		OPDEF	ENDUUO	[37B8!12B12!4]	;UUO TO DISPLAY LIGHTS
   305		037700	000004		OPDEF	EOPUUO	[37B8!16B12!4]	;END OF PROGRAM UUO
   306
   307					;*MEMORY MANAGEMENT UUO'S
   308					;*UUO'S TO PERFORM VARIOUS MEMORY FUNCTIONS. MAPPING, ZEROING, PAGING,
   309					;*ADDRESS CONVERSION, ETC...
   310
   311		037000	000004		OPDEF	MAPMEM	[37B8!0B12!4]	;MAP MEMORY
   312		037500	000002		OPDEF	MEMZRO	[37B8!12B12!2]	;ZERO MEMORY
   313		037440	000002		OPDEF	MEMSEG	[37B8!11B12!2]	;SETUP MEMORY SEGMENT
   314		037540	000002		OPDEF	MAPADR	[37B8!13B12!2]	;VIRTUAL TO PHYSICAL ADR CONVERT
   315		037640	000002		OPDEF	MAPCNK	[37B8!15B12!2]	;MAP MEMORY CHUNK
   316		037600	000002		OPDEF	MAPSET	[37B8!14B12!2]	;SET KI10 EXEC PAGE MAP
   317		037740	000002		OPDEF	MAPPNT	[37B8!17B12!2]	;PRINT MEMORY MAP
   318
   319					;*DEVICE CODE MODIFICATION UUO
   320					;*ALLOWS THE MODIFICATION OF IOT'S TO ONE DEVICE TO BE CHANGED TO
   321					;*IOT'S TO A DIFFERENT DEVICE CODE.
   322
   323		037340	000002		OPDEF	MODPCU	[37B8!7B12!2]	;MODIFY PERHIPERAL CODE, USER
   324		037300	000002		OPDEF	MODPCP	[37B8!6B12!2]	;MODIFY PERHIPERAL CODE, PROGRAM
   325
   326			030000			IFNDEF	MODDVL,<MODDVL==BEGIN>
   327			030000			IFNDEF	MODDVU,<MODDVU==BEGIN>
   328
   329					;*"DIAMON" FILE SELECTION AND READ UUOS
   330
   331		037240	000004		OPDEF	FSELECT	[37B8!5B12!4]	;FILE SELECTION
   332		037300	000004		OPDEF	FREAD	[37B8!6B12!4]	;FILE READ - ASCII DATA
   333		037340	000004		OPDEF	FRD36	[37B8!7B12!4]	;FILE READ - 36 BIT DATA
   334		037400	000004		OPDEF	FRD8	[37B8!10B12!4]	;FILE READ - 8 BIT DATA
   335
   336					;*KI10 ONLY UUO FOR PRINTING MARGIN VALUES
   337
   338		037700	000002		OPDEF	PNTMGN	[37B8!16B12!2]	;PRINT MARGIN VALUE
   339
   340						XLIST
   341					IFNDEF	KLOLD,<LIST
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 6
PARAM	KLM	18-JAN-77 11:38		ERROR HANDLING UUO DEFINITIONS, JAN 18,1977                                        SEQ 0016

   342					SUBTTL	ERROR HANDLING UUO DEFINITIONS, JAN 18,1977
   343
   344					S^;*********************************************************************^
   345					;*ERROR HANDLER PARAMETERS
   346					S^;*********************************************************************^
   347
   348		036000	000000		OPDEF	ERUUO	[36B8]		;ERROR CALL UUO
   349		035000	000000		OPDEF	ERLOOP	[35B8]		;ERROR LOOP, CHECKS PC,REPT,REPT1,ERROR
   350		035040	000000		OPDEF	ERLP1	[35B8!1B12]	;ERROR LOOP IF PC'S MATCH
   351		035100	000000		OPDEF	ERLP2	[35B8!2B12]	;ERROR LOOP IF ANY ERROR
   352		034000	000000		OPDEF	REPTUO	[34B8]		;REPEAT LOOP UUO
   353
   354					;*THE ERROR HANDLER MACROS
   355
   356					;*A MACRO TO REPORT AN ERROR AND LOOP
   357
   358						DEFINE	ERROR	(ADR,FORMAT,CORECT,ACTUAL,F,D,ERR)<
   359						SALL
   360						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   361							   CORECT,,ACTUAL
   362							   [SIXBIT\D'_\],,ERR]
   363						XALL
   364
   365						ERLOOP	ADR		;IF ERROR, LOOP TO ADR
   366					>
   367
   368					;*A MACRO TO REPORT AN ERROR AND NOT LOOP
   369
   370						DEFINE	ERROR1	(FORMAT,CORECT,ACTUAL,F,D,ERR)<
   371						SALL
   372						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   373							   CORECT,,ACTUAL
   374							   [SIXBIT\D'_\],,ERR]
   375						XALL	>
   376
   377					>;END OF KLOLD CONDITIONAL
   378
   379						XLIST
   380						LIST
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 1
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0017

   381					SUBTTL	*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977
   382
   383	030000					LOC	30000
   384
   385					S^;*********************************************************************^
   386					;*PROGRAM STARTING ADDRESSES
   387					;*THESE ADDRESSES CALL VARIOUS SPECIAL START ROUTINES AND OR OPTIONS
   388					;*NORMAL START ADDRESS IS 30000 ALL OTHERS ARE SPECIAL. INVOKED BECAUSE
   389					;*OF END OF PASS, POWER FAILURE, DDT START, RE-ENTERING(TYPICALLY USER
   390					;*MODE), OR ANY NUMBER OF SPECIAL FEATURE TESTS.
   391					S^;*********************************************************************^
   392
   393	030000	254 00 1 00 027776 	BEGIN:	JRST	@MODLNK		;STAND-ALONE START
   394	030001	254 00 0 00 030712 	$START:	JRST	START		;MODE CHECK STARTING ADDRESS
   395
   396	030002	254 00 1 00 027774 	DIAGMN:	JRST	@LDLNK		;DIAGNOSTIC MONITOR START
   397
   398	030003	254 00 1 00 027774 	SYSEXR:	JRST	@LDLNK		;SYSTEM EXERCISER START
   399
   400	030004	254 00 0 00 030712 	SFSTRT:	JRST	SADR1		;SPECIAL FEATURE START
   401
   402	030005	254 00 0 00 030712 	PFSTRT:	JRST	SADR2		;POWER FAIL RESTART
   403
   404	030006	254 00 0 00 030712 	REENTR:	JRST	SADR3		;REENTER START(USUALLY USER MODE ONLY)
   405
   406	030007				SRTDDT:				;COMMONLY MISTAKEN NAME FOR "DDTSRT"
   407	030007	254 00 1 00 027775 	DDTSRT:	JRST	@DDTLNK		;DDT START
   408
   409	030010	254 00 0 00 030741 	BEGIN1:	JRST	STARTA		;LOOP START(END OF PASS COMES HERE)
   410	030011	254 00 1 00 027777 	SBINIT:	JRST	@SUBLNK		;PMGINT LINKAGE
   411	030012	000000	000000		RETURN:	0			;RETURN ADDRESS STORAGE
   412
   413	030013	254000	030712		START1:	SADR7			;OPTIONAL STARTING ADR/INSTRUCTIONS
   414	030014	254000	030712		START2:	SADR8			; "
   415	030015	254000	030712		START3:	SADR9			; "
   416	030016	254000	030712		START4:	SADR10			; "
   417	030017	254000	030712		START5:	SADR11			; "
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 2
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0018

   418					S^;*********************************************************************^
   419					;*PROGRAM FIXED PARAMETER AREA
   420					S^;*********************************************************************^
   421
   422	030020	444153	414700		PNTNAM:	PAREA3		;SIXBIT PROGRAM NAME
   423	030021	645560	000000		PNTEXT:	PAREA4		;SIXBIT PROGRAM EXTENSION
   424	030022	000000	000000		RANDBS:	PAREA1		;RANDOM BASE NUMBER
   425	030023	000000	000000		SWTEXR:	PAREA2		;SYSTEM EXERCISER SWITCHES
   426	030024	000000	001000		ITRCNT:	ITERAT		;PROGRAM ITERATIONS
   427	030025	000000	030725		$PNAME:	PGMNAM		;POINTER TO PROGRAMS NAME
   428	030026	000000	000002		$PVER:	MCNVER,,DECVER	;MCN & DEC VERSION LEVEL
   429	030027	000000	030000		$MODVL:	MODDVL		;DEVICE CODE CHANGE LOWER LIMIT
   430	030030	000000	030000		$MODVU:	MODDVU		;DEVICE CODE CHANGE UPPER LIMIT
   431	030031	777777	777777		$EMODE:	IFNDEF EXCASB,<0> IFDEF EXCASB,<-1>	;EXEC ALLOWED
   432	030032	777777	777777		$UMODE:	IFNDEF USRASB,<0> IFDEF USRASB,<-1>	;USER ALLOWED
   433	030033	000000	000000		$DSKUP:	IFNDEF DSKUPD,<0> IFDEF DSKUPD,<-1>	;DISK UPDATE MODE
   434	030034	000000	000000		$MMAP:	IFNDEF MEMMAP,<0> IFDEF MEMMAP,<-1>	;ALLOW MEMORY RTNS
   435	030035	000000	000000		PAREA7:	PAREA5		;OPTIONAL PARAMETER
   436	030036	000000	000000		PAREA8:	PAREA6		;OPTIONAL PARAMETER
   437
   438					S^;*********************************************************************^
   439					;*PROGRAM VARIABLE PARAMETER AREA
   440					S^;*********************************************************************^
   441
   442	030037	000000	000000		USER:	0		; 0 = EXEC, -1 = USER MODE FLAG
   443	030040	000000	000000		KAIFLG:	0		;PROCESSOR TYPE, 0 = KA10, -1 = KI10
   444	030041	000000	000000		KLFLG:	0		;PROCESSOR TYPE, 0 = KA/KI, -1 = KL10
   445	030042	777777	777777		MONFLG:	-1		;DIAG MONITOR SPECIAL USER FLAG
   446	030043	000000	000000		MONCTL:	0		;DIAG MON/SYS EXR FLAG
   447	030044	000000	000000		MONTEN:	0		;-1= LOADED BY 10
   448	030045	000000	000000		CLOCKF:	0		;CLOCK TICKED FLAG
   449	030046	000000	000000		CONSW:	0		;CONSOLE SWITCH SETTINGS
   450	030047	000000	000000		PASCNT:	0		;PROGRAM PASS COUNT
   451	030050	000000	000000		RUNFLG:	0		;PROGRAM RUN FLAG
   452	030051	000000	000000		TESTPC:	0		;SUBTEST PC
   453	030052	000000	000000		ERRPC:	0		;ERROR PC
   454	030053	000000	000000		ERRTLS:	0		;ERROR TOTALS
   455	030054	000000	000000		TICKS:	0		;PROGRAM RUNNING TIME
   456	030055	000000	000000		MARGIN:	0		;KI10 MARGIN WORD VALUE
   457	030056	000000	000000		$ONETM:	0		;SUBROUTINE INITIALIZATION FLAG
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 3
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0019

   458					S^;*********************************************************************^
   459					;*SPECIAL PROGRAM DISPATCH ADDRESSES
   460					S^;*********************************************************************^
   461
   462	030057	037 12 0 00 000004 	BEGEND:	ENDUUO		;END OF PASS
   463	030060	254 00 0 00 030010 	$BEND1:	JRST	BEGIN1	;KEEP RUNNING PROGRAM
   464	030061	037 16 0 00 000004 	$BEND2:	EOPUUO		;END OF PROGRAM - NO RETURN
   465	030062	254000	030712		CNTLC:	SADR5		;CONTROL C XFER ADDRESS
   466	030063	254000	030712		ALTMGO:	SADR6		;ALTMODE XFER ADDRESS
   467	030064				CPOPJ1:			;SKIP RETURN
   468	030064	350 00 0 17 000000 	UUOSKP:	AOS	(P)	;SKIP RETURN FROM UUO
   469	030065				CPOPJ:			;NON-SKIP REGULAR RETURN
   470	030065	263 17 0 00 000000 	UUOEXT:	RTN		;UUO RETURN
   471	030066	255 00 0 00 000000 	UUORTN:	JFCL		;ADDITIONAL USERS UUO ROUTINE
   472	030067	255 00 0 00 000000 	$UORTX:	JFCL		;ADDITIONAL UUO LINKAGE
   473	030070	255 00 0 00 000000 	$UUOER:	JFCL		;INITED AS (JRST $UOERX)
   474	030071	255 00 0 00 000000 	$ITRHL:	JFCL		;ADDITIONAL INTERRUPT LINKAGE
   475	030072	255 00 0 00 000000 	$ITRX1:	JFCL		; "
   476	030073	255 00 0 00 000000 	$USRHL:	JFCL		; "
   477	030074	255 00 0 00 000000 	$RSRTX:	JFCL		;ADDITIONAL POWER FAIL LINKAGE
   478	030075	255 00 0 00 000000 	$RSRTY:	JFCL		; "
   479	030076	255 00 0 00 000000 	RESRT1:	JFCL		; INITED AS (JRST RESRTX)
   480	030077	255 00 0 00 000000 	RESRT2:	JFCL		; "
   481	030100	255 00 0 00 000000 	$PARER:	JFCL		;ADDITIONAL PARITY ERROR LINKAGE
   482	030101	255 00 0 00 000000 	ERMORE:	JFCL		;ADDITIONAL ERROR HANDLER LINKAGE
   483	030102	254 04 0 00 030102 		HALT	.	;IMPROPER TRANSFER HALT
   484
   485	030103	000000	000000		$PSHER:	0		;INITED AS (JRST PSHERR)
   486	030104	000000	000000		ITRCH1:	0		;PC & FLAGS OF CURRENT INTERRUPT
   487	030105	000000	000000			0		;INITED AS (JRST $ITRC1)
   488
   489					S^;*********************************************************************^
   490					;*PROCESSOR CONTROL STORAGE
   491					S^;*********************************************************************^
   492
   493	030106	000000	000000		$ACC0:	0		;INTERRUPT SAVED AC0
   494	030107	000000	000000		$SVPI:	0		;INTERRUPT SAVED PI
   495	030110	000000	000000		$SVAPR:	0		;INTERRUPT SAVED APR
   496	030111	000000	000000		$SVPAG:	0		;INTERRUPT SAVED PAG (DATAI)
   497	030112	000000	000000		$SPAG1:	0		;INTERRUPT SAVED PAG (CONI)
   498
   499	030113	000000	000000		$SVUUO:	0		;CURRENT USERS UUO
   500	030114	000000	000000		$SVUPC:	0		;PC OF CURRENT USERS UUO
   501
   502	030115	000000	000000		REPTU:	0		;REPEAT UUO ITERATIONS
   503	030116	000000	000000		SCOPE:	0		;ERROR HANDLER SCOPE LOOP FLAG
   504	030117	000000	000000		%CORFLG:0		; " CORRECT FLAG
   505	030120	000000	000000		%COREC:	0		; " CORRECT DATA
   506	030121	000000	000000		%ACTFL:	0		; " ACTUAL FLAG
   507	030122	000000	000000		%ACTUL:	0		; " ACTUAL DATA
   508	030123	000000	000000		%DISCR:	0		; " DISCREPENCY DATA
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 4
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0020

   509					S^;*********************************************************************^
   510					;*UUO DISPATCH TABLE
   511					S^;*********************************************************************^
   512						XLIST
   513						LIST
   514	030124	030070	030070		UUODIS:	LUUO1,,$UUOER
   515	030125	030070	030070			LUUO3,,LUUO2
   516	030126	030070	030070			LUUO5,,LUUO4
   517	030127	030070	030070			LUUO7,,LUUO6
   518	030130	030070	030070			LUUO11,,LUUO10
   519	030131	030070	030070			LUUO13,,LUUO12
   520	030132	030070	030070			LUUO15,,LUUO14
   521	030133	030070	030070			LUUO17,,LUUO16
   522	030134	030070	030070			LUUO21,,LUUO20
   523	030135	030070	030070			LUUO23,,LUUO22
   524	030136	030070	030070			LUUO25,,LUUO24
   525	030137	030070	030070			LUUO27,,LUUO26
   526	030140	030070	030070			LUUO31,,LUUO30
   527	030141	030070	030070			LUUO33,,LUUO32
   528
   529					S^;*********************************************************************^
   530					;*MEMORY MANAGMENT STORAGE
   531					S^;*********************************************************************^
   532
   533	030142	000000	000000		DF22F:	0		;DF10 CONTROL FLAG, 0 = 18, -1 = 22 BIT
   534	030143	000000	000000		MAPNEW:	0		;MEMORY MAPPING CONTROL FLAG, -1 = 4096K MAPPING
   535	030144	000000	000000		MEMTOT:	0		;TOTAL MEMORY SIZE IN K (1024.)
   536	030145	000000	000000		MEMLOW:	0		;LOWEST USABLE MEMORY
   537	030146				MEMSIZ:	BLOCK ^D41	;MEMORY SEGMENT POINTER TABLE
   538
   539					S^;*********************************************************************^
   540					;*PRINT CONTROL STORAGE
   541					S^;*********************************************************************^
   542
   543	030217	000000	000000		PNTFLG:	0		;PRINT FLAG, -1 WHILE IN PRINT ROUTINE
   544	030220	000000	000000		PNTENB:	0		;PRINT ENABLE
   545	030221	000000	000000		PDISF:	0		;PRINT DISABLED FLAG
   546	030222	000000	000000		PNTINH:	0		;INHIBIT PRINT INPUT CHECKS
   547	030223	000000	000000		PNTSPC:	0		;PRINT SPACE CONTROL
   548	030224	000000	000000		OPTIME:	0		;TYPE-IN WAIT TIME
   549	030225	000000	000000		$TWCNT:	0		;TIME WAITED
   550	030226	000000	000000		$DVOFF:	0		;LOGICAL DEVICE INITED FLAG
   551	030227	000000	000000		TTYFIL:	0		;TTY EXEC FILLERS FLAG
   552	030230	000000	000000		TTYSPD:	0		;TTY EXEC BAUD RATE
   553	030231	000000	000000		$TTCHR:	0		;ACTUAL TYPED IN CHAR
   554	030232	000000	000000		$CHRIN:	0		;UPPER CASED & PARITY STRIPPED CHAR
   555	030233	000000	000000		$TYPNB:	0		;TYPED IN NUMBER
   556	030234	000000	000000		$CRLF:	0		;FREE CR/LF FLAG
   557	030235	000000	000000		$TABF:	0		;TAB CONVERSION FLAG
   558	030236	000000	000000		$FFF:	0		;FORM FEED CONVERSION FLAG
   559	030237	000000	000000		$VTF:	0		;VERTICAL TAB CONVERSION FLAG
   560	030240	000000	000000		USRLFF:	0		;USER LF FILLERS
   561	030241	000000	000000		USRCRF:	0		;USER CR FILLERS
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 5
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0021

   562					S^;*********************************************************************^
   563					;*THE FOLLOWING MISCELLANEOUS PRINT CHARACTERS ARE INCLUDED
   564					;*TO FACILITATE PRINTING AND ARE CALLED AS FOLLOWS:
   565					;*	MOVEI	NAME
   566					;*	PNTA		;OR PNTAF
   567					S^;*********************************************************************^
   568
   569	030242				CRLF:	ASCII/
   570	030242	015 012 000 000 000 	/
   571	030243				CRLF2:	ASCII/
   572
   573	030243	015 012 015 012 000 	/
   574	030244	054 000 000 000 000 	COMMA:	ASCII/,/
   575	030245	056 000 000 000 000 	PERIOD:	ASCII/./
   576	030246	040 000 000 000 000 	SPACE:	ASCII/ /
   577	030247	011 000 000 000 000 	TAB:	ASCII/	/
   578	030250				MINUS:
   579	030250	055 000 000 000 000 	HYPEN:	ASCII/-/
   580	030251	053 000 000 000 000 	PLUS:	ASCII/+/
   581	030252	052 000 000 000 000 	AST:	ASCII/*/
   582	030253	100 000 000 000 000 	ATSIN:	ASCII/@/
   583	030254	050 000 000 000 000 	LFP:	ASCII/(/
   584	030255	051 000 000 000 000 	RTP:	ASCII/)/
   585	030256	007 0000000000 		BELL:	BYTE (7) 007
   586	030257	077 000 000 000 000 	QUEST:	ASCII/?/
   587	030260	057 000 000 000 000 	SLASH:	ASCII!/!
   588	030261	044 000 000 000 000 	DOLLAR:	ASCII/$/
   589	030262	000000	000012		RADIX:	^D10			;DECIMAL PRINT RADIX
   590	030263	000000	000040		RADLSP:	40			;DECIMAL PRINT LEADING CHAR
   591	030264	000000	000012		RADLSC:	^D10			;DECIMAL PRINT LEADING CHAR COUNT
   592
   593					S^;*********************************************************************^
   594					;*USER MODE OUTPUT FILE INFORMATION
   595					S^;*********************************************************************^
   596
   597	030265				$OBUF:	BLOCK	3		;LOGICAL FILE OUTPUT BUFFER HEADER
   598	030270	60 62 51 56 64 00 	$OUTNM:	SIXBIT	/PRINT/		;FILE NAME
   599	030271	60 56 64 00 00 00 	$OUTEX:	SIXBIT	/PNT/		;FILE NAME EXTENSION
   600	030272					BLOCK	2
   601
   602					S^;*********************************************************************^
   603					;*DISK UPDATE MODE FILE INFORMATION
   604					S^;*********************************************************************^
   605
   606	030274				$IBUF:	BLOCK	3
   607	030277	60 62 51 56 64 00 	$INNM:	SIXBIT	/PRINT/
   608	030300	60 56 64 00 00 00 	$INEXT:	SIXBIT	/PNT/
   609	030301					BLOCK	2
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 6
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0022

   610					S^;*********************************************************************^
   611					;*PUSHDOWN LIST CONTROL INFORMATION
   612					S^;*********************************************************************^
   613
   614	030303	777577	030303		PLIST:	PLIST-PLISTE,,PLIST
   615	030304				PLISTS:	BLOCK	200
   616	030504	000000	000000		PLISTE:	0		;END OF PUSHDOWN LIST
   617
   618					S^;*********************************************************************^
   619					;*POWER LINE CLOCK FREQUENCY FLAG
   620					S^;*********************************************************************^
   621
   622	030505	000000	000000		CYCL60:	0	;0 = 60, -1 = 50 CYCLE
   623
   624					S^;*********************************************************************^
   625					;*KL10 CACHE CONTROL FLAGS
   626					S^;*********************************************************************^
   627
   628	030506	000000	000000		CSHFLG:	0	;ALLOW CACHE IF 0
   629	030507	000000	000000		CSHMEM:	0	;CACHE MEMORY SEGMENTS IF 0
   630
   631					S^;*********************************************************************^
   632					;*NUMBER INPUT DIGIT FLAG
   633					S^;*********************************************************************^
   634
   635	030510	000000	000000		TTNBRF:	0	;-1 IF ANY DIGIT TYPED
   636
   637					S^;*********************************************************************^
   638					;*KL10 & KI10 "INHPAG" SWITCH PAGING PREVENTION
   639					S^;*********************************************************************^
   640
   641	030511	000000	000000		PVPAGI:	0	;IF NON-ZERO, OVERRIDE "INHPAG" SWITCH ACTION
   642
   643					S^;*********************************************************************^
   644					;*ERROR REPORTING ROUTINE ADDITIONAL USERS CONTROL INSTRUCTIONS
   645					S^;*********************************************************************^
   646
   647	030512	000000	000000		%ERHI1:	0	;IF NON-ZERO, XCT'D AT START OF %ERUUO
   648	030513	000000	000000		%ERHI2:	0	;IF NON-ZERO, XCT'D AT END OF %ERUUO
   649	030514	000000	000000		%ERHI3:	0	;IF NON-ZERO, XCT'D AFTER "PC" OF %ERUUO
   650
   651					S^;*********************************************************************^
   652					;*SPECIAL USERS UUO INTERCEPT INSTRUCTION
   653					S^;*********************************************************************^
   654
   655	030515	000000	000000		$$UUO:	0	;IF NON-ZERO, XCT'D AT START OF $UORTN
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 7
FIXED	KLM	18-JAN-77 11:39		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, JAN 18,1977                            SEQ 0023

   656					S^;*********************************************************************^
   657					;*KL10 PROCESSOR TYPE FLAG, 0=P0, 1=BBD NEW, 2=BBD OLD
   658					S^;*********************************************************************^
   659
   660	030516	000000	000000		KLTYP:	0
   661
   662					S^;*********************************************************************^
   663					;*SPECIAL USERS MUUO INTERCEPT INSTRUCTION
   664					S^;*********************************************************************^
   665
   666	030517	000000	000000		$$MUUO:	0	;IF NON-ZERO, XCT'D AT START OF MUUOER
   667
   668					S^;*********************************************************************^
   669					;*SPECIAL USERS USER MODE OUTPUT ERROR INTERCEPT INSTUCTION
   670					S^;*********************************************************************^
   671
   672	030520	000000	000000		$$OUTER:0	;IF NON-ZERO, XCT'D AT END OF USER MODE ERROR
   673
   674					S^;*********************************************************************^
   675					;*"SWITCH" CALL USAGE CONTROL
   676					S^;*********************************************************************^
   677
   678	030521	000000	000000		$$TOGGLE:0	;IF NON-ZERO, USE C(CONSW) FOR SWITCHES
   679
   680					S^;*********************************************************************^
   681					;*SPECIAL USERS ALTMODE SWITCH CALL INTERCEPT INSTRUCTIONS
   682					S^;*********************************************************************^
   683
   684	030522	000000	000000		$$TAX1:	0	;IF NON-ZERO, XCT'D AT START OF ALTMODE SWITCH CALL
   685	030523	000000	000000		$$TAX2:	0	;IF NON-ZERO, XCT'D AT END OF ALTMODE SWITCH CALL
   686
   687					S^;*********************************************************************^
   688					;*SPECIAL FUTURE EXPANSION ROOM
   689					;*IF ANY FIXED AREA TAGS ARE ADDED, REDUCE THE SIZE OF
   690					;*THIS BLOCK STATEMENT ACCORDINGLY.  THIS MUST BE DONE
   691					;*SO THAT PREVIOUS FIXED ASSIGNMENTS DO NOT CHANGE.
   692					S^;*********************************************************************^
   693
   694	030524					BLOCK	53	;HOPEFULLY THIS IS ENOUGH FOREVER
   695
   696					S^;*********************************************************************^
   697					;*END OF FIXED STORAGE
   698					S^;*********************************************************************^
   699
   700			030577			$ENDFX=<PLISTE+100>&<777700>-1
   701	030577					LOC	$ENDFX
   702	030577	000000	000000		ENDFIX:	0		;END OF FIXED STORAGE
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 1
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0024

   703					SUBTTL	*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76
   704
   705					;NEW DEFINITIONS USED BY THE KL10 SUBROUTINE PACKAGE
   706
   707			000000		AC0=	0
   708			030000		DIAGNOS=30000		;PDP-10 DIAGNOSTIC START ADDRESS
   709			010000		DDT=	10000		;PDP-10 DDT START ADDRESS
   710			020000		DIAMON=	20000		;PDP-10 DIAMON LOADER START ADDRESS
   711			020000		DONG11=	1B22		;11 DOORBELL (FROM THE 10)
   712
   713					;DTE20 DEVICE CODES
   714
   715			000200		DTE==	200		;DTE0
   716			000204		DTE0==	204
   717			000204		DTE1==	204
   718			000210		DTE2==	210
   719			000214		DTE3==	214
   720
   721					;KL10 EPT COMMUNICATION AREA
   722
   723			000440		$STD=	440		;PDP-10 DIAGNOSTIC START ADDRESS
   724			000441		$DDT=	441		;PDP-10 DDT START ADDRESS
   725			000442		$STL=	442		;PDP-10 LOADER START ADDRESS
   726			000443		$STM=	443		;PDP-10 MONITOR START ADDRESS
   727
   728			000444		$DTFLG=	444		;DTE20 OPERATION COMPLETE FLAG
   729			000445		$DTCLK=	445		;DTE20 CLOCK INTERRUPT FLAG
   730			000446		$DTCI=	446		;DTE20 CLOCK INTERRUPT INSTRUCTION
   731			000447		$DTT11=	447		;DTE20 10 TO 11 ARGUMENT
   732			000450		$DTF11=	450		;DTE20 11 TO 10 ARGUMENT
   733			000451		$DTCMD=	451		;DTE20 TO 11 COMMAND WORD
   734			000452		$DTSEQ=	452		;DTE20 OPERATION SEQUENCE NUMBER
   735			000453		$DTOPR=	453		;DTE20 OPERATIONAL DTE #
   736			000454		$DTCHR=	454		;DTE20 LAST TYPED CHARACTER
   737			000455		$DTMTD=	455		;DTE20 MONITOR TTY OUTPUT COMPLETE FLAG
   738			000456		$DTMTI=	456		;DTE20 MONITOR TTY INPUT FLAG
   739
   740			000457		$DTSWR=	457		;DTE20 CONSOLE SWITCH REGISTER
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 2
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0025

   741					;SPECIAL "FIXED" REASSIGNMENTS
   742
   743			030600			$$LOC=.			;SAVE CURRENT LOCATION
   744
   745	030000					LOC	30000
   746	030000	254 00 0 00 030600 	$$BEGIN:JRST	$$START		;SETUP SPECIAL START
   747	030001	254 00 0 00 030600 		JRST	$$START		;"DIAMON" CHAIN START ADDRESS
   748
   749	000440					LOC	440
   750	000440	254 00 0 00 030000 	$STD:	JRST	BEGIN		;SETUP FOR "STD"
   751	000443					LOC	443
   752	000443	254 00 0 00 030636 	$STM:	JRST	$SPEC		;SIMPLE RUN CONTROL
   753
   754	030057					LOC	30057
   755	030057	254 00 0 00 030641 	$BEGEND:JRST	$SPBEND		;SETUP SPECIAL "BEGEND"
   756
   757					;SPECIAL MUUO, TRAP & PAGE FAIL SETUP
   758
   759	000420					LOC	420
   760	000420	254 04 0 00 000420 	$$420:	HALT	.		;KI10 PAGE FAIL
   761	000421	255 00 0 00 000000 	$$421:	JFCL			;OVERFLOW
   762	000422	254 04 0 00 000422 	$$422:	HALT	.		;PUSHDOWN OVERFLOW
   763	000423	254 04 0 00 000423 	$$423:	HALT	.		;TRAP 3
   764	000424	000000	000000		$$424:	0			;MMUO
   765	000425	000000	000000		$$425:	0			;MMUO PC
   766	000426	000000	000000		$$426:	0			;KI10-PAGE FAIL, KL10-PROCESS CONTEXT
   767	000427	254 04 0 00 000427 	$$427:	HALT	.
   768	000430	000000	000427		$$430:	427			;MMUO NEW PC'S
   769	000431	000000	000427		$$431:	427
   770	000432	000000	000427		$$432:	427
   771	000433	000000	000427		$$433:	427
   772	000434	000000	000427		$$434:	427
   773	000435	000000	000427		$$435:	427
   774	000436	000000	000427		$$436:	427
   775	000437	000000	000427		$$437:	427
   776
   777	000500					LOC	500
   778	000500	000000	000000		$$500:	0			;KL10 PAGE FAIL WORD
   779	000501	000000	000000		$$501:	0			;KL10 PAGE FAIL PC
   780	000502	000000	000503		$$502:	503			;KL10 PAGE FAIL NEW PC
   781	000503	254 04 0 00 000503 	$$503:	HALT	.
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 3
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0026

   782	030600					LOC	$$LOC		;RESET CURRENT LOCATION
   783
   784					;SPECIAL STARTUP SEQUENCE
   785
   786	030600	402 00 0 00 030037 	$$START:SETZM	USER
   787	030601	265 00 0 00 030602 		JSP	0,.+1		;IN USER MODE ?
   788	030602	603 00 0 00 010000 		TLNE	0,USERF
   789	030603	476 00 0 00 030037 		SETOM	USER		;YES, SET CONTROL WORD
   790	030604	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE ?
   791	030605	402 00 0 00 030037 		SETZM	USER		;YES, RUN AS EXEC
   792	030606	332 00 0 00 030037 		SKIPE	USER
   793	030607	254 00 0 00 030712 		JRST	START		;USER MODE, DON'T NEED CPU TYPE
   794
   795	030610	336 00 0 00 030044 	$STKIL:	SKIPN	MONTEN		;LOADED BY "DIAMON" ?
   796	030611	476 00 0 00 030024 		SETOM	ITRCNT		;NO, RUN FOREVER
   797	030612	402 00 0 00 030516 		SETZM	KLTYP
   798	030613	402 00 0 00 030041 		SETZM	KLFLG		;ASSUME KI10
   799	030614	200 01 0 00 032223 		MOVE	1,[1,,1]
   800	030615	251 01 0 00 000001 		BLT	1,1		;HOPE THIS WORKS
   801	030616	316 01 0 00 032223 		CAMN	1,[1,,1]	;IF AC NE 1,,1 AFTER BLT, KL10
   802	030617	254 00 0 00 030712 		JRST	START		;KI10, NO ADDITIONAL SETUP
   803
   804	030620	7 000 20 0 00 010040 	$STKL:	CONO	APR,10040	;SET BBD NOT BIT
   805	030621	7 000 24 0 00 000000 		CONI	APR,0
   806	030622	7 000 20 0 00 020040 		CONO	APR,20040	;CLEAR BBD NOT BIT
   807	030623	606 00 0 00 000040 		TRNN	0,40		;IF SET, KL10
   808	030624	350 00 0 00 030516 		AOS	KLTYP		;IF NOT, BBD
   809	030625	402 00 0 00 000444 		SETZM	$DTFLG
   810	030626	402 00 0 00 000445 		SETZM	$DTCLK
   811	030627	200 00 0 00 000453 		MOVE	$DTOPR		;GET DTE #
   812	030630	436 00 0 00 030670 		ORM	$$DTE0		;INSERT IN DTE I/O INSTS
   813	030631	436 00 0 00 030672 		ORM	$$DTE1
   814	030632	436 00 0 00 030704 		ORM	$$DTE2
   815	030633	436 00 0 00 030706 		ORM	$$DTE3
   816	030634	476 00 0 00 030041 		SETOM	KLFLG		;SET KL10 CONTROL FLAG
   817	030635	254 00 0 00 030712 		JRST	START
   818
   819	030636	200 00 0 00 032224 	$SPEC:	MOVE	[JRST STARTA]	;SIMPLE RUN CONTROL
   820	030637	202 00 0 00 030643 		MOVEM	$SPB1
   821	030640	254 00 0 00 030712 		JRST	START
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 4
SPCCPU	KLM	26-FEB-76 05:50		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76                            SEQ 0027

   822					;SPECIAL "BEGEND" ROUTINE
   823
   824	030641	350 00 0 00 030047 	$SPBEND:AOS	PASCNT		;INCREMENT PASS COUNT
   825	030642	370 00 0 00 030024 		SOS	ITRCNT		;DECREMENT ITERATION COUNT
   826	030643	336 00 0 00 030037 	$SPB1:	SKIPN	USER
   827	030644	254 00 0 00 030652 		JRST	$SPBEX		;EXEC MODE
   828
   829	030645	332 00 0 00 030024 	$SPBUS:	SKIPE	ITRCNT		;USER MODE, COMPLETED ?
   830	030646	254 00 0 00 030741 		JRST	STARTA		;NO, KEEP RUNNING
   831	030647	336 00 0 00 030044 		SKIPN	MONTEN		;DONE, LOADED BY "DIAMON" ?
   832	030650	047 00 0 00 000012 		EXIT			;NO, RETURN TO MONITOR
   833	030651	254 00 1 00 030012 		JRST	@RETURN		;YES, RETURN TO "DIAMON"
   834
   835	030652	332 00 0 00 030041 	$SPBEX:	SKIPE	KLFLG
   836	030653	254 00 0 00 030660 		JRST	$SPBKL		;KL10 & EXEC
   837	030654	7 004 14 0 00 030024 		DATAO	PI,ITRCNT	;KI10 & EXEC, DISPLAY ITER COUNT
   838	030655	332 00 0 00 030024 		SKIPE	ITRCNT
   839	030656	254 00 0 00 030741 		JRST	STARTA		;NOT COMPLETED YET
   840	030657	254 00 1 00 030012 		JRST	@RETURN		;DONE
   841
   842	030660	336 00 0 00 030024 	$SPBKL:	SKIPN	ITRCNT
   843	030661	254 00 0 00 030676 		JRST	$SPKLD		;KL10, EXEC & COMPLETED
   844
   845	030662	335 00 0 00 030043 		SKIPGE	MONCTL
   846	030663	254 00 0 00 030741 		JRST	STARTA		;"DIAMON" CONTROL
   847	030664	201 00 0 00 000404 		MOVEI	0,404		;NOTIFY PDP-11 OF END OF PASS
   848	030665	202 00 0 00 000451 		MOVEM	0,$DTCMD
   849	030666	402 00 0 00 000444 		SETZM	$DTFLG
   850	030667	336 00 0 00 030516 		SKIPN	KLTYP
   851	030670	7 200 20 0 00 020000 	$$DTE0:	CONO	DTE,DONG11
   852	030671	332 00 0 00 030516 		SKIPE	KLTYP
   853	030672	7 200 20 0 00 010000 	$$DTE1:	CONO	DTE,10000
   854	030673	336 00 0 00 000444 		SKIPN	$DTFLG		;WAIT TILL 11 RESPONDS
   855	030674	254 00 0 00 030673 		JRST	.-1
   856	030675	254 00 0 00 030741 		JRST	STARTA		;KEEP RUNNING
   857
   858					;SPECIAL KL10 COMPLETED ROUTINE
   859
   860	030676	332 00 0 00 030044 	$SPKLD:	SKIPE	MONTEN
   861	030677	254 00 1 00 030012 		JRST	@RETURN		;LOADED BY "DIAMON"
   862
   863	030700	201 00 0 00 000403 		MOVEI	0,403		;NOTIFY PDP-11 OF COMPLETION
   864	030701	202 00 0 00 000451 		MOVEM	0,$DTCMD
   865	030702	402 00 0 00 000444 		SETZM	$DTFLG
   866	030703	336 00 0 00 030516 		SKIPN	KLTYP
   867	030704	7 200 20 0 00 020000 	$$DTE2:	CONO	DTE,DONG11
   868	030705	332 00 0 00 030516 		SKIPE	KLTYP
   869	030706	7 200 20 0 00 010000 	$$DTE3:	CONO	DTE,10000
   870	030707	336 00 0 00 000444 		SKIPN	$DTFLG		;SHOULD NEVER HAPPEN
   871	030710	254 00 0 00 030707 		JRST	.-1		;11 NEVER RETURNS ON END OF PROGRAM
   872	030711	254 04 0 00 030000 		HALT	BEGIN		;IF IT DOES, HALT.
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 1
DAKAGM	MAC	19-JAN-77 17:37		DIAGNOSTIC SECTION                                                                 SEQ 0028

   873					SUBTTL	DIAGNOSTIC SECTION
   874
   875	030712	402 00 0 00 030037 	START:	SETZM	USER#		;CLEAR USER CONTROL WORD
   876	030713	265 00 0 00 030714 		JSP	0,.+1		;GET FLAGS
   877	030714	603 00 0 00 010000 		TLNE	USERF		;IN USER MODE?
   878	030715	476 00 0 00 030037 		SETOM	USER		;YES, SET USER CONTROL WORD
   879	030716	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE?
   880	030717	402 00 0 00 030037 		SETZM	USER		;YES, CLEAR USER CONTROL WORD
   881	030720	336 00 0 00 030037 		SKIPN	USER
   882	030721	254 00 0 00 030741 		JRST	STARTA
   883	030722	331 00 0 00 030043 		SKIPL	MONCTL
   884	030723	051 03 0 00 030725 		TTCALL	3,PGMNAM	;MENTION OUR NAME
   885	030724	254 00 0 00 030741 		JRST	STARTA
   886
   887	030725				PGMNAM:	ASCIZ/
   888	030725	015 012 120 104 120 	PDP-10 KI10 BASIC INSTRUCTION DIAGNOSTIC (7) [DAKAG]
   889	030726	055 061 060 040 113
   890	030727	111 061 060 040 102
   891	030730	101 123 111 103 040
   892	030731	111 116 123 124 122
   893	030732	125 103 124 111 117
   894	030733	116 040 104 111 101
   895	030734	107 116 117 123 124
   896	030735	111 103 040 050 067
   897	030736	051 040 133 104 101
   898	030737	113 101 107 135 015
   899	030740	012 000 000 000 000 	/
   900
   901	030741	254 00 0 00 030742 	STARTA:	JRST	.+1
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 2
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSH INSTRUCTION                                                           SEQ 0029

   902					SUBTTL	TEST OF PUSH INSTRUCTION
   903
   904					;**********
   905
   906					;THIS TEST VERIFIES THAT PUSH DECODES CORRECTLY.
   907					;IF PUSH DECODES AS PUSHJ, THIS TEST FAILS.
   908
   909	030742	400 02 0 00 000000 	C27200:	SETZ	2,		;CLEAR AC
   910	030743	261 02 0 00 030745 		PUSH	2,.+2		;*PUSH SHOULD NOT JUMP
   911	030744	334 00 0 00 000000 		SKIPA			;PASS IF PUSH DID NOT JUMP
   912						STOP^
   913	030745	254 04 0 00 030746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   914	030746	324 00 0 00 030747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   915									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   916									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
   917									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
   918
   919					;**********
   920
   921					;THIS TEST VERIFIES THAT PUSH DOES NOT MODIFY C(E).
   922					;CLEAR E AND AC; THEN, EXECUTE PUSH.
   923					;CHECK E FOR ORIGINAL CONTENTS ,0.
   924					;PASS IF C(E)=0.
   925
   926	030747	403 00 0 00 000002 	C27300:	SETZB	2		;CLEAR AC,E
   927	030750	261 02 0 00 000000 		PUSH	2,		;*PUSH SHOULD NOT ALTER C(E)
   928	030751	332 00 0 00 000000 		SKIPE			;PASS IF C(E)=0,,0
   929						STOP^
   930	030752	254 04 0 00 030753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   931	030753	324 00 0 00 030754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   932									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   933									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
   934									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
   935
   936					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 3
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSH INSTRUCTION                                                           SEQ 0030

   937					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC.
   938					;FIRST THE AC IS CLEARED; THEN PUSH IS EXECUTED.
   939					;THE AC IS CHECKED FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
   940
   941	030754	400 02 0 00 000000 	C27400:	SETZ	2,		;CLEAR AC
   942	030755	261 02 0 00 030756 		PUSH	2,.+1		;*PUSH SHOULD ADD 1,,1 TO C(AC)
   943	030756	312 02 0 00 032223 		CAME	2,[XWD 1,1]	;PASS IF C(AC)=1,,1
   944						STOP^
   945	030757	254 04 0 00 030760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   946	030760	324 00 0 00 030761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   947									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   948									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
   949									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
   950
   951					;**********
   952
   953					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC BEFORE MODIFYING C(C(AC-RIGHT)).
   954					;FIRST, THE AC AND AC0 ARE ZEROED; THEN PUSH IS EXECUTED.
   955					;C(C(AC-RIGHT)) [BEFORE AC UPDATING] (AC0) IS CHECKED FOR THE INITIAL VALUE, 0.
   956					;IF C(AC0)=0, THIS TEST PASSES
   957
   958	030761	403 00 0 00 000002 	C27500:	SETZB	2		;CLEAR AC AND AC0
   959	030762	261 02 0 00 032225 		PUSH	2,[16541320]	;*PUSH SHOULD NOT MODIFY C(AC0)
   960	030763	332 00 0 00 000000 		SKIPE			;PASS IF C(AC0)=0
   961						STOP^
   962	030764	254 04 0 00 030765 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   963	030765	324 00 0 00 030766 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   964									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   965									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
   966									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
   967
   968					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 4
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSH INSTRUCTION                                                           SEQ 0031

   969					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC BEFORE MODIFYING C(C(AC-RIGHT)).
   970					;FIRST, THE AC AND AC0 ARE ZEROED; THEN PUSH IS EXECUTED.
   971					;C(C(AC-RIGHT)) [BEFORE AC UPDATING] (AC0) IS CHECKED FOR
   972					;IF C(AC0)IS NOT EQUAL TO E, THIS TEST PASSES
   973
   974	030766	403 01 0 00 000002 	C27600:	SETZB	1,2		;CLEAR AC AND AC0
   975	030767	261 02 0 00 030770 		PUSH	2,.+1		;*PUSH SHOULD NOT MODIFY C(AC0)
   976	030770	306 00 0 00 030770 		CAIN	.		;FAIL IF C(AC0)=E
   977						STOP^
   978	030771	254 04 0 00 030772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   979	030772	324 00 0 00 030773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   980									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   981									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
   982									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
   983
   984					;**********
   985
   986					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
   987					;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE, AC AND THE LOCATION SPECIFIED
   988					;BY UPDATING C(AC-RIGHT) ARE CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=-1,,-1.
   989					;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR -1,,-1, THE
   990					;ORIGINAL C(E).  IF C(C(AC-RIGHT))=-1,,-1, THIS TEST PASSES.
   991
   992	030773	403 01 0 00 000002 	C27700:	SETZB	1,2		;CLEAR AC, C(AC-RIGHT)
   993	030774	261 02 0 00 032226 		PUSH	2,[-1]		;*PUSH SHOULD PLACE -1,,-1 INTO AC1
   994	030775	312 01 0 00 032226 		CAME	1,[-1]		;PASS IF C(1)=-1,,-1
   995						STOP^
   996	030776	254 04 0 00 030777 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   997	030777	324 00 0 00 031000 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
   998									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
   999									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1000									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1001
  1002					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 5
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSH INSTRUCTION                                                           SEQ 0032

  1003					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
  1004					;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE, AC
  1005					;IS CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=0.
  1006					;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR 0, THE
  1007					;ORIGINAL C(E).  IF C(C(AC-RIGHT))=0, THIS TEST PASSES.
  1008
  1009	031000	402 00 0 00 000002 	C30000:	SETZM	2		;CLEAR AC
  1010	031001	261 02 0 00 032227 		PUSH	2,[0]		;*PUSH SHOULD PLACE 0 INTO AC1
  1011	031002	332 00 0 00 000001 		SKIPE	1		;PASS IF C(1)=0
  1012						STOP^
  1013	031003	254 04 0 00 031004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1014	031004	324 00 0 00 031005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1015									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1016									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1017									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1018
  1019					;**********
  1020
  1021					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
  1022					;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE,
  1023					;AC IS PRELOADED WITH 0,,-1, AND THE LOCATION SPECIFIED
  1024					;BY UPDATING C(AC-RIGHT) IS CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=-1,,-1.
  1025					;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR -1,,-1, THE
  1026					;ORIGINAL C(E).  IF C(C(AC-RIGHT))=-1,,-1, THIS TEST PASSES.
  1027
  1028	031005	201 02 0 00 777777 	C30100:	MOVEI	2,-1		;PRELOAD AC WITH 0,,-1
  1029	031006	400 00 0 00 000000 		SETZ			;CLEAR AC, C(AC-RIGHT)
  1030	031007	261 02 0 00 032226 		PUSH	2,[-1]		;*PUSH SHOULD PLACE -1,,-1 INTO AC0
  1031	031010	312 00 0 00 032226 		CAME	[-1]		;PASS IF C(0)=-1,,-1
  1032						STOP^
  1033	031011	254 04 0 00 031012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1034	031012	324 00 0 00 031013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1035									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1036									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1037									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1038
  1039					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 6
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSH INSTRUCTION                                                           SEQ 0033

  1040					;THIS TEST VERIFIES THAT THERE IS A CARRY FROM AC BIT 18 TO BIT 17 OF THE AC ON PUSH.
  1041					;THE AC IS PRELOADED WITH 0,,-1; THEN PUSH IS EXECUTED. PUSH SHOULD ADD ONE TO BOTH
  1042					;HALVES OF THE AC, GENERATING A CARRY FROM BIT 18 TO BIT 17. IF A CARRY WAS GENERATED,
  1043					;THIS TEST PASSES.
  1044
  1045	031013	201 02 0 00 777777 	C30101:	MOVEI	2,-1		;PRELOAD AC WITH 0,,-1
  1046	031014	261 02 0 00 000000 		PUSH	2,0		;*PUSH SHOULD GENERATE A CARRY FROM BIT 18 TO BIT 17
  1047	031015	312 02 0 00 032230 		CAME	2,[2,,0]	;PASS IF C(AC)=2,,0 (CARRY WAS GENERATED)
  1048						STOP^
  1049	031016	254 04 0 00 031017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1050	031017	324 00 0 00 031020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1051									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1052									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1053									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1054
  1055					;*************
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 7
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0034

  1056					SUBTTL	TEST OF PUSHJ INSTRUCTION
  1057
  1058					;**********
  1059
  1060					;THIS TEST VERIFIES THAT PUSHJ TRANSFERS CONTROL TO THE LOCATION ADDRESSED BY E.
  1061					;IF PUSHJ DOES NOT JUMP, THIS TEST FAILS
  1062
  1063	031020				C30200:	SFLAG	CRY0		^;SETS CRY0 FLAG
  1064
  1065	031020	205 01 0 00 200000 		MOVSI	1,CRY0
  1066	031021	255 17 0 00 031022 		JFCL	17,.+1		;RESET ALL FLAGS
  1067	031022	254 02 0 01 031023 		JRST	2,.+1(1)	;SET CRY0 FLAG
  1068	031023	400 00 0 00 000000 		SETZ			;CLEAR AC
  1069	031024	260 00 0 00 031026 		PUSHJ	.+2		;*PUSHJ SHOULD JUMP TO LOCATION E
  1070						STOP^
  1071	031025	254 04 0 00 031026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1072	031026	324 00 0 00 031027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1073									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1074									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1075									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1076
  1077					;**********
  1078
  1079					;THIS TEST VERIFIES THAT PUSHJ DOES NOT MODIFY C(PC) WHERE PC IS ONE GREATER
  1080					;THAN THE LOCATION OF THE PUSHJ INSTRUCTION.
  1081					;IF PUSHJ MODIFIES C(PC), THIS TEST FAILS
  1082
  1083	031027				C30300:	SFLAG	CRY0		^;SET CRY0
  1084
  1085	031027	205 01 0 00 200000 		MOVSI	1,CRY0
  1086	031030	255 17 0 00 031031 		JFCL	17,.+1		;RESET ALL FLAGS
  1087	031031	254 02 0 01 031032 		JRST	2,.+1(1)	;SET CRY0 FLAG
  1088	031032	403 01 0 00 031034 		SETZB	1,.+2		;CLEAR C(AC-RIGHT) AND C(PC)
  1089	031033	260 00 0 00 031036 		PUSHJ	.+3		;*PUSHJ SHOULD NOT MODIFY C(PC)
  1090	031034	000000	000000			0			;THIS LOCATION SHOULD NOT BE MODIFIED BY PUSHJ
  1091	031035	310 00 0 00 000000 		CAM			;PUSHJ SHOULD JUMP OVER THIS LOCATION
  1092	031036	332 00 0 00 031034 		SKIPE	.-2		;PASS IF PUSHJ DID NOT MODIFY C(PC)
  1093						STOP^
  1094	031037	254 04 0 00 031040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1095	031040	324 00 0 00 031041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1096									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1097									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1098									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1099
  1100					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 8
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0035

  1101					;THIS TEST VERIFIES THAT PUSHJ DOES NOT STORE IN E
  1102					;IF PUSHJ STORED IN E, THIS TEST FAILS
  1103
  1104	031041				C30400:	SFLAG	CRY0		^;SET CRY0
  1105
  1106	031041	205 01 0 00 200000 		MOVSI	1,CRY0
  1107	031042	255 17 0 00 031043 		JFCL	17,.+1		;RESET ALL FLAGS
  1108	031043	254 02 0 01 031044 		JRST	2,.+1(1)	;SET CRY0 FLAG
  1109	031044	403 00 0 00 000001 		SETZB	1		;CLEAR AC AND C(AC-RIGHT
  1110	031045	260 00 0 00 031046 		PUSHJ	.+1		;*PUSHJ SHOULD NOT STORE IN E
  1111	031046	200 02 0 00 031046 		MOVE	2,.		;SAVE C(E)
  1112	031047	312 02 0 00 031046 		CAME	2,.-1		;FAIL IF PUSHJ STORED IN E
  1113						STOP^
  1114	031050	254 04 0 00 031051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1115	031051	324 00 0 00 031052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1116									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1117									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1118									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1119
  1120					;**********
  1121
  1122					;THIS TEST VERIFIES THAT PUSHJ DOES NOT STORE IN LOC 0
  1123					;PUSHJ SHOULD STORE PC IN C(AC-RIGHT) - LOCATION 2.
  1124					;IF PUSHJ STORES IN LOCATION 0, THIS TEST FAILS
  1125
  1126	031052	201 02 0 00 000001 	C30500:	MOVEI	2,1		;PRELOAD AC WITH 0,,1
  1127	031053	400 00 0 00 000000 		SETZ	0		;CLEAR 0
  1128	031054	260 02 0 00 031055 		PUSHJ	2,.+1		;*PUSHJ SHOULD NOT STORE IN LOCATION 0
  1129	031055	332 00 0 00 000000 		SKIPE			;FAIL IF PUSHJ STORED IN LOCATION 0
  1130						STOP^
  1131	031056	254 04 0 00 031057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1132	031057	324 00 0 00 031060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1133									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1134									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1135									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1136
  1137					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 9
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0036

  1138					;THIS TEST VERIFIES THAT PUSHJ STORES THE PC IN THE LOCATION SPECIFIED
  1139					;BY C(AC-RIGHT) AFTER INCREMENTING AC.
  1140					;IN THIS TEST, AC AND C(AC-RIGHT) ARE CLEARED; THEN, PUSHJ IS EXECUTED.
  1141					;C(C(AC-RIGHT))IS THEN COMPARED TO ZERO.  IF C(C(AC-RIGHT)) IS NON-ZERO,
  1142					;A PC WAS STORED AND THIS TEST PASSES.
  1143
  1144	031060	403 00 0 00 000001 	C30600:	SETZB	1		;CLEAR AC, C(AC-RIGHT)
  1145	031061	260 00 0 00 031063 		PUSHJ	.+2		;*PUSHJ SHOULD STORE PC IN RIGHT HALF OF C(AC-RIGHT)
  1146	031062	254 04 0 00 031062 		HALT	.		;PUSHJ SHOULD JUMP OVER THIS INSTRUCTION
  1147	031063	405 01 0 00 777777 		ANDI	1,-1		;SAVE C(C(AC-RIGHT))
  1148	031064	306 01 0 00 031063 		CAIN	1,.-1		;FAIL IF PC WAS NOT STORED IN C(AC-RIGHT)
  1149						STOP^
  1150	031065	254 04 0 00 031066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1151	031066	324 00 0 00 031067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1152									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1153									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1154									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1155
  1156					;**********
  1157
  1158					;THIS TEST VERIFIES THAT PUSHJ ADDS 1,,1 TO THE AC
  1159					;THE AC IS CLEARED AND PUSHJ IS EXECUTED
  1160					;AC IS CHECKED FOR 1,,1 IF C(AC)=1,,1, THIS TEST PASSES
  1161
  1162	031067	400 00 0 00 000000 	C31000:	SETZ			;CLEAR AC
  1163	031070	260 00 0 00 031071 		PUSHJ	.+1		;*PUSHJ SHOULD PLACE 1,,1 INTO THE AC
  1164	031071	312 00 0 00 032223 		CAME	[1,,1]		;PASS IF C(AC)=1,,1
  1165						STOP^
  1166	031072	254 04 0 00 031073 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1167	031073	324 00 0 00 031074 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1168									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1169									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1170									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1171
  1172					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 10
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0037

  1173					;THIS TEST VERIFIES THAT PUSHJ STORES THE FLAGS IN LEFT HALF OF C(AC-RIGHT)
  1174					;FIRST, CRY0 IS SET AND AC AND C(AC-RIGHT) ARE CLEARED; THEN, PUSHJ IS EXECUTED.
  1175					;C(C(AC-RIGHT)) IS THEN CHECKED FOR CRY0.  IF CRY0 IS SET, THIS TEST PASSES.
  1176
  1177	031074				C31100:	SFLAG	CRY0		^;SET CRY0
  1178
  1179	031074	205 01 0 00 200000 		MOVSI	1,CRY0
  1180	031075	255 17 0 00 031076 		JFCL	17,.+1		;RESET ALL FLAGS
  1181	031076	254 02 0 01 031077 		JRST	2,.+1(1)	;SET CRY0 FLAG
  1182	031077	403 00 0 00 000001 		SETZB	1		;CLEAR AC AND C(AC-RIGHT)
  1183	031100	260 00 0 00 031101 		PUSHJ	.+1		;*PUSHJ SHOULD STORE FLAGS IN LEFT HALF OF C(AC-RIGHT)
  1184	031101	607 01 0 00 200000 		TLNN	1,CRY0		;PASS IF CRY0 STORED CORRECTLY
  1185						STOP^
  1186	031102	254 04 0 00 031103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1187	031103	324 00 0 00 031104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1188									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1189									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1190									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1191
  1192					;**********
  1193
  1194					;THIS TEST VERIFIES THAT PUSHJ ADDS 1,,1 TO THE AC
  1195					;THE AC IS PRELOADED WITH 0,,1 AND PUSHJ IS EXECUTED
  1196					;AC IS CHECKED FOR 1,,2 IF C(AC)=1,,2, THIS TEST PASSES
  1197
  1198	031104	201 01 0 00 000001 	C31400:	MOVEI	1,1		;PRELOAD AC WITH 0,,1
  1199	031105	260 01 0 00 031107 		PUSHJ	1,.+2		;*PUSHJ SHOULD PLACE 1,,2 INTO THE AC
  1200	031106	254 04 0 00 000000 		HALT			;PUSHJ SHOULD JUMP OVER THIS INSTRUCTION
  1201	031107	312 01 0 00 032231 		CAME	1,[XWD 1,2]	;PASS IF AC WAS INCREMENTED CORRECTLY
  1202						STOP^
  1203	031110	254 04 0 00 031111 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1204	031111	324 00 0 00 031112 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1205									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1206									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1207									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1208
  1209					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 11
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0038

  1210					;THIS TEST VERIFIES THAT PUSHJ STORES THE PC IN RIGHT HALF OF C(AC-RIGHT)
  1211					;THIS TEST PASSES IF THE PC WAS STORED CORRECTLY.
  1212
  1213	031112	201 01 0 00 000001 	C31500:	MOVEI	1,1		;PLACE 0,,1 INTO AC
  1214	031113	260 01 0 00 031115 		PUSHJ	1,.+2		;*PUSHJ SHOULD STORE .+1 INTO RIGHT HALF OF C(AC-RIGHT)
  1215	031114	254 04 0 00 000000 		HALT			;PUSHJ SHOULD JUMP OVER THIS PC
  1216	031115	405 02 0 00 777777 		ANDI	2,-1		;SAVE RIGHT HALF OF C(AC-RIGHT)
  1217	031116	302 02 0 00 031114 		CAIE	2,.-2		;PASS IF PC STORED CORRECTLY
  1218						STOP^
  1219	031117	254 04 0 00 031120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1220	031120	324 00 0 00 031121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1221									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1222									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1223									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1224
  1225					;**********
  1226
  1227					;THIS TEST VERIFIES THAT PUSHJ ALWAYS RESETS BIS.
  1228					;FIRST BIS IS SET; THEN PUSHJ IS EXECUTED.  THE FLAGS ARE
  1229					;THEN SAVED AND CHECKED.  IF BIS WAS RESET VIA PUSHJ, THIS TEST PASSES.
  1230
  1231	031121				C31501:	SFLAG	BIS		^;SET BIS
  1232
  1233	031121	205 01 0 00 020000 		MOVSI	1,BIS
  1234	031122	255 17 0 00 031123 		JFCL	17,.+1		;RESET ALL FLAGS
  1235	031123	254 02 0 01 031124 		JRST	2,.+1(1)	;SET BIS FLAG
  1236	031124	400 00 0 00 000000 		SETZ			;CLEAR AC
  1237	031125	260 00 0 00 031126 		PUSHJ	.+1		;*PUSHJ SHOULD RESET BIS
  1238	031126	265 00 0 00 031127 		JSP	.+1		;SAVE FLAGS
  1239	031127	603 00 0 00 020000 		TLNE	BIS		;PASS IF BIS FLAG IS RESET
  1240						STOP^
  1241	031130	254 04 0 00 031131 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1242	031131	324 00 0 00 031132 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1243									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1244									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1245									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1246
  1247					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 12
DAKAGM	MAC	19-JAN-77 17:37		TEST OF PUSHJ INSTRUCTION                                                          SEQ 0039

  1248					;THIS TEST VERIFIES THAT THERE IS A CARRY FROM BIT18 TO BIT17 OF THE AC ON PUSHJ.
  1249					;THE AC IS PRELOADED WITH 0,,-1; THEN PUSHJ IS EXECUTED. PUSHJ SHOULD ADD ONE TO
  1250					;BOTH HALVES OF THE AC, GENERATING A CARRY FROM BIT18 TO BIT17. IF A
  1251					;CARRY WAS GENERATED, THE TEST PASSES.
  1252
  1253	031132	201 02 0 00 777777 	C31502:	MOVEI	2,-1		;PRELOAD AC WITH 0,,-1
  1254	031133	260 02 0 00 031134 		PUSHJ	2,.+1		;*PUSHJ SHOULD GENERATE A CARRY FROM BIT18 TO BIT17
  1255	031134	312 02 0 00 032230 		CAME	2,[2,,0]	;PASS IF C(AC)=2,,0 (CARRY WAS GENERATED)
  1256						STOP^
  1257	031135	254 04 0 00 031136 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1258	031136	324 00 0 00 031137 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1259									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1260									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1261									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1262
  1263					;****************
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 13
DAKAGM	MAC	19-JAN-77 17:37		TEST OF POP INSTRUCTION                                                            SEQ 0040

  1264					SUBTTL	TEST OF POP INSTRUCTION
  1265
  1266					;**********
  1267
  1268					;THIS TEST VERIFIES THAT POP SUBTRACTS 1,,1 FROM THE AC
  1269					;THE AC IS PRELOADED WITH 1,,1; THEN, POP IS EXECUTED.
  1270					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
  1271
  1272	031137	200 00 0 00 032223 	C31600:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
  1273	031140	262 00 0 00 000001 		POP	1		;*POP SHOULD SUBTRACT 1,,1 FROM THE AC
  1274	031141	332 00 0 00 000000 		SKIPE			;PASS IF AC WAS DECREMENTED CORRECTLY
  1275						STOP^
  1276	031142	254 04 0 00 031143 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1277	031143	324 00 0 00 031144 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1278									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1279									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1280									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1281
  1282					;**********
  1283
  1284					;THIS TEST VERIFIES THAT POP SUBTRACTS 1,,1 FROM THE AC
  1285					;THE AC IS PRELOADED WITH 2,,2; THEN, POP IS EXECUTED.
  1286					;THE AC IS CHECKED FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
  1287
  1288	031144	200 00 0 00 032232 	C31700:	MOVE	[XWD 2,2]	;PRELOAD AC WITH E,,E WHERE E=2
  1289	031145	201 02 0 00 000005 		MOVEI	2,5		;PRELOAD 2 WITH 0,,5
  1290	031146	262 00 0 00 000002 		POP	2		;*POP SHOULD SUBTRACT 1,,1 FROM THE AC
  1291	031147	312 00 0 00 032223 		CAME	[1,,1]		;PASS IF AC WAS DECREMENTED CORRECTLY
  1292						STOP^
  1293	031150	254 04 0 00 031151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1294	031151	324 00 0 00 031152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1295									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1296									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1297									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1298
  1299					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 14
DAKAGM	MAC	19-JAN-77 17:37		TEST OF POP INSTRUCTION                                                            SEQ 0041

  1300					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E
  1301					;IN THIS CASE, AC=0 AND AC IS PRELOADED WITH 2,,2; E=2 AND IS PRELOADED WITH 0.
  1302					;POP IS THEN EXECUTED.  POP SHOULD PLACE 0 INTO E.  IF C(E)=0, THIS TEST PASSES.
  1303
  1304	031152	200 00 0 00 032232 	C32300:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
  1305	031153	402 00 0 00 000002 		SETZM	2		;CLEAR E AND C(AC-RIGHT)
  1306	031154	262 00 0 00 000002 		POP	2		;*POP SHOULD PLACE 0 INTO E
  1307	031155	332 00 0 00 000002 		SKIPE	2		;PASS IF C(E)=0
  1308						STOP^
  1309	031156	254 04 0 00 031157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1310	031157	324 00 0 00 031160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1311									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1312									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1313									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1314
  1315					;**********
  1316
  1317					;THIS TEST VERIFIES THAT POP DOES NOT MODIFY C(C(AC-RIGHT)-1).
  1318					;THIS TEST FAILS IF C(C(AC-RIGHT)-1) IS MODIFIED BY POP.
  1319
  1320	031160	200 00 0 00 032232 	C32400:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
  1321	031161	201 02 0 00 000017 		MOVEI	2,17		;PRELOAD 2 WITH 0,,17
  1322	031162	402 00 0 00 000001 		SETZM	1		;CLEAR C(C(AC-RIGHT)-1)
  1323	031163	262 00 0 00 000002 		POP	2		;*POP SHOULD NOT MODIFY C(C(AC-RIGHT)-1)
  1324	031164	332 00 0 00 000001 		SKIPE	1		;PASS IF C(C(AC-RIGHT)-1) WAS UNALTERED
  1325						STOP^
  1326	031165	254 04 0 00 031166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1327	031166	324 00 0 00 031167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1328									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1329									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1330									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1331
  1332					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 15
DAKAGM	MAC	19-JAN-77 17:37		TEST OF POP INSTRUCTION                                                            SEQ 0042

  1333					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.
  1334					;IN THIS CASE, AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH 0,,3.
  1335					;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR 0,,3 [C(C(AC-RIGHT))] .
  1336					;IF C(E)=0,,3, THIS TEST PASSES.
  1337
  1338	031167	200 00 0 00 032232 	C32500:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
  1339	031170	201 02 0 00 000003 		MOVEI	2,3		;PRELOAD C(AC-RIGHT) WITH 0,,3
  1340	031171	402 00 0 00 000003 		SETZM	3		;CLEAR E
  1341	031172	262 00 0 00 000003 		POP	3		;*POP SHOULD PLACE 0,,3 INTO E
  1342	031173	302 03 0 00 000003 		CAIE	3,3		;PASS IF C(E)=0,,3
  1343						STOP^
  1344	031174	254 04 0 00 031175 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1345	031175	324 00 0 00 031176 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1346									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1347									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1348									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1349
  1350					;**********
  1351
  1352					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.  IN THIS CASE,
  1353					;AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH 0,,17.
  1354					;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR 0,,17 [C(C(AC-RIGHT))] .
  1355					;IF C(E)=0,,17, THIS TEST PASSES.
  1356
  1357	031176	402 00 0 00 000002 	C32600:	SETZM	2		;CLEAR E
  1358	031177	200 00 0 00 032232 		MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
  1359	031200	201 02 0 00 000017 		MOVEI	2,17		;PRELOAD C(AC-RIGHT) WITH 0,,17
  1360	031201	262 00 0 00 000002 		POP	2		;*POP SHOULD PLACE 0,,17 INTO E
  1361	031202	302 02 0 00 000017 		CAIE	2,17		;PASS IF C(E)=0,,17
  1362						STOP^
  1363	031203	254 04 0 00 031204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1364	031204	324 00 0 00 031205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1365									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1366									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1367									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1368
  1369					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 16
DAKAGM	MAC	19-JAN-77 17:37		TEST OF POP INSTRUCTION                                                            SEQ 0043

  1370					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.  IN THIS CASE,
  1371					;AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH -1,,-1.
  1372					;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR -1,,-1 [C(C(AC-RIGHT))] .
  1373					;IF C(E)=0,,3, THIS TEST PASSES.
  1374
  1375	031205	200 00 0 00 032232 	C33100:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
  1376	031206	476 00 0 00 000002 		SETOM	2		;PRELOAD C(AC-RIGHT) WITH -1,,-1
  1377	031207	402 00 0 00 000003 		SETZM	3		;CLEAR E
  1378	031210	262 00 0 00 000003 		POP	3		;*POP SHOULD PLACE -1,,-1 INTO E
  1379	031211	312 03 0 00 032226 		CAME	3,[-1]		;PASS IF C(E)=-1,,-1
  1380						STOP^
  1381	031212	254 04 0 00 031213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1382	031213	324 00 0 00 031214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1383									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1384									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1385									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1386
  1387					;**********
  1388
  1389					;THIS TEST VERIFIES THAT POP PLACES C(C(AC-RIGHT)) INTO E AND ADDS 1,,1 TO AC.
  1390					;IN THIS CASE, THE AC IS PRELOADED WITH 1,,17; E=1 AND E IS PRELOADED WITH 0;
  1391					;C(AC-RIGHT) IS PRELOADED WITH -1,,-1; AND POP IS EXECUTED.  POP SHOULD PLACE -1,,-1
  1392					;INTO E AND 0,,16 INTO AC.  IF AC AND E ARE UPDATED CORRECTLY, THIS TEST PASSES.
  1393
  1394	031214	200 00 0 00 032233 	C33300:	MOVE	[XWD 1,17]	;PRELOAD AC WITH 1,,17
  1395	031215	402 00 0 00 000001 		SETZM	1		;PRELOAD E WITH 0
  1396	031216	476 00 0 00 000017 		SETOM	17		;PRELOAD C(AC-RIGHT) WITH 1,,1
  1397	031217	262 00 0 00 000001 		POP	1		;*POP SHOULD PLACE -1,,-1 INTO E AND 0,,16 INTO AC
  1398	031220	312 01 0 00 032226 		CAME	1,[-1]		;PASS IF C(E)=-1,,-1
  1399						STOP^
  1400	031221	254 04 0 00 031222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1401	031222	324 00 0 00 031223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1402									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1403									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1404									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1405	031223	302 00 0 00 000016 	C33310:	CAIE	16		;PASS IF C(AC)=0,,16
  1406						STOP^
  1407	031224	254 04 0 00 031225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1408	031225	324 00 0 00 031226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1409									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1410									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1411									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1412
  1413					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 17
DAKAGM	MAC	19-JAN-77 17:37		TEST OF POP INSTRUCTION                                                            SEQ 0044

  1414					;THIS TEST VERIFIES THAT POP PLACES C(C(AC-RIGHT)) INTO E AND ADDS 1,,1 TO AC
  1415					;IN THIS CASE, THE AC IS PRELOADED WITH -1,,0; E=17
  1416					;C(AC-RIGHT) IS PRELOADED WITH 0; AND POP IS EXECUTED.  POP SHOULD PLACE 0
  1417					;INTO E.  IF AC IS UPDATED CORRECTLY, THIS TEST PASSES.
  1418
  1419	031226	205 01 0 00 777777 	C33400:	MOVSI	1,-1		;PRELOAD AC WITH -1,,0
  1420	031227	400 00 0 00 000000 		SETZ			;CLEAR C(AC-RIGHT)
  1421	031230	262 01 0 00 000017 		POP	1,17		;*POP SHOULD PLACE 0 INTO E
  1422	031231	332 00 0 00 000017 		SKIPE	17		;PASS IF C(E)=0
  1423						STOP^
  1424	031232	254 04 0 00 031233 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1425	031233	324 00 0 00 031234 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1426									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1427									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1428									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1429
  1430					;**********
  1431
  1432					;THIS TEST VERIFIES THAT THERE IS A CARRY FROM BIT18 TO BIT17 OF THE AC ON POP.
  1433					;THE AC IS PRELOADED WITH 2,,0; THEN POP IS EXECUTED. POP SHOULD SUBTRACT ONE FROM
  1434					;BOTH HALVES OF THE AC, GENERATING A CARRY FROM BIT18 TO BIT17.
  1435					;IF A CARRY WAS GENERATED, THIS TEST PASSES.
  1436
  1437	031234	515 02 0 00 000002 	C33401:	HRLZI	2,2		;PRELOAD AC WITH 2,,0
  1438	031235	262 02 0 00 000000 		POP	2,0		;*POP SHOULD GENERATE A CARRY FROM BIT18 TO BIT17
  1439	031236	302 02 0 00 777777 		CAIE	2,-1		;PASS IF C(AC) = 0,,-1	(CARRY WAS GENERATED)
  1440						STOP^
  1441	031237	254 04 0 00 031240 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1442	031240	324 00 0 00 031241 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1443									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1444									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1445									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1446
  1447					;************
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 18
DAKAGM	MAC	19-JAN-77 17:37		TEST OF POPJ INSTRUCTION                                                           SEQ 0045

  1448					SUBTTL	TEST OF POPJ INSTRUCTION
  1449
  1450					;**********
  1451
  1452					;THIS TEST VERIFIES THAT POPJ JUMPS TO THE LOCATION ADDRESSED BY RIGHT HALF OF
  1453					;C(C(AC-RIGHT)) BEFORE POPJ DECREMENTED THE AC.
  1454					;THIS TEST PASSES IF POPJ JUMPS CORRECTLY.
  1455
  1456	031241	200 00 0 00 032223 	C33500:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
  1457	031242	201 01 0 00 031245 		MOVEI	1,.+3		;PRELOAD C(AC-RIGHT) WITH .+3
  1458	031243	263 00 0 00 031245 		POPJ	.+2		;*POPJ SHOULD JUMP TO LOCATION
  1459									;ADDRESSED BY C(C(AC-RIGHT))
  1460						STOP^
  1461	031244	254 04 0 00 031245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1462	031245	324 00 0 00 031246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1463									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1464									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1465									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1466
  1467					;**********
  1468
  1469					;THIS TEST VERIFIES THAT POPJ SUBTRACTS 1,,1 FROM THE AC
  1470					;THIS AC IS PRELOADED WITH 1,,1; THEN,POPJ IS EXECUTED.
  1471					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
  1472
  1473	031246	200 00 0 00 032223 	C33600:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
  1474	031247	201 01 0 00 031251 		MOVEI	1,.+2		;PRELOAD C(AC-NIGHT)WITH .+2
  1475	031250	263 00 0 00 031251 		POPJ	.+1		;*POPJ SHOULD SUBTRACT 1,,1 FROM AC
  1476	031251	312 00 0 00 032227 		CAME	[0]		;PASS IF C(AC)=0
  1477						STOP^
  1478	031252	254 04 0 00 031253 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1479	031253	324 00 0 00 031254 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1480									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1481									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1482									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1483
  1484					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 19
DAKAGM	MAC	19-JAN-77 17:37		TEST OF POPJ INSTRUCTION                                                           SEQ 0046

  1485					;THIS TEST VERIFIES THAT POPJ JUMPS TO THE LOCATION ADDRESSED BY RIGHT HALF OF
  1486					;C(C(AC-RIGHT)) BEFORE POPJ DECREMENTED THE AC.
  1487					;THIS TEST PASSES IF POPJ JUMPS CORRECTLY.
  1488
  1489	031254	200 00 0 00 032223 	C33700:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
  1490	031255	201 01 0 00 031257 		MOVEI	1,.+2		;PRELOAD C(AC-RIGHT) WITH C33700+3
  1491
  1492	031256	263 00 0 00 031260 		POPJ	.+2		;*POPJ SHOULD JUMP TO C33700+3
  1493	031257	334 00 0 00 000000 		SKIPA			;PASS IF POPJ JUMPED CORRECTLY
  1494						STOP^
  1495	031260	254 04 0 00 031261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1496	031261	324 00 0 00 031262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1497									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1498									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1499									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1500
  1501					;**********
  1502
  1503					;THIS TEST VERIFIES THAT THERE IS A CARRY FROM BIT18 TO BIT17 OF THE AC ON POPJ.
  1504					;THE AC IS PRELOADED WITH 2,,0; THEN POPJ IS EXECUTED POPJ SHOULD SUBTRACT ONE FROM
  1505					;BOTH HALVES OF THE AC, GENERATING A CARRY FROM BIT18 TO BIT17.
  1506					;IF A CARRY WAS GENERATED, THIS TEST PASSES.
  1507
  1508	031262	515 02 0 00 000002 	C33701:	HRLZI	2,2		;PRELOAD AC WITH 2,,0
  1509	031263	201 00 0 00 031265 		MOVEI	0,.+2		;PRELOAD RH(AC) WITH C33701: +3
  1510	031264	263 02 0 00 000000 		POPJ	2,0		;*POPJ SHOULD GENERATE A CARRY FROM BIT18 TO BIT17
  1511	031265	302 02 0 00 777777 		CAIE	2,-1		;PASS IF C(AC)=0,,-1 (CARRY WAS GENERATED)
  1512						STOP^
  1513	031266	254 04 0 00 031267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1514	031267	324 00 0 00 031270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1515									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1516									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1517									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1518
  1519					;*************
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 20
DAKAGM	MAC	19-JAN-77 17:37		XCT INSTRUCTION - ADDITIONAL TESTS                                                 SEQ 0047

  1520					SUBTTL	XCT INSTRUCTION - ADDITIONAL TESTS
  1521
  1522					;**********
  1523
  1524					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
  1525					;TO THE LOCATION OF THE XCT.
  1526
  1527	031270	477 00 0 00 000001 	C34000:	SETOB	1
  1528	031271	256 00 0 00 032234 		XCT	[CAME 0,1]	;*CAME SHOULD SKIP TO C34000+3
  1529						STOP^
  1530	031272	254 04 0 00 031273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1531	031273	324 00 0 00 031274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1532									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1533									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1534									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1535
  1536					;**********
  1537
  1538					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
  1539					;TO THE LOCATION OF THE XCT.
  1540
  1541	031274	477 00 0 00 000001 	C34100:	SETOB	1
  1542	031275	256 00 0 00 032236 		XCT	[XCT[XCT[CAME 0,1]]]	;*CAME SHOULD SKIP TO C34100+3
  1543						STOP^
  1544	031276	254 04 0 00 031277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1545	031277	324 00 0 00 031300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1546									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1547									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1548									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1549
  1550					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 21
DAKAGM	MAC	19-JAN-77 17:37		XCT INSTRUCTION - ADDITIONAL TESTS                                                 SEQ 0048

  1551					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
  1552					;SPECIFIED BY THE JUMP.
  1553
  1554	031300	256 00 0 00 032237 	C34200:	XCT	[JRST .+4]	;*JRST SHOULD JUMP TO C34200+4
  1555
  1556	031301	254 04 0 00 000000 		HALT			;JRST SHOULD JUMP OVER THIS LOCATION
  1557	031302	254 04 0 00 000000 		HALT			;JRST SHOULD JUMP OVER THIS LOCATION
  1558						STOP^
  1559	031303	254 04 0 00 031304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1560	031304	324 00 0 00 031305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1561									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1562									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1563									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1564
  1565					;**********
  1566
  1567					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
  1568					;SPECIFIED BY THE JUMP AND THAT WHEN THE PC IS SAVED IT CONTAINS AN
  1569					;ADDRESS ONE GREATER THAN THE LOCATION OF FIRST XCT OF THE CHAIN.
  1570
  1571	031305	402 00 0 00 000003 	C34300:	SETZM	3		;CLEAR AC OF JSP
  1572	031306	256 00 0 00 032242 		XCT	[XCT[XCT[JSP 3,.+3]]] ;*JSP SHOULD JUMP TO C34300+4 AND
  1573	031307	254 04 0 00 000000 		HALT			;THE SAVED PC SHOULD BE C 34300+2
  1574	031310	254 04 0 00 000000 		HALT			;PASS IF JSP JUMPED CORRECTLY
  1575	031311	620 03 0 00 031307 		TRZ	3,.-2		;AND SAVED PC=C34300+2
  1576	031312	602 03 0 00 777777 		TRNE	3,-1
  1577						STOP^
  1578	031313	254 04 0 00 031314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1579	031314	324 00 0 00 031315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1580									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1581									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1582									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1583
  1584					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 22
DAKAGM	MAC	19-JAN-77 17:37		XCT INSTRUCTION - ADDITIONAL TESTS                                                 SEQ 0049

  1585					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
  1586					;TO THE LOCATION OF THE XCT.
  1587					;IN THIS CASE, NO SKIP SHOULD OCCUR  ;HENCE, THE INSTRUCTION
  1588					;FOLLOWING XCT SHOULD BE EXECUTED AFTER 'CAME' IS EXECUTED.
  1589
  1590	031315	403 00 0 00 000000 	C34400:	SETZB	0		;SET-UP AC,E SO THAT
  1591	031316	476 00 0 00 000001 		SETOM	1		;CAME WILL NOT SKIP
  1592	031317	256 00 0 00 032234 		XCT	[CAME 0,1]	;*CAME SHOULD CAUSE EXECUTION
  1593									;OF INSTRUCTION FOLLOWING XCT
  1594	031320	254 00 0 00 031322 		JRST	.+2		;PASS IF THIS INSTRUCTION IS EXECUTED
  1595						STOP^
  1596	031321	254 04 0 00 031322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1597	031322	324 00 0 00 031323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1598									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1599									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1600									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1601
  1602					;**********
  1603
  1604					;THIS TEST VERIFIES INDEXING FOR XCT OF AN ADD INSTRUCTION
  1605					;C(4)=10, AND C(6)=3, SO THE RESULT IN 6 (THE AC) SHOULD BE 16
  1606					;C(11)=13
  1607
  1608	031323	201 04 0 00 000010 	C34500:	MOVEI	4,10		;PRELOAD INDEX REG WITH 10
  1609	031324	201 11 0 00 000013 		MOVEI	11,13		;PRELOAD EFFECTIVE ADDRESS WITH 13
  1610	031325	201 06 0 00 000003 		MOVEI	6,3		;PRELOAD AC WITH 3
  1611	031326	256 00 0 00 032243 		XCT	[ADD 6,1(4)]	;*ADD SHOULD PLACE 16 IN AC
  1612	031327	302 06 0 00 000016 		CAIE	6,16		;PASS IF C(AC)=16
  1613						STOP^
  1614	031330	254 04 0 00 031331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1615	031331	324 00 0 00 031332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1616									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1617									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1618									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1619
  1620					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 23
DAKAGM	MAC	19-JAN-77 17:37		XCT INSTRUCTION - ADDITIONAL TESTS                                                 SEQ 0050

  1621					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
  1622					;TO THE LOCATION OF THE XCT
  1623					;IN THIS CASE, NO SKIP SHOULD OCCUR  ;HENCE, THE INSTRUCTION
  1624					;FOLLOWING XCT SHOULD BE EXECUTED AFTER CAME IS EXECUTED.
  1625
  1626	031332	402 00 0 00 000002 	C34600:	SETZM	2		;SETUP E SO THAT SKIPL WILL NOT SKIP
  1627	031333	256 00 0 00 032244 		XCT	[SKIPL 1,2]	;*SKIPL SHOULD CAUSE INSTRUCTION
  1628									;OF FOLLOWING INSTRUCTION
  1629	031334	254 00 0 00 031336 		JRST	.+2		;PASS IF THIS INSTRUCTION IS EXECUTED.
  1630						STOP^
  1631	031335	254 04 0 00 031336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1632	031336	324 00 0 00 031337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1633									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1634									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1635									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1636	031337	332 00 0 00 000001 	C34610:	SKIPE	1		;*SKIPE SHOULD SKIP BECAUSE XCT OF SKIPL
  1637									;PLACED 0 INTO AC1
  1638						STOP^
  1639	031340	254 04 0 00 031341 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1640	031341	324 00 0 00 031342 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1641									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1642									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1643									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1644
  1645					;**********
  1646
  1647					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
  1648					;TO THE LOCATION OF THE XCT.
  1649
  1650	031342	476 00 0 00 000006 	C34700:	SETOM	6		;SETUP E SO THAT SKIPL WILL SKIP
  1651	031343	256 00 0 00 032245 		XCT	[SKIPL 3,6]	;*SKIPL SHOULD SKIP TO C34700+3
  1652						STOP^
  1653	031344	254 04 0 00 031345 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1654	031345	324 00 0 00 031346 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1655									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1656									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1657									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1658	031346	331 00 0 00 000003 	C34710:	SKIPL	3		;*SKIPE SHOULD SKIP BECAUSE XCT OF SKIPL
  1659									;PLACED 0 INTO AC1
  1660						STOP^
  1661	031347	254 04 0 00 031350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1662	031350	324 00 0 00 031351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1663									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1664									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1665									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1666
  1667					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 24
DAKAGM	MAC	19-JAN-77 17:37		XCT INSTRUCTION - ADDITIONAL TESTS                                                 SEQ 0051

  1668					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
  1669					;SPECIFIED BY THE JUMP.
  1670					;THIS TEST ALSO VERIFIES CORRECT UPDATING OF THE AC FOR AOBJN
  1671
  1672	031351	200 03 0 00 032246 	C35000:	MOVE	3,[-2,,5]	;SETUP AC SO THAT AOBJN WILL JUMP
  1673	031352	256 00 0 00 032247 		XCT	[AOBJN 3,.+3]	;*JUMP SHOULD BE TO C35000+4
  1674	031353	254 04 0 00 000000 		HALT			;JUMP OVER THIS INSTRUCTION
  1675	031354	254 04 0 00 000000 		HALT			;JUMP OVER THIS INSTRUCTION
  1676	031355	312 03 0 00 032250 		CAME	3,[-1,,6]	;PASS IF C(AC)=-1,,6 AND AOBJN JUMPED
  1677						STOP^
  1678	031356	254 04 0 00 031357 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1679	031357	324 00 0 00 031360 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1680									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1681									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1682									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1683
  1684					;**********
  1685
  1686					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
  1687					;SPECIFIED BY THE JUMP.
  1688					;THIS TEST ALSO VERIFIES CORRECT UPDATING OF THE AC FOR AOBJN
  1689
  1690	031360	200 03 0 00 032250 	C35100:	MOVE	3,[-1,,6]	;SETUP AC SO THAT AOBJN WILL NOT JUMP
  1691	031361	256 00 0 00 032251 		XCT	[AOBJN 3,.+2]	;*AOBJN SHOULD NOT JUMP
  1692	031362	312 03 0 00 032252 		CAME	3,[0,,7]	;PASS IF AOBJN DID NOT JUMP AND C(AC)=0,,7
  1693						STOP^
  1694	031363	254 04 0 00 031364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1695	031364	324 00 0 00 031365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1696									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1697									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1698									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1699
  1700					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 25
DAKAGM	MAC	19-JAN-77 17:37		TEST XCT INSTRUCTION WITH INDIRECT ADDRESSING AND INDEXING                         SEQ 0052

  1701					SUBTTL	TEST XCT INSTRUCTION WITH INDIRECT ADDRESSING AND INDEXING
  1702
  1703					;**********
  1704
  1705					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
  1706					;FROM AN INDIRECTLY ADDRESSED LOCATION
  1707
  1708	031365	403 00 0 00 000002 	C35200:	SETZB	2
  1709	031366	254 00 0 00 031371 		JRST	.+3
  1710	031367	000000	031370				.+1
  1711	031370	476 00 0 00 000002 		SETOM	2		;THIS INSTRUCTION SHOULD BE EXECUTED
  1712	031371	256 00 1 00 031367 		XCT	@.-2
  1713	031372	312 02 0 00 032226 		CAME	2,[-1,,-1]	;PASS IF 'SETOM 2' WAS EXECUTED
  1714						STOP^
  1715	031373	254 04 0 00 031374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1716	031374	324 00 0 00 031375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1717									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1718									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1719									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1720
  1721					;**********
  1722
  1723					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
  1724					;FROM AN INDEXED LOCATION
  1725
  1726	031375	201 04 0 00 031376 	C35300:	MOVEI	4,.+1
  1727	031376	254 00 0 00 031400 		JRST	.+2
  1728	031377	302 04 0 00 031376 		CAIE	4,.-1		;THIS INSTRUCTION SHOULD BE EXECUTED
  1729	031400	256 00 0 04 000001 		XCT	1(4)
  1730						STOP			^;PASS IF 'CAIE 4,,-1' WAS EXECUTED
  1731
  1732	031401	254 04 0 00 031402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1733	031402	324 00 0 00 031403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1734									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1735									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1736									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1
  1737
  1738					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 26
DAKAGM	MAC	19-JAN-77 17:37		TEST XCT INSTRUCTION WITH INDIRECT ADDRESSING AND INDEXING                         SEQ 0053

  1739					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
  1740					;FROM AN INDIRECTLY ADDRESSED AND INDEXED LOCATION
  1741
  1742	031403	402 00 0 00 000005 	C35400:	SETZM	5
  1743	031404	201 03 0 00 031407 		MOVEI	3,.+3
  1744	031405	254 00 0 00 031407 		JRST	.+2
  1745	031406	201 05 0 00 031411 		MOVEI	5,.+3
  1746	031407	256 00 1 03 777777 		XCT	@-1(3)
  1747	031410	254 00 0 00 031412 		JRST	.+2
  1748	031411	476 00 0 00 000005 		SETOM	5		;THIS INSTRUCTION SHOULD BE EXECUTED
  1749	031412	312 05 0 00 032226 		CAME	5,[-1,,-1]	;PASS IF 'SETOM 5' WAS EXECUTED
  1750						STOP^
  1751	031413	254 04 0 00 031414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1752	031414	324 00 0 00 031415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1753									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1754									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1755									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1756
  1757					;**********
  1758
  1759					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INDIRECTLY ADDRESSED
  1760					;AND INDEXED INSTRUCTION
  1761
  1762	031415	402 00 0 00 000003 	C35500:	SETZM	3
  1763	031416	201 10 0 00 000003 		MOVEI	10,3
  1764	031417	254 00 0 00 031424 		JRST	.+5
  1765	031420	254 04 0 00 000000 		HALT
  1766	031421	254 04 0 00 000000 		HALT
  1767	031422	200 03 1 10 031420 		MOVE	3,@.-2(10)	;THIS INSTRUCTION SHOULD BE EXECUTED
  1768	031423	254 04 0 00 032253 		HALT	[0,,707070]
  1769	031424	256 00 0 00 031422 		XCT	.-2
  1770	031425	302 03 0 00 707070 		CAIE	3,707070	;PASS IF 'MOVE 3,@.-2(10)' WAS EXECUTED
  1771						STOP^
  1772	031426	254 04 0 00 031427 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1773	031427	324 00 0 00 031430 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1774									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1775									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1776									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1777
  1778					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 27
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0054

  1779					SUBTTL	TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER
  1780
  1781					;**********
  1782
  1783					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  1784					;IN THIS CASE, 0,,0 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
  1785					;SO THAT FINAL C(AC)=0,,0.
  1786					;C(AC+1) SHOULD NOT BE AFFECTED.
  1787
  1788	031430	200 00 0 00 032227 	C35600:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
  1789	031431	200 01 0 00 032254 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  1790	031432	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 0,,0 RIGHT 3 BIT POSITIONS
  1791	031433	312 00 0 00 032227 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
  1792						STOP^
  1793	031434	254 04 0 00 031435 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1794	031435	324 00 0 00 031436 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1795									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1796									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1797									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1798	031436	312 01 0 00 032254 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  1799						STOP^
  1800	031437	254 04 0 00 031440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1801	031440	324 00 0 00 031441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1802									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1803									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1804									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1805
  1806					;**********
  1807
  1808					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  1809					;IN THIS CASE, -1,,-1 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
  1810					;SO THAT FINAL C(AC)=-1,,-1.
  1811					;C(AC+1) SHOULD NOT BE AFFECTED.
  1812
  1813	031441	200 00 0 00 032226 	C35700:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH 0,,0
  1814	031442	200 01 0 00 032254 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  1815	031443	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE -1,,-1 RIGHT 3 BIT POSITIONS
  1816	031444	312 00 0 00 032226 		CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
  1817						STOP^
  1818	031445	254 04 0 00 031446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1819	031446	324 00 0 00 031447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1820									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1821									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1822									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1823	031447	312 01 0 00 032254 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  1824						STOP^
  1825	031450	254 04 0 00 031451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1826	031451	324 00 0 00 031452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1827									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1828									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1829									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1830
  1831					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 28
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0055

  1832					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  1833					;IN THIS CASE, 252525,,252525 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
  1834					;SO THAT FINAL C(AC)=525252,,525252.
  1835					;C(AC+1) SHOULD NOT BE AFFECTED.
  1836
  1837	031452	200 00 0 00 032255 	C36000:	MOVE	0,[252525,,252525] ;PRELOAD AC WITH 252525,,252525
  1838	031453	200 01 0 00 032254 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  1839	031454	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 252525,,252525
  1840									;RIGHT 3 BIT POSITIONS
  1841	031455	312 00 0 00 032256 		CAME	0,[525252,,525252] ;PASS IF C(AC)=525252,,525252
  1842						STOP^
  1843	031456	254 04 0 00 031457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1844	031457	324 00 0 00 031460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1845									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1846									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1847									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1848	031460	312 01 0 00 032254 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  1849						STOP^
  1850	031461	254 04 0 00 031462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1851	031462	324 00 0 00 031463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1852									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1853									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1854									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1855
  1856					;**********
  1857
  1858					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  1859					;IN THIS CASE, 525252,,525252 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
  1860					;SO THAT FINAL C(AC)=252525,,252525.
  1861					;C(AC+1) SHOULD NOT BE AFFECTED.
  1862
  1863	031463	200 00 0 00 032256 	C36100:	MOVE	0,[525252,,525252] ;PRELOAD AC WITH 525252,,525252
  1864	031464	200 01 0 00 032254 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  1865	031465	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 525252,,525252
  1866									;RIGHT 3 BIT POSITIONS
  1867	031466	312 00 0 00 032255 		CAME	0,[252525,,252525] ;PASS IF C(AC)=252525,,252525
  1868						STOP^
  1869	031467	254 04 0 00 031470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1870	031470	324 00 0 00 031471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1871									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1872									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1873									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1874	031471	312 01 0 00 032254 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  1875						STOP^
  1876	031472	254 04 0 00 031473 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1877	031473	324 00 0 00 031474 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1878									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1879									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1880									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1881
  1882					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 29
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0056

  1883					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  1884					;IN THIS CASE, 230703,,603700 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
  1885					;SO THAT FINAL C(AC)=023070,,360370.
  1886					;C(AC+1) SHOULD NOT BE AFFECTED.
  1887
  1888	031474	200 00 0 00 032257 	C36200:	MOVE	0,[230703,,603700] ;PRELOAD AC WITH 230703,,603700
  1889	031475	200 01 0 00 032254 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  1890	031476	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 230703,,603700
  1891									;RIGHT 3 BIT POSITIONS
  1892	031477	312 00 0 00 032260 		CAME	0,[023070,,360370] ;PASS IF C(AC)=023070,,360370
  1893						STOP^
  1894	031500	254 04 0 00 031501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1895	031501	324 00 0 00 031502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1896									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1897									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1898									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1899	031502	312 01 0 00 032254 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  1900						STOP^
  1901	031503	254 04 0 00 031504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1902	031504	324 00 0 00 031505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1903									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1904									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1905									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1906
  1907					;**********
  1908
  1909					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  1910					;IN THIS CASE, 007603,,607062 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
  1911					;SO THAT FINAL C(AC)=200760,,360706.
  1912					;C(AC+1) SHOULD NOT BE AFFECTED.
  1913
  1914	031505	200 00 0 00 032261 	C36300:	MOVE	0,[007603,,607062] ;PRELOAD AC WITH 007603,,607062
  1915	031506	200 01 0 00 032254 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  1916	031507	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 007603,,607062
  1917									;RIGHT 3 BIT POSITIONS
  1918	031510	312 00 0 00 032262 		CAME	0,[200760,,360706] ;PASS IF C(AC)=200760,,360706
  1919						STOP^
  1920	031511	254 04 0 00 031512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1921	031512	324 00 0 00 031513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1922									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1923									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1924									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1925	031513	312 01 0 00 032254 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  1926						STOP^
  1927	031514	254 04 0 00 031515 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1928	031515	324 00 0 00 031516 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1929									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1930									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1931									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1932
  1933					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 30
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0057

  1934					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  1935					;IN THIS CASE, 0,,0 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
  1936					;SO THAT FINAL C(AC)=0,,0.
  1937					;C(AC+1) SHOULD NOT BE AFFECTED.
  1938
  1939	031516	200 02 0 00 032227 	C36400:	MOVE	2,[0,,0]	;PRELOAD AC WITH 0,,0
  1940	031517	200 03 0 00 032254 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  1941	031520	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 0,,0 LEFT 15 BIT POSITIONS
  1942	031521	312 02 0 00 032227 		CAME	2,[0,,0]	;PASS IF C(AC)=0,,0
  1943						STOP^
  1944	031522	254 04 0 00 031523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1945	031523	324 00 0 00 031524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1946									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1947									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1948									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1949	031524	312 03 0 00 032254 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  1950						STOP^
  1951	031525	254 04 0 00 031526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1952	031526	324 00 0 00 031527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1953									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1954									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1955									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1956
  1957					;**********
  1958
  1959					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  1960					;IN THIS CASE, -1,,-1 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
  1961					;SO THAT FINAL C(AC)=-1,,-1.
  1962					;C(AC+1) SHOULD NOT BE AFFECTED.
  1963
  1964	031527	200 02 0 00 032226 	C36500:	MOVE	2,[-1,,-1]	;PRELOAD AC WITH -1,,-1
  1965	031530	200 03 0 00 032254 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  1966	031531	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE -1,,-1 LEFT 15 BIT POSITIONS
  1967	031532	312 02 0 00 032226 		CAME	2,[-1,,-1]	;PASS IF C(AC)=-1,,-1
  1968						STOP^
  1969	031533	254 04 0 00 031534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1970	031534	324 00 0 00 031535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1971									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1972									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1973									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1974	031535	312 03 0 00 032254 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  1975						STOP^
  1976	031536	254 04 0 00 031537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1977	031537	324 00 0 00 031540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1978									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1979									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1980									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1981
  1982					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 31
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0058

  1983					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  1984					;IN THIS CASE, 252525,,252525 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
  1985					;SO THAT FINAL C(AC)=525252,,525252.
  1986					;C(AC+1) SHOULD NOT BE AFFECTED.
  1987
  1988	031540	200 02 0 00 032255 	C36600:	MOVE	2,[252525,,252525] ;PRELOAD AC WITH 252525,,252525
  1989	031541	200 03 0 00 032254 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  1990	031542	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 252525,,252525
  1991									;LEFT 15 BIT POSITIONS
  1992	031543	312 02 0 00 032256 		CAME	2,[525252,,525252] ;PASS IF C(AC)=525252,,525252
  1993						STOP^
  1994	031544	254 04 0 00 031545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1995	031545	324 00 0 00 031546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  1996									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  1997									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  1998									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  1999	031546	312 03 0 00 032254 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  2000						STOP^
  2001	031547	254 04 0 00 031550 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2002	031550	324 00 0 00 031551 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2003									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2004									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2005									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2006
  2007					;**********
  2008
  2009					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  2010					;IN THIS CASE, 525252,,525252 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
  2011					;SO THAT FINAL C(AC)=252525,,252525.
  2012					;C(AC+1) SHOULD NOT BE AFFECTED.
  2013
  2014	031551	200 02 0 00 032256 	C36700:	MOVE	2,[525252,,525252] ;PRELOAD AC WITH 525252,,525252
  2015	031552	200 03 0 00 032254 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  2016	031553	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 525252,,525252
  2017									;LEFT 15 BIT POSITIONS
  2018	031554	312 02 0 00 032255 		CAME	2,[252525,,252525] ;PASS IF C(AC)=252525,,252525
  2019						STOP^
  2020	031555	254 04 0 00 031556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2021	031556	324 00 0 00 031557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2022									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2023									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2024									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2025	031557	312 03 0 00 032254 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  2026						STOP^
  2027	031560	254 04 0 00 031561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2028	031561	324 00 0 00 031562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2029									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2030									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2031									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2032
  2033					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 32
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0059

  2034					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  2035					;IN THIS CASE, 230703,,603700 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
  2036					;SO THAT FINAL C(AC)074076,,004616.
  2037					;C(AC+1) SHOULD NOT BE AFFECTED.
  2038
  2039	031562	200 02 0 00 032257 	C37000:	MOVE	2,[230703,,603700] ;PRELOAD AC WITH 230703,,603700
  2040	031563	200 03 0 00 032254 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  2041	031564	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 230703,,603700
  2042									;LEFT 15 BIT POSITIONS
  2043	031565	312 02 0 00 032263 		CAME	2,[074076,,004616] ;PASS IF C(AC)074076,,004616
  2044						STOP^
  2045	031566	254 04 0 00 031567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2046	031567	324 00 0 00 031570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2047									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2048									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2049									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2050	031570	312 03 0 00 032254 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  2051						STOP^
  2052	031571	254 04 0 00 031572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2053	031572	324 00 0 00 031573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2054									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2055									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2056									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2057
  2058					;**********
  2059
  2060					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
  2061					;IN THIS CASE, 007603,,607062 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
  2062					;SO THAT FINAL C(AC)074161,,440174.
  2063					;C(AC+1) SHOULD NOT BE AFFECTED.
  2064
  2065	031573	200 02 0 00 032261 	C37100:	MOVE	2,[007603,,607062] ;PRELOAD AC WITH 007603,,607062
  2066	031574	200 03 0 00 032254 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  2067	031575	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 007603,,607062
  2068									;LEFT 15 BIT POSITIONS
  2069	031576	312 02 0 00 032264 		CAME	2,[074161,,440174] ;PASS IF C(AC)074161,,440174
  2070						STOP^
  2071	031577	254 04 0 00 031600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2072	031600	324 00 0 00 031601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2073									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2074									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2075									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2076	031601	312 03 0 00 032254 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  2077						STOP^
  2078	031602	254 04 0 00 031603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2079	031603	324 00 0 00 031604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2080									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2081									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2082									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2083
  2084					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 33
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0060

  2085					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2086					;IN THIS CASE, 0,,0 0,,0 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
  2087					;SO THAT FINAL C(AC)=0,,0 AND FINAL C(AC+1)=0,,0
  2088
  2089	031604	200 00 0 00 032227 	C37200:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
  2090	031605	200 01 0 00 032227 		MOVE	1,[0,,0]	;PRELOAD AC+1 WITH 0,,0
  2091	031606	245 00 0 00 000003 		ROTC	0,3		;*ROTC SHOULD ROTATE 0,,0 0,,0 LEFT 3 BIT POSITIONS
  2092	031607	312 00 0 00 032227 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
  2093						STOP^
  2094	031610	254 04 0 00 031611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2095	031611	324 00 0 00 031612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2096									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2097									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2098									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2099	031612	312 01 0 00 032227 		CAME	1,[0,,0]	;PASS IF C(AC+1)=0,,0
  2100						STOP^
  2101	031613	254 04 0 00 031614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2102	031614	324 00 0 00 031615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2103									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2104									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2105									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2106
  2107					;**********
  2108
  2109					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2110					;IN THIS CASE, -1,,-1 -1,,-1 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
  2111					;SO THAT FINAL C(AC)=-1,,-1 AND FINAL C(AC+1)=-1,,-1
  2112
  2113	031615	200 00 0 00 032226 	C37300:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
  2114	031616	200 01 0 00 032226 		MOVE	1,[-1,,-1]	;PRELOAD AC+1 WITH -1,,-1
  2115	031617	245 00 0 00 000003 		ROTC	0,3		;*ROTC SHOULD ROTATE -1,,-1
  2116									;-1,,-1 LEFT 3 BIT POSITIONS
  2117	031620	312 00 0 00 032226 		CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
  2118						STOP^
  2119	031621	254 04 0 00 031622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2120	031622	324 00 0 00 031623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2121									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2122									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2123									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2124	031623	312 00 0 00 032226 		CAME	0,[-1,,-1]	;PASS IF C(AC+1)=-1,,-1
  2125						STOP^
  2126	031624	254 04 0 00 031625 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2127	031625	324 00 0 00 031626 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2128									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2129									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2130									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2131
  2132					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 34
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0061

  2133					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2134					;IN THIS CASE, 252525,,252525 252525,,252525 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
  2135					;SO THAT FINAL C(AC)=525252,,525252 AND FINAL C(AC+1)=525252,,525252
  2136
  2137	031626	200 00 0 00 032255 	C37400:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
  2138	031627	200 01 0 00 032255 		MOVE	1,[252525,,252525]	;PRELOAD AC+1 WITH 252525,,252525
  2139	031630	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 252525,,252525
  2140										;252525,,252525 LEFT 3 BIT POSITIONS
  2141	031631	312 00 0 00 032256 		CAME	0,[525252,,525252]	;PASS IF C(AC)=525252,,525252
  2142						STOP^
  2143	031632	254 04 0 00 031633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2144	031633	324 00 0 00 031634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2145									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2146									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2147									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2148	031634	312 01 0 00 032256 		CAME	1,[525252,,525252]	;PASS IF C(AC+1)=525252,,525252
  2149						STOP^
  2150	031635	254 04 0 00 031636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2151	031636	324 00 0 00 031637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2152									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2153									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2154									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2155
  2156					;**********
  2157
  2158					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2159					;IN THIS CASE, 525252,,525252 525252,,525252 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
  2160					;SO THAT FINAL C(AC)=252525,,252525 AND FINAL C(AC+1)=252525,,252525
  2161
  2162	031637	200 00 0 00 032256 	C37500:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
  2163	031640	200 01 0 00 032256 		MOVE	1,[525252,,525252]	;PRELOAD AC+1 WITH 525252,,525252
  2164	031641	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 525252,,525252
  2165										;525252,,525252 LEFT 3 BIT POSITIONS
  2166	031642	312 00 0 00 032255 		CAME	0,[252525,,252525]	;PASS IF C(AC)=252525,,252525
  2167						STOP^
  2168	031643	254 04 0 00 031644 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2169	031644	324 00 0 00 031645 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2170									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2171									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2172									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2173	031645	312 01 0 00 032255 		CAME	1,[252525,,252525]	;PASS IF C(AC+1)=252525,,252525
  2174						STOP^
  2175	031646	254 04 0 00 031647 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2176	031647	324 00 0 00 031650 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2177									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2178									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2179									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2180
  2181					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 35
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0062

  2182					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2183					;IN THIS CASE, 230703,,603700 770037,,600377 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
  2184					;SO THAT FINAL C(AC)=307036,,37007 AND FINAL C(AC+1)=700376,,003772
  2185
  2186	031650	200 00 0 00 032257 	C37600:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
  2187	031651	200 01 0 00 032265 		MOVE	1,[770037,,600377]	;PRELOAD AC+1 WITH 770037,,600377
  2188	031652	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 230703,,603700
  2189										;770037,,600377 LEFT 3 BIT POSITIONS
  2190	031653	312 00 0 00 032266 		CAME	0,[307036,,037007]	;PASS IF C(AC)=307036,,37007
  2191						STOP^
  2192	031654	254 04 0 00 031655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2193	031655	324 00 0 00 031656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2194									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2195									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2196									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2197	031656	312 01 0 00 032267 		CAME	1,[700376,,003772]	;PASS IF C(AC+1)=700376,,003772
  2198						STOP^
  2199	031657	254 04 0 00 031660 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2200	031660	324 00 0 00 031661 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2201									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2202									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2203									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2204
  2205					;**********
  2206
  2207					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2208					;IN THIS CASE, 776003,,760077 007603,,607062 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
  2209					;SO THAT FINAL C(AC)=760037,,600770 AND FINAL C(AC+1)=076036,,070627
  2210
  2211	031661	200 00 0 00 032270 	C37700:	MOVE	0,[776003,,760077]	;PRELOAD AC WITH 776003,,760077
  2212	031662	200 01 0 00 032261 		MOVE	1,[007603,,607062]	;PRELOAD AC+1 WITH 007603,,607062
  2213	031663	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 776003,,760077
  2214										;007603,,607062 LEFT 3 BIT POSITIONS
  2215	031664	312 00 0 00 032271 		CAME	0,[760037,,600770]	;PASS IF C(AC)=076036,,070627
  2216						STOP^
  2217	031665	254 04 0 00 031666 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2218	031666	324 00 0 00 031667 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2219									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2220									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2221									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2222	031667	312 01 0 00 032272 		CAME	1,[076036,,070627]	;PASS IF C(AC+1)=760037,,600770
  2223						STOP^
  2224	031670	254 04 0 00 031671 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2225	031671	324 00 0 00 031672 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2226									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2227									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2228									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2229
  2230					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 36
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0063

  2231					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2232					;IN THIS CASE, 0,,0 0,,0 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
  2233					;SO THAT FINAL C(AC)=0,,0 AND FINAL C(AC+1)=0,,0
  2234
  2235	031672	200 00 0 00 032227 	C40000:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
  2236	031673	200 01 0 00 032227 		MOVE	1,[0,,0]	;PRELOAD AC+1 WITH 0,,0
  2237	031674	245 00 0 00 000007 		ROTC	0,7		;*ROTC SHOULD ROTATE 0,,0 0,,0 LEFT 7 BIT POSITIONS
  2238	031675	312 00 0 00 032227 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
  2239						STOP^
  2240	031676	254 04 0 00 031677 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2241	031677	324 00 0 00 031700 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2242									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2243									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2244									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2245	031700	312 01 0 00 032227 		CAME	1,[0,,0]	;PASS IF C(AC+1)=0,,0
  2246						STOP^
  2247	031701	254 04 0 00 031702 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2248	031702	324 00 0 00 031703 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2249									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2250									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2251									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2252
  2253					;**********
  2254
  2255					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2256					;IN THIS CASE, -1,,-1 -1,,-1  SHOULD BE ROTATED LEFT 7 BIT POSITIONS
  2257					;SO THAT FINAL C(AC)=-1,,-1 AND FINAL C(AC+1)=-1,,-1
  2258
  2259	031703	200 00 0 00 032226 	C40100:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
  2260	031704	200 01 0 00 032226 		MOVE	1,[-1,,-1]	;PRELOAD AC+1 WITH -1,,-1
  2261	031705	245 00 0 00 000007 		ROTC	0,7		;*ROTC SHOULD ROTATE -1,,-1
  2262									;-1,,-1 LEFT 7 BIT POSITIONS
  2263	031706	312 00 0 00 032226 		CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
  2264						STOP^
  2265	031707	254 04 0 00 031710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2266	031710	324 00 0 00 031711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2267									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2268									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2269									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2270	031711	312 01 0 00 032226 		CAME	1,[-1,,-1]	;PASS IF C(AC+1)=-1,,-1
  2271						STOP^
  2272	031712	254 04 0 00 031713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2273	031713	324 00 0 00 031714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2274									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2275									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2276									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2277
  2278					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 37
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0064

  2279					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2280					;IN THIS CASE, 252525,,252525 252525,,252525 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
  2281					;SO THAT FINAL C(AC)=525252,,525252 AND FINAL C(AC+1)=525252,,525252
  2282
  2283	031714	200 00 0 00 032255 	C40200:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
  2284	031715	200 01 0 00 032255 		MOVE	1,[252525,,252525]	;PRELOAD AC+1 WITH 252525,,252525
  2285	031716	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 252525,,252525
  2286										;252525,,252525 LEFT 7 BIT POSITIONS
  2287	031717	312 00 0 00 032256 		CAME	0,[525252,,525252]	;PASS IF C(AC)=525252,,525252
  2288						STOP^
  2289	031720	254 04 0 00 031721 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2290	031721	324 00 0 00 031722 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2291									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2292									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2293									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2294	031722	312 01 0 00 032256 		CAME	1,[525252,,525252]	;PASS IF C(AC+1)=525252,,525252
  2295						STOP^
  2296	031723	254 04 0 00 031724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2297	031724	324 00 0 00 031725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2298									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2299									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2300									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2301
  2302					;**********
  2303
  2304					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2305					;IN THIS CASE, 525252,,525252 525252,,525252 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
  2306					;SO THAT FINAL C(AC)=252525,,252525 AND FINAL C(AC+1)=252525,,252525
  2307
  2308	031725	200 00 0 00 032256 	C40300:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
  2309	031726	200 01 0 00 032256 		MOVE	1,[525252,,525252]	;PRELOAD AC+1 WITH 525252,,525252
  2310	031727	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 525252,,525252
  2311										;525252,,525252 LEFT 7 BIT POSITIONS
  2312	031730	312 00 0 00 032255 		CAME	0,[252525,,252525]	;PASS IF C(AC)=252525,,252525
  2313						STOP^
  2314	031731	254 04 0 00 031732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2315	031732	324 00 0 00 031733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2316									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2317									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2318									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2319	031733	312 01 0 00 032255 		CAME	1,[252525,,252525]	;PASS IF C(AC+1)=252525,,252525
  2320						STOP^
  2321	031734	254 04 0 00 031735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2322	031735	324 00 0 00 031736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2323									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2324									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2325									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2326
  2327					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 38
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0065

  2328					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2329					;IN THIS CASE, 230703,,603700 770037,,600377 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
  2330					;SO THAT FINAL C(AC)=160740,,760176 AND FINAL C(AC+1)=007740,,077646
  2331
  2332	031736	200 00 0 00 032257 	C40400:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
  2333	031737	200 01 0 00 032265 		MOVE	1,[770037,,600377]	;PRELOAD AC+1 WITH 770037,,600377
  2334	031740	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 230703,,603700
  2335										;770037,,600377 LEFT 7 BIT POSITIONS
  2336	031741	312 00 0 00 032273 		CAME	0,[160740,,760176]	;PASS IF C(AC)=160740,,760176
  2337						STOP^
  2338	031742	254 04 0 00 031743 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2339	031743	324 00 0 00 031744 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2340									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2341									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2342									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2343	031744	312 01 0 00 032274 		CAME	1,[007740,,077646]	;PASS IF C(AC+1)=007740,,077646
  2344						STOP^
  2345	031745	254 04 0 00 031746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2346	031746	324 00 0 00 031747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2347									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2348									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2349									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2350
  2351					;**********
  2352
  2353					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
  2354					;IN THIS CASE, 776003,,760077 007603,,607063 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
  2355					;SO THAT FINAL C(AC)=400774,,017610 AND FINAL C(AC+1)=740741,,614577
  2356
  2357	031747	200 00 0 00 032270 	C40500:	MOVE	0,[776003,,760077]	;PRELOAD AC WITH 776003,,760077
  2358	031750	200 01 0 00 032261 		MOVE	1,[007603,,607062]	;PRELOAD AC+1 WITH 007603,,607062
  2359	031751	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 776003,,760077
  2360										;007603,,607062 LEFT 7 BIT POSITIONS
  2361	031752	312 00 0 00 032275 		CAME	0,[400774,,017601]	;PASS IF C(AC)=400774,,017601
  2362						STOP^
  2363	031753	254 04 0 00 031754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2364	031754	324 00 0 00 031755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2365									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2366									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2367									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2368	031755	312 01 0 00 032276 		CAME	1,[740741,,614577]	;PASS IF C(AC+1)=740741,,614577
  2369						STOP^
  2370	031756	254 04 0 00 031757 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2371	031757	324 00 0 00 031760 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2372									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2373									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2374									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2375
  2376					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 39
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0066

  2377					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2378					;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2379					;SO THAT FINAL C(AC)=0,,0.
  2380					;C(AC+1) SHOULD NOT BE AFFECTED
  2381
  2382	031760	200 00 0 00 032227 	C40600:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
  2383	031761	200 01 0 00 032254 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  2384	031762	242 00 0 00 777745 		LSH	0,-33		;*LSH SHOULD LOGICALLY SHIFT 0,,0
  2385									;RIGHT 33 OCTAL BIT POSITIONS
  2386	031763	312 00 0 00 032227 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
  2387						STOP^
  2388	031764	254 04 0 00 031765 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2389	031765	324 00 0 00 031766 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2390									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2391									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2392									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2393	031766	312 01 0 00 032254 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  2394						STOP^
  2395	031767	254 04 0 00 031770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2396	031770	324 00 0 00 031771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2397									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2398									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2399									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2400
  2401					;**********
  2402
  2403					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2404					;IN -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2405					;SO THAT FINAL C(AC)=0,,777.
  2406					;C(AC+1) SHOULD NOT BE AFFECTED
  2407
  2408	031771	200 00 0 00 032226 	C40700:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
  2409	031772	200 01 0 00 032254 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
  2410	031773	242 00 0 00 777745 		LSH	0,-33		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
  2411									;RIGHT 33 OCTAL BIT POSITIONS
  2412	031774	312 00 0 00 032277 		CAME	0,[0,777]	;PASS IF C(AC)=0,,777
  2413						STOP^
  2414	031775	254 04 0 00 031776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2415	031776	324 00 0 00 031777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2416									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2417									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2418									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2419	031777	312 01 0 00 032254 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
  2420						STOP^
  2421	032000	254 04 0 00 032001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2422	032001	324 00 0 00 032002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2423									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2424									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2425									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2426
  2427					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 40
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0067

  2428					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2429					;IN 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2430					;SO THAT FINAL C(AC)=0,,252.
  2431					;C(AC+1) SHOULD NOT BE AFFECTED
  2432
  2433	032002	200 00 0 00 032255 	C41000:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
  2434	032003	200 01 0 00 032254 		MOVE	1,[172737,,405060] 	;PRELOAD AC+1 WITH 172737,,405060
  2435	032004	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
  2436										;RIGHT 33 OCTAL BIT POSITIONS
  2437	032005	312 00 0 00 032300 		CAME	0,[0,,252]		;PASS IF C(AC)=0,,252
  2438						STOP^
  2439	032006	254 04 0 00 032007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2440	032007	324 00 0 00 032010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2441									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2442									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2443									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2444	032010	312 01 0 00 032254 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2445						STOP^
  2446	032011	254 04 0 00 032012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2447	032012	324 00 0 00 032013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2448									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2449									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2450									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2451
  2452					;**********
  2453
  2454					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2455					;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2456					;SO THAT FINAL C(AC)=0,,525.
  2457					;C(AC+1) SHOULD NOT BE AFFECTED
  2458
  2459	032013	200 00 0 00 032256 	C41100:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
  2460	032014	200 01 0 00 032254 		MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
  2461	032015	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
  2462										;RIGHT 33 OCTAL BIT POSITIONS
  2463	032016	312 00 0 00 032301 		CAME	0,[0,,525]		;PASS IF C(AC)=0,,525
  2464						STOP^
  2465	032017	254 04 0 00 032020 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2466	032020	324 00 0 00 032021 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2467									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2468									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2469									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2470	032021	312 01 0 00 032254 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2471						STOP^
  2472	032022	254 04 0 00 032023 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2473	032023	324 00 0 00 032024 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2474									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2475									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2476									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2477
  2478					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 41
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0068

  2479					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2480					;IN THIS CASE, 230703,,603700 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2481					;SO THAT FINAL C(AC)=0,,230.
  2482					;C(AC+1) SHOULD NOT BE AFFECTED
  2483
  2484	032024	200 00 0 00 032257 	C41200:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
  2485	032025	200 01 0 00 032254 		MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
  2486	032026	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
  2487										;RIGHT 33 OCTAL BIT POSITIONS
  2488	032027	312 00 0 00 032302 		CAME	0,[0,,230]		;PASS IF C(AC)=230703,,603700
  2489						STOP^
  2490	032030	254 04 0 00 032031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2491	032031	324 00 0 00 032032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2492									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2493									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2494									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2495	032032	312 01 0 00 032254 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2496						STOP^
  2497	032033	254 04 0 00 032034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2498	032034	324 00 0 00 032035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2499									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2500									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2501									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2502
  2503					;**********
  2504
  2505					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2506					;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2507					;SO THAT FINAL C(AC)=0,,7.
  2508					;C(AC+1) SHOULD NOT BE AFFECTED
  2509
  2510	032035	200 00 0 00 032261 	C41300:	MOVE	0,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
  2511	032036	200 01 0 00 032254 		MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
  2512	032037	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 007603,,6070062
  2513										;RIGHT 33 OCTAL BIT POSITIONS
  2514	032040	312 00 0 00 032252 		CAME	0,[0,,7]		;PASS IF C(AC)=0,,7
  2515						STOP^
  2516	032041	254 04 0 00 032042 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2517	032042	324 00 0 00 032043 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2518									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2519									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2520									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2521	032043	312 01 0 00 032254 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2522						STOP^
  2523	032044	254 04 0 00 032045 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2524	032045	324 00 0 00 032046 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2525									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2526									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2527									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2528
  2529					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 42
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0069

  2530					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2531					;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
  2532					;SO THAT FINAL C(AC)=0,,0.
  2533					;C(AC+1) SHOULD NOT BE AFFECTED
  2534
  2535	032046	200 01 0 00 032227 	C41400:	MOVE	1,[0,,0]	;PRELOAD AC WITH 0,,0
  2536	032047	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2537	032050	242 01 0 00 777751 		LSH	1,-27		;*LSH SHOULD LOGICALLY SHIFT 0,,0
  2538									;RIGHT 27 OCTAL BIT POSITIONS
  2539	032051	312 01 0 00 032227 		CAME	1,[0,,0]	;PASS IF C(AC)=0,,0
  2540						STOP^
  2541	032052	254 04 0 00 032053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2542	032053	324 00 0 00 032054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2543									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2544									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2545									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2546	032054	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2547						STOP^
  2548	032055	254 04 0 00 032056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2549	032056	324 00 0 00 032057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2550									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2551									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2552									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2553
  2554					;**********
  2555
  2556					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2557					;IN THIS CASE, -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
  2558					;SO THAT FINAL C(AC)=0,,17777.
  2559					;C(AC+1) SHOULD NOT BE AFFECTED
  2560
  2561	032057	200 01 0 00 032226 	C41500:	MOVE	1,[-1,,-1]	;PRELOAD AC WITH -1,,-1
  2562	032060	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2563	032061	242 01 0 00 777751 		LSH	1,-27		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
  2564									;RIGHT 27 OCTAL BIT POSITIONS
  2565	032062	312 01 0 00 032303 		CAME	1,[0,,17777]	;PASS IF C(AC)=0,17777
  2566						STOP^
  2567	032063	254 04 0 00 032064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2568	032064	324 00 0 00 032065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2569									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2570									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2571									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2572	032065	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2573						STOP^
  2574	032066	254 04 0 00 032067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2575	032067	324 00 0 00 032070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2576									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2577									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2578									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2579
  2580					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 43
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0070

  2581					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2582					;IN THIS CASE, 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
  2583					;SO THAT FINAL C(AC)=0,,5252.
  2584					;C(AC+1) SHOULD NOT BE AFFECTED
  2585
  2586	032070	200 01 0 00 032255 	C41600:	MOVE	1,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
  2587	032071	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2588	032072	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
  2589										;RIGHT 27 OCTAL BIT POSITIONS
  2590	032073	312 01 0 00 032304 		CAME	1,[0,,5252]		;PASS IF C(AC)=0,,5252
  2591						STOP^
  2592	032074	254 04 0 00 032075 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2593	032075	324 00 0 00 032076 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2594									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2595									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2596									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2597	032076	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2598						STOP^
  2599	032077	254 04 0 00 032100 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2600	032100	324 00 0 00 032101 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2601									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2602									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2603									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2604
  2605					;**********
  2606
  2607					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2608					;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
  2609					;SO THAT FINAL C(AC)=0,,12525.
  2610					;C(AC+1) SHOULD NOT BE AFFECTED
  2611
  2612	032101	200 01 0 00 032256 	C41700:	MOVE	1,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
  2613	032102	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2614	032103	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
  2615										;RIGHT 27 OCTAL BIT POSITIONS
  2616	032104	312 01 0 00 032305 		CAME	1,[0,,12525]		;PASS IF C(AC)=0,,12525
  2617						STOP^
  2618	032105	254 04 0 00 032106 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2619	032106	324 00 0 00 032107 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2620									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2621									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2622									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2623	032107	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2624						STOP^
  2625	032110	254 04 0 00 032111 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2626	032111	324 00 0 00 032112 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2627									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2628									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2629									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2630
  2631					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 44
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0071

  2632					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2633					;IN THIS CASE, 230703,602700 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
  2634					;SO THAT FINAL C(AC)=0,,4616.
  2635					;C(AC+1) SHOULD NOT BE AFFECTED
  2636
  2637	032112	200 01 0 00 032257 	C42000:	MOVE	1,[230703,,603700]	;PRELOAD AC WITH 230703,603700
  2638	032113	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2639	032114	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
  2640										;RIGHT 27 OCTAL BIT POSITIONS
  2641	032115	312 01 0 00 032306 		CAME	1,[0,,4616]		;PASS IF C(AC)=0,,4616
  2642						STOP^
  2643	032116	254 04 0 00 032117 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2644	032117	324 00 0 00 032120 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2645									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2646									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2647									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2648	032120	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2649						STOP^
  2650	032121	254 04 0 00 032122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2651	032122	324 00 0 00 032123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2652									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2653									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2654									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2655
  2656					;**********
  2657
  2658					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2659					;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
  2660					;SO THAT FINAL C(AC)=0,,174.
  2661					;C(AC+1) SHOULD NOT BE AFFECTED
  2662
  2663	032123	200 01 0 00 032261 	C42100:	MOVE	1,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
  2664	032124	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2665	032125	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 007603,,607062
  2666										;RIGHT 27 OCTAL BIT POSITIONS
  2667	032126	312 01 0 00 032307 		CAME	1,[0,,174]		;PASS IF C(AC)=0,,174
  2668						STOP^
  2669	032127	254 04 0 00 032130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2670	032130	324 00 0 00 032131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2671									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2672									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2673									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2674	032131	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2675						STOP^
  2676	032132	254 04 0 00 032133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2677	032133	324 00 0 00 032134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2678									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2679									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2680									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2681
  2682					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 45
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0072

  2683					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2684					;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2685					;SO THAT FINAL C(AC)=0,,0.
  2686					;C(AC+1) SHOULD NOT BE AFFECTED
  2687
  2688	032134	200 01 0 00 032227 	C42200:	MOVE	1,[0,0]		;PRELOAD AC WITH 0,,0
  2689	032135	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2690	032136	242 01 0 00 777745 		LSH	1,-33		;*LSH SHOULD LOGICALLY SHIFT 0,,0
  2691									;RIGHT 33 OCTAL BIT POSITIONS
  2692	032137	312 01 0 00 032227 		CAME	1,[0,,0]	;PASS IF C(AC)=0,,0
  2693						STOP^
  2694	032140	254 04 0 00 032141 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2695	032141	324 00 0 00 032142 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2696									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2697									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2698									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2699	032142	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2700						STOP^
  2701	032143	254 04 0 00 032144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2702	032144	324 00 0 00 032145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2703									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2704									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2705									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2706
  2707					;**********
  2708
  2709					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2710					;IN THIS CASE, -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2711					;SO THAT FINAL C(AC)=0,,777.
  2712					;C(AC+1) SHOULD NOT BE AFFECTED
  2713
  2714	032145	200 01 0 00 032226 	C42300:	MOVE	1,[-1,,-1]	;PRELOAD AC WITH -1,,-1
  2715	032146	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2716	032147	242 01 0 00 777745 		LSH	1,-33		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
  2717									;RIGHT 33 OCTAL BIT POSITIONS
  2718	032150	312 01 0 00 032277 		CAME	1,[0,,777]	;PASS IF C(AC)=0,,777
  2719						STOP^
  2720	032151	254 04 0 00 032152 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2721	032152	324 00 0 00 032153 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2722									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2723									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2724									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2725	032153	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2726						STOP^
  2727	032154	254 04 0 00 032155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2728	032155	324 00 0 00 032156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2729									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2730									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2731									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2732
  2733					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 46
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0073

  2734					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2735					;IN THIS CASE, 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2736					;SO THAT FINAL C(AC)=0,,252.
  2737					;C(AC+1) SHOULD NOT BE AFFECTED
  2738
  2739	032156	200 01 0 00 032255 	C42400:	MOVE	1,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
  2740	032157	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2741	032160	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
  2742										;RIGHT 33 OCTAL BIT POSITIONS
  2743	032161	312 01 0 00 032300 		CAME	1,[0,,252]		;PASS IF C(AC)=0,,252
  2744						STOP^
  2745	032162	254 04 0 00 032163 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2746	032163	324 00 0 00 032164 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2747									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2748									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2749									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2750	032164	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2751						STOP^
  2752	032165	254 04 0 00 032166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2753	032166	324 00 0 00 032167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2754									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2755									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2756									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2757
  2758					;**********
  2759
  2760					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2761					;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2762					;SO THAT FINAL C(AC)=0,,525.
  2763					;C(AC+1) SHOULD NOT BE AFFECTED
  2764
  2765	032167	200 01 0 00 032256 	C42500:	MOVE	1,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
  2766	032170	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2767	032171	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
  2768										;RIGHT 33 OCTAL BIT POSITIONS
  2769	032172	312 01 0 00 032301 		CAME	1,[0,,525]		;PASS IF C(AC)=0,525
  2770						STOP^
  2771	032173	254 04 0 00 032174 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2772	032174	324 00 0 00 032175 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2773									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2774									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2775									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2776	032175	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2777						STOP^
  2778	032176	254 04 0 00 032177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2779	032177	324 00 0 00 032200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2780									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2781									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2782									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2783
  2784					;**********
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 47
DAKAGM	MAC	19-JAN-77 17:37		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER                        SEQ 0074

  2785					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2786					;IN THIS CASE, 230703,,603700 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2787					;SO THAT FINAL C(AC)=0,,230.
  2788					;C(AC+1) SHOULD NOT BE AFFECTED
  2789
  2790	032200	200 01 0 00 032257 	C42600:	MOVE	1,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
  2791	032201	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2792	032202	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
  2793										;RIGHT 33 OCTAL BIT POSITIONS
  2794	032203	312 01 0 00 032302 		CAME	1,[0,,230]		;PASS IF C(AC)=0,,230
  2795						STOP^
  2796	032204	254 04 0 00 032205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2797	032205	324 00 0 00 032206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2798									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2799									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2800									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2801	032206	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2802						STOP^
  2803	032207	254 04 0 00 032210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2804	032210	324 00 0 00 032211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2805									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2806									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2807									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2808
  2809					;**********
  2810
  2811					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
  2812					;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
  2813					;SO THAT FINAL C(AC)=0,,7.
  2814					;C(AC+1) SHOULD NOT BE AFFECTED
  2815
  2816	032211	200 01 0 00 032261 	C42700:	MOVE	1,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
  2817	032212	200 02 0 00 032254 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
  2818	032213	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 007603,,607062
  2819										;RIGHT 33 OCTAL BIT POSITIONS
  2820	032214	312 01 0 00 032252 		CAME	1,[0,,7]		;PASS IF C(AC)=0,,7
  2821						STOP^
  2822	032215	254 04 0 00 032216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2823	032216	324 00 0 00 032217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2824									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2825									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2826									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2827	032217	312 02 0 00 032254 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
  2828						STOP^
  2829	032220	254 04 0 00 032221 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2830	032221	324 00 0 00 032222 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
  2831									;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
  2832									;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
  2833									;AND CHANGE HALT INSTRUCTION TO JUMPA .+1^
  2834
  2835	032222	254 00 0 00 030057 		JRST	BEGEND		;REPEAT TEST
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 1
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 0075

  2836					SUBTTL	*STOR* RESERVED STORAGE, JAN 18,1977
  2837
  2838					;PROGRAM LITERALS
  2839
  2840						XLIST
  2841					IFNDEF	$LPAPER,<LIST>
  2842	032223					LIT
  2843	032223	000001	000001
  2844	032224	254 00 0 00 030741
  2845	032225	000016	541320
  2846	032226	777777	777777
  2847	032227	000000	000000
  2848	032230	000002	000000
  2849	032231	000001	000002
  2850	032232	000002	000002
  2851	032233	000001	000017
  2852	032234	312 00 0 00 000001
  2853	032235	256 00 0 00 032234
  2854	032236	256 00 0 00 032235
  2855	032237	254 00 0 00 031304
  2856	032240	265 03 0 00 031311
  2857	032241	256 00 0 00 032240
  2858	032242	256 00 0 00 032241
  2859	032243	270 06 0 04 000001
  2860	032244	331 01 0 00 000002
  2861	032245	331 03 0 00 000006
  2862	032246	777776	000005
  2863	032247	253 03 0 00 031355
  2864	032250	777777	000006
  2865	032251	253 03 0 00 031363
  2866	032252	000000	000007
  2867	032253	000000	707070
  2868	032254	172737	405060
  2869	032255	252525	252525
  2870	032256	525252	525252
  2871	032257	230703	603700
  2872	032260	023070	360370
  2873	032261	007603	607062
  2874	032262	200760	360706
  2875	032263	074076	004616
  2876	032264	074161	440174
  2877	032265	770037	600377
  2878	032266	307036	037007
  2879	032267	700376	003772
  2880	032270	776003	760077
  2881	032271	760037	600770
  2882	032272	076036	070627
  2883	032273	160740	760176
  2884	032274	007740	077646
  2885	032275	400774	017601
  2886	032276	740741	614577
  2887	032277	000000	000777
  2888	032300	000000	000252
  2889	032301	000000	000525
  2890	032302	000000	000230
DAKAG PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7) 0,2	MACRO %52(537) 10:20 20-JAN-77 PAGE 1-1
STOR	KLM	18-JAN-77 11:42		*STOR* RESERVED STORAGE, JAN 18,1977                                               SEQ 0076

  2891	032303	000000	017777
  2892	032304	000000	005252
  2893	032305	000000	012525
  2894	032306	000000	004616
  2895	032307	000000	000174
  2896						LIST
  2897	032310	000000	000000		ENDSLD:	0
  2898
  2899					IFDEF	DEBUG,<
  2900	032311				PATCH:	BLOCK DEBUG		;PATCHING AREA
  2901					>
  2902
  2903					;PROGRAM VARIABLES
  2904	032411					VAR
  2905
  2906					IFDEF	PGMEND,<
  2907	032411	000000	000000		END:	0
  2908			030000			END	BEGIN	>

NO ERRORS DETECTED

PROGRAM BREAK IS 000000
ABSLUTE BREAK IS 032412
CPU TIME USED 00:13.678

10K CORE USED
