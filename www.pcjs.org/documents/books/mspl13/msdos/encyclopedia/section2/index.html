<!DOCTYPE html>
<html lang="en-US">
  <!--
   _____   _____ _
  |  __ \ / ____(_)
  | |__) | |     _ ___
  |  ___/| |    | / __|
  | |    | |____| \__ \
  |_|     \_____| |___/
               _/ |
              |__/
  -->

  
<!-- Mirrored from www.pcjs.org/documents/books/mspl13/msdos/encyclopedia/section2/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 30 Nov 2022 13:05:44 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>The MS-DOS Encyclopedia: Section II: Programming in the MS-DOS Environment | PCjs Machines</title>
    <meta name="description" content="Home of the original IBM PC emulator for browsers. PCjs offers a variety of online machine emulators written in JavaScript. Run DOS, Windows, OS/2 and other vintage PC applications in a web browser on your desktop computer, iPhone, or iPad. An assortment of microcomputers, minicomputers, terminals, programmable calculators, and arcade machines are available, along with an archive of historical software and documentation.">
    <meta name="apple-mobile-web-app-title" content="PCjs Machines">
    <meta name="twitter:title" property="og:title" content="The MS-DOS Encyclopedia: Section II: Programming in the MS-DOS Environment">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@jeffpar">
    <meta name="twitter:image" property="og:image" content="../../../../../../assets/img/logo-home.png">
    <link rel="canonical" href="index.html">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../../../../assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="180x180" href="../../../../../../assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../../../assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../../../assets/icons/favicon-16x16.png">
    <link rel="manifest" href="../../../../../../assets/icons/site.webmanifest">
    <link rel="mask-icon" href="../../../../../../assets/icons/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="../../../../../../assets/icons/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="../../../../../../assets/icons/browserconfig.xml">
    <link rel="stylesheet" href="../../../../../../assets/css/style60f2.css?v=cbc86f1f4eee442a9c361804aff3eb42dedeeb16">
    <link rel="stylesheet" href="../../../../../../machines/pcx86/xsl/components.css">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="wrapper">
      <header>
        <h1 id="pcjs-machines"><a href="../../../../../../index.html">PCjs Machines</a></h1>
        <p>Home of the original IBM PC emulator for browsers.</p>
        <ul class="menu">
          <li><a href="../../../../../../about/index.html">About</a></li>
          <li><a href="../../../../../../blog/index.html">Blog</a></li>
          <li class="optional"><a href="#pcjs-explorer" onclick="pcjsExplorerView(this, event)">Explorer</a></li>
          <li><a href="https://github.com/jeffpar/pcjs">Repository</a></li>
        </ul>
        <a href="../../../../../../software/pcx86/index.html"><img src="../../../../../../assets/img/logo-home.png" alt="Logo" /></a>
      </header>
      <section>
        <h2 id="pcjs-heading">The MS-DOS Encyclopedia</h2>

<h3 id="section-ii-programming-in-the-ms-dos-environment">Section II: Programming in the MS-DOS Environment</h3>

<pre><code class="language-none">Part A  Structure of MS-DOS


Article 1:  An Introduction to MS-DOS


    An operating system is a set of interrelated supervisory programs that
    manage and control computer processing. In general, an operating
    system provides

    ■  Storage management
    ■  Processing management
    ■  Security
    ■  Human interface

    Existing operating systems for microcomputers fall into three major
    categories: ROM monitors, traditional operating systems, and operating
    environments. The general characteristics of the three categories are
    listed in Table 1-1.


    Table 1-1. Characteristics of the Three Major Types of
                Operating Systems.

╓┌──────────────────────────┌─────────────┌─────────────┌────────────────────╖
                                        Traditional
                        ROM           Operating     Operating
                        Monitor       System        Environment
    ──────────────────────────────────────────────────────────────────
    Complexity            Low           Medium        High
    Built on              Hardware      BIOS          Operating system
    Delivered on          ROM           Disk          Disk
    Programs on           ROM           Disk          Disk
    Peripheral support    Physical      Logical       Logical
    Disk access           Sector        File system   File system
    Example               PC ROM BIOS   MS-DOS        Microsoft Windows


    A ROM monitor is the simplest type of operating system. It is designed
    for a particular hardware configuration and provides a program with
    basic--and often direct--access to peripherals attached to the
    computer. Programs coupled with a ROM monitor are often used for
    dedicated applications such as controlling a microwave oven or
    controlling the engine of a car.

    A traditional microcomputer operating system is built on top of a ROM
    monitor, or BIOS (basic input/output system), and provides additional
    features such as a file system and logical access to peripherals.
    (Logical access to peripherals allows applications to run in a
    hardware-independent manner.) A traditional operating system also
    stores programs in files on peripheral storage devices and, on
    request, loads them into memory for execution. MS-DOS is a traditional
    operating system.

    An operating environment is built on top of a traditional operating
    system. The operating environment provides additional services, such
    as common menu and forms support, that simplify program operation and
    make the user interface more consistent. Microsoft Windows is an
    operating environment.


MS-DOS System Components

    The Microsoft Disk Operating System, MS-DOS, is a traditional
    microcomputer operating system that consists of five major components:

    ■  The operating-system loader
    ■  The MS-DOS BIOS
    ■  The MS-DOS kernel
    ■  The user interface (shell)
    ■  Support programs

    Each of these is introduced briefly in the following pages. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: STRUCTURE OF MS-DOS: The
    Components of MS-DOS.

The operating-system loader

    The operating-system loader brings the operating system from the
    startup disk into RAM.

    The complete loading process, called bootstrapping, is often complex,
    and multiple loaders may be involved. (The term bootstrapping came
    about because each level pulls up the next part of the system, like
    pulling up on a pair of bootstraps.) For example, in most standard
    MS-DOS-based microcomputer implementations,  the ROM loader, which is
    the first program the microcomputer executes when it is turned on or
    restarted, reads the disk bootstrap loader from the first (boot)
    sector of the startup disk and executes it. The disk bootstrap loader,
    in turn, reads the main portions of MS-DOS--MSDOS.SYS and IO.SYS
    (IBMDOS.COM and IBMBIO.COM with PC-DOS)--from conventional disk files
    into memory. The special module SYSINIT within MSDOS.SYS then
    initializes MS-DOS's tables and buffers and discards itself. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: STRUCTURE OF MS-DOS: MS-DOS
    Storage Devices.

    (The term loader is also used to refer to the portion of the operating
    system that brings application programs into memory for execution.
    This loader is different from the ROM loader and the operating-system
    loader.)

The MS-DOS BIOS

    The MS-DOS BIOS, loaded from the file IO.SYS during system
    initialization, is the layer of the operating system that sits between
    the operating-system kernel and the hardware. An application performs
    input and output by making requests to the operating-system kernel,
    which, in turn, calls the MS-DOS BIOS routines that access the
    hardware directly. See SYSTEM CALLS. This division of function allows
    application programs to be written in a hardware-independent manner.

    The MS-DOS BIOS consists of some initialization code and a collection
    of device drivers. (A device driver is a specialized program that
    provides support for a specific device such as a display or serial
    port.) The device drivers are responsible for hardware access and for
    the interrupt support that allows the associated devices to signal the
    microprocessor that they need service.

    The device drivers contained in the file IO.SYS, which are always
    loaded during system initialization, are sometimes referred to as the
    resident drivers. With MS-DOS versions 2.0 and later, additional
    device drivers, called installable drivers, can optionally be loaded
    during system initialization as a result of DEVICE directives in the
    system's configuration file. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: CUSTOMIZING MS-DOS: Installable Device Drivers; USER
    COMMANDS: CONFIG.SYS:DEVICE.

The MS-DOS kernel

    The services provided to application programs by the MS-DOS kernel
    include

    ■  Process control
    ■  Memory management
    ■  Peripheral support
    ■  A file system

    The MS-DOS kernel is loaded from the file MSDOS.SYS during system
    initialization.

Process control
    Process, or task, control includes program loading, task execution,
    task termination, task scheduling, and intertask communication.

    Although MS-DOS is not a multitasking operating system, it can have
    multiple programs residing in memory at the same time. One program can
    invoke another, which then becomes the active (foreground) task. When
    the invoked task terminates, the invoking program again becomes the
    foreground task. Because these tasks never execute simultaneously,
    this stack-like operation is still considered to be a single-tasking
    operating system.

    MS-DOS does have a few "hooks" that allow certain programs to do some
    multitasking on their own. For example, terminate-and-stay-resident
    (TSR) programs such as PRINT use these hooks to perform limited
    concurrent processing by taking control of system resources while
    MS-DOS is "idle," and the Microsoft Windows operating environment adds
    support for nonpreemptive task switching.

    The traditional intertask communication methods include semaphores,
    queues, shared memory, and pipes. Of these, MS-DOS formally supports
    only pipes. (A pipe is a logical, unidirectional, sequential stream of
    data that is written by one program and read by another.) The data in
    a pipe resides in memory or in a disk file, depending on the
    implementation; MS-DOS uses disk files for intermediate storage of
    data in pipes because it is a single-tasking operating system.

Memory management
    Because the amount of memory a program needs varies from program to
    program, the traditional operating system ordinarily provides memory-
    management functions. Memory requirements can also vary during program
    execution, and memory management is especially necessary when two or
    more programs are present in memory at the same time.

    MS-DOS memory management is based on a pool of variable-size memory
    blocks. The two basic memory-management actions are to allocate a
    block from the pool and to return an allocated block to the pool.
    MS-DOS allocates program space from the pool when the program is
    loaded; programs themselves can allocate additional memory from the
    pool. Many programs perform their own memory management by using a
    local memory pool, or heap--an additional memory block allocated from
    the operating system that the application program itself divides into
    blocks for use by its various routines. See PROGRAMMING IN
    THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: Memory Management.

Peripheral support
    The operating system provides peripheral support to programs through a
    set of operating-system calls that are translated by the operating
    system into calls to the appropriate device driver.

    Peripheral support can be a direct logical-to-physical-device
    translation or the operating system can interject additional features
    or translations. Keyboards, displays, and printers usually require
    only logical-to-physical-device translations; that is, the data is
    transferred between the application program and the physical device
    with minimal alterations, if any, by the operating system. The data
    provided by clock devices, on the other hand, must be transformed to
    operating-system-dependent time and date formats. Disk devices--and
    block devices in general--have the greatest number of features added
    by the operating system. See The File System, below.

    As stated earlier, an application need not be concerned with the
    details of peripheral devices or with any special features the devices
    might have. Because the operating system takes care of all the
    logical-to-physical-device translations, the application program need
    only make requests of the operating system.

The file system
    The file system is one of the largest portions of an operating system.
    A file system is built on the storage medium of a block device
    (usually a floppy disk or a fixed disk) by mapping a directory
    structure and files onto the physical unit of storage. A file system
    on a disk contains, at a minimum, allocation information, a directory,
    and space for files. See PROGRAMMING IN THE MS-DOS ENVIRONMENT:
    STRUCTURE OF MS-DOS: MS-DOS Storage Devices.

    The file allocation information can take various forms, depending on
    the operating system, but all forms basically track the space used by
    files and the space available for new data. The directory contains a
    list of the files stored on the device, their sizes, and information
    about where the data for each file is located.

    Several different approaches to file allocation and directory entries
    exist. MS-DOS uses a particular allocation method called a file
    allocation table (FAT) and a hierarchical directory structure. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: STRUCTURE OF MS-DOS: MS-DOS
    Storage Devices; PROGRAMMING FOR MS-DOS: Disk Directories and Volume
    Labels.

    The file granularity available through the operating system also
    varies depending on the implementation. Some systems, such as MS-DOS,
    have files that are accessible to the byte level; others are
    restricted to a fixed record size.

    File systems are sometimes extended to map character devices as if
    they were files. These device "files" can be opened, closed, read
    from, and written to like normal disk files, but all transactions
    occur directly with the specified character device. Device files
    provide a useful consistency to the environment for application
    programs; MS-DOS supports such files by assigning a reserved logical
    name (such as CON or PRN) to each character device.

The user interface

    The user interface for an operating system, also called a shell or
    command processor, is generally a conventional program that allows the
    user to interact with the operating system itself. The default MS-DOS
    user interface is a replaceable shell program called COMMAND.COM.

    One of the fundamental tasks of a shell is to load a program into
    memory on request and pass control of the system to the program so
    that the program can execute. When the program terminates, control
    returns to the shell, which prompts the user for another command. In
    addition, the shell usually includes functions for file and directory
    maintenance and display. In theory, most of these functions could be
    provided as programs, but making them resident in the shell allows
    them to be accessed more quickly. The tradeoff is memory space versus
    speed and flexibility. Early microcomputer-based operating systems
    provided a minimal number of resident shell commands because of
    limited memory space; modern operating systems such as MS-DOS include
    a wide variety of these functions as internal commands.

Support programs

    The MS-DOS software includes support programs that provide access to
    operating-system facilities not supplied as resident shell commands
    built into COMMAND.COM. Because these programs are stored as
    executable files on disk, they are essentially the same as application
    programs and MS-DOS loads and executes them as it would any other
    program.

    The support programs provided with MS-DOS, often referred to as
    external commands, include disk utilities such as FORMAT and CHKDSK
    and more general support programs such as EDLIN (a line-oriented text
    editor) and PRINT (a TSR utility that allows files to be printed while
    another program is running). See USER COMMANDS.

MS-DOS releases

    MS-DOS and PC-DOS have been released in a number of forms, starting in
    1981. See THE DEVELOPMENT OF MS-DOS. The major MS-DOS and PC-DOS
    implementations are summarized in the following table.

╓┌────────────────────────┌─────────┌────────────────────────────────────────╖
    Version             Date      Special Characteristics
    ──────────────────────────────────────────────────────────────────
    PC-DOS 1.0          1981      First operating system for the IBM
                                PC Record-oriented files

    PC-DOS 1.1          1982      Double-sided-disk support

    MS-DOS 1.25         1982      First OEM release of MS-DOS

    MS-DOS/PC-DOS 2.0   1983      Operating system for the IBM
                                PC/XT UNIX/XENIX-like file system
                                Installable device drivers
                                Byte-oriented files
                                Support for fixed disks

    PC-DOS 2.1                    Operating system for the IBM PCjr

    MS-DOS 2.11                   Internationalization support 2.0x bug
                                fixes

    MS-DOS/PC-DOS 3.0   1984      Operating system for the IBM PC/AT
                                Support for 1.2 MB floppy disks
                                Support for large fixed disks
                                Support for file and record locking
                                Application control of print spooler

    MS-DOS/PC-DOS 3.1   1984      Support for MS Networks

    MS-DOS/PC-DOS 3.2   1986      3.5-inch floppy-disk support
                                Disk track formatting support added
                                to device drivers

    MS-DOS/PC-DOS 3.3   1987      Support for the IBM PS/2
                                Enhancedinternationalization support
                                Improved file-system performance
                                Partitioning support for disks with
                                capacity above 32 MB

    PC-DOS version 1.0 was the first commercial version of MS-DOS. It was
    developed for the original IBM PC, which was typically shipped with 64
    KB of memory or less. MS-DOS and PC-DOS versions 1.x were similar in
    many ways to CP/M, the popular operating system for 8-bit
    microcomputers based on the Intel 8080 (the predecessor of the 8086).
    These versions of MS-DOS used a single-level file system with no
    subdirectory support and did not support installable device drivers or
    networks. Programs accessed files using file control blocks (FCBs)
    similar to those found in CP/M programs. File operations were record
    oriented, again like CP/M, although record sizes could be varied in
    MS-DOS.

    Although they retained compatibility with versions 1.x, MS-DOS and
    PC-DOS versions 2.x represented a major change. In addition to
    providing support for fixed disks, the new versions switched to a
    hierarchical file system like that found in UNIX/XENIX and to file-
    handle access instead of FCBs. (A file handle is a 16-bit number used
    to reference an internal table that MS-DOS uses to keep track of
    currently open files; an application program has no access to this
    internal table.) The UNIX/XENIX-style file functions allow files to be
    treated as a byte stream instead of as a collection of records.
    Applications can read or write 1 to 65535 bytes in a single operation,
    starting at any byte offset within the file. Filenames used for
    opening a files are passed as text strings instead of being parsed
    into an FCB. Installable device drivers were another major
    enhancement.

    MS-DOS and PC-DOS versions 3.x added a number of valuable features,
    including support for the added capabilities of the IBM PC/AT, for
    larger-capacity disks, and for file-locking and record-locking
    functions. Network support was added by providing hooks for a
    redirector (an additional operating-system module that has the ability
    to redirect local system service requests to a remote system by means
    of a local area network).

    With all these changes, MS-DOS remains a traditional single-tasking
    operating system. It provides a large number of system services in a
    transparent fashion so that, as long as they use only the MS-DOS-
    supplied services and refrain from using hardware-specific operations,
    applications developed for one MS-DOS machine can usually run on
    another.


Basic MS-DOS Requirements

    Foremost among the requirements for MS-DOS is an Intel 8086-compatible
    microprocessor. See Specific Hardware Requirements below.

    The next requirement is the ROM bootstrap loader and enough RAM to
    contain the MS-DOS BIOS, kernel, and shell and an application program.
    The RAM must start at address 0000:0000H and, to be managed by MS-DOS,
    must be contiguous. The upper limit for RAM is the limit placed upon
    the system by the 8086 family--1 MB.

    The final requirement for MS-DOS is a set of devices supported by
    device drivers, including at least one block device, one character
    device, and a clock device. The block device is usually the boot disk
    device (the disk device from which MS-DOS is loaded); the character
    device is usually a keyboard/display combination for interaction with
    the user; the clock device, required for time-of-day and date support,
    is a hardware counter driven in a submultiple of one second.

Specific hardware requirements

    MS-DOS uses several hardware components and has specific requirements
    for each. These components include

    ■  An 8086-family microprocessor
    ■  Memory
    ■  Peripheral devices
    ■  A ROM BIOS (PC-DOS only)

The microprocessor
    MS-DOS runs on any machine that uses a microprocessor that executes
    the 8086/8088 instruction set, including the Intel 8086, 80C86, 8088,
    80186, 80188, 80286, and 80386 and the NEC V20, V30, and V40.

    The 80186 and 80188 are versions of the 8086 and 8088, integrated in a
    single chip with direct memory access, timer, and interrupt support
    functions. PC-DOS cannot usually run on the 80186 or 80188 because
    these chips have internal interrupt and interface register addresses
    that conflict with addresses used by the PC ROM BIOS. See PROGRAMMING
    IN THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Hardware Interrupt
    Handlers. MS-DOS, however, does not have address requirements that
    conflict with those interrupt and interface areas.

    The 80286 has an extended instruction set and two operating modes:
    real and protected. Real mode is compatible with the 8086/8088 and
    runs MS-DOS. Protected mode, used by operating systems like UNIX/XENIX
    and MS OS/2, is partially compatible with real mode in terms of
    instructions but provides access to 16 MB of memory versus only 1 MB
    in real mode (the limit of the 8086/8088).

    The 80386 adds further instructions and a third mode called virtual 86
    mode. The 80386 instructions operate in either a 16-bit or a 32-bit
    environment. MS-DOS can run on the 80386 in real or virtual 86 mode,
    although the latter requires additional support in the form of a
    virtual machine monitor such as Windows /386.

Memory requirements
    At a minimum, MS-DOS versions 1.x require 64 KB of contiguous RAM from
    the base of memory to do useful work; versions 2.x and 3.x need at
    least 128 KB. The maximum is 1 MB, although most MS-DOS machines have
    a 640 KB limit for IBM PC compatibility. MS-DOS can use additional
    noncontiguous RAM for a RAMdisk if the proper device driver is
    included. (Other uses for noncontiguous RAM include buffers for video
    displays, fixed disks, and network adapters.)

    PC-DOS has the same minimum memory requirements but has an upper limit
    of 640 KB on the initial contiguous RAM, which is generally referred
    to as conventional memory. This limit was imposed by the architecture
    of the original IBM PC, with the remaining area above 640 KB reserved
    for video display buffers, fixed disk adapters, and the ROM BIOS. Some
    of the reserved areas include

╓┌──────────────────────┌─────────────────────┌──────────────────────────────╖
    Base Address      Size (bytes)          Description
    ──────────────────────────────────────────────────────────────────
    A000:0000H        10000H (64 KB)        EGA video buffer
    B000:0000H        1000H (4 KB)          Monochrome video buffer
    B800:0000H        4000H (16 KB)         Color/graphics video buffer
    C800:0000H        4000H (16 KB)         Fixed-disk ROM
    F000:0000H        10000H (64 KB)        PC ROM BIOS and ROM BASIC

    The bottom 1024 bytes of system RAM (locations 00000-003FFH) are used
    by the microprocessor for an interrupt vector table--that is, a list
    of addresses for interrupt handler routines. MS-DOS uses some of the
    entries in this table, such as the vectors for interrupts 20H through
    2FH, to store addresses of its own tables and routines and to provide
    linkage to its services for application programs. The IBM PC ROM BIOS
    and IBM PC BASIC use many additional vectors for the same purposes.

Peripheral devices
    MS-DOS can support a wide variety of devices, including floppy disks,
    fixed disks, CD ROMs, RAMdisks, and digital tape drives. The required
    peripheral support for MS-DOS is provided by the MS-DOS BIOS or by
    installable device drivers.

    Five logical devices are provided in a basic MS-DOS system:

╓┌────────────────────────────┌──────────────────────────────────────────────╖
    Device Name             Description
    ──────────────────────────────────────────────────────────────────
    CON                     Console input and output

    PRN                     Printer output

    AUX                     Auxiliary input and output

    CLOCK$                  Date and time support

    Varies (A-E)            One block device

    These five logical devices can be implemented with a BIOS supporting a
    minimum of three physical devices: a keyboard and display, a timer or
    clock/calendar chip that can provide a hardware interrupt at regular
    intervals, and a block storage device. In such a minimum case, the
    printer and auxiliary device are simply aliases for the console
    device. However, most MS-DOS systems support several additional
    logical and physical devices. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: Character Device Input and
    Output.

    The MS-DOS kernel provides one additional device: the NUL device. NUL
    is a "bit bucket"--that is, anything written to NUL is simply
    discarded. Reading from NUL always returns an end-of-file marker. One
    common use for the NUL device is as the redirected output device of a
    command or application that is being run in a batch file; this
    redirection prevents screen clutter and disruption of the batch file's
    menus and displays.

The ROM BIOS
    MS-DOS requires no ROM support (except that most bootstrap loaders
    reside in ROM) and does not care whether device-driver support resides
    in ROM or is part of the MS-DOS IO.SYS file loaded at initialization.
    PC-DOS, on the other hand, uses a very specific ROM BIOS. The PC ROM
    BIOS does not provide device drivers; rather, it provides support
    routines used by the device drivers found in IBMBIO.COM (the PC-DOS
    version of IO.SYS). The support provided by a PC ROM BIOS includes

    ■  Power-on self test (POST)
    ■  Bootstrap loader
    ■  Keyboard
    ■  Displays (monochrome and color/graphics adapters)
    ■  Serial ports 1 and 2
    ■  Parallel printer ports 1, 2, and 3
    ■  Clock
    ■  Print screen

    The PC ROM BIOS loader routine searches the ROM space above the PC-DOS
    640 KB limit for additional ROMs. The IBM fixed-disk adapter and
    enhanced graphics adapter (EGA) contain such ROMs. (The fixed-disk ROM
    also includes an additional loader routine that allows the system to
    start from the fixed disk.)


Summary

    MS-DOS is a widely accepted traditional operating system. Its
    consistent and well-defined interface makes it one of the easier
    operating systems to adapt and program.

    MS-DOS is also a growing operating system--each version has added more
    features yet made the system easier to use for both end-users and
    programmers. In addition, each version has included more support for
    different devices, from 5.25-inch floppy disks to high-density 3.5-
    inch floppy disks. As the hardware continues to evolve and user needs
    become more sophisticated, MS-DOS too will continue to evolve.

                                                William Wong



Article 2:  The Components of MS-DOS


    MS-DOS is a modular operating system consisting of multiple components
    with specialized functions. When MS-DOS is copied into memory during
    the loading process, many of its components are moved, adjusted, or
    discarded. However, when it is running, MS-DOS is a relatively static
    entity and its components are predictable and easy to study.
    Therefore, this article deals first with MS-DOS in its running state
    and later with its loading behavior.


The Major Elements

    MS-DOS consists of three major modules:

╓┌────────────────────────────┌───────────────────────┌──────────────────────╖
    Module                  MS-DOS Filename         PC-DOS Filename
    ──────────────────────────────────────────────────────────────────
    MS-DOS BIOS             IO.SYS                  IBMBIO.COM

    MS-DOS kernel           MSDOS.SYS               IBMDOS.COM

    MS-DOS shell            COMMAND.COM             COMMAND.COM

    During system initialization, these modules are loaded into memory, in
    the order given, just above the interrupt vector table located at the
    beginning of memory. All three modules remain in memory until the
    computer is reset or turned off. (The loader and system initialization
    modules are omitted from this list because they are discarded as soon
    as MS-DOS is running. See Loading MS-DOS, below.)

    The MS-DOS BIOS is supplied by the original equipment manufacturer
    (OEM) that distributes MS-DOS, usually for a particular computer. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: STRUCTURE OF MS-DOS: An
    Introduction to MS-DOS. The kernel is supplied by Microsoft and is the
    same across all OEMs for a particular version of MS-DOS--that is, no
    modifications are made by the OEM. The shell is a replaceable module
    that can be supplied by the OEM or replaced by the user; the default
    shell, COMMAND.COM, is supplied by Microsoft.

The MS-DOS BIOS

    The file IO.SYS contains the MS-DOS BIOS and the MS-DOS initialization
    module, SYSINIT. The MS-DOS BIOS is customized for a particular
    machine by an OEM. SYSINIT is supplied by Microsoft and is put into
    IO.SYS by the OEM when the file is created. See Loading MS-DOS, below.

    The MS-DOS BIOS consists of a list of resident device drivers and an
    additional initialization module created by the OEM. The device
    drivers appear first in IO.SYS because they remain resident after
    IO.SYS is initialized; the MS-DOS BIOS initialization routine and
    SYSINIT are usually discarded after initialization.

    The minimum set of resident device drivers is CON, PRN, AUX, CLOCK$,
    and the driver for one block device. The resident character-device
    drivers appear in the driver list before the resident block-device
    drivers; installable character-device drivers are placed ahead of the
    resident device drivers in the list; installable block-device drivers
    are placed after the resident device drivers in the list. This
    sequence allows installable character-device drivers to supersede
    resident drivers. The NUL device driver, which must be the first
    driver in the chain, is contained in the MS-DOS kernel.

    Device driver code can be split between IO.SYS and ROM. For example,
    most MS-DOS systems and all PC-DOS-compatible systems have a ROM BIOS
    that contains primitive device support routines. These routines are
    generally used by resident and installable device drivers to augment
    routines contained in RAM. (Placing the entire driver in RAM makes the
    driver dependent on a particular hardware configuration; placing part
    of the driver in ROM allows the MS-DOS BIOS to be paired with a
    particular ROM interface that remains constant for many different
    hardware configurations.)

    The IO.SYS file is an absolute program image and does not contain
    relocation information. The routines in IO.SYS assume that the CS
    register contains the segment at which the file is loaded. Thus,
    IO.SYS has the same 64 KB restriction as a .COM file. See PROGRAMMING
    IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: Structure of an
    Application Program. Larger IO.SYS files are possible, but all device
    driver headers must lie in the first 64 KB and the code must rely on
    its own segment arithmetic to access routines outside the first 64 KB.

The MS-DOS kernel

    The MS-DOS kernel is the heart of MS-DOS and provides the functions
    found in a traditional operating system. It is contained in a single
    proprietary file, MSDOS.SYS, supplied by Microsoft Corporation. The
    kernel provides its support functions (referred to as system
    functions) to application programs in a hardware-independent manner
    and, in turn, is isolated from hardware characteristics by relying on
    the driver routines in the MS-DOS BIOS to perform physical input and
    output operations.

    The MS-DOS kernel provides the following services through the use of
    device drivers:

    ■  File and directory management
    ■  Character device input and output
    ■  Time and date support

    It also provides the following non-device-related functions:

    ■  Memory management
    ■  Task and environment management
    ■  Country-specific configuration

    Programs access system functions using software interrupt (INT)
    instructions. MS-DOS reserves Interrupts 20H through 3FH for this
    purpose. The MS-DOS interrupts are

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Interrupt        Name
    ──────────────────────────────────────────────────────────────────
    20H              Terminate Program

    21H              MS-DOS Function Calls

    22H              Terminate Routine Address

    23H              Control-C Handler Address

    24H              Critical Error Handler Address

    25H              Absolute Disk Read

    26H              Absolute Disk Write

    27H              Terminate and Stay Resident

    28H-2EH          Reserved

    2FH              Multiplex

    30H-3FH          Reserved

    Interrupt 21H is the main source of MS-DOS services. The Interrupt 21H
    functions are implemented by placing a function number in the AH
    register, placing any necessary parameters in other registers, and
    issuing an INT 21H instruction. (MS-DOS also supports a call
    instruction interface for CP/M compatibility. The function and
    parameter registers differ from the interrupt interface. The CP/M
    interface was provided in MS-DOS version 1.0 solely to assist in
    movement of CP/M-based applications to MS-DOS. New applications should
    use Interrupt 21H functions exclusively.)

    MS-DOS version 2.0 introduced a mechanism to modify the operation of
    the MS-DOS BIOS and kernel: the CONFIG.SYS file. CONFIG.SYS is a text
    file containing command options that modify the size or configuration
    of internal MS-DOS tables and cause additional device drivers to be
    loaded. The file is read when MS-DOS is first loaded into memory. See
    USER COMMANDS: CONFIG.SYS.

The MS-DOS shell

    The shell, or command interpreter, is the first program started by
    MS-DOS after the MS-DOS BIOS and kernel have been loaded and
    initialized. It provides the interface between the kernel and the
    user. The default MS-DOS shell, COMMAND.COM, is a command-oriented
    interface; other shells may be menu-driven or screen-oriented.

    COMMAND.COM is a replaceable shell. A number of commercial products
    can be used as COMMAND.COM replacements, or a programmer can develop a
    customized shell. The new shell program is installed by renaming the
    program to COMMAND.COM or by using the SHELL command in CONFIG.SYS.
    The latter method is preferred because it allows initialization
    parameters to be passed to the shell program.

    COMMAND.COM can execute a set of internal (built-in) commands, load
    and execute programs, or interpret batch files. Most of the internal
    commands support file and directory operations and manipulate the
    program environment segment maintained by COMMAND.COM. The programs
    executed by COMMAND.COM are .COM or .EXE files loaded from a block
    device. The batch (.BAT) files supported by COMMAND.COM provide a
    limited programming language and are therefore useful for performing
    small, frequently used series of MS-DOS commands. In particular, when
    it is first loaded by MS-DOS, COMMAND.COM searches for the batch file
    AUTOEXEC.BAT and interprets it, if found, before taking any other
    action. COMMAND.COM also provides default terminate, Control-C and
    critical error handlers whose addresses are stored in the vectors for
    Interrupts 22H, 23H, and 24H. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: CUSTOMIZING MS-DOS: Exception Handlers.

COMMAND.COM's split personality
    COMMAND.COM is a conventional .COM application with a slight twist.
    Ordinarily, a .COM program is loaded into a single memory segment.
    COMMAND.COM starts this way but then copies the nonresident portion of
    itself into high memory and keeps the resident portion in low memory.
    The memory above the resident portion is released to MS-DOS.

    The effect of this split is not apparent until after an executed
    program has terminated and the resident portion of COMMAND.COM regains
    control of the system. The resident portion then computes a checksum
    on the area in high memory where the nonresident portion should be, to
    determine whether it has been overwritten. If the checksum matches a
    stored value, the nonresident portion is assumed to be intact;
    otherwise, a copy of the nonresident portion is reloaded from disk and
    COMMAND.COM continues its normal operation.

    This "split personality" exists because MS-DOS was originally designed
    for systems with a limited amount of RAM. The nonresident portion of
    COMMAND.COM, which contains the built-in commands and batch-file-
    processing routines that are not essential to regaining control and
    reloading itself, is much larger than the resident portion, which is
    responsible for these tasks. Thus, permitting the nonresident portion
    to be overwritten frees additional RAM and allows larger application
    programs to be run.

Command execution
    COMMAND.COM interprets commands by first checking to see if the
    specified command matches the name of an internal command. If so, it
    executes the command; otherwise, it searches for a .COM, .EXE, or .BAT
    file (in that order) with the specified name. If a .COM or .EXE
    program is found, COMMAND.COM uses the MS-DOS EXEC function (Interrupt
    21H Function 4BH) to load and execute it; COMMAND.COM itself
    interprets .BAT files. If no file is found, the message Bad command or
    file name is displayed.

    Although a command is usually simply a filename without the extension,
    MS-DOS versions 3.0 and later allow a command name to be preceded by a
    full pathname. If a path is not explicitly specified, the COMMAND.COM
    search mechanism uses the contents of the PATH environment variable,
    which can contain a list of paths to be searched for commands. The
    search starts with the current directory and proceeds through the
    directories specified by PATH until a file is found or the list is
    exhausted. For example, the PATH specification

    PATH C:\BIN;D:\BIN;E:\

    causes COMMAND.COM to search the current directory, then C:\BIN, then
    D:\BIN, and finally the root directory of drive E. COMMAND.COM
    searches each directory for a matching .COM, .EXE, or .BAT file, in
    that order, before moving to the next directory.

MS-DOS environments
    Version 2.0 introduced the concept of environments to MS-DOS. An
    environment is a paragraph-aligned memory segment containing a
    concatenated set of zero-terminated (ASCIIZ) variable-length strings
    of the form

    variable=value

    that provide such information as the current search path used by
    COMMAND.COM to find executable files, the location of COMMAND.COM
    itself, and the format of the user prompt. The end of the set of
    strings is marked by a null string--that is, a single zero byte. A
    specific environment is associated with each program in memory through
    a pointer contained at offset 2CH in the 256-byte program segment
    prefix (PSP). The maximum size of an environment is 32 KB; the default
    size is 160 bytes.

    If a program uses the EXEC function to load and execute another
    program, the contents of the new program's environment are provided to
    MS-DOS by the initiating program--one of the parameters passed to the
    MS-DOS EXEC function is a pointer to the new program's environment.
    The default environment provided to the new program is a copy of the
    initiating program's environment.

    A program that uses the EXEC function to load and execute another
    program will not itself have access to the new program's environment,
    because MS-DOS provides a pointer to this environment only to the new
    program. Any changes made to the new program's environment during
    program execution are invisible to the initiating program because a
    child program's environment is always discarded when the child program
    terminates.

    The system's master environment is normally associated with the shell
    COMMAND.COM. COMMAND.COM creates this set of environment strings
    within itself from the contents of the CONFIG.SYS and AUTOEXEC.BAT
    files, using the SET, PATH, and PROMPT commands. See USER COMMANDS:
    AUTOEXEC.BAT; CONFIG.SYS. In MS-DOS version 3.2, the initial size of
    COMMAND.COM's environment can be controlled by loading COMMAND.COM
    with the /E parameter, using the SHELL directive in CONFIG.SYS. For
    example, placing the line

    SHELL=COMMAND.COM /E:2048 /P

    in CONFIG.SYS sets the initial size of COMMAND.COM's environment to 2
    KB. (The /P option prevents COMMAND.COM from terminating, thus causing
    it to remain in memory until the system is turned off or restarted.)

    The SET command is used to display or change the COMMAND.COM
    environment contents. SET with no parameters displays the list of all
    the environment strings in the environment. A typical listing might
    show the following settings:

    COMSPEC=A:\COMMAND.COM
    PATH=C:\;A:\;B:\
    PROMPT=$p  $d  $t$_$n$g
    TMP=C:\TEMP

    The following is a dump of the environment segment containing the
    previous environment example:

    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
0000  43 4F 4D 53 50 45 43 3D-41 3A 5C 43 4F 4D 4D 41   COMSPEC=A:\COMMA
0010  4E 44 2E 43 4F 4D 00 50-41 54 48 3D 43 3A 5C 3B   ND.COM.PATH=C:\;
0020  41 3A 5C 3B 42 3A 5C 00-50 52 4F 4D 50 54 3D 24   A:\;B:\.PROMPT=$
0030  70 20 20 24 64 20 20 24-74 24 5F 24 6E 24 67 00   p  $d  $t$_$n$g.
0040  54 4D 50 3D 43 3A 5C 54-45 4D 50 00 00 00 00 00   TMP=C:\TEMP.....

    A SET command that specifies a variable but does not specify a value
    for it deletes the variable from the environment.

    A program can ignore the contents of its environment; however, use of
    the environment can add a great deal to the flexibility and
    configurability of batch files and application programs.

Batch files
    Batch files are text files with a .BAT extension that contain MS-DOS
    user and batch commands. Each line in the file is limited to 128
    bytes. See USER COMMANDS: BATCH. Batch files can be created using most
    text editors, including EDLIN, and short batch files can even be
    created using the COPY command:

    C&gt;COPY CON SAMPLE.BAT  &lt;ENTER&gt;

    The CON device is the system console; text entered from the keyboard
    is echoed on the screen as it is typed. The copy operation is
    terminated by pressing Ctrl-Z (or the F6 key on IBM-compatible
    machines), followed by the Enter key.

    Batch files are interpreted by COMMAND.COM one line at a time. In
    addition to the standard MS-DOS commands, COMMAND.COM's batch-file
    interpreter supports a number of special batch commands:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Command          Meaning
    ──────────────────────────────────────────────────────────────────
    ECHO             Display a message.

    FOR              Execute a command for a list of files.

    GOTO             Transfer control to another point.

    IF               Conditionally execute a command.

    PAUSE            Wait for any key to be pressed.

    REM              Insert comment line.

    SHIFT            Access more than 10 parameters.

    Execution of a batch file can be terminated before completion by
    pressing Ctrl-C or Ctrl-Break, causing COMMAND.COM to display the
    prompt

    Terminate batch job? (Y/N)

I/O redirection
    I/O redirection was introduced with MS-DOS version 2.0. The
    redirection facility is implemented within COMMAND.COM using the
    Interrupt 21H system functions Duplicate File Handle (45H) and Force
    Duplicate File Handle (46H). COMMAND.COM uses these functions to
    provide both redirection at the command level and a UNIX/XENIX-like
    pipe facility.

    Redirection is transparent to application programs, but to take
    advantage of redirection, an application program must make use of the
    standard input and output file handles. The input and output of
    application programs that directly access the screen or keyboard or
    use ROM BIOS functions cannot be redirected.

    Redirection is specified in the command line by prefixing file or
    device names with the special characters &gt;, &gt;&gt;, and &lt;. Standard output
    (default = CON) is redirected using &gt; and &gt;&gt; followed by the name of a
    file or character device. The former character creates a new file (or
    overwrites an existing file with the same name); the latter appends
    text to an existing file (or creates the file if it does not exist).
    Standard input (default = CON) is redirected with the &lt; character
    followed by the name of a file or character device. See also
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Writing MS-
    DOS Filters.

    The redirection facility can also be used to pass information from one
    program to another through a "pipe." A pipe in MS-DOS is a special
    file created by COMMAND.COM. COMMAND.COM redirects the output of one
    program into this file and then redirects this file as the input to
    the next program. The pipe symbol, a vertical bar (), separates the
    program names. Multiple program names can be piped together in the
    same command line:

    C&gt;DIR *.* | SORT | MORE

    This command is equivalent to

    C&gt;DIR *.* &gt; PIPE0  &lt;ENTER&gt;
    C&gt;SORT &lt; PIPE0 &gt; PIPE1  &lt;ENTER&gt;
    C&gt;MORE &lt; PIPE1  &lt;ENTER&gt;

    The concept of pipes came from UNIX/XENIX, but UNIX/XENIX is a
    multitasking operating system that actually runs the programs
    simultaneously. UNIX/XENIX uses memory buffers to connect the
    programs, whereas MS-DOS loads one program at a time and passes
    information through a disk file.


Loading MS-DOS

    Getting MS-DOS up to the standard A&gt; prompt is a complex process with
    a number of variations. This section discusses the complete process
    normally associated with MS-DOS versions 2.0 and later. (MS-DOS
    versions 1.x use the same general steps but lack support for various
    system tables and installable device drivers.)

    MS-DOS is loaded as a result of either a "cold boot" or a "warm boot."
    On IBM-compatible machines, a cold boot is performed when the computer
    is first turned on or when a hardware reset occurs. A cold boot
    usually performs a power-on self test (POST) and determines the amount
    of memory available, as well as which peripheral adapters are
    installed. The POST is ordinarily reserved for a cold boot because it
    takes a noticeable amount of time. For example, an IBM-compatible ROM
    BIOS tests all conventional and extended RAM (RAM above 1 MB on an
    80286-based  or 80386-based machine), a procedure that can take tens
    of seconds. A warm boot, initiated by simultaneously pressing the
    Ctrl, Alt, and Del keys, bypasses these hardware checks and begins by
    checking for a bootable disk.

    A bootable disk normally contains a small loader program that loads
    MS-DOS from the same disk. See PROGRAMMING IN THE MS-DOS ENVIRONMENT:
    STRUCTURE OF MS-DOS: MS-DOS Storage Devices. The body of MS-DOS is
    contained in two files: IO.SYS and MSDOS.SYS (IBMBIO.COM and
    IBMDOS.COM with PC-DOS). IO.SYS contains the Microsoft system
    initialization module, SYSINIT, which configures MS-DOS using either
    default values or the specifications in the CONFIG.SYS file, if one
    exists, and then starts up the shell program (usually COMMAND.COM, the
    default). COMMAND.COM checks for an AUTOEXEC.BAT file and interprets
    the file if found. (Other shells might not support such batch files.)
    Finally, COMMAND.COM prompts the user for a command. (The standard
    MS-DOS prompt is A&gt; if the system was booted from a floppy disk and C&gt;
    if the system was booted from a fixed disk.) Each of these steps is
    discussed in detail below.

The ROM BIOS, POST, and bootstrapping

    All 8086/8088-compatible microprocessors begin execution with the
    CS:IP set to FFFF:0000H, which typically contains a jump instruction
    to a destination in the ROM BIOS that contains the initialization code
    for the machine. (This has nothing to do with MS-DOS; it is a feature
    of the Intel microprocessors.) On IBM-compatible machines, the ROM
    BIOS occupies the address space from F000:0000H to this jump
    instruction. Figure 2-1 shows the location of the ROM BIOS within the
    1 MB address space. Supplementary ROM support can be placed before (at
    lower addresses than) the ROM BIOS.

    All interrupts are disabled when the microprocessor starts execution
    and it is up to the initialization routine to set up the interrupt
    vectors at the base of memory.


    ┌───────────────────┐──FFFF:000FH (1 MB)
    │     ROM BIOS      │──FFFF:0000H
    ├───────────────────┤──F000:0000H
    │                   │
    │ Other ROM and RAM │
    │                   │
    ├───────────────────┤──Top of RAM
    │                   │   (A000:0000H for IBM PC)
    │                   │
    │                   │
    │     Free RAM      │
    │                   │
    │                   │
    │                   │
    └───────────────────┘──0000:0000H

    Figure 2-1. Memory layout at startup.


    The initialization routine in the ROM BIOS--the POST procedure--
    typically determines what devices are installed and operational and
    checks conventional memory (the first 1 MB) and, for 80286-based or
    80386-based machines, extended memory (above 1 MB). The devices are
    tested, where possible, and any problems are reported using a series
    of beeps and display messages on the screen.

    When the machine is found to be operational, the ROM BIOS sets it up
    for normal operation. First, it initializes the interrupt vector table
    at the beginning of memory and any interrupt controllers that
    reference the table. The interrupt vector table area is located from
    0000:0000H to 0000:03FFH. On IBM-compatible machines, some of the
    subsequent memory (starting at address 0000:0400H) is used for table
    storage by various ROM BIOS routines (Figure 2-2). The beginning load
    address for the MS-DOS system files is usually in the range 0000:0600H
    to 0000:0800H.


    ┌───────────────────┐──FFFF:000FH (1 MB)
    │     ROM BIOS      │──FFFF:0000H
    ├───────────────────┤──F000:0000H
    │                   │
    │ Other ROM and RAM │
    │                   │
    ├───────────────────┤──Top of RAM
    │                   │   (A000:0000H for IBM PC)
    │                   │
    │                   │
    │     Free RAM      │
    │                   │
    │                   │
    │                   │
    ├───────────────────┤──0000:0600H
    │  ROM BIOS tables  │
    ├───────────────────┤──0000:0400H
    │ Interrupt vectors │
    │                   │
    └───────────────────┘──0000:0000H

    Figure 2-2. The interrupt vector table and the ROM BIOS table.


    Next, the ROM BIOS sets up any necessary hardware interfaces, such as
    direct memory access (DMA) controllers, serial ports, and the like.
    Some hardware setup may be done before the interrupt vector table area
    is set up. For example, the IBM PC DMA controller also provides
    refresh for the dynamic RAM chips and RAM cannot be used until the
    refresh DMA is running; therefore, the DMA must be set up first.

    Some ROM BIOS implementations also check to see if additional ROM
    BIOSs are installed by scanning the memory from A000:0000H to
    F000:0000H for a particular sequence of signature bytes. If additional
    ROM BIOSs are found, their initialization routines are called to
    initialize the associated devices. Examples of additional ROMs for the
    IBM PC family are the PC/XT's fixed-disk ROM BIOS and the EGA ROM
    BIOS.

    The ROM BIOS now starts the bootstrap procedure by executing the ROM
    loader routine. On the IBM PC, this routine checks the first floppy-
    disk drive to see if there is a bootable disk in it. If there
    is not, the routine then invokes the ROM associated with another
    bootable device to see if that device contains a bootable disk. This
    procedure is repeated until a bootable disk is found or until all
    bootable devices have been checked without success, in which case ROM
    BASIC is enabled.

    Bootable devices can be detected by a number of proprietary means. The
    IBM PC ROM BIOS reads the first sector on the disk into RAM (Figure 2-
    3) and checks for an 8086-family short or long jump at the beginning
    of the sector and for AA55H in the last word of the sector. This
    signature indicates that the sector contains the operating-system
    loader. Data disks--those disks not set up with the MS-DOS system
    files--usually cause the ROM loader routine to display a message
    indicating that the disk is not a bootable system disk. The customary
    recovery procedure is to display a message asking the user to insert
    another disk (with the operating system files on it) and press a key
    to try the load operation again. The ROM loader routine is then
    typically reexecuted from the beginning so that it can repeat its
    normal search procedure.


    ┌───────────────────┐──FFFF:000FH (1 MB)
    │     ROM BIOS      │──FFFF:0000H
    ├───────────────────┤──F000:0000H
    │                   │
    │ Other ROM and RAM │
    │                   │
    ├───────────────────┤──Top of RAM
    │                   │   (A000:0000H for IBM PC)
    │                   │
    │                   │
    │     Free RAM      │
    │                   │
    │                   │
    │                   │
    ├───────────────────┤──0000:0600H
    │  ROM BIOS tables  │
    ├───────────────────┤──0000:0400H
    │ Interrupt vectors │
    │                   │
    └───────────────────┘──0000:0000H

    Figure 2-3. A loaded boot sector.


    When it finds a bootable device, the ROM loader routine loads the
    operating-system loader and transfers control to it. The operating-
    system loader then uses the ROM BIOS services through the interrupt
    table to load the next part of the operating system into low memory.

    Before it can proceed, the operating-system loader must know something
    about the configuration of the system boot disk (Figure 2-4). MS-DOS-
    compatible disks contain a data structure that contains this
    information. This structure, known as the BIOS parameter block (BPB),
    is located in the same sector as the operating-system loader. From the
    contents of the BPB, the operating-system loader calculates the
    location of the root directory for the boot disk so that it can verify
    that the first two entries in the root directory are IO.SYS and
    MSDOS.SYS. For versions of MS-DOS through 3.2, these files must also
    be the first two files in the file data area, and they must be
    contiguous. (The operating-system loader usually does not check the
    file allocation table [FAT] to see if IO.SYS and MSDOS.SYS are
    actually stored in contiguous sectors.) See PROGRAMMING IN
    THE MS-DOS ENVIRONMENT: STRUCTURE OF MS-DOS: MS-DOS Storage Devices.


    ┌───────────────────┐
    │    Boot sector    │──First sector on the disk
    ├───────────────────┤
    │Reserved (optional)│
    ├───────────────────┤
    │       FAT#1       │
    ├───────────────────┤
    │       FAT#2       │
    ├───────────────────┤
    │  Root directory   │
    ├───────────────────┤
    │      IO.SYS       │
    ├───────────────────┤
    │     MSDOS.SYS     │
    ├───────────────────┤
    │                   │
    │                   │
    │  File data area   │
    │                   │
    └─────┐             │
    ┌────┐└───────┐     │
    │    └───────┐└─────┘
    │            └──────┐
    └───────────────────┘

    Figure 2-4. Boot-disk configuration.


    Next, the operating-system loader reads the sectors containing IO.SYS
    and MSDOS.SYS into contiguous areas of memory just above the ROM BIOS
    tables (Figure 2-5). (An alternative method is to take advantage
    of the operating-system loader's final jump to the entry point in
    IO.SYS and include routines in IO.SYS that allow it to load
    MSDOS.SYS.)

    Finally, assuming the file was loaded without any errors, the
    operating-system loader transfers control to IO.SYS, passing the
    identity of the boot device. The operating-system loader is no longer
    needed and its RAM is made available for other purposes.


    ┌───────────────────┐──FFFF:000FH (1 MB)
    │     ROM BIOS      │
    ├───────────────────┤──F000:0000H
    │                   │
    │ Other ROM and RAM │
    │                   │
    ├───────────────────┤──Top of RAM
    │                   │   (A000:0000H for IBM PC)
    │ Possible free RAM │
    │                   │
    ├───────────────────┤
    │    Boot sector    │──Arbitrary location
    ├───────────────────┤
    │                   │
    │                   │
    │                   │
    │     Free RAM      │
    │                   │
    │                   │
    │                   │
    ├───────────────────┤
    │     MSDOS.SYS     │
    ├───────────────────┤
    │                   │
    │      IO.SYS       │──SYSINIT
    │                   │──MS-DOS BIOS (resident device drivers)
    ├───────────────────┤──0000:0600H
    │  ROM BIOS tables  │
    ├───────────────────┤──0000:0400H
    │ Interrupt vectors │
    │                   │
    └───────────────────┘──0000:0000H

    Figure 2-5. IO.SYS and MSDOS.SYS loaded.


MS-DOS system initialization (SYSINIT)

    MS-DOS system initialization begins after the operating-system loader
    has loaded IO.SYS and MSDOS.SYS and transferred control to the
    beginning of IO.SYS. To this point, there has been no standard loading
    procedure imposed by MS-DOS, although the IBM PC loading procedure
    outlined here has become the de facto standard for most MS-DOS
    machines. When control is transferred to IO.SYS, however, MS-DOS
    imposes its standards.

    The IO.SYS file is divided into three modules:

    ■  The resident device drivers
    ■  The basic MS-DOS BIOS initialization module
    ■  The MS-DOS system initialization module, SYSINIT

    The two initialization modules are usually discarded as soon as MS-DOS
    is completely initialized and the shell program is running; the
    resident device drivers remain in memory while MS-DOS is running and
    are therefore placed in the first part of the IO.SYS file, before the
    initialization modules.

    The MS-DOS BIOS initialization module ordinarily displays a sign-on
    message and the copyright notice for the OEM that created IO.SYS. On
    IBM-compatible machines, it then examines entries in the interrupt
    table to determine what devices were found by the ROM BIOS at POST
    time and adjusts the list of resident device drivers accordingly. This
    adjustment usually entails removing those drivers that have no
    corresponding installed hardware. The initialization routine may also
    modify internal tables within the device drivers. The device driver
    initialization routines will be called later by SYSINIT, so the MS-DOS
    BIOS initialization routine is now essentially finished and control is
    transferred to the SYSINIT module.

    SYSINIT locates the top of RAM and copies itself there. It then
    transfers control to the copy and the copy proceeds with system
    initialization. The first step is to move MSDOS.SYS, which contains
    the MS-DOS kernel, to a position immediately following the end of the
    resident portion of IO.SYS, which contains the resident device
    drivers. This move overwrites the original copy of SYSINIT and usually
    all of the MS-DOS BIOS initialization routine, which are no longer
    needed. The resulting memory layout is shown in Figure 2-6.


    ┌───────────────────┐──FFFF:000FH (1 MB)
    │     ROM BIOS      │
    ├───────────────────┤──F000:0000H
    │                   │
    │ Other ROM and RAM │
    │                   │
    ├───────────────────┤──Top of RAM
    │                   │   (A000:0000H for IBM PC)
    │      SYSINIT      │
    │                   │
    ├───────────────────┤
    │                   │
    │     Free RAM      │
    │                   │
    ├───────────────────┤
    │   MS-DOS kernel   │
    │    (MSDOS.SYS)    │
    ├───────────────────┤
    │    MS-DOS BIOS    │──Resident device drivers
    │     (IO.SYS)      │
    ├───────────────────┤──0000:0600H
    │  ROM BIOS tables  │
    ├───────────────────┤──0000:0400H
    │ Interrupt vectors │
    └───────────────────┘──0000:0000H

    Figure 2-6. SYSINIT and MSDOS.SYS relocated.


    SYSINIT then calls the initialization routine in the newly relocated
    MS-DOS kernel. This routine performs the internal setup for the
    kernel, including putting the appropriate values into the vectors for
    Interrupts 20H through 3FH.

    The MS-DOS kernel initialization routine then calls the initialization
    function of each resident device driver to set up vectors for any
    external hardware interrupts used by the device. Each block-device
    driver returns a pointer to a BPB for each drive that it supports;
    these BPBs are inspected by SYSINIT to find the largest sector size
    used by any of the drivers. See PROGRAMMING IN THE MS-DOS ENVIRONMENT:
    STRUCTURE OF MS-DOS: MS-DOS Storage Devices. The kernel initialization
    routine then allocates a sector buffer the size of the largest sector
    found and places the NUL device driver at the head of the device
    driver list.

    The kernel initialization routine's final operation before returning
    to SYSINIT is to display the MS-DOS copyright message. The loading of
    the system portion of MS-DOS is now complete and SYSINIT can use any
    MS-DOS function in conjunction with the resident set of device
    drivers.

    SYSINIT next attempts to open the CONFIG.SYS file in the root
    directory of the boot drive. If the file does not exist, SYSINIT uses
    the default system parameters; if the file is opened, SYSINIT reads
    the entire file into high memory and converts all characters to
    uppercase. The file contents are then processed to determine such
    settings as the number of disk buffers, the number of entries in the
    file tables, and the number of entries in the drive translation table
    (depending on the specific commands in the file), and these structures
    are allocated following the MS-DOS kernel (Figure 2-7).

    Then SYSINIT processes the CONFIG.SYS text sequentially to determine
    what installable device drivers are to be implemented and loads the
    installable device driver files into memory after the system disk
    buffers and the file and drive tables. Installable device driver files
    can be located in any directory on any drive whose driver has already
    been loaded. Each installable device driver initialization function is
    called after the device driver file is loaded into memory. The
    initialization procedure is the same as for resident device drivers,
    except that SYSINIT uses an address returned by the device driver
    itself to determine where the next device driver is to be placed. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Installable
    Device Drivers.


    ┌───────────────────┐──FFFF:000FH (1 MB)
    │     ROM BIOS      │
    ├───────────────────┤──F000:0000H
    │                   │
    │ Other ROM and RAM │
    │                   │
    ├───────────────────┤──Top of RAM
    │                   │   (A000:0000H for IBM PC)
    │      SYSINIT      │
    │                   │
    ├───────────────────┤
    │                   │
    │                   │
    │     Free RAM      │
    │                   │
    │                   │
    ├───────────────────┤
    │    Installable    │
    │  device drivers   │
    ├───────────────────┤
    │File control blocks│
    ├───────────────────┤
    │   Disk buffers    │
    ├───────────────────┤
    │   MS-DOS tables   │
    ├───────────────────┤
    │   MS-DOS kernel   │
    │    (MSDOS.SYS)    │
    ├───────────────────┤
    │    MS-DOS BIOS    │──Resident device drivers
    │     (IO.SYS)      │
    ├───────────────────┤──0000:0600H
    │  ROM BIOS tables  │
    ├───────────────────┤──0000:0400H
    │ Interrupt vectors │
    │                   │
    └───────────────────┘──0000:0000H

    Figure 2-7. Tables allocated and installable device drivers loaded.


    Like resident device drivers, installable device drivers can be
    discarded by SYSINIT if the device driver initialization routine
    determines that a device is inoperative or nonexistent. A discarded
    device driver is not included in the list of device drivers.
    Installable character-device drivers supersede resident character-
    device drivers with the same name; installable block-device drivers
    cannot supersede resident block-drivers and are assigned drive letters
    following those of the resident block-device drivers.

    SYSINIT now closes all open files and then opens the three character
    devices CON, PRN, and AUX. The console (CON) is used as standard
    input, standard output, and standard error; the standard printer port
    is PRN (which defaults to LPT1); the standard auxiliary port is AUX
    (which defaults to COM1). Installable device drivers with these names
    will replace any resident versions.

Starting the shell

    SYSINIT's last function is to load and execute the shell program by
    using the MS-DOS EXEC function. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: The MS-DOS EXEC Function. The
    SHELL statement in CONFIG.SYS specifies both the name of the shell
    program and its initial parameters; the default MS-DOS shell is
    COMMAND.COM. The shell program is loaded at the start of free memory
    after the installable device drivers or after the last internal MS-DOS
    file control block if there are no installable device drivers (Figure
    2-8).

COMMAND.COM
    COMMAND.COM consists of three parts:

    ■  A resident portion
    ■  An initialization module
    ■  A transient portion

    The resident portion contains support for termination of programs
    started by COMMAND.COM and presents critical-error messages. It is
    also responsible for reloading the transient portion when necessary.

    The initialization module is called once by the resident portion.
    First, it moves the transient portion to high memory. (Compare Figures
    2-8 and 2-9.) Then it processes the parameters specified in the SHELL
    command in the CONFIG.SYS file, if any. See USER COMMANDS: COMMAND.
    Next, it processes the AUTOEXEC.BAT file, if one exists, and finally,
    it transfers control back to the resident portion, which frees the
    space used by the initialization module and transient portion. The
    relocated transient portion then displays the MS-DOS user prompt and
    is ready to accept commands.

    The transient portion gets a command from either the console or a
    batch file and executes it. Commands are divided into three
    categories:

    ■  Internal commands
    ■  Batch files
    ■  External commands

    Internal commands are routines contained within COMMAND.COM and
    include operations like COPY or ERASE. Execution of an internal
    command does not overwrite the transient portion. Internal commands
    consist of a keyword, sometimes followed by a list of command-specific
    parameters.


    ┌───────────────────┐──FFFF:000FH (1 MB)
    │     ROM BIOS      │
    ├───────────────────┤──F000:0000H
    │                   │
    │ Other ROM and RAM │
    │                   │
    ├───────────────────┤──Top of RAM
    │                   │   (A000:0000H for IBM PC)
    │      SYSINIT      │
    │                   │
    ├───────────────────┤
    │                   │
    │                   │
    │     Free RAM      │
    │                   │
    │                   │
    ├───────────────────┤
    │    COMMAND.COM    │
    │    (transient)    │
    ├───────────────────┤
    │    COMMAND.COM    │
    │ (initialization)  │
    ├───────────────────┤
    │    COMMAND.COM    │
    │    (resident)     │
    ├───────────────────┤
    │    Installable    │
    │  device drivers   │
    ├───────────────────┤
    │File control blocks│
    ├───────────────────┤
    │   Disk buffers    │
    ├───────────────────┤
    │   MS-DOS tables   │
    ├───────────────────┤
    │   MS-DOS kernel   │
    │    (MSDOS.SYS)    │
    ├───────────────────┤
    │    MS-DOS BIOS    │──Resident device drivers
    │     (IO.SYS)      │
    ├───────────────────┤──0000:0600H
    │  ROM BIOS tables  │
    ├───────────────────┤──0000:0400H
    │ Interrupt vectors │
    └───────────────────┘──0000:0000H

    Figure 2-8. COMMAND.COM loaded.


    ┌───────────────────┐──FFFF:000FH (1 MB)
    │     ROM BIOS      │
    ├───────────────────┤──F000:0000H
    │                   │
    │ Other ROM and RAM │
    │                   │
    ├───────────────────┤──Top of RAM
    │    COMMAND.COM    │   (A000:0000H for IBM PC)
    │    (transient)    │
    ├───────────────────┤
    │                   │
    │                   │
    │     Free RAM      │
    │                   │
    │                   │
    ├───────────────────┤
    │    COMMAND.COM    │
    │    (resident)     │
    ├───────────────────┤
    │    Installable    │
    │  device drivers   │
    ├───────────────────┤
    │File control blocks│
    ├───────────────────┤
    │   Disk buffers    │
    ├───────────────────┤
    │   MS-DOS tables   │
    ├───────────────────┤
    │   MS-DOS kernel   │
    │    (MSDOS.SYS)    │
    ├───────────────────┤
    │    MS-DOS BIOS    │──Resident device drivers
    │     (IO.SYS)      │
    ├───────────────────┤──0000:0600H
    │  ROM BIOS tables  │
    ├───────────────────┤──0000:0400H
    │ Interrupt vectors │
    │                   │
    └───────────────────┘──0000:0000H

    Figure 2-9. COMMAND.COM after relocation.


    Batch files are text files that contain internal commands, external
    commands, batch-file directives, and nonexecutable comments. See USER
    COMMANDS: BATCH.

    External commands, which are actually executable programs, are stored
    in separate files with .COM and .EXE extensions and are included on
    the MS-DOS distribution disks. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: Structure of an Application
    Program. These programs are invoked with the name of the file without
    the extension. (MS-DOS versions 3.x allow the complete pathname of the
    external command to be specified.)

    External commands are loaded by COMMAND.COM by means of the MS-DOS
    EXEC function. The EXEC function loads a program into the free memory
    area, also called the transient program area (TPA), and then passes it
    control. Control returns to COMMAND.COM when the new program
    terminates. Memory used by the program is released unless it is a
    terminate-and-stay-resident (TSR) program, in which case some of the
    memory is retained for the resident portion of the program. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Terminate-
    and-Stay-Resident Utilities.

    After a program terminates, the resident portion of COMMAND.COM checks
    to see if the transient portion is still valid, because if the program
    was large, it may have overwritten the transient portion's memory
    space. The validity check is done by computing a checksum on the
    transient portion and comparing it with a stored value. If the
    checksums do not match, the resident portion loads a new copy of the
    transient portion from the COMMAND.COM file.

    Just as COMMAND.COM uses the EXEC function to load and execute a
    program, programs can load and execute other programs until the system
    runs out of memory. Figure 2-10 shows a typical memory configuration
    for multiple applications loaded at the same time. The active task--
    the last one executed--ordinarily has complete control over the
    system, with the exception of the hardware interrupt handlers, which
    gain control whenever a hardware interrupt needs to be serviced.

    MS-DOS is not a multitasking operating system, so although several
    programs can be resident in memory, only one program can be active at
    a time. The stack-like nature of the system is apparent in Figure
    2-10. The top program is the active one; the next program down will
    continue to run when the top program exits, and so on until control
    returns to COMMAND.COM. RAM-resident programs that remain in memory
    after they have terminated are the exception. In this case, a program
    lower in memory than another program can become the active program,
    although the one-active-process limit is still in effect.


    ┌───────────────────┐──FFFF:000FH (1 MB)
    │     ROM BIOS      │
    ├───────────────────┤──F000:0000H
    │                   │
    │ Other ROM and RAM │
    │                   │
    ├───────────────────┤──Top of RAM
    │    COMMAND.COM    │   (A000:0000H for IBM PC)
    │    (transient)    │
    ├───────────────────┤
    │                   │
    │     Free RAM      │
    │                   │
    ├───────────────────┤
    │    Program #3     │
    │     (active)      │
    ├───────────────────┤
    │    Program #2     │
    ├───────────────────┤
    │    Program #1     │
    ├───────────────────┤
    │    COMMAND.COM    │
    │    (resident)     │
    ├───────────────────┤
    │    Installable    │
    │  device drivers   │
    ├───────────────────┤
    │File control blocks│
    ├───────────────────┤
    │   Disk buffers    │
    ├───────────────────┤
    │   MS-DOS tables   │
    ├───────────────────┤
    │   MS-DOS kernel   │
    │    (MSDOS.SYS)    │
    ├───────────────────┤
    │    MS-DOS BIOS    │──Resident device drivers
    │     (IO.SYS)      │
    ├───────────────────┤──0000:0600H
    │  ROM BIOS tables  │
    ├───────────────────┤──0000:0400H
    │ Interrupt vectors │
    │                   │
    └───────────────────┘──0000:0000H

    Figure 2-10. Multiple programs loaded.


A custom shell program
    The SHELL directive in the CONFIG.SYS file can be used to replace the
    system's default shell, COMMAND.COM, with a custom shell. Nearly any
    program can be used as a system shell as long as it supplies default
    handlers for the Control-C and critical error exceptions. For example,
    the program in Figure 2-11 can be used to make any application program
    appear to be a shell program--if the application program terminates,
    SHELL.COM restarts it, giving the appearance that the application
    program is the shell program.

    SHELL.COM sets up the segment registers for operation as a .COM file
    and reduces the program segment size to less than 1 KB. It then
    initializes the segment values in the parameter table for the EXEC
    function, because .COM files cannot set up segment values within a
    program. The Control-C and critical error interrupt handler vectors
    are set to the address of the main program loop, which tries to load
    the new shell program. SHELL.COM prints a message if the EXEC
    operation fails. The loop continues forever and SHELL.COM will never
    return to the now-discarded SYSINIT that started it.

    ──────────────────────────────────────────────────────────────────────

    Figure 2-11. A simple program to run an application as an MS-DOS
    shell.

    ──────────────────────────────────────────────────────────────────────

    SHELL.COM is very short and not too smart. It needs to be changed and
    rebuilt if the name of the application program changes. A simple
    extension to SHELL--call it XSHELL-would be to place the name of the
    application program and any parameters in the command line. XSHELL
    would then have to parse the program name and the contents of the two
    FCBs needed for the EXEC function. The CONFIG.SYS line for starting
    this shell would be

    SHELL=XSHELL \SHELL\DEMO.EXE PARAM1 PARAM2 PARAM3

    SHELL.COM does not set up a new environment but simply uses the one
    passed to it.

                                                William Wong



Article 3:  MS-DOS Storage Devices


    Application programs access data on MS-DOS storage devices through the
    MS-DOS file-system support that is part of the MS-DOS kernel. The
    MS-DOS kernel accesses these storage devices, also called block
    devices, through two types of device drivers: resident block-device
    drivers contained in IO.SYS and installable block-device drivers
    loaded from individual files when MS-DOS is loaded. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: STRUCTURE OF MS-DOS: The
    Components of MS-DOS; CUSTOMIZING MS-DOS: Installable
    Device Drivers.

    MS-DOS can handle almost any medium, recording method, or other
    variation for a storage device as long as there is a device driver for
    it. MS-DOS needs to know only the sector size and the maximum number
    of sectors for the device; the appropriate translation between logical
    sector number and physical location is made by the device driver.
    Information about the number of heads, tracks, and so on is required
    only for those partitioning programs that allocate logical devices
    along these boundaries. See Layout of a Partition, below.

    The floppy-disk drive is perhaps the best-known block device, followed
    by its faster cousin, the fixed-disk drive. Other MS-DOS media include
    RAMdisks, nonvolatile RAMdisks, removable hard disks, tape drives, and
    CD ROM drives. With the proper device driver, MS-DOS can place a file
    system on any of these devices (except read-only media such as CD
    ROM).

    This article discusses the structure of the file system on floppy and
    fixed disks, starting with the physical layout of a disk and then
    moving on to the logical layout of the file system. The scheme
    examined is for the IBM PC fixed disk.


Structure of an MS-DOS Disk

    The structure of an MS-DOS disk can be viewed in a number of ways:

    ■  Physical device layout
    ■  Logical device layout
    ■  Logical block layout
    ■  MS-DOS file system

    The physical layout of a disk is expressed in terms of sectors,
    tracks, and heads. The logical device layout, also expressed in terms
    of sectors, tracks, and heads, indicates how a logical device maps
    onto a physical device. A partitioned physical device contains
    multiple logical devices; a physical device that cannot be partitioned
    contains only one. Each logical device has a logical block layout used
    by MS-DOS to implement a file system. These various views of an MS-DOS
    disk are discussed below. See also PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: File and Record Management; Disk
    Directories and Volume Labels.

Layout of a physical block device

    The two major block-device implementations are solid-state RAMdisks
    and rotating magnetic media such as floppy or fixed disks. Both
    implementations provide a fixed amount of storage in a fixed number of
    randomly accessible same-size sectors.

RAMdisks
    A RAMdisk is a block device that has sectors mapped sequentially into
    RAM. Thus, the RAMdisk is viewed as a large set of sequentially
    numbered sectors whose addresses are computed by simply multiplying
    the sector number by the sector size and adding the base address of
    the RAMdisk sector buffer. Access is fast and efficient and the access
    time to any sector is fixed, making the RAMdisk the fastest block
    device available. However, there are significant drawbacks to
    RAMdisks. First, they are volatile; their contents are irretrievably
    lost when the computer's power is turned off (although a special
    implementation of the RAMdisk known as a nonvolatile RAMdisk includes
    a battery backup system that ensures that its contents are not lost
    when the computer's power is turned off). Second, they are usually not
    portable.

Physical disks
    Floppy-disk and fixed-disk systems, on the other hand, store
    information on revolving platters coated with a special magnetic
    material. The disk is rotated in the drive at high speeds--
    approximately 300 revolutions per minute (rpm) for floppy disks and
    3600 rpm for fixed disks. (The term "fixed" refers to the fact that
    the medium is built permanently into the drive, not to the motion of
    the medium.) Fixed disks are also referred to as "hard" disks, because
    the disk itself is usually made from a rigid material such as metal or
    glass; floppy disks are usually made from a flexible material such as
    plastic.

    A transducer element called the read/write head is used to read and
    write tiny magnetic regions on the rotating magnetic medium. The
    regions act like small bar magnets with north and south poles. The
    magnetic regions of the medium can be logically oriented toward one or
    the other of these poles--orientation toward one pole is interpreted
    as a specific binary state (1 or 0) and orientation toward the other
    pole is interpreted as the opposite binary state. A change in the
    direction of orientation (and hence a change in the binary value)
    between two adjacent regions is called a flux reversal, and the
    density of a particular disk implementation can be measured by the
    number of regions per inch reliably capable of flux reversal. Higher
    densities of these regions yield higher-capacity disks. The flux
    density of a particular system depends on the drive mechanics, the
    characteristics of the read/write head, and the magnetic properties of
    the medium.

    The read/write head can encode digital information on a disk using a
    number of recording techniques, including frequency modulation (FM),
    modified frequency modulation (MFM), run length limited (RLL)
    encoding, and advanced run length limited (ARLL) encoding. Each
    technique offers double the data encoding density of the previous one.
    The associated control logic is more complex for the denser
    techniques.

    Tracks
    A read/write head reads data from or writes data to a thin section of
    the disk called a track, which is laid out in a circular fashion
    around the disk (Figure 3-1). Standard 5.25-inch floppy disks contain
    either 40 (0-39) or 80 (0-79) tracks per side. Like-numbered tracks on
    either side of a double-sided disk are distinguished by the number of
    the read/write head used to access the track. For example, track 1 on
    the top of the disk is identified as head 0, track 1; track 1 on the
    bottom of the disk is identified as head 1, track 1.

    Tracks can be either spirals, as on a phonograph record, or concentric
    rings. Computer media usually use one of two types of concentric
    rings. The first type keeps the same number of sectors on each track
    (see Sectors, below) and is rotated at a constant angular velocity
    (CAV). The second type maintains the same recording density across the
    entire surface of the disk, so a track near the center of a disk
    contains fewer sectors than a track near the perimeter. This latter
    type of disk is rotated at different speeds to keep the medium under
    the magnetic head moving at a constant linear velocity (CLV).


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 3-1 is found on page 87        ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 3-1. The physical layout of a CAV 9-sector, 5.25-inch floppy
    disk.


    Most MS-DOS computers use CAV disks, although a CLV disk can store
    more sectors using the same type of medium. This difference in storage
    capacity occurs because the limiting factor is the flux density of the
    medium and a CAV disk must maintain the same number of magnetic flux
    regions per sector on the interior of the disk as at the perimeter.
    Thus, the sectors on or near the perimeter do not use the full
    capability of the medium and the heads, because the space reserved for
    each magnetic flux region on the perimeter is larger than that
    available near the center of the disk. In spite of their greater
    storage capacity, however, CLV disks (such as CD ROMs) usually have
    slower access times than CAV disks because of the constant need to
    fine-tune the motor speed as the head moves from track to track. Thus,
    CAV disks are preferred for MS-DOS systems.

    Heads
    Simple disk systems use a single disk, or platter, and use one or two
    sides of the platter; more complex systems, such as fixed disks, use
    multiple platters. Disk systems that use both sides of a disk have one
    read/write head per side; the heads are positioned over the track to
    be read from or written to by means of a positioning mechanism such as
    a solenoid or servomotor. The heads are ordinarily moved in unison,
    using a single head-movement mechanism; thus, heads on opposite sides
    of a platter in a double-sided disk system typically access the same
    logical track on their associated sides of the platter. (Performance
    can be increased by increasing the number of heads to as many as one
    head per track, eliminating the positioning mechanism. However,
    because they are quite expensive, such multiple-head systems are
    generally found only on high-performance minicomputers and
    mainframes.)

    The set of like-numbered tracks on the two sides of a platter (or on
    all sides of all platters in a multiplatter system) is called a
    cylinder. Disks are usually partitioned along cylinders. Tracks and
    cylinders may appear to have the same meaning; however, the term track
    is used to define a concentric ring containing a specific number of
    sectors on a single side of a single platter, whereas the term
    cylinder refers to the number of like-numbered tracks on a device
    (Figure 3-2).


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 3-2 is found on page 88        ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 3-2. Tracks and cylinders on a fixed-disk system.


    Sectors
    Each track is divided into equal-size portions called sectors. The
    size of a sector is a power of 2 and is usually greater than 128
    bytes--typically, 512 bytes.

    Floppy disks are either hard-sectored or soft-sectored, depending on
    the disk drive and the medium. Hard-sectored disks are implemented
    using a series of small holes near the center of the disk that
    indicate the beginning of each sector; these holes are read by a
    photosensor/LED pair built into the disk drive. Soft-sectored disks
    are implemented by magnetically marking the beginning of each sector
    when the disk is formatted. A soft-sectored disk has a single hole
    near the center of the disk (see Figure 3-1) that marks the location
    of sector 0 for reference when the disk is formatted or when error
    detection is performed; this hole is also read by a photosensor/LED
    pair. Fixed disks use a special implementation of soft sectors (see
    below). A hard-sectored floppy disk cannot be used in a disk drive
    built for use with soft-sectored floppy disks (and vice versa).

    In addition to a fixed number of data bytes, both sector types include
    a certain amount of overhead information, such as error correction and
    sector identification, in each sector. The structure of each sector is
    implemented during the formatting process.

    Standard fixed disks and 5.25-inch floppy disks generally have from 8
    to 17 physical sectors per track. Sectors are numbered beginning at 1.
    Each sector is uniquely identified by a complete specification of the
    read/write head, cylinder number, and sector number. To access a
    particular sector, the disk drive controller hardware moves all heads
    to the specified cylinder and then activates the appropriate head for
    the read or write operation.

    The read/write heads are mechanically positioned using one of two
    hardware implementations. The first method, used with floppy disks,
    employs an "open-loop" servomechanism in which the software computes
    where the heads should be and the hardware moves them there. (A
    servomechanism is a device that can move a solenoid or hold it in a
    fixed position.) An open-loop system employs no feedback mechanism to
    determine whether the heads were positioned correctly--the hardware
    simply moves the heads to the requested position and returns an error
    if the information read there is not what was expected. The
    positioning mechanism in floppy-disk drives is made with close
    tolerances because if the positioning of the heads on two drives
    differs, disks written on one might not be usable on the other.

    Most fixed disk systems use the second method--a "closed-loop"
    servomechanism that reserves one side of one platter for positioning
    information. This information, which indicates where the tracks and
    sectors are located, is written on the disk at the factory when the
    drive is assembled. Positioning the read/write heads in a closed-loop
    system is actually a two-step process: First, the head assembly is
    moved to the approximate location of the read or write operation; then
    the disk controller reads the closed-loop servo information, compares
    it to the desired location, and fine-tunes the head position
    accordingly. This fine-tuning approach yields faster access times and
    also allows for higher-capacity disks because the positioning can be
    more accurate and the distances between tracks can therefore be
    smaller. Because the "servo platter" usually has positioning
    information on one side and data on the other, many systems have an
    odd number of read/write heads for data.

    Interleaving
    CAV MS-DOS disks are described in terms of bytes per sector, sectors
    per track, number of cylinders, and number of read/write heads.
    Overall access time is based on how fast the disk rotates (rotational
    latency) and how fast the heads can move from track to track (track-
    to-track latency).

    On most fixed disks, the sectors on the disk are logically or
    physically numbered so that logically sequential sectors are not
    physically adjacent (Figure 3-3). The underlying principle is that,
    because the controller cannot finish processing one sector before the
    next sequential sector arrives under the read/write head, the
    logically numbered sectors must be staggered around the track. This
    staggering of sectors is called skewing or, more commonly,
    interleaving. A 2-to-1 (2:1) interleave places sequentially accessed
    sectors so that there is one additional sector between them; a 3:1
    interleave places two additional sectors between them. A slower disk
    controller needs a larger interleave factor. A 3:1 interleave means
    that three revolutions are required to read all sectors on a track in
    numeric order.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 3-3 is found on page 90        ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 3-3. A 3:1 interleave.


    One approach to improving fixed-disk performance is to decrease the
    interleave ratio. This generally requires a specialized utility
    program and also requires that the disk be reformatted to adjust to
    the new layout. Obviously, a 1:1 interleave is the most efficient,
    provided the disk controller can process at that speed. The normal
    interleave for an IBM PC/AT and its standard fixed disk and disk
    controller is 3:1, but disk controllers are available for the PC/AT
    that are capable of handling a 1:1 interleave. Floppy disks on MS-DOS-
    based computers all have a 1:1 interleave ratio.

Layout of a partition

    For several reasons, large physical block devices such as fixed disks
    are often logically partitioned into smaller logical block devices
    (Figure 3-4). For instance, such partitions allow a device to be
    shared among different operating systems. Partitions can also be used
    to keep the size of each logical device within the PC-DOS 32 MB
    restriction (important for large fixed disks). MS-DOS permits a
    maximum of four partitions.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 3-4 is found on page 91        ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 3-4. A partitioned disk.


    A partitioned block device has a partition table located in one sector
    at the beginning of the disk. This table indicates where the logical
    block devices are physically located. (Even a partitioned device with
    only one partition usually has such a table.)

    Under the MS-DOS partitioning standard, the first physical sector on
    the fixed disk contains the partition table and a bootstrap program
    capable of checking the partition table for a bootable partition,
    loading the bootable partition's boot sector, and transferring control
    to it. The partition table, located at the end of the first physical
    sector of the disk, can contain a maximum of four entries:

╓┌────────────────────────┌───────────────────┌──────────────────────────────╖
    Offset From
    Start of Sector     Size (bytes)        Description
    ──────────────────────────────────────────────────────────────────
    01BEH               16                  Partition #4
    01CEH               16                  Partition #3
    01DEH               16                  Partition #2
    01EEH               16                  Partition #1
    01FEH                2                  Signature: AA55H

    The partitions are allocated in reverse order. Each 16-byte entry
    contains the following information:

╓┌─────────────────────┌─────────────┌───────────────────────────────────────╖
    Offset From
    Start of Entry   Size (bytes)  Description
    ──────────────────────────────────────────────────────────────────
    00H              1             Boot indicator
    01H              1             Beginning head
    02H              1             Beginning sector
    03H              1             Beginning cylinder
    04H              1             System indicator
    05H              1             Ending head
    06H              1             Ending sector
    07H              1             Ending cylinder
    08H              4             Starting sector (relative to
                                    beginning of disk)
    0CH              4             Number of sectors in partition

    The boot indicator is zero for a nonbootable partition and 80H for a
    bootable (active) partition. A fixed disk can have only one bootable
    partition. (When setting a bootable partition, partition programs such
    as FDISK reset the boot indicators for all other partitions to zero.)
    See USER COMMANDS: FDISK.

    The system indicators are

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Code        Meaning
    ──────────────────────────────────────────────────────────────────
    00H         Unknown
    01H         MS-DOS, 12-bit FAT
    04H         MS-DOS, 16-bit FAT

    Each partition's boot sector is located at the start of the partition,
    which is specified in terms of beginning head, beginning sector, and
    beginning cylinder numbers. This information, stored in the partition
    table in this order, is loaded into the DX and CX registers by the PC
    ROM BIOS loader routine when the machine is turned on or restarted.
    The starting sector of the partition relative to the beginning of the
    disk is also indicated. The ending head, sector, and cylinder numbers,
    also included in the partition table, specify the last accessible
    sector for the partition. The total number of sectors in a partition
    is the difference between the starting and ending head and cylinder
    numbers times the number of sectors per cylinder.

    MS-DOS versions 2.0 through 3.2 allow only one MS-DOS partition per
    partitioned device. Various device drivers have been implemented that
    use a different partition table that allows more than one MS-DOS
    partition to be installed, but the secondary MS-DOS partitions are
    usually accessible only by means of an installable device driver that
    knows about this change. (Even with additional MS-DOS partitions, a
    fixed disk can have only one bootable partition.)

Layout of a file system

    Block devices are accessed on a sector basis. The MS-DOS kernel,
    through the device driver, sees a block device as a logical fixed-size
    array of sectors and assumes that the array contains a valid MS-DOS
    file system. The device driver, in turn, translates the logical sector
    requests from MS-DOS into physical locations on the block device.

    The initial MS-DOS file system is written to the storage medium by the
    MS-DOS FORMAT program. See USER COMMANDS: FORMAT. The general layout
    for the file system is shown in Figure 3-5.


    ┌────────────────────────────────────────────────────────┐
    │OEM identification, BIOS parameter block, Loader routine│
    │                     Reserved area                      │
    ├────────────────────────────────────────────────────────┤
    │             File allocation table (FAT) #1             │
    ├────────────────────────────────────────────────────────┤
    │           Possible additional copies of FAT            │
    ├────────────────────────────────────────────────────────┤
    │                                                        │
    │                  Root disk directory                   │
    │                                                        │
    ├────────────────────────────────────────────────────────┤
    │                                                        │
    │                                                        │
    │                                                        │
    │                       Files area                       │
    │                                                        │
    └───────────────────┐                                    │
    ┌──────────────────┐└──────────────────┐                 │
    │                  └──────────────────┐└─────────────────┘
    │                                     └──────────────────┐
    │                                                        │
    └────────────────────────────────────────────────────────┘

    Figure 3-5. The MS-DOS file system.


    The boot sector is always at the beginning of a partition. It contains
    the OEM identification, a loader routine, and a BIOS parameter block
    (BPB) with information about the device, and it is followed by an
    optional area of reserved sectors. See The Boot Sector, below. The
    reserved area has no specific use, but an OEM might require a more
    complex loader routine and place it in this area. The file allocation
    tables (FATs) indicate how the file data area is allocated; the root
    directory contains a fixed number of directory entries; and the file
    data area contains data files, subdirectory files, and free data
    sectors.

    All the areas just described--the boot sector, the FAT, the root
    directory, and the file data area--are of fixed size; that is, they do
    not change after FORMAT sets up the medium. The size of each of these
    areas depends on various factors. For instance, the size of the FAT is
    proportional to the file data area. The root directory size ordinarily
    depends on the type of device; a single-sided floppy disk can hold 64
    entries, a double-sided floppy disk can hold 112, and a fixed disk can
    hold 256. (RAMdisk drivers such as RAMDRIVE.SYS and some
    implementations of FORMAT allow the number of directory entries to be
    specified.)

    The file data area is allocated in terms of clusters. A cluster is a
    fixed number of contiguous sectors. Sector size and cluster size must
    be a power of 2. The sector size is usually 512 bytes and the cluster
    size is usually 1, 2, or 4 KB, but larger sector and cluster sizes are
    possible. Commonly used MS-DOS cluster sizes are

╓┌────────────────────────────────┌───────────────────┌──────────────────────╖
    Disk Type                   Sectors/Cluster     Bytes/Cluster
    ──────────────────────────────────────────────────────────────────
    Single-sided floppy disk     1                    512
    Double-sided floppy disk     2                   1024
    PC/AT fixed disk             4                   2048
    PC/XT fixed disk             8                   4096
    Other fixed disks           16                   8192
    Other fixed disks           32                  16384

    In general, larger cluster sizes are used to support larger fixed
    disks. Although smaller cluster sizes make allocation more space
    -efficient, larger clusters are usually more efficient for random and
    sequential access, especially if the clusters for a single file are
    not sequentially allocated.

    The file allocation table contains one entry per cluster in the file
    data area. Doubling the sectors per cluster will also halve the number
    of FAT entries for a given partition. See The File Allocation Table,
    below.

The boot sector
    The boot sector (Figure 3-6) contains a BIOS parameter block, a loader
    routine, and some other fields useful to device drivers. The BPB
    describes a number of physical parameters of the device, as well as
    the location and size of the other areas on the device. The device
    driver returns the BPB information to MS-DOS when requested, so that
    MS-DOS can determine how the disk is configured.


    00H ┌───────────────────────────────────────────┐
        │           E9 XX XX or EB XX 90            │
    03H ├───────────────────────────────────────────┤
        │                                           │
        │      OEM name and version (8 bytes)       │
        │                                           │
    0BH ├───────────────────────────────────────────┤
        │        Bytes per sector (2 bytes)         │▒
    0DH ├───────────────────────────────────────────┤▒
        │   Sectors per allocation unit (1 byte)    │▒
    0EH ├───────────────────────────────────────────┤▒
        │ Reserved sectors, starting at 0 (2 bytes) │▒
    10H ├───────────────────────────────────────────┤▒
        │          Number of FATs (1 byte)          │▒
    11H ├───────────────────────────────────────────┤▒ BPB
        │Number of root-directory entries (2 bytes) │▒
    13H ├───────────────────────────────────────────┤▒
        │ Total sectors in logical volume (2 bytes) │▒
    15H ├───────────────────────────────────────────┤▒
        │           Media descriptor byte           │▒
    16H ├───────────────────────────────────────────┤▒
        │    Number of sectors per FAT (2 bytes)    │▒
    18H ├───────────────────────────────────────────┤
        │        Sectors per track (2 bytes)        │
    1AH ├───────────────────────────────────────────┤
        │         Number of heads (2 bytes)         │
    1CH ├───────────────────────────────────────────┤
        │    Number of hidden sectors (2 bytes)     │
    1EH ├───────────────────────────────────────────┤
        │                                           │
        │                                           │
        │                                           │
        │              Loader routine               │
        │                                           │
        │                                           │
        │                                           │
        │                                           │
        │                                           │
        └───────────────────────────────────────────┘

    Figure 3-6. Map of the boot sector of an MS-DOS disk. Bytes 0BH
    through 17H are the BIOS parameter block (BPB).


    Figure 3-7 is a hexadecimal dump of an actual boot sector. The first 3
    bytes of the boot sector shown in Figure 3-7 would be E9H 2CH 00H if a
    long jump were used instead of a short one (as in early versions of
    MS-DOS). The last 2 bytes in the sector, 55H and AAH, are a fixed
    signature used by the loader routine to verify that the sector is a
    valid boot sector.


    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
0000  EB 2D 90 20 20 20 20 20-20 20 20 00 02 02 01 00   k-.        .....
0010  02 70 00 A0 05 F9 03 00-09 00 02 00 00 00 00 00   .p. .y..........
0020  00 0A 00 00 DF 02 25 02-09 2A FF 50 F6 0A 02 FA   ...._.%..*.Pv..z
0030  B8 C0 07 8E D8 BC 00 7C-33 C0 8E D0 8E C0 FB FC   8@..X&lt;.|3@.P.@{|
.
.
.
0180  0A 44 69 73 6B 20 42 6F-6F 74 20 46 61 69 6C 75   .Disk Boot Failu
0190  72 65 0D 0A 0D 0A 4E 6F-6E 2D 53 79 73 74 65 6D   re....Non-System
01A0  20 64 69 73 6B 20 6F 72-20 64 69 73 6B 20 65 72    disk or disk er
01B0  72 6F 72 0D 0A 52 65 70-6C 61 63 65 20 61 6E 64   ror..Replace and
01C0  20 70 72 65 73 73 20 61-6E 79 20 6B 65 79 20 77    press any key w
01D0  68 65 6E 20 72 65 61 64-79 0D 0A 00 00 00 00 00   hen ready.......
01E0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   ................
01F0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 55 AA   ...............*

    Figure 3-7. Hexadecimal dump of an MS-DOS boot sector. The BPB is
    highlighted.


    The BPB information contained in bytes 0BH through 17H indicates that
    there are

    512 bytes per sector
        2 sectors per cluster
        1 reserved sector (for the boot sector)
        2 FATs
    112 root directory entries
    1440 sectors on the disk
    F9H media descriptor
        3 sectors per FAT

    Additional information immediately after the BPB indicates that there
    are 9 sectors per track, 2 read/write heads, and 0 hidden sectors.

    The media descriptor, which appears in the BPB and in the first byte
    of each FAT, is used to indicate the type of medium currently in a
    drive. IBM-compatible media have the following descriptors:

╓┌───────────────────┌────────────────────────────────┌──────────────────────╖
    Descriptor     Media Type                       MS-DOS Versions
    ──────────────────────────────────────────────────────────────────
    0F8H           Fixed disk                       2, 3
    0F0H           3.5-inch, 2-sided, 18 sector     3.2
    0F9H           3.5-inch, 2-sided, 9 sector      3.2
    0F9H           5.25-inch, 2-sided, 15 sector    3.x
    0FCH           5.25-inch, 1-sided, 9 sector     2.x, 3.x
    0FDH           5.25-inch, 2-sided, 9 sector     2.x, 3.x
    0FEH           5.25-inch, 1-sided, 8 sector     1.x, 2.x, 3.x
    0FFH           5.25-inch, 2-sided, 8 sector     1.x (except 1.0), 2, 3
    0FEH           8-inch, 1-sided, single-density
    0FDH           8-inch, 2-sided, single-density
    0FEH           8-inch, 1-sided, double-density
    0FDH           8-inch, 2-sided, double-density


The file allocation table
    The file allocation table provides a map to the storage locations of
    files on a disk by indicating which clusters are allocated to each
    file and in what order. To enable MS-DOS to locate a file, the file's
    directory entry contains its beginning FAT entry number. This FAT
    entry, in turn, contains the entry number of the next cluster if the
    file is larger than one cluster or a last-cluster number if there is
    only one cluster associated with the file. A file whose size implies
    that it occupies 10 clusters will have 10 FAT entries and 9 FAT links.
    (The set of links for a particular file is called a chain.)

    Additional copies of the FAT are used to provide backup in case of
    damage to the first, or primary, FAT; the typical floppy disk or fixed
    disk contains two FATs. The FATs are arranged sequentially after the
    boot sector, with some possible intervening reserved area. MS-DOS
    ordinarily uses the primary FAT but updates all FATs when a change
    occurs. It also compares all FATs when a disk is first accessed, to
    make sure they match.

    MS-DOS supports two types of FAT: One uses 12-bit links; the other,
    introduced with version 3.0 to accommodate large fixed disks with more
    than 4087 clusters, uses 16-bit links.

    The first two entries of a FAT are always reserved and are filled with
    a copy of the media descriptor byte and two (for a 12-bit FAT) or
    three (for a 16-bit FAT) 0FFH bytes, as shown in the following dumps
    of the first 16 bytes of the FAT:

    12-bit FAT:

    F9 FF FF 03 40 00 FF 6F-00 07 F0 FF 00 00 00 00

    16-bit FAT:

    F8 FF FF FF 03 00 04 00-FF FF 06 00 07 00 FF FF

    The remaining FAT entries have a one-to-one relationship with the
    clusters in the file data area. Each cluster's use status is indicated
    by its corresponding FAT value. (FORMAT initially marks the FAT entry
    for each cluster as free.) The use status is one of the following:

╓┌──────────────────────────┌──────────────────┌─────────────────────────────╖
    12-bit                16-bit             Meaning
    ──────────────────────────────────────────────────────────────────
    000H                  0000H              Free cluster
    001H                  0001H              Unused code
    FF0-FF6H              FFF0-FFF6H         Reserved
    FF7H                  FFF7H              Bad cluster; cannot be used
    FF8-FFFH              FFF8-FFFFH         Last cluster of file
    All other values      All other values   Link to next cluster in file

    If a FAT entry is nonzero, the corresponding cluster has been
    allocated. A free cluster is found by scanning the FAT from the
    beginning to find the first zero value. Bad clusters are ordinarily
    identified during formatting. Figure 3-8 shows a typical FAT chain.


FAT:  0      1      2      3      4      5      6      7      8      9
entry
                    ┌─────┐ ┌───────────┐ ┌─────┐
┌──────┬──────┬───┴──┬───┴─┬──────┬───┴─┬─────┬──────┬──────┬──────┬─
│ FFDH │ FFFH │ 003H │ 005H │ FF7H │ 006H │ FFFH │ 000H │ 000H │ 000H │
│(4093)│(4095)│ (3)  │ (5)  │(4087)│ (6)  │(4095)│ (0)  │ (0)  │ (0)  │
└──┬───┴──┬───┴──────┴──────┴──┬───┴──────┴──────┴──┬───┴──────┴──────┴─
    │      │                    │                    │       continues...
    │      │                    │                    │
    │      │                    │                    │
    │      │                    │                    └─Unused;
    │      │                    │                      available cluster
    │      │                    │
    │      │                    └─Unusable
    │      │
    │      └─Unused; not available
    │
    └─Disk is double-sided, double-density

    Figure 3-8. Space allocation in the FAT for a typical MS-DOS disk.


    Free FAT entries contain a link value of zero; a link value of 1 is
    never used. Thus, the first allocatable link number, associated with
    the first available cluster in the file data area, is 2, which is the
    number assigned to the first physical cluster in the file data area.
    Figure 3-9 shows the relationship of files, FAT entries, and clusters
    in the file data area.


12-bit FAT:

    Reserved    003H        FFFH        007H        000H
        │       ┌────┐      ┌────┐      ┌────┐      ┌────┐
┌────┴─────┐┌┴─┐  │     ┌┴─┐  │     ┌┴─┐  │     ┌┴─┐  │
│F9  FF  FF││03│ 40 │00││FF│ 6F │00││07│ F0 │FF││00│ 00
                    │  └─┬┘     │  └─┬┘     │  └─┬┘
                    └────┘      └────┘      └────┘
                    004H        006H        FFFH


16-bit FAT:

    Reserved
        │         0003H   0004H   FFFFH   0006H   0007H   FFFFH   0000H
┌──────┴───────┐┌──────┐┌──────┐┌──────┐┌──────┐┌──────┐┌──────┐┌──────┐
│F8  FF  FF  FF││03  00││04  00││FF  FF││06  00││07  00││FF  FF││00  00│

    FAT entry:     0     1     2     3     4     5     6     7     8
                ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─
    12-bit FAT: │     │     │ 003H│ 004H│ FFFH│ 006H│ 007H│ FFFH│ 000H│
                │ Reserved  │     │     │     │     │     │     │     │
    16-bit FAT: │     │     │0003H│0004H│FFFFH│0006H│0007H│FFFFH│0000H│
                └─────┴─────┴──┬─┴──┬─┴────┴──┬─┴──┬─┴────┴─────┴─
                            │ └───┘ └───┘     │ └───┘ └───┘continues...
        Directory entry      │                 │
    ┌───────────────────────┐ │                 │
    │        FILE1.TXT      ├─┘                 │
    │(points to FAT entry 2)│                   │
    └───────────────────────┘                   │
                                                │
    ┌───────────────────────┐                   │
    │        FILE2.TXT      ├───────────────────┘
    │(points to FAT entry 5)│
    └───────────────────────┘
                    File data area       Corresponding FAT entry
                ┌───────────────────────┐
                │       FILE1.TXT       │            2
                ├───────────────────────┤
                │       FILE1.TXT       │            3
                ├───────────────────────┤
                │       FILE1.TXT       │            4
                ├───────────────────────┤
                │       FILE2.TXT       │            5
                ├───────────────────────┤
                │       FILE2.TXT       │            6
                ├───────────────────────┤
                │       FILE2.TXT       │            7
                ├───────────────────────┤
                │  Unused (available)   │            8
                ├───────────────────────┤

    Figure 3-9. Correspondence between the FAT and the file data area.


    There is no logical difference between the operation of the 12-bit and
    16-bit FAT entries; the difference is simply in the storage and access
    methods. Because the 8086 is specifically designed to manipulate 8- or
    16-bit values efficiently, the access procedure for the 12-bit FAT is
    more complex than that for the 16-bit FAT (see Figures 3-10
    and 3-11).

    Special considerations
    The FAT is a highly efficient bookkeeping system, but various
    tradeoffs and problems can occur. One tradeoff is having a partially
    filled cluster at the end of a file. This situation leads to an
    efficiency problem when a large cluster size is used, because an
    entire cluster is allocated, regardless of the number of bytes it
    contains. For example, ten 100-byte files on a disk with 16 KB
    clusters use 160 KB of disk space; the same files on a disk with 1 KB
    clusters use only 10 KB--a difference of 150 KB, or 15 times less
    storage used by the smaller cluster size. On the other hand, the 12-
    bit FAT routine in Figure 3-10 shows the difficulty (and therefore
    slowness) of moving through a large file that has a long linked list
    of many small clusters. Therefore, the nature of the data must be
    considered: Large database applications work best with a larger
    cluster size; a smaller cluster size allows many small text files to
    fit on a disk. (The programmer writing the device driver for a disk
    device ordinarily sets the cluster size.)

    ──────────────────────────────────────────────────────────────────────

    Figure 3-10. Assembly-language routine to access a 12-bit FAT.

    ──────────────────────────────────────────────────────────────────────

    Figure 3-11. Assembly-language routine to access a 16-bit FAT.

    ──────────────────────────────────────────────────────────────────────

    Problems with corrupted directories or FATs, induced by such events as
    power failures and programs running wild, can lead to greater problems
    if not corrected. The MS-DOS CHKDSK program can detect and fix some of
    these problems. See USER COMMANDS: CHKDISK. For example, one common
    problem is dangling allocation lists caused by the absence of a
    directory entry pointing to the start of the list. This situation
    often results when the directory entry was not updated because a file
    was not closed before the computer was turned off or restarted. The
    effect is relatively benign: The data is inaccessible, but this
    limitation does not affect other file allocation operations. CHKDSK
    can fix this problem by making a new directory entry and linking it to
    the list.

    Another difficulty occurs when the file size in a directory entry does
    not match the file length as computed by traversing the linked list in
    the FAT. This problem can result in improper operation of a program
    and in error responses from MS-DOS.

    A more complex (and rarer) problem occurs when the directory entry is
    properly set up but all or some portion of the linked list is also
    referenced by another directory entry. The problem is grave, because
    writing or appending to one file changes the contents of the other
    file. This error usually causes severe data and/or directory
    corruption or causes the system to crash.

    A similar difficulty occurs when a linked list terminates with a free
    cluster instead of a last-cluster number. If the free cluster is
    allocated before the error is corrected, the problem eventually
    reverts to the preceding problem. An associated difficulty occurs if a
    link value of 1 or a link value that exceeds the size of the FAT is
    encountered.

    In addition to CHKDSK, a number of commercially available utility
    programs can be used to assist in FAT maintenance. For instance, disk
    reorganizers can be used to essentially rearrange the FAT and adjust
    the directory so that all files on a disk are laid out sequentially in
    the file data area and, of course, in the FAT.

The root directory
    Directory entries, which are 32 bytes long, are found in both the root
    directory and the subdirectories. Each entry includes a filename and
    extension, the file's size, the starting FAT entry, the time and date
    the file was created or last revised, and the file's attributes. This
    structure resembles the format of the CP/M-style file control blocks
    (FCBs) used by the MS-DOS version 1.x file functions. See PROGRAMMING
    IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: Disk Directories
    and Volume Labels.

    The MS-DOS file-naming convention is also derived from CP/M: an eight-
    character filename followed by a three-character file type, each left
    aligned and padded with spaces if necessary. Within the limitations of
    the character set, the name and type are completely arbitrary. The
    time and date stamps are in the same format used by other MS-DOS
    functions and reflect the time the file was last written to.

    Figure 3-12 shows a dump of a 512-byte directory sector containing 16
    directory entries. (Each entry occupies two lines in this example.)
    The byte at offset 0ABH, containing a 10H, signifies that the entry
    starting at 0A0H is for a subdirectory. The byte at offset 160H,
    containing 0E5H, means that the file has been deleted. The byte at
    offset 8BH, containing the value 08H, indicates that the directory
    entry beginning at offset 80H is a volume label. Finally the zero byte
    at offset 1E0H marks the end of the directory, indicating that the
    subsequent entries in the directory have never been used and therefore
    need not be searched (versions 2.0 and later).


    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
0000  49 4F 20 20 20 20 20 20-53 59 53 27 00 00 00 00   IO      SYS'....
0010  00 00 00 00 00 00 59 53-89 0B 02 00 D1 12 00 00   ......YS....Q...
0020  4F 53 44 4F 53 20 20 20-53 59 53 27 00 00 00 00   MSDOS   SYS'....
0030  00 00 00 00 00 00 41 49-52 0A 07 00 C9 43 00 00   ......AIR...IC..
0040  41 4E 53 49 20 20 20 20-53 59 53 20 00 00 00 00   ANSI    SYS ....
0050  00 00 00 00 00 00 41 49-52 0A 18 00 76 07 00 00   ......AIR...v...
0060  58 54 41 4C 4B 20 20 20-45 58 45 20 00 00 00 00   XTALK   EXE ....
0070  00 00 00 00 00 00 F7 7D-38 09 23 02 84 0B 01 00   ......w}8.#.....
0080  4C 41 42 45 4C 20 20 20-20 20 20 08 00 00 00 00   LABEL       ....
0090  00 00 00 00 00 00 8C 20-2A 09 00 00 00 00 00 00   ....... *.D..R..
00A0  4C 4F 54 55 53 20 20 20-20 20 20 10 00 00 00 00   LOTUS       ....
00B0  00 00 00 00 00 00 E0 0A-E1 06 A6 01 00 00 00 00   ......'.a.&amp;.a...
00C0  4C 54 53 4C 4F 41 44 20-43 4F 4D 20 00 00 00 00   LTSLOAD COM ....
00D0  00 00 00 00 00 00 E0 0A-E1 06 A7 01 A0 27 00 00   ......'.a.'. '..
00E0  4D 43 49 2D 53 46 20 20-58 54 4B 20 00 00 00 00   MCI-SF  XTK ....
00F0  00 00 00 00 00 00 46 19-32 0D B1 01 79 04 00 00   ......F.2.1.y...
0100  58 54 41 4C 4B 20 20 20-48 4C 50 20 00 00 00 00   XTALK   HLP ....
0110  00 00 00 00 00 00 C5 6D-73 07 A3 02 AF 88 00 00   ......Ems.#./...
0120  54 58 20 20 20 20 20 20-43 4F 4D 20 00 00 00 00   TX      COM ....
0130  00 00 00 00 00 00 05 61-65 0C 39 01 E8 20 00 00   .......ae.9.h ..
0140  43 4F 4D 4D 41 4E 44 20-43 4F 4D 20 00 00 00 00   COMMAND COM ....
0150  00 00 00 00 00 00 41 49-52 0A 27 00 55 3F 00 00   ......AIR.'.U?..
0160  E5 32 33 20 20 20 20 20-45 58 45 20 00 00 00 00   e23     EXE ....
0170  00 00 00 00 00 00 9C B2-85 0B 42 01 80 5F 01 00   .......2..B.._..
0180  47 44 20 20 20 20 20 20-44 52 56 20 00 00 00 00   GD      DRV ....
0190  00 00 00 00 00 00 E0 0A-E1 06 9A 01 5B 08 00 00   ......'.a...[...
01A0  4B 42 20 20 20 20 20 20-44 52 56 20 00 00 00 00   KB      DRV ....
01B0  00 00 00 00 00 00 E0 0A-E1 06 9D 01 60 01 00 00   ......'.a...'...
01C0  50 52 20 20 20 20 20 20-44 52 56 20 00 00 00 00   PR      DRV ....
01D0  00 00 00 00 00 00 E0 0A-E1 06 9E 01 49 01 00 00   ......'.a...I...
01E0  00 F6 F6 F6 F6 F6 F6 F6-F6 F6 F6 F6 F6 F6 F6 F6   ................
01F0  F6 F6 F6 F6 F6 F6 F6 F6-F6 F6 F6 F6 F6 F6 F6 F6   ................

    Figure 3-12. Hexadecimal dump of a 512-byte directory sector.


    The sector shown in Figure 3-12 is actually an example of the first
    directory sector in the root directory of a bootable disk. Notice that
    IO.SYS and MSDOS.SYS are the first two files in the directory and that
    the file attribute byte (offset 0BH in a directory entry) has a binary
    value of 00100111, indicating that both files have hidden (bit 1 = 1),
    system (bit 0 = 1), and read-only (bit 2 = 1) attributes. The archive
    bit (bit 5) is also set, marking the files for possible backup.

    The root directory can optionally have a special type of entry called
    a volume label, identified by an attribute type of 08H, that is used
    to identify disks by name. A root directory can contain only one
    volume label. The root directory can also contain entries that point
    to subdirectories; such entries are identified by an attribute type of
    10H and a file size of zero. Programs that manipulate subdirectories
    must do so by tracing through their chains of clusters in the FAT.

    Two other special types of directory entries are found only within
    subdirectories. These entries have the filenames . and .. and
    correspond to the current directory and the parent directory of the
    current directory. These special entries, sometimes called directory
    aliases, can be used to move quickly through the directory structure.

    The maximum pathname length supported by MS-DOS, excluding a drive
    specifier but including any filename and extension and subdirectory
    name separators, is 64 characters. The size of the directory structure
    itself is limited only by the number of root directory entries and the
    available disk space.

The file area
    The file area contains subdirectories, file data, and unallocated
    clusters. The area is divided into fixed-size clusters and the use for
    a particular cluster is specified by the corresponding FAT entry.


Other MS-DOS Storage Devices

    As mentioned earlier, MS-DOS supports other types of storage devices,
    such as magnetic-tape drives and CD ROM drives. Tape drives are most
    often used for archiving and for sequential transaction processing and
    therefore are not discussed here.

    CD ROMs are compact laser discs that hold a massive amount of
    information--a single side of a CD ROM can hold almost 500 MB of data.
    However, there are some drawbacks to current CD ROM technology. For
    instance, data cannot be written to them--the information is placed on
    the compact disk at the factory when the disk is made and is available
    on a read-only basis. In addition, the access time for a CD ROM is
    much slower than for most magnetic-disk systems. Even with these
    limitations, however, the ability to hold so much information makes
    CD ROM a good method for storing large amounts of static information.

                                                William Wong



───────────────────────────────────────────────────────────────────────────

Part B  Programming for MS-DOS



Article 4:  Structure of an Application Program


    Planning an MS-DOS application program requires serious analysis of
    the program's size. This analysis can help the programmer determine
    which of the two program styles supported by MS-DOS best suits the
    application. The .EXE program structure provides a large program with
    benefits resulting from the extra 512 bytes (or more) of header that
    preface all .EXE files. On the other hand, at the cost of losing the
    extra benefits, the .COM program structure does not burden a small
    program with the overhead of these extra header bytes.

    Because .COM programs start their lives as .EXE programs (before being
    converted by EXE2BIN) and because several aspects of application
    programming under MS-DOS remain similar regardless of the program
    structure used, a solid understanding of .EXE structures is beneficial
    even to the programmer who plans on writing only .COM programs.
    Therefore, we'll begin our discussion with the structure and behavior
    of .EXE programs and then look at differences between .COM programs
    and .EXE programs, including restrictions on the structure and content
    of .COM programs.


The .EXE Program

    The .EXE program has several advantages over the .COM program for
    application design. Considerations that could lead to the choice of
    the .EXE format include

    ■  Extremely large programs
    ■  Multiple segments
    ■  Overlays
    ■  Segment and far address constants
    ■  Long calls
    ■  Possibility of upgrading programs to MS OS/2 protected mode

    The principal advantages of the .EXE format are provided by the file
    header. Most important, the header contains information that permits a
    program to make direct segment address references--a requirement if
    the program is to grow beyond 64 KB.

    The file header also tells MS-DOS how much memory the program
    requires. This information keeps memory not required by the program
    from being allocated to the program-an important consideration if the
    program is to be upgraded in the future to run efficiently under MS
    OS/2 protected mode.

    Before discussing the .EXE program structure in detail, we'll look at
    how .EXE programs behave.

Giving control to the .EXE program

    Figure 4-1 gives an example of how a .EXE program might appear in
    memory when MS-DOS first gives the program control. The diagram shows
    Microsoft's preferred program segment arrangement.


                    ┌─────────────────────┬───────────────────────┐ SP
                    │                    ▒│Any segments with class│
                    │                    ▒│        STACK          │
                    │                    ▒├───────────────────────┤ SS
                    │    All segments    ▒│Any segments with class│
                    │     declared as    ▒│         BSS           │
                    │    part of group   ▒├───────────────────────┤
                    │        DGROUP      ▒│  Any DGROUP segments  │
                    │                    ▒│  not shown elsewhere  │
                    │                    ▒├───────────────────────┤
                    │                    ▒│Any segments with class│
                    │                    ▒│        BEGDATA        │
                    ├─────────────────────┴───────────────────────┤
                    │        Any segments with class names        │ IP
    Start segment │              ending with CODE               │
    and start of  ├─────────────────────────────────────────────┤ CS
    program image          Program segment prefix (PSP)
    (load module) └─  ──  ──  ──  ──  ──  ──  ──  ──  ──  ──  ──┘ DS,ES

    Figure 4-1. The .EXE program: memory map diagram with register
    pointers.


    Before transferring control to the .EXE program, MS-DOS initializes
    various areas of memory and several of the microprocessor's registers.
    The following discussion explains what to expect from MS-DOS before it
    gives the .EXE program control.

The program segment prefix
    The program segment prefix (PSP) is not a direct result of any program
    code. Rather, this special 256-byte (16-paragraph) page of memory is
    built by MS-DOS in front of all .EXE and .COM programs when they are
    loaded into memory. Although the PSP does contain several fields of
    use to newer programs, it exists primarily as a remnant of CP/M--
    Microsoft adopted the PSP for ease in porting the vast number of
    programs available under CP/M to the MS-DOS environment. Figure 4-2
    shows the fields that make up the PSP.



        x0H    x1H    x2H    x3H    x4H    x5H    x6H    x7H     x8H    x9H    xAH    xBH    xCH    xDH    xEH    xFH
        ┌─────────────┬─────────────┬──────┬───────────────────────────────────┬───────────────────────────┬─────────────┐
        │             │             │      │                                   │                           │             │
        │  INT 20H    │  End alloc  │ Resv.│  Far call to MS-DOS fn handler... │Prev terminate address     │Prev Ctrl C...
    0xH │             │             │      │                                   │                           │             │
        │ 0CDH │ 20H  │seg lo│seg hi│      │ 9AH  │ofs lo│ofs hi│ seg lo│seg hi│ofs lo│ofs hi│seg lo│seg hi│ofs lo│ofs hi│
        └──────┴──────┼──────┴──────┴──────┴──────┼──────┴──────┴───────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘
                    │                           │
        │ ...address  │Prev critical error address│                      ...Reserved...
    1xH │             │                           │
        │seg lo│seg hi│ofs lo│ofs hi│seg lo│seg hi│      │      │       │      │      │      │      │      │      │      │
        └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴───────┴──────┴──────┴──────┼──────┴──────┼──────┴──────┘
                                                                                            │             │             │
        │                                  ...Reserved...                                    │ Environ seg │ Reserved...
    2xH │                                                                                    │             │             │
        │      │      │      │      │      │      │      │      │       │      │      │      │seg lo│seg hi│      │      │
        └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴───────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘
                                                                                            ░░░░░░░░░░░░░░░──────────────────────┐
        │                                                 ...Reserved...
    3xH │                                                                                                                    (MS-DOS 2.0
        │      │      │      │      │      │      │      │      │       │      │      │      │      │      │      │      │ and later only)
        └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴───────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┤
                                                                                                                        │
        │                                                                                                                │
        │                                                   ...Reserved...                                               │
    4xH │                                                                                                                │
        │      │      │      │      │      │      │      │      │       │      │      │      │      │      │      │      │
        ├──────┴──────┴──────┼──────┴──────┴──────┴──────┴──────┴───────┴──────┴──────┴──────┼──────┴──────┴──────┴──────┘
        │                    │                                                               │
        │  INT 21H and RETF  │                                 Reserved                      │      Primary FCB...
    5xH │                    │                                                               │
        │ OCDH │ 21H  │ OCBH │      │      │      │      │      │       │      │      │      │  d   │  F   │  i   │  l   │
        └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴───────┴──────┴──────┴──────┼──────┴──────┴──────┴──────┘
                                                                                            │
        │                   ...Primary file control block (FCB)...                           │      Secondary FCB...
    6xH │                                                                                    │
        │  e   │  n   │  a   │  m   │  e   │  E   │  x   │  t   │  00H  │ 00H  │ 00H  │ 00H  │  d   │  F   │  i   │  l   │
        └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴───────┴──────┴──────┴──────┼──────┴──────┴──────┴──────┤
                                                                                            │                           │
        │                 ...Secondary file control block (FCB)...                           │         Reserved          │
    7xH │                                                                                    │                           │
        │  e   │  n   │  a   │  m   │  e   │  E   │  x   │  t   │  00H  │ 00H  │ 00H  │ 00H  │      │      │      │      │
        └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴───────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘
        │
        │                            Command trail and default disk transfer area (DTA)
    8xH │                                          (continues through OFFH)...
        │ Len  │      │      │      │      │      │      │      │       │      │      │      │      │      │      │      │
        └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴───────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘

    Figure 4-2. The program segment prefix (PSP).


    PSP:0000H (Terminate [old Warm Boot] Vector) The PSP begins with an
    8086-family INT 20H instruction, which the program can use to transfer
    control back to MS-DOS. The PSP includes this instruction at offset
    00H because this address was the WBOOT (Warm Boot/Terminate) vector
    under CP/M and CP/M programs usually terminated by jumping to this
    vector. This method of termination should not be used in newer
    programs. See Terminating the .EXE Program, below.

    PSP:0002H (Address of Last Segment Allocated to Program) MS-DOS
    introduced the word at offset 02H into the PSP. It contains the
    segment address of the paragraph following the block of memory
    allocated to the program. This address should be used only to
    determine the size or the end of the memory block allocated to the
    program; it must not be considered a pointer to free memory that the
    program can appropriate. In most cases this address will not point to
    free memory, because any free memory will already have been
    allocated to the program unless the program was linked using the
    /CPARMAXALLOC switch. Even when /CPARMAXALLOC is used, MS-DOS may fit
    the program into a block of memory only as big as the program
    requires. Well-behaved programs should acquire additional memory only
    through the MS-DOS function calls provided for that purpose.

    PSP:0005H (MS-DOS Function Call [old BDOS] Vector) Offset 05H is also
    a hand-me-down from CP/M. This location contains an 8086-family far
    (intersegment) call instruction to MS-DOS's function request handler.
    (Under CP/M, this address was the Basic Disk Operating System [BDOS]
    vector, which served a similar purpose.) This vector should not be
    used to call MS-DOS in newer programs. The System Calls section of
    this book explains the newer, approved method for calling MS-DOS.
    MS-DOS provides this vector only to support CP/M-style programs and
    therefore honors only the CP/M-style functions (00-24H) through it.

    PSP:000AH-0015H (Parent's 22H, 23H, and 24H Interrupt Vector Save)
    MS-DOS uses offsets 0AH through 15H to save the contents of three
    program-specific interrupt vectors. MS-DOS must save these vectors
    because it permits any program to execute another program (called a
    child process) through an MS-DOS function call that returns control to
    the original program when the called program terminates. Because the
    original program resumes executing when the child program terminates,
    MS-DOS must restore these three interrupt vectors for the original
    program in case the called program changed them. The three vectors
    involved include the program termination handler vector (Interrupt
    22H), the Control-C/Control-Break handler vector (Interrupt 23H), and
    the critical error handler vector (Interrupt 24H). MS-DOS saves the
    original preexecution contents of these vectors in the child program's
    PSP as doubleword fields beginning at offsets 0AH for the program
    termination handler vector, 0EH for the Control-C/Control-Break
    handler vector, and 12H for the critical error handler vector.

    PSP:002CH (Segment Address of Environment) Under MS-DOS versions 2.0
    and later, the word at offset 2CH contains one of the most useful
    pieces of information a program can find in the PSP--the segment
    address of the first paragraph of the MS-DOS environment. This pointer
    enables the program to search through the environment for any
    configuration or directory search path strings placed there by users
    with the SET command.

    PSP:0050H (New MS-DOS Call Vector) Many programmers disregard the
    contents of offset 50H. The location consists simply of an INT 21H
    instruction followed by a RETF. A .EXE program can call this location
    using a far call as a means of accessing the MS-DOS function handler.
    Of course, the program can also simply do an INT 21H directly, which
    is smaller and faster than calling 50H. Unlike calls to offset 05H,
    calls to offset 50H can request the full range of MS-DOS functions.

    PSP:005CH (Default File Control Block 1) and PSP:006CH (Default File
    Control Block 2) MS-DOS parses the first two parameters the user
    enters in the command line following the program's name. If the first
    parameter qualifies as a valid (limited) MS-DOS filename (the name can
    be preceded by a drive letter but not a directory path), MS-DOS
    initializes offsets 5CH through 6BH with the first 16 bytes of an
    unopened file control block (FCB) for the specified file. If the
    second parameter also qualifies as a valid MS-DOS filename, MS-DOS
    initializes offsets 6CH through 7BH with the first 16 bytes of an
    unopened FCB for the second specified file. If the user specifies a
    directory path as part of either filename, MS-DOS initializes only the
    drive code in the associated FCB. Many programmers no longer use this
    feature, because file access using FCBs does not support directory
    paths and other newer MS-DOS features.

    Because FCBs expand to 37 bytes when the file is opened, opening the
    first FCB at offset 5CH causes it to grow from 16 bytes to 37 bytes
    and to overwrite the second FCB. Similarly, opening the second FCB at
    offset 6CH causes it to expand and to overwrite the first part of the
    command tail and default disk transfer area (DTA). (The command tail
    and default DTA are described below.) To use the contents of both
    default FCBs, the program should copy the FCBs to a pair of 37-byte
    fields located in the program's data area. The program can use the
    first FCB without moving it only after relocating the second FCB (if
    necessary) and only by performing sequential reads or writes when
    using the first FCB. To perform random reads and writes using the
    first FCB, the programmer must either move the first FCB or change the
    default DTA address. Otherwise, the first FCB's random record field
    will overlap the start of the default DTA. See PROGRAMMING IN THE MS-
    DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: File and Record Management.

    PSP:0080H (Command Tail and Default DTA) The default DTA resides in
    the entire second half (128 bytes) of the PSP. MS-DOS uses this area
    of memory as the default record buffer if the program uses the FCB-
    style file access functions. Again, MS-DOS inherited this location
    from CP/M. (MS-DOS provides a function the program can call to change
    the address MS-DOS will use as the current DTA. See SYSTEM CALLS:
    INTERRUPT 21H: Function 1AH.) Because the default DTA serves no
    purpose until the program performs some file activity that requires
    it, MS-DOS places the command tail in this area for the program to
    examine. The command tail consists of any text the user types
    following the program name when executing the program. Normally, an
    ASCII space (20H) is the first character in the command tail, but any
    character MS-DOS recognizes as a separator can occupy this position.
    MS-DOS stores the command-tail text starting at offset 81H and always
    places an ASCII carriage return (0DH) at the end of the text. As an
    additional aid, it places the length of the command tail at offset
    80H. This length includes all characters except the final 0DH. For
    example, the command line

    C&gt;DOIT WITH CLASS  &lt;ENTER&gt;

    will result in the program DOIT being executed with PSP:0080H
    containing

    0B  20 57 49 54 48 20 43 4C 41 53 53 0D
    len sp W  I  T  H  sp C  L  A  S  S  cr

The stack
    Because .EXE-style programs did not exist under CP/M, MS-DOS expects
    .EXE programs to operate in strictly MS-DOS fashion. For example,
    MS-DOS expects the .EXE program to supply its own stack. (Figure 4-1
    shows the program's stack as the top box in the diagram.)

    Microsoft's high-level-language compilers create a stack themselves,
    but when writing in assembly language the programmer must specifically
    declare one or more segments with the STACK combine type. If the
    programmer declares multiple stack segments, possibly in different
    source modules, the linker combines them into one large segment. See
    Controlling the .EXE Program's Structure, below.

    Many programmers declare their stack segments as preinitialized with
    some recognizable repeating string such as *STACK. This makes it
    possible to examine the program's stack in memory (using a debugger
    such as DEBUG) to determine how much stack space the program actually
    used. On the other hand, if the stack is left as uninitialized memory
    and linked at the end of the .EXE program, it will not require space
    within the .EXE file. (The reason for this will become more apparent
    when we examine the structure of a .EXE file.)

    Note: When multiple stack segments have been declared in different
    .ASM files, the Microsoft Object Linker (LINK) correctly allocates the
    total amount of stack space specified in all the source modules, but
    the initialization data from all modules is overlapped module by
    module at the high end of the combined segment.

    An important difference between .COM and .EXE programs is that MS-DOS
    preinitializes a .COM program's stack with a termination address
    before transferring control to the program. MS-DOS does not do this
    for .EXE programs, so a .EXE program cannot simply execute an 8086-
    family RET instruction as a means of terminating.

    Note: In the assembly-language files generated for a Microsoft C
    program or for programs in most other high-level-languages, the
    compiler's placement of a RET instruction at the end of the main
    function/subroutine/procedure might seem confusing. After all, MS-DOS
    does not place any return address on the stack. The compiler places
    the RET at the end of main because main does not receive control
    directly from MS-DOS. A library initialization routine receives
    control from MS-DOS; this routine then calls main. When main performs
    the RET, it returns control to a library termination routine, which
    then terminates back to MS-DOS in an approved manner.

Preallocated memory
    While loading a .EXE program, MS-DOS performs several steps to
    determine the initial amount of memory to be allocated to the program.
    First, MS-DOS reads the two values the linker places near the start of
    the .EXE header: The first value, MINALLOC, indicates the minimum
    amount of extra memory the program requires to start executing; the
    second value, MAXALLOC, indicates the maximum amount of extra memory
    the program would like allocated before it starts executing. Next,
    MS-DOS locates the largest free block of memory available. If the size
    of the program's image within the .EXE file combined with the value
    specified for MINALLOC exceeds the memory block it found, MS-DOS
    returns an error to the process trying to load the program. If that
    process is COMMAND.COM, COMMAND.COM then displays a Program too big to
    fit in memory error message and terminates the user's execution
    request. If the block exceeds the program's MINALLOC requirement,
    MS-DOS then compares the memory block against the program's image
    combined with the MAXALLOC request. If the free block exceeds the
    maximum memory requested by the program, MS-DOS allocates only the
    maximum request; otherwise, it allocates the entire block. MS-DOS then
    builds a PSP at the start of this block and loads the program's image
    from the .EXE file into memory following the PSP.

    This process ensures that the extra memory allocated to the program
    will immediately follow the program's image. The same will not
    necessarily be true for any memory MS-DOS allocates to the program as
    a result of MS-DOS function calls the program performs during its
    execution. Only function calls requesting MS-DOS to increase the
    initial allocation can guarantee additional contiguous memory. (Of
    course, the granting of such increase requests depends on the
    availability of free memory following the initial allocation.)

    Programmers writing .EXE programs sometimes find the lack of keywords
    or compiler/ assembler switches that deal with MINALLOC (and possibly
    MAXALLOC) confusing. The programmer never explicitly specifies a
    MINALLOC value because LINK sets MINALLOC to the total size of all
    uninitialized data and/or stack segments linked at the very end of the
    program. The MINALLOC field allows the compiler to indicate the size
    of the initialized data fields in the load module without actually
    including the fields themselves, resulting in a smaller .EXE program
    file. For LINK to minimize the size of the .EXE file, the program must
    be coded and linked in such a way as to place all uninitialized data
    fields at the end of the program. Microsoft high-level-language
    compilers handle this automatically; assembly-language programmers
    must give LINK a little help.

    Note: Beginning and even advanced assembly-language programmers can
    easily fall into an argument with the assembler over field addressing
    when attempting to place data fields after the code in the source
    file. This argument can be avoided if programmers use the SEGMENT and
    GROUP assembler directives. See Controlling the .EXE Program's
    Structure, below.

    No reliable method exists for the linker to determine the correct
    MAXALLOC value required by the .EXE program. Therefore, LINK uses a
    "safe" value of FFFFH, which causes MS-DOS to allocate all of the
    largest block of free memory--which is usually all free memory--to the
    program. Unless a program specifically releases the memory for which
    it has no use, it denies multitasking supervisor programs, such as
    IBM's TopView, any memory in which to execute additional programs--
    hence the rule that a well-behaved program releases unneeded memory
    during its initialization. Unfortunately, this memory conservation
    approach provides no help if a multitasking supervisor supports the
    ability to load several programs into memory without executing them.
    Therefore, programs that have correctly established MAXALLOC values
    actually are well-behaved programs.

    To this end, newer versions of Microsoft LINK include the
    /CPARMAXALLOC switch to permit specification of the maximum amount of
    memory required by the program. The /CPARMAXALLOC switch can also be
    used to set MAXALLOC to a value that is known to be less than
    MINALLOC. For example, specifying a MAXALLOC value of 1 (/CP:1) forces
    MS-DOS to allocate only MINALLOC extra paragraphs to the program. In
    addition, Microsoft supplies a program called EXEMOD with most of its
    languages. This program permits modification of the MAXALLOC field in
    the headers of existing .EXE programs. See Modifying the .EXE File
    Header, below.

The registers
    Figure 4-1 gives a general indication of how MS-DOS sets the 8086-
    family registers before transferring control to a .EXE program. MS-DOS
    determines most of the original register values from information the
    linker places in the .EXE file header at the start of the .EXE file.

    MS-DOS sets the SS register to the segment (paragraph) address of the
    start of any segments declared with the STACK combine type and sets
    the SP register to the offset from SS of the byte immediately after
    the combined stack segments. (If no stack segment is declared, MS-DOS
    sets SS:SP to CS:0000.) Because in the 8086-family architecture a
    stack grows from high to low memory addresses, this effectively sets
    SS:SP to point to the base of the stack. Therefore, if the programmer
    declares stack segments when writing an assembly-language program, the
    program will not need to initialize the SS and SP registers.
    Microsoft's high-level-language compilers handle the creation of stack
    segments automatically. In both cases, the linker determines the
    initial SS and SP values and places them in the header at the start of
    the .EXE program file.

    Unlike its handling of the SS and SP registers, MS-DOS does not
    initialize the DS and ES registers to any data areas of the .EXE
    program. Instead, it points DS and ES to the start of the PSP. It does
    this for two primary reasons: First, MS-DOS uses the DS and ES
    registers to tell the program the address of the PSP; second, most
    programs start by examining the command tail within the PSP. Because
    the program starts without DS pointing to the data segments, the
    program must initialize DS and (optionally) ES to point to the data
    segments before it starts trying to access any fields in those
    segments. Unlike .COM programs, .EXE programs can do this easily
    because they can make direct references to segments, as follows:

            MOV     AX,SEG DATA_SEGMENT_OR_GROUP_NAME
            MOV     DS,AX
            MOV     ES,AX

    High-level-language programs need not initialize and maintain DS and
    ES; the compiler and library support routines do this.

    In addition to pointing DS and ES to the PSP, MS-DOS also sets AH and
    AL to reflect the validity of the drive identifiers it placed in the
    two FCBs contained in the PSP. MS-DOS sets AL to 0FFH if the first FCB
    at PSP:005CH was initialized with a nonexistent drive identifier;
    otherwise, it sets AL to zero. Similarly, MS-DOS sets AH to reflect
    the drive identifier placed in the second FCB at PSP:006CH.

    When MS-DOS analyzes the first two command-line parameters following
    the program name in order to build the first and second FCBs, it
    treats any character followed by a colon as a drive prefix. If the
    drive prefix consists of a lowercase letter (ASCII a through z), MS-
    DOS starts by converting the character to uppercase (ASCII A through
    Z). Then it subtracts 40H from the character, regardless of its
    original value. This converts the drive prefix letters A through Z to
    the drive codes 01H through 1AH, as required by the two FCBs. Finally,
    MS-DOS places the drive code in the appropriate FCB.

    This process does not actually preclude invalid drive specifications
    from being placed in the FCBs. For instance, MS-DOS will accept the
    drive prefix !: and place a drive code of 0E1H in the FCB (! = 21H;
    21H-40H = 0E1H). However, MS-DOS will then check the drive code to see
    if it represents an existing drive attached to the computer and will
    pass a value of 0FFH to the program in the appropriate register (AL or
    AH) if it does not.

    As a side effect of this process, MS-DOS accepts @: as a valid drive
    prefix because the subtraction of 40H converts the @ character (40H)
    to 00H. MS-DOS accepts the 00H value as valid because a 00H drive code
    represents the current default drive. MS-DOS will leave the FCB's
    drive code set to 00H rather than translating it to the code for the
    default drive because the MS-DOS function calls that use FCBs accept
    the 00H code.

    Finally, MS-DOS initializes the CS and IP registers, transferring
    control to the program's entry point. Programs developed using high-
    level-language compilers usually receive control at a library
    initialization routine. A programmer writing an assembly-language
    program using the Microsoft Macro Assembler (MASM) can declare any
    label within the program as the entry point by placing the label
    after the END statement as the last line of the program:

            END     ENTRY_POINT_LABEL

    With multiple source files, only one of the files should have a label
    following the END statement. If more than one source file has such a
    label, LINK uses the first one it encounters as the entry point.

    The other processor registers (BX, CX, DX, BP, SI, and DI) contain
    unknown values when the program receives control from MS-DOS. Once
    again, high-level-language programmers can ignore this fact--the
    compiler and library support routines deal with the situation. How-
    ever, assembly-language programmers should keep this fact in mind.
    It may give needed insight sometime in the future when a program
    functions at certain times and not at others.

    In many cases, debuggers such as DEBUG and SYMDEB initialize
    uninitialized registers to some predictable but undocumented state.
    For instance, some debuggers may predictably set BP to zero before
    starting program execution. However, a program must not rely on such
    debugger actions, because MS-DOS makes no such promises. Situations
    like this could account for a program that fails when executed
    directly under MS-DOS but works fine when executed using a debugger.

Terminating the .EXE program

    After MS-DOS has given the .EXE program control and it has completed
    whatever task it set out to perform, the program needs to give control
    back to MS-DOS. Because of MS-DOS's evolution, five methods of program
    termination have accumulated--not including the several ways MS-DOS
    allows programs to terminate but remain resident in memory.

    Before using any of the termination methods supported by MS-DOS, the
    program should always close any files it had open, especially those
    to which data has been written or whose lengths were changed. Under
    versions 2.0 and later, MS-DOS closes any files opened using handles.
    However, good programming practice dictates that the program not rely
    on the operating system to close the program's files. In addition,
    programs written to use shared files under MS-DOS versions 3.0 and
    later should release any file locks before closing the files and
    terminating.

The Terminate Process with Return Code function
    Of the five ways a program can terminate, only the Interrupt 21H
    Terminate Process with Return Code function (4CH) is recommended for
    programs running under MS-DOS version 2.0 or later. This method is one
    of the easiest approaches to terminating any program, regardless of
    its structure or segment register settings. The Terminate Process with
    Return Code function call simply consists of the following:

            MOV     AH,4CH               ;load the MS-DOS function code
            MOV     AL,RETURN_CODE       ;load the termination code
            INT     21H                  ;call MS-DOS to terminate program

    The example loads the AH register with the Terminate Process with
    Return Code function code. Then it loads the AL register with a return
    code. Normally, the return code represents the reason the program
    terminated or the result of any operation the program performed.

    A program that executes another program as a child process can recover
    and analyze the child program's return code if the child process used
    this termination method. Likewise, the child process can recover the
    RETURN_CODE returned by any program it executes as a child process.
    When a program is terminated using this method and control returns to
    MS-DOS, a batch (.BAT) file can be used to test the terminated
    program's return code using the IF ERRORLEVEL statement.

    Only two general conventions have been adopted for the value of
    RETURN_CODE: First, a RETURN_CODE value of 00H indicates a normal
    no-error termination of the program; second, increasing RETURN_CODE
    values indicate increasing severity of conditions under which the
    program terminated. For instance, a compiler could use the RETURN_CODE
    00H if it found no errors in the source file, 01H if it found only
    warning errors, or 02H if it found severe errors.

    If a program has no need to return any special RETURN_CODE values,
    then the following instructions will suffice to terminate the program
    with a RETURN_CODE of 00H:

            MOV     AX,4C00H
            INT     21H

    Apart from being the approved termination method, Terminate Process
    with Return Code is easier to use with .EXE programs than any other
    termination method because all other methods require that the CS
    register point to the start of the PSP when the program terminates.
    This restriction causes problems for .EXE programs because they have
    code segments with segment addresses different from that of the PSP.

    The only problem with Terminate Process with Return Code is that it is
    not available under MS-DOS versions earlier than 2.0, so it cannot be
    used if a program must be compatible with early MS-DOS versions.
    However, Figure 4-3 shows how a program can use the approved
    termination method when available but still remain pre-2.0 compatible.
    See The Warm Boot/Terminate Vector, below.

    ──────────────────────────────────────────────────────────────────────

    Figure 4-3. Terminating properly under any MS-DOS version.

    ──────────────────────────────────────────────────────────────────────

The Terminate Program interrupt
    Before MS-DOS version 2.0, terminating with an approved method meant
    executing an INT 20H instruction, the Terminate Program interrupt. The
    INT 20H instruction was replaced as the approved termination method
    for two primary reasons: First, it did not provide a means whereby
    programs could return a termination code; second, CS had to point to
    the PSP before the INT 20H instruction was executed.

    The restriction placed on the value of CS at termination did not pose
    a problem for .COM programs because they execute with CS pointing to
    the beginning of the PSP. A .EXE program, on the other hand, executes
    with CS pointing to various code segments of the program, and the
    value of CS cannot be changed arbitrarily when the program is ready to
    terminate. Because of this, few .EXE programs attempt simply to
    execute a Terminate Program interrupt from directly within their own
    code segments. Instead, they usually use the termination method
    discussed next.

The Warm Boot/Terminate vector
    The earlier discussion of the structure of the PSP briefly covered one
    older method a .EXE program can use to terminate: Offset 00H within
    the PSP contains an INT 20H instruction to which the program can jump
    in order to terminate. MS-DOS adopted this technique to support the
    many CP/M programs ported to MS-DOS. Under CP/M, this PSP location was
    referred to as the Warm Boot vector because the CP/M operating system
    was always reloaded from disk (rebooted) whenever a program
    terminated.

    Because offset 00H in the PSP contains an INT 20H instruction, jumping
    to that location terminates a program in the same manner as an INT 20H
    included directly within the program, but with one important
    difference: By jumping to PSP:0000H, the program sets the CS register
    to point to the beginning of the PSP, thereby satisfying the only
    restriction imposed on executing the Terminate Program interrupt. The
    discussion of MS-DOS Function 4CH gave an example of how a .EXE
    program can terminate via PSP:0000H. The example first asks MS-DOS for
    its version number and then terminates via PSP:0000H only under
    versions of MS-DOS earlier than 2.0. Programs can also use PSP:0000H
    under MS-DOS versions 2.0 and later; the example uses Function 4CH
    simply because it is preferred under the later MS-DOS versions.

The RET instruction
    The other popular method used by CP/M programs to terminate involved
    simply executing a RET instruction. This worked because CP/M pushed
    the address of the Warm Boot vector onto the stack before giving the
    program control. MS-DOS provides this support only for .COM-style
    programs; it does not push a termination address onto the stack before
    giving .EXE programs control.

    The programmer who wants to use the RET instruction to return to
    MS-DOS can use the variation of the Figure 4-3 listing shown in
    Figure 4-4.

    ──────────────────────────────────────────────────────────────────────

    Figure 4-4. Using RET to return control to MS-DOS.

    ──────────────────────────────────────────────────────────────────────

The Terminate Process function
    The final method for terminating a .EXE program is Interrupt 21H
    Function 00H (Terminate Process). This method maintains the same
    restriction as all other older termination methods: CS must point to
    the PSP. Because of this restriction, .EXE programs typically avoid
    this method in favor of terminating via PSP:0000H, as discussed above
    for programs executing under versions of MS-DOS earlier than 2.0.

Terminating and staying resident
    A .EXE program can use any of several additional termination methods
    to return control to MS-DOS but still remain resident within memory to
    service a special event. See PROGRAMMING IN THE MS-DOS ENVIRONMENT:
    CUSTOMIZING MS-DOS: Terminate-and-Stay-Resident Utilities.

Structure of the .EXE files

    So far we've examined how the .EXE program looks in memory, how MS-DOS
    gives the program control of the computer, and how the program should
    return control to MS-DOS. Next we'll investigate what the program
    looks like as a disk file, before MS-DOS loads it into memory. Figure
    4-5 shows the general structure of a .EXE file.



                x0H    x1H    x2H    x3H    x4H    x5H    x6H    x7H    x8H    x9H    xAH    xBH    xCH    xDH    xEH    xFH
                ┌─────────────┬─────────────┬─────────────┬─────────────┬─────────────┬─────────────┬─────────────┬─────────────┐
                │             │             │             │             │             │             │             │             │
                │  Signature  │  Last page  │ File Pages  │ Reloc Items │Header Paras │  MINALLOC   │  MAXALLOC   │PreReloc SS  │
        0xH  │             │    Size     │             │             │             │             │             │             │
                │  4DH │ 5AH  │lo byt│hi byt│lo byt│hi byt│lo byt│hi byt│lo byt│hi byt│lo byt│hi byt│lo byt│hi byt│lo byt│hi byt│
                ├──────┴──────┼──────┴──────┼──────┴──────┼──────┴──────┼──────┴──────┼──────┴──────┼──────┴──────┴──────┴──────┤
                │             │             │             │             │             │             │                           │
                │ Initial SP  │ Neg Chksum  │ Initial IP  │Pre Reloc CS │Reloc Tbl Ofs│ Overlay Num │         Reserved          │
        1xH  │             │             │             │             │             │             │                           │
                │ofs lo│ofs hi│lo byt│hi byt│ofs lo│ofs hi│seg lo│seg hi│lo byt│hi byt│lo byt│hi byt│                           │
                ├──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘                           │
                └────────────────────┐                                                                         ┌────────────────┘
                ┌───────────────────┐└────────────────────┐                                 ┌──────────────────┘┌───────────────┐
                │                   └────────────────────┐└─────────────────────────────────┘┌──────────────────┘               │
    Use Reloc   │                                        └───────────────────────────────────┘                                  │
Tbl Ofs at   │                                                                                                               │
18H (offset   ├───────────────────────────┬───────────────────────────┬───────────────────────────┬───────────────────────────┤
    is from   │   Seg relocation Ptr #1   │   Seg relocation Ptr #2   │   Seg Relocation Ptr #3   │   Seg Relocation Ptr #4   │
    start of  │                           │                           │                           │                           │
        file)   │                           │                           │                           │                           │
                │ofs lo│ofs hi│seg lo│seg hi│ofs lo│ofs hi│seg lo│seg hi│ofs lo│ofs hi│seg lo│seg hi│ofs lo│ofs hi│seg lo│seg hi│
                ├──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┤
                └────────────────────┐                                                                            ┌─────────────┘
                ┌───────────────────┐└────────────────────┐                                  ┌────────────────────┘┌────────────┐
                │                   └────────────────────┐└──────────────────────────────────┘┌────────────────────┘            │
                │                                        └────────────────────────────────────┘                                 │
                │                                                                                                               │
                ├───────────────────────────┬───────────────────────────┬───────────────────────────┬───────────────────────────┤
                │   Seg relocation Ptr #n-3 │   Seg relocation Ptr #n-2 │  Seg relocation Ptr #n-1  │   Seg relocation Ptr #n   │
                │                           │                           │                           │                           │─┐
                │                           │                           │                           │                           │ Use
                │ofs lo│ofs hi│seg lo│seg hi│ofs lo│ofs hi│seg lo│seg hi│ofs lo│ofs hi│seg lo│seg hi│ofs lo│ofs hi│seg lo│seg hi│ Reloc
                ├──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┤ Items
                └────────────────────┐                                                                            ┌─────────────┘ at
Use Header   ┌───────────────────┐└────────────────────┐                                  ┌────────────────────┘┌────────────┐ 06H
Paras at 08H   │                   └────────────────────┐└──────────────────────────────────┘┌────────────────────┘            │
(load module   │                                        └────────────────────────────────────┘                                 │
always starts   │                                                                                                               │
on paragraph  ├───────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
    boundary)   │                                                                                                              │
                │      Program image                                                                                            │
                │  - - - - - - - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  │
                │      (load module)            Use last page size at 02H                                                      │
                │                                                                                     Final 512-byte page as   │
End of file  ├─────────────────────────────────────────────────────────────────────────────────────indicated by File Pages───┘
                |                                                                                            at 04H             |
                |                                                                                                              |
                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    Figure 4-5. Structure of a .EXE file.


The file header
    Unlike .COM program files, .EXE program files contain information that
    permits the .EXE program and MS-DOS to use the full capabilities of
    the 8086 family of microprocessors. The linker places all this extra
    information in a header at the start of the .EXE file. Although the
    .EXE file structure could easily accommodate a header as small as 32
    bytes, the linker never creates a header smaller than 512 bytes. (This
    minimum header size corresponds to the standard record size preferred
    by MS-DOS.) The .EXE file header contains the following information,
    which MS-DOS reads into a temporary work area in memory for use while
    loading the .EXE program:

    00-01H (.EXE Signature) MS-DOS does not rely on the extension (.EXE or
    .COM) to determine whether a file contains a .COM or a .EXE program.
    Instead, MS-DOS recognizes the file as a .EXE program if the first 2
    bytes in the header contain the signature 4DH 5AH (ASCII characters M
    and Z). If either or both of the signature bytes contain other values,
    MS-DOS assumes the file contains a .COM program, regardless of the
    extension. The reverse is not necessarily true--that is, MS-DOS does
    not accept the file as a .EXE program simply because the file begins
    with a .EXE signature. The file must also pass several other tests.

    02-03H (Last Page Size) The word at this location indicates the actual
    number of bytes in the final 512-byte page of the file. This word
    combines with the following word to determine the actual size of the
    file.

    04-05H (File Pages) This word contains a count of the total number of
    512-byte pages required to hold the file. If the file contains 1024
    bytes, this word contains the value 0002H; if the file contains 1025
    bytes, this word contains the value 0003H. The previous word (Last
    Page Size, 02-03H) is used to determine the number of valid bytes in
    the final 512-byte page. Thus, if the file contains 1024 bytes, the
    Last Page Size word contains 0000H because no bytes overflow into a
    final partly used page; if the file contains 1025 bytes, the Last Page
    Size word contains 0001H because the final page contains only a single
    valid byte (the 1025th byte).

    06-07H (Relocation Items) This word gives the number of entries that
    exist in the relocation pointer table. See Relocation Pointer Table,
    below.

    08-09H (Header Paragraphs) This word gives the size of the .EXE file
    header in 16-byte paragraphs. It indicates the offset of the program's
    compiled/assembled and linked image (the load module) within the .EXE
    file. Subtracting this word from the two file-size words starting at
    02H and 04H reveals the size of the program's image. The header always
    spans an even multiple of 16-byte paragraphs. For example, if the file
    consists of a 512-byte header and a 513-byte program image, then the
    file's total size is 1025 bytes. As discussed before, the Last Page
    Size word (02-03H) will contain 0001H and the File Pages word (04-05H)
    will contain 0003H. Because the header is 512 bytes, the Header
    Paragraphs word (08-09H) will contain 32 (0020H). (That is, 32
    paragraphs times 16 bytes per paragraph totals 512 bytes.) By
    subtracting the 512 bytes of the header from the 1025-byte total file
    size, the size of the program's image can be determined--in this case,
    513 bytes.

    0A-0BH (MINALLOC) This word indicates the minimum number of 16-byte
    paragraphs the program requires to begin execution in addition to the
    memory required to hold the program's image. MINALLOC normally
    represents the total size of any uninitialized data and/or stack
    segments linked at the end of the program. LINK excludes the space
    reserved by these fields from the end of the .EXE file to avoid
    wasting disk space. If not enough memory remains to satisfy MINALLOC
    when loading the program, MSDOS returns an error to the process trying
    to load the program. If the process is COMMAND.COM, COMMAND.COM then
    displays a Program too big to fit in memory error message. The EXEMOD
    utility can alter this field if desired. See Modifying the .EXE File
    Header, below.

    0C-0DH (MAXALLOC) This word indicates the maximum number of 16-byte
    paragraphs the program would like allocated to it before it begins
    execution. MAXALLOC indicates additional memory desired beyond that
    required to hold the program's image. MS-DOS uses this value to
    allocate MAXALLOC extra paragraphs, if available. If MAXALLOC
    paragraphs are not available, the program receives the largest memory
    block available--at least MINALLOC additional paragraphs. The
    programmer could use the MAXALLOC field to request that MS-DOS
    allocate space for use as a print buffer or as a program-maintained
    heap, for example.

    Unless otherwise specified with the /CPARMAXALLOC switch at link time,
    the linker sets MAXALLOC to FFFFH. This causes MS-DOS to allocate all
    of the largest block of memory it has available to the program. To
    make the program compatible with multitasking supervisor programs, the
    programmer should use /CPARMAXALLOC to set the true maximum number of
    extra paragraphs the program desires. The EXEMOD utility can also be
    used to alter this field.

    Note: If both MINALLOC and MAXALLOC have been set to 0000H, MS-DOS
    loads the program as high in memory as possible. LINK sets these
    fields to 0000H if the /HIGH switch was used; the EXEMOD utility can
    also be used to modify these fields.

    0E-0FH (Initial SS Value) This word contains the paragraph address of
    the stack segment relative to the start of the load module. At load
    time, MS-DOS relocates this value by adding the program's start
    segment address to it, and the resulting value is placed in the SS
    register before giving the program control. (The start segment
    corresponds to the first segment boundary in memory following the
    PSP.)

    10-11H (Initial SP Value) This word contains the absolute value that
    MS-DOS loads into the SP register before giving the program control.
    Because MS-DOS always loads programs starting on a segment address
    boundary, and because the linker knows the size of the stack segment,
    the linker is able to determine the correct SP offset at link time;
    therefore, MS-DOS does not need to adjust this value at load time. The
    EXEMOD utility can be used to alter this field.

    12-13H (Complemented Checksum) This word contains the one's complement
    of the summation of all words in the .EXE file. Current versions of
    MS-DOS basically ignore this word when they load a .EXE program;
    however, future versions might not. When LINK generates a .EXE file,
    it adds together all the contents of the .EXE file (including the .EXE
    header) by treating the entire file as a long sequence of 16-bit
    words. During this addition, LINK gives the Complemented Checksum word
    (12-13H) a temporary value of 0000H. If the file consists of an odd
    number of bytes, then the final byte is treated as a word with a high
    byte of 00H. Once LINK has totaled all words in the .EXE file, it
    performs a one's complement operation on the total and records the
    answer in the .EXE file header at offsets 12-13H. The validity of a
    .EXE file can then be checked by performing the same word-totaling
    process as LINK performed. The total should be FFFFH, because the
    total will include LINK's calculated complemented checksum, which is
    designed to give the file the FFFFH total.

    An example 7-byte .EXE file illustrates how .EXE file checksums are
    calculated. (This is a totally fictitious file, because .EXE headers
    are never smaller than 512 bytes.) If this fictitious file contained
    the bytes 8CH C8H 8EH D8H BAH 10H B4H, then the file's total would be
    calculated using C88CH+D88EH+10BAH+00B4H=1B288H. (Overflow past 16
    bits is ignored, so the value is interpreted as B288H.) If this were a
    valid .EXE file, then the B288H total would have been FFFFH instead.

    14-15H (Initial IP Value) This word contains the absolute value that
    MS-DOS loads into the IP register in order to transfer control to the
    program. Because MS-DOS always loads programs starting on a segment
    address boundary, the linker can calculate the correct IP offset from
    the initial CS register value at link time; therefore, MS-DOS does not
    need to adjust this value at load time.

    16-17H (Pre-Relocated Initial CS Value) This word contains the initial
    value, relative to the start of the load module, that MS-DOS places in
    the CS register to give the .EXE program control. MS-DOS adjusts this
    value in the same manner as the initial SS value before loading it
    into the CS register.

    18-19H (Relocation Table Offset) This word gives the offset from the
    start of the file to the relocation pointer table. This word must be
    used to locate the relocation pointer table, because variable-length
    information pertaining to program overlays can occur before the table,
    thus causing the position of the table to vary.

    1A-1BH (Overlay Number) This word is normally set to 0000H, indicating
    that the .EXE file consists of the resident, or primary, part of the
    program. This number changes only in files containing programs that
    use overlays, which are sections of a program that remain on disk
    until the program actually requires them. These program sections are
    loaded into memory by special overlay managing routines included in
    the run-time libraries supplied with some Microsoft high-level-
    language compilers.

    The preceding section of the header (00-1BH) is known as the formatted
    area. Optional information used by high-level-language overlay
    managers can follow this formatted area. Unless the program in the
    .EXE file incorporates such information, the relocation pointer table
    immediately follows the formatted header area.

    Relocation Pointer Table The relocation pointer table consists of a
    list of pointers to words within the .EXE program image that MS-DOS
    must adjust before giving the program control. These words consist of
    references made by the program to the segments that make up the
    program. MS-DOS must adjust these segment address references when it
    loads the program, because it can load the program into memory
    starting at any segment address boundary.

    Each pointer in the table consists of a doubleword. The first word
    contains an offset from the segment address given in the second word,
    which in turn indicates a segment address relative to the start of the
    load module. Together, these two words point to a third word within
    the load module that must have the start segment address added to it.
    (The start segment corresponds to the segment address at which MS-DOS
    started loading the program's image, immediately following the PSP.)
    Figure 4-6 shows the entire procedure MS-DOS performs for each
    relocation table entry.


        .EXE File
┌────────────────────┐ End of file
│                    │
│                    │
│                    │
│┌──────────────────┐│
││Rel Seg Ref=003CH ││
││Abs Seg Ref=25D1H ││
│└──────────────────┘│
│    Load module     │
├────────────────────┤
└────────┐           │                                      Memory
┌───────┐└────────┐  │                             ┌──────────────────────┐
│       └────────┐└──┘                             │                      │
│                └───┐                    003CH──┐│                      │
│┌──────────────────┐│                ┌─+2595H   ││ ┌─────────────────┐  │
││Relocation pointer││                │   ─────   └┼─┤Rel Seg Ref=003CH│  │
││   0002H:0005H ───┼┼─┐              │   25D1H────┼─Abs Seg Ref=25D1H│  │
│└──────────────────┘│ │              │┌───────────┼│                 │  │
│ Relocation pointer │ │              ││           │ └─────────────────┘  │
│      table         │ └─ 0002H:0005H││           │                      │
├────────────────────┤    +2595H ────┴┼"Start seg"│    Load module       │
│  Formatted header  │     ─────────── │   2595H  ├──────────────────────┤
│       area         │     2597H:0005H─┘           │Program segment prefix│
└────────────────────┘Start of file                └──────────────────────┘

    Figure 4-6. The .EXE file relocation procedure.


The load module
    The load module starts where the .EXE header ends and consists of the
    fully linked image of the program. The load module appears within the
    .EXE file exactly as it would appear in memory if MS-DOS were to load
    it at segment address 0000H. The only changes MS-DOS makes to the load
    module involve relocating any direct segment references.

    Although the .EXE file contains distinct segment images within the
    load module, it provides no information for separating those
    individual segments from one another. Existing versions of MS-DOS
    ignore how the program is segmented; they simply copy the load module
    into memory, relocate any direct segment references, and give the
    program control.

Loading the .EXE program

    So far we've covered all the characteristics of the .EXE program as
    it resides in memory and on disk. We've also touched on all the steps
    MS-DOS performs while loading the .EXE program from disk and executing
    it. The following list recaps the .EXE program loading process in the
    order in which MS-DOS performs it:

    1. MS-DOS reads the formatted area of the header (the first
        1BH bytes) from the .EXE file into a work area.

    2. MS-DOS determines the size of the largest available block of
        memory.

    3. MS-DOS determines the size of the load module using the Last Page
        Size (offset 02H), File Pages (offset 04H), and Header Paragraphs
        (offset 08H) fields from the header. An example of this process
        is in the discussion of the Header Paragraphs field.

    4. MS-DOS adds the MINALLOC field (offset 0AH) in the header to the
        calculated load-module size and the size of the PSP (100H bytes).
        If this total exceeds the size of the largest available block,
        MS-DOS terminates the load process and returns an error to the
        calling process. If the calling process was COMMAND.COM,
        COMMAND.COM then displays a Program too big to fit in memory
        error message.

    5. MS-DOS adds the MAXALLOC field (offset 0CH) in the header to the
        calculated load-module size and the size of the PSP. If the memory
        block found earlier exceeds this calculated total, MS-DOS allo-
        cates the calculated memory size to the program from the memory
        block; if the calculated total exceeds the block's size, MS-DOS
        allocates the entire block.

    6. If the MINALLOC and MAXALLOC fields both contain 0000H, MS-DOS
        uses the calculated load-module size to determine a start segment.
        MS-DOS calculates the start segment so that the load module will
        load into the high end of the allocated block. If either MINALLOC
        or MAXALLOC contains nonzero values (the normal case), MS-DOS
        establishes the start segment as the segment following the PSP.

    7. MS-DOS loads the load module into memory starting at the start
        segment.

    8. MS-DOS reads the relocation pointers into a work area and re-
        locates the load module's direct segment references, as shown in
        Figure 4-6.

    9. MS-DOS builds a PSP in the first 100H bytes of the allocated
        memory block. While building the two FCBs within the PSP, MS-DOS
        determines the initial values for the AL and AH registers.

    10. MS-DOS sets the SS and SP registers to the values in the header
        after the start segment is added to the SS value.

    11. MS-DOS sets the DS and ES registers to point to the beginning of
        the PSP.

    12. MS-DOS transfers control to the .EXE program by setting CS and IP
        to the values in the header after adding the start segment to the
        CS value.

Controlling the .EXE program's structure

    We've now covered almost every aspect of a completed .EXE program.
    Next, we'll discuss how to control the structure of the final .EXE
    program from the source level. We'll start by covering the statements
    provided by MASM that permit the programmer to define the structure of
    the program when programming in assembly language. Then we'll cover
    the five standard memory models provided by Microsoft's C and FORTRAN
    compilers (both version 4.0), which provide predefined structuring
    over which the programmer has limited control.

The MASM SEGMENT directive
    MASM's SEGMENT directive and its associated ENDS directive mark the
    beginning and end of a program segment. Program segments contain
    collections of code or data that have offset addresses relative to the
    same common segment address.

    In addition to the required segment name, the SEGMENT directive has
    three optional parameters:

    segname SEGMENT [align] [combine] ['class']

    With MASM, the contents of a segment can be defined at one point in
    the source file and the definition can be resumed as many times as
    necessary throughout the remainder of the file. When MASM encounters a
    SEGMENT directive with a segname it has previously encountered, it
    simply resumes the segment definition where it left off. This occurs
    regardless of the combine type specified in the SEGMENT directive--the
    combine type influences only the actions of the linker. See The
    combine Type Parameter, below.

    The align type parameter
    The optional align parameter lets the programmer send the linker an
    instruction on how to align a segment within memory. In reality, the
    linker can align the segment only in relation to the start of the
    program's load module, but the result remains the same because MS-DOS
    always loads the module aligned on a paragraph (16-byte) boundary.
    (The PAGE align type creates a special exception, as discussed below.)

    The following alignment types are permitted:

    BYTE This align type instructs the linker to start the segment on the
    byte immediately following the previous segment. BYTE alignment
    prevents any wasted memory between the previous segment and the BYTE-
    aligned segment.

    A minor disadvantage to BYTE alignment is that the 8086-family segment
    registers might not be able to directly address the start of the
    segment in all cases. Because they can address only on paragraph
    boundaries, the segment registers may have to point as many as 15
    bytes behind the start of the segment. This means that the segment
    size should not be more than 15 bytes short of 64 KB. The linker
    adjusts offset and segment address references to compensate for
    differences between the physical segment start and the paragraph
    addressing boundary.

    Another possible concern is execution speed on true 16-bit 8086-family
    microprocessors. When using non-8088 microprocessors, a program can
    actually run faster if the instructions and word data fields within
    segments are aligned on word boundaries. This permits the 16-bit
    processors to fetch full words in a single memory read, rather than
    having to perform two single-byte reads. The EVEN directive tells MASM
    to align instructions and data fields on word boundaries; however,
    MASM can establish this alignment only in relation to the start of the
    segment, so the entire segment must start aligned on a word or larger
    boundary to guarantee alignment of the items within the segment.

    WORD This align type instructs the linker to start the segment on the
    next word boundary. Word boundaries occur every 2 bytes and consist of
    all even addresses (addresses in which the least significant bit
    contains a zero). WORD alignment permits alignment of data fields and
    instructions within the segment on word boundaries, as discussed for
    the BYTE alignment type. However, the linker may have to waste 1 byte
    of memory between the previous segment and the word-aligned segment in
    order to position the new segment on a word boundary.

    Another minor disadvantage to WORD alignment is that the 8086-family
    segment registers might not be able to directly address the start of
    the segment in all cases. Because they can address only on paragraph
    boundaries, the segment registers may have to point as many as 14
    bytes behind the start of the segment. This means that the segment
    size should not be more than 14 bytes short of 64 KB. The linker
    adjusts offset and segment address references to compensate for
    differences between the physical segment start and the paragraph
    addressing boundary.

    PARA This align type instructs the linker to start the segment on the
    next paragraph boundary. The segments default to PARA if no alignment
    type is specified. Paragraph boundaries occur every 16 bytes and
    consist of all addresses with hexadecimal values ending in zero
    (0000H, 0010H, 0020H, and so forth). Paragraph alignment ensures that
    the segment begins on a segment register addressing boundary, thus
    making it possible to address a full 64 KB segment. Also, because
    paragraph addresses are even addresses, PARA alignment has the same
    advantages as WORD alignment. The only real disadvantage to PARA
    alignment is that the linker may have to waste as many as 15 bytes of
    memory between the previous segment and the paragraph-aligned segment.

    PAGE This align type instructs the linker to start the segment on the
    next page boundary. Page boundaries occur every 256 bytes and consist
    of all addresses in which the low address byte equals zero (0000H,
    0100H, 0200H, and so forth). PAGE alignment ensures only that the
    linker positions the segment on a page boundary relative to the start
    of the load module. Unfortunately, this does not also ensure alignment
    of the segment on an absolute page within memory, because MS-DOS only
    guarantees alignment of the entire load module on a paragraph
    boundary.

    When a programmer declares pieces of a segment with the same name in
    different source modules, the align type specified for each segment
    piece influences the alignment of that specific piece of the segment.
    For example, assume the following two segment declarations appear in
    different source modules:

    _DATA   SEGMENT PARA PUBLIC 'DATA'
            DB      '123'
    _DATA   ENDS

    _DATA   SEGMENT PARA PUBLIC 'DATA'
            DB      '456'
    _DATA   ENDS

    The linker starts by aligning the first segment piece located in the
    first object module on a paragraph boundary, as requested. When the
    linker encounters the second segment piece in the second object
    module, it aligns that piece on the first paragraph boundary following
    the first segment piece. This results in a 13-byte gap between the
    first segment piece and the second. The segment pieces must exist in
    separate source modules for this to occur. If the segment pieces exist
    in the same source module, MASM assumes that the second segment
    declaration is simply a resumption of the first and creates an object
    module with segment declarations equivalent to the following:

    _DATA   SEGMENT PARA PUBLIC 'DATA'
            DB      '123'
            DB      '456'
    _DATA   ENDS

    The combine type parameter
    The optional combine parameter allows the programmer to send
    directions to the linker on how to combine segments with the same
    segname occurring in different object modules. If no combine type is
    specified, the linker treats such segments as if each had a different
    segname. The combine type has no effect on the relationship of
    segments with different segnames. MASM and LINK both support the
    following combine types:

    PUBLIC This combine type instructs the linker to concatenate multiple
    segments having the same segname into a single contiguous segment. The
    linker adjusts any address references to labels within the
    concatenated segments to reflect the new position of those labels
    relative to the start of the combined segment. This combine type is
    useful for accessing code or data in different source modules using a
    common segment register value.

    STACK This combine type operates similarly to the PUBLIC combine type,
    except for two additional effects: The STACK type tells the linker
    that this segment comprises part of the program's stack and
    initialization data contained within STACK segments is handled
    differently than in PUBLIC segments. Declaring segments with the STACK
    combine type permits the linker to determine the initial SS and SP
    register values it places in the .EXE file header. Normally, a
    programmer would declare only one STACK segment in one of the source
    modules. If pieces of the stack are declared in different source
    modules, the linker will concatenate them in the same fashion as
    PUBLIC segments. However, initialization data declared within any
    STACK segment is placed at the high end of the combined STACK segments
    on a module-by-module basis. Thus, each successive module's
    initialization data overlays the previous module's data. At least one
    segment must be declared with the STACK combine type; otherwise, the
    linker will issue a warning message because it cannot determine the
    program's initial SS and SP values. (The warning can be ignored if the
    program itself initializes SS and SP.)

    COMMON This combine type instructs the linker to overlap multiple
    segments having the same segname. The length of the resulting segment
    reflects the length of the longest segment declared. If any code or
    data is declared in the overlapping segments, the data contained in
    the final segments linked replaces any data in previously loaded
    segments. This combine type is useful when a data area is to be shared
    by code in different source modules.

    MEMORY Microsoft's LINK treats this combine type the same as it treats
    the PUBLIC type. MASM, however, supports the MEMORY type for
    compatibility with other linkers that use Intel's definition of a
    MEMORY combine type.

    AT address This combine type instructs LINK to pretend that the
    segment will reside at the absolute segment address. LINK then adjusts
    all address references to the segment in accordance with the
    masquerade. LINK will not create an image of the segment in the load
    module, and it will ignore any data defined within the segment. This
    behavior is consistent with the fact that MS-DOS does not support the
    loading of program segments into absolute memory segments. All pro-
    grams must be able to execute from any segment address at which MS-DOS
    can find available memory. The SEGMENT AT address combine type is
    useful for creating templates of various areas in memory outside the
    program. For instance, SEGMENT AT 0000H could be used to create a
    template of the 8086-family interrupt vectors. Because data contained
    within SEGMENT AT address segments is suppressed by LINK and not by
    MASM (which places the data in the object module), it is possible to
    use .OBJ files generated by MASM with another linker that supports ROM
    or other absolute code generation should the programmer require this
    specialized capability.

    The class type parameter
    The class parameter provides the means to organize different segments
    into classifications. For instance, here are three source modules,
    each with its own separate code and data segments:

    ;Module "A"
    A_DATA  SEGMENT PARA PUBLIC 'DATA'
    ;Module "A" data fields
    A_DATA  ENDS
    A_CODE  SEGMENT PARA PUBLIC 'CODE'
    ;Module "A" code
    A_CODE  ENDS
            END

    ;Module "B"
    B_DATA  SEGMENT PARA PUBLIC 'DATA'
    ;Module "B" data fields
    B_DATA  ENDS
    B_CODE  SEGMENT PARA PUBLIC 'CODE'
    ;Module "B" code
    B_CODE  ENDS
            END

    ;Module "C"
    C_DATA  SEGMENT PARA PUBLIC 'DATA'
    ;Module "C" data fields
    C_DATA  ENDS
    C_CODE  SEGMENT PARA PUBLIC 'CODE'
    ;Module "C" code
    C_CODE  ENDS
            END

    If the 'CODE' and 'DATA' class types are removed from the SEGMENT
    directives shown above, the linker organizes the segments as it en-
    counters them. If the programmer specifies the modules to the linker
    in alphabetic order, the linker produces the following segment
    ordering:

            A_DATA
            A_CODE
            B_DATA
            B_CODE
            C_DATA
            C_CODE

    However, if the programmer specifies the class types shown in the
    sample source modules, the linker organizes the segments by
    classification as follows:

            'DATA' class:    A_DATA
                            B_DATA
                            C_DATA

            'CODE' class:    A_CODE
                            B_CODE
                            C_CODE

    Notice that the linker still organizes the classifications in the
    order in which it encounters the segments belonging to the various
    classifications. To completely control the order in which the linker
    organizes the segments, the programmer must use one of three basic
    approaches. The preferred method involves using the /DOSSEG switch
    with the linker. This produces the segment ordering shown in Figure
    4-1. The second method involves creating a special source module that
    contains empty SEGMENT-ENDS blocks for all the segments declared in
    the various other source modules. The programmer creates the list in
    the order the segments are to be arranged in memory and then specifies
    the .OBJ file for this module as the first file for the linker to
    process. This procedure establishes the order of all the segments
    before LINK begins processing the other program modules, so the
    programmer can declare segments in these other modules in any con-
    venient order. For instance, the following source module rearranges
    the result of the previous example so that the linker places the
    'CODE' class before the 'DATA' class:

    A_CODE  SEGMENT PARA PUBLIC 'CODE'
    A_CODE  ENDS
    B_CODE  SEGMENT PARA PUBLIC 'CODE'
    B_CODE  ENDS
    C_CODE  SEGMENT PARA PUBLIC 'CODE'
    C_CODE  ENDS

    A_DATA  SEGMENT PARA PUBLIC 'DATA'
    A_DATA  ENDS
    B_DATA  SEGMENT PARA PUBLIC 'DATA'
    B_DATA  ENDS
    C_DATA  SEGMENT PARA PUBLIC 'DATA'
    C_DATA  ENDS

            END

    Rather than creating a new module, the third method places the same
    segment ordering list shown above at the start of the first module
    containing actual code or data that the programmer will be specifying
    for the linker. This duplicates the approach used by Microsoft's newer
    compilers, such as C version 4.0.

    The ordering of segments within the load module has no direct effect
    on the linker's adjustment of address references to locations within
    the various segments. Only the GROUP directive and the SEGMENT
    directive's combine parameter affect address adjustments performed by
    the linker. See The MASM GROUP Directive, below.

    Note: Certain older versions of the IBM Macro Assembler wrote segments
    to the object file in alphabetic order regardless of their order in
    the source file. These older versions can limit efforts to control
    segment ordering. Upgrading to a new version of the assembler is the
    best solution to this problem.

    Ordering segments to shrink the .EXE file
    Correct segment ordering can significantly decrease the size of a .EXE
    program as it resides on disk. This size-reduction ordering is
    achieved by placing all uninitialized data fields in their own
    segments and then controlling the linker's ordering of the program's
    segments so that the uninitialized data field segments all reside at
    the end of the program. When the program modules are assembled, MASM
    places information in the object modules to tell the linker about
    initialized and uninitialized areas of all segments. The linker then
    uses this information to prevent the writing of uninitialized data
    areas that occur at the end of the program image as part of the
    resulting .EXE file. To account for the memory space required by these
    fields, the linker also sets the MINALLOC field in the .EXE file
    header to represent the data area not written to the file. MS-DOS then
    uses the MINALLOC field to reallocate this missing space when loading
    the program.

The MASM GROUP directive
    The MASM GROUP directive can also have a strong impact on a .EXE
    program. However, the GROUP directive has no effect on the arrangement
    of program segments within memory. Rather, GROUP associates program
    segments for addressing purposes.

    The GROUP directive has the following syntax:

    grpname GROUP segname,segname,segname,...

    This directive causes the linker to adjust all address references to
    labels within any specified segname to be relative to the start of the
    declared group. The start of the group is determined at link time. The
    group starts with whichever of the segments in the GROUP list the
    linker places lowest in memory.

    That the GROUP directive neither causes nor requires contiguous
    arrangement of the grouped segments creates some interesting, although
    not necessarily desirable, possibilities. For instance, it permits the
    programmer to locate segments not belonging to the declared group
    between segments that do belong to the group. The only restriction
    imposed on the declared group is that the last byte of the last
    segment in the group must occur within 64 KB of the start of the
    group. Figure 4-7 illustrates this type of segment arrangement:


    ────────────────────────────────── ┌─────────────────────────────────┐
                                      │                                 │
    │                                  │            SEGMENT_C            │
    │                                  │  (listed with GROUP directive)  │
    │          ───────────────LABEL_C │                                 │
    │                                 ├─────────────────────────────────┤
    │          │         ─────LABEL_B │                                 │
64 KB        │                      │            SEGMENT_B            │
maximum       │       Offset to       │(not listed with GROUP directive)│
    │       Offset to     LABEL_B     │                                 │
    │       LABEL_C      ───────────── ├─────────────────────────────────┤
    │          │         ─────LABEL_A │                                 │
    │          │                      │            SEGMENT_A            │
    │          │       Offset to       │  (listed with GROUP directive)  │
                        LABEL_A     │                                 │
    ────────────────────────────────── └─────────────────────────────────┘

    Figure 4-7. Noncontiguous segments in the same GROUP.


    Warning: One of the most confusing aspects of the GROUP directive
    relates to MASM's OFFSET operator. The GROUP directive affects only
    the offset addresses generated by such direct addressing instructions
    as

            MOV     AX,FIELD_LABEL

    but it has no effect on immediate address values generated by such
    instructions as

            MOV     AX,OFFSET FIELD_LABEL

    Using the OFFSET operator on labels contained within grouped segments
    requires the following approach:

            MOV     AX,OFFSET GROUP_NAME:FIELD_LABEL

    The programmer must explicitly request the offset from the group base,
    because MASM defines the result of the OFFSET operator to be the
    offset of the label from the start of its segment, not its group.

Structuring a small program with SEGMENT and GROUP
    Now that we have analyzed the functions performed by the SEGMENT and
    GROUP directives, we'll put both directives to work structuring a
    skeleton program. The program, shown in Figures 4-8, 4-9, and 4-10,
    consists of three source modules (MODULE_A, MODULE_B, and MODULE_C),
    each using the following four program segments:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Segment          Definition
    ──────────────────────────────────────────────────────────────────
    _TEXT            The code or program text segment

    _DATA            The standard data segment containing preinitialized
                    data fields the program might change

    CONST            The constant data segment containing constant data
                    fields the program will not change

    _BSS             The "block storage segment/space" segment containing
                    uninitialized data fields

    ──────────────────────────────────────────────────────────────────────

    Figure 4-8. Structuring a .EXE program: MODULE_A.

    ──────────────────────────────────────────────────────────────────────

    Figure 4-9. Structuring a .EXE program: MODULE_B.

    ──────────────────────────────────────────────────────────────────────

    Figure 4-10. Structuring a .EXE program: MODULE_C.

    ──────────────────────────────────────────────────────────────────────


    This example creates a small memory model program image, so the linked
    program can have only a single code segment and a single data
    segment--the simplest standard form of a .EXE program. See Using
    Microsoft's Contemporary Memory Models, below.

    In addition to declaring the four segments already discussed, MODULE_A
    declares a STACK segment in which to define a block of memory for use
    as the program's stack and also defines the linking order of the five
    segments. Defining the linking order leaves the programmer free to
    declare the segments in any order when defining the segment contents--
    a necessity because the assembler has difficulty assembling programs
    that use forward references.

    With Microsoft's MASM and LINK on the same disk with the .ASM files,
    the following commands can be made into a batch file:

    MASM STRUCA;
    MASM STRUCB;
    MASM STRUCC;
    LINK STRUCA+STRUCB+STRUCC/M;

    These commands will assemble and link all the .ASM files listed,
    producing the memory map report file STRUCA.MAP shown in Figure 4-11.

    Start  Stop   Length Name                   Class
    00000H 0000CH 0000DH _TEXT                  CODE
    0000EH 0001FH 00012H _DATA                  DATA
    00020H 0003DH 0001EH CONST                  CONST
    0003EH 0004EH 00011H _BSS                   BSS
    00050H 0014FH 00100H STACK                  STACK

    Origin   Group
    0000:0   DGROUP

    Address         Publics by Name

    0000:000B       PROC_B
    0000:000C       PROC_C

    Address         Publics by Value

    0000:000B       PROC_B
    0000:000C       PROC_C
    Program entry point at 0000:0000

    Figure 4-11. Structuring a .EXE program: memory map report.


    The above memory map report represents the memory diagram shown in
    Figure 4-12.


    Absolute address                                      Size in bytes
            00150H ┌────────┬──────────┬──────────┬──────      ─────
                    │        │  STACK   │  STACK   │  256         
                    │        │  Class   │   (A)    │              │
            00050H ├ ─ ─ ─ ─┼──────────┴──────────┼──────        │
                    │        │ PARA align gap      │   1          │
            0004FH ├ ─ ─ ─ ─┼──────────┬──────────┼───────────   │
                    │        │          │BSS (C)   │   5          │
            0004AH ├ ─ ─ ─ ─┼ ─ ─ ─ ─ ─┼──────────┼──────  │     │
                    │        │          │WORD      │        │     │
                    │        │          │align gap │        │     │
            00049H ├ ─ ─ ─ ─├  BSS  ─ ─┼──────────┤        │     │
                    │        │          │BSS (B)   │   5    15    │
            00044H ├ ─ ─ ─ ─├ Class ─ ─┼──────────┼──────  │     │
                    │        │          │WORD      │        │     │
                    │        │          │align gap │        │     │
            00043H ├ DGROUP─│ ─ ─ ─ ─ ─┼──────────┤        │    321
                    │        │          │BSS (A)   │   5          │
            0003EH ├ Group ─┼──────────┼──────────┼───────────   │
                    │        │          │CONST(C)  │  10          │
            00034H ├ ─ ─ ─ ─┼ CONST ─ ─┼──────────┼──────  │     │
                    │        │          │CONST(B)  │  10    30    │
            0002AH ├ ─ ─ ─ ─┼ Class ─ ─┼──────────┼──────  │     │
                    │        │          │CONST(A)  │  10          │
            00020H ├ ─ ─ ─ ─┼──────────┬──────────┬───────────   │
                    │        │          │DATA (C)  │    6         │
            0001AH ├ ─ ─ ─ ─┼─ DATA─ ─ ├──────────┼──────  │     │
                    │        │          │DATA (B)  │    6   18    │
            00014H ├ ─ ─ ─ ─┼─ Class ─ ├──────────┼──────  │     │
                    │        │          │DATA (A)  │    6         │
            0000EH ├ ─ ─ ─ ─┼──────────┴──────────┼───────────   │
                    │        │   WORD align gap    │    1         
            0000DH ├────────┼──────────┬──────────┼──────────── ─────
                    │        │          │TEXT (C)  │    1   
            0000CH │ ─ ─ ─CODE ─ ─ ─ ─ ├──────────┼──────  │
                    │                   │TEXT (B)  │    1   13
            0000BH │ ─ ─ ─Class─ ─ ─ ─ ├──────────┼──────  │
    DGROUP         │        │          │TEXT (A)  │   11   
addressing  00000H └────────┴──────────┴──────────┴───────────
    base

    Figure 4-12. Structure of the sample .EXE program.


Using Microsoft's contemporary memory models

    Now that we've analyzed the various aspects of designing assembly-
    language .EXE programs, we can look at how Microsoft's high-level-
    language compilers create .EXE programs from high-level-language
    source files. Even assembly-language programmers will find this
    discussion of interest and should seriously consider using the five
    standard memory models outlined here.

    This discussion is based on the Microsoft C Compiler version 4.0,
    which, along with the Microsoft FORTRAN Compiler version 4.0,
    incorporates the most contemporary code generator currently available.
    These newer compilers generate code based on three to five
    of the following standard programmer-selectable program structures,
    referred to as memory models. The discussion of each of these memory
    models will center on the model's use with the Microsoft C Compiler
    and will close with comments regarding any differences for the
    Microsoft FORTRAN Compiler.

    Small (C compiler switch /AS) This model, the default, includes only a
    single code segment and a single data segment. All code must fit
    within 64 KB, and all data must fit within an additional 64 KB. Most C
    program designs fall into this category. Data can exceed the 64 KB
    limit only if the far and huge attributes are used, forcing the
    compiler to use far addressing, and the linker to place far and huge
    data items into separate segments. The data-size-threshold switch
    described for the compact model is ignored by the Microsoft C Compiler
    when used with a small model. The C compiler uses the default segment
    name _TEXT for all code and the default segment name _DATA for all
    non-far/huge data. Microsoft FORTRAN programs can generate a semblance
    of this model only by using the /NM (name module) and /AM (medium
    model) compiler switches in combination with the near attribute on all
    subprogram declarations.

    Medium (C and FORTRAN compiler switch /AM) This model includes only a
    single data segment but breaks the code into multiple code segments.
    All data must fit within 64 KB, but the 64 KB restriction on code size
    applies only on a module-by-module basis. Data can exceed the 64 KB
    limit only if the far and huge attributes are used, forcing the
    compiler to use far addressing, and the linker to place far and huge
    data items into separate segments. The data-size-threshold switch
    described for the compact model is ignored by the Microsoft C Compiler
    when used with a medium model. The compiler uses the default segment
    name _DATA for all non-far/huge data and the template module_TEXT to
    create names for all code segments. The module element of module_TEXT
    indicates where the compiler is to substitute the name of the source
    module. For example, if the source module HELPFUNC.C is compiled using
    the medium model, the compiler creates the code segment HELPFUNC_TEXT.
    The Microsoft FORTRAN Compiler version 4.0 directly supports the
    medium model.

    Compact (C compiler switch /AC) This model includes only a single code
    segment but breaks the data into multiple data segments. All code must
    fit within 64 KB, but the data is allowed to consume all the remaining
    available memory. The Microsoft C Compiler's optional data-size-
    threshold switch (/Gt) controls the placement of the larger data items
    into additional data segments, leaving the smaller items in the
    default segment for faster access. Individual data items within the
    program cannot exceed 64 KB under the compact model without being
    explicitly declared huge. The compiler uses the default segment name
    _TEXT for all code segments and the template module#_DATA to create
    names for all data segments. The module element indicates where the
    compiler is to substitute the source module's name; the # element
    represents a digit that the compiler changes for each additional data
    segment required to hold the module's data. The compiler starts with
    the digit 5 and counts up. For example, if the name of the source
    module is HELPFUNC.C, the compiler names the first data segment
    HELPFUNC5_DATA. FORTRAN programs can generate a semblance of this
    model only by using the /NM (name module) and /AL (large model)
    compiler switches in combination with the near attribute on all
    subprogram declarations.

    Large (C and FORTRAN compiler switch /AL) This model creates multiple
    code and data segments. The compiler treats data in the same manner as
    it does for the compact model and treats code in the same manner as it
    does for the medium model. The Microsoft FORTRAN Compiler version 4.0
    directly supports the large model.

    Huge (C and FORTRAN compiler switch /AH) Allocation of segments under
    the huge model follows the same rules as for the large model. The
    difference is that individual data items can exceed 64 KB. Under the
    huge model, the compiler generates the necessary code to index arrays
    or adjust pointers across segment boundaries, effectively transforming
    the microprocessor's segment-addressed memory into linear-addressed
    memory. This makes the huge model especially useful for porting a
    program originally written for a processor that used linear
    addressing. The speed penalties the program pays in exchange for this
    addressing freedom require serious consideration. If the program
    actually contains any data structures exceeding 64 KB, it probably
    contains only a few. In that case, it is best to avoid using the huge
    model by explicitly declaring those few data items as huge using the
    huge keyword within the source module. This prevents penalizing all
    the non-huge items with extra addressing math. The Microsoft FORTRAN
    Compiler version 4.0 directly supports the huge model.

    Figure 4-13 shows an example of the segment arrangement created by a
    large/huge model program. The example assumes two source modules:
    MSCA.C and MSCB.C. Each source module specifies enough data to cause
    the compiler to create two extra data segments for that module. The
    diagram does not show all the various segments that occur as a result
    of linking with the run-time library or as a result of compiling with
    the intention of using the CodeView debugger.


Groups     Classes     Segments
┌───────────┬───────────┬───────────┐
│           │           │           │ SMCLH: Program stack
│           │   STACK   │  STACK    │
│           ├───────────┼───────────┤
│           │           │           │ SM: All unitialized global
│           │           │ c_common  │  items, CLH: Empty
│  DGROUP   │    BSS    ├───────────┤
│           │           │           │ SMCLH: All uninitialized non-
│           │           │  _BSS     │  far/huge items
│           ├───────────┼───────────┤
│           │           │           │ SMCLH: Constants (floating point
│           │   CONST   │  CONST    │  constraints, segment addresses, etc)
│           ├───────────┼───────────┤
│           │           │           │ SMCLH: All items that don't end up
│           │    DATA   │  _DATA    │  anywhere else
├───────────┼───────────┼───────────┤
│           │           │           │ SM: Nonexistent, CLH: All unini-
│           │  FAR_BSS  │  FAR_BSS  │  tialized global items
│           ├───────────┼───────────┤
│           │           │           │ From MSCB only: SM Far/huge items,
│           │           │MSCB6_DATA │  CLH: Items larger than threshold
│           │           ├───────────┤
│           │           │           │ From MSCB only: SM Far/huge items,
│           │           │MSCB5_DATA │  CLH: Items larger than threshold
│           │ FAR_DATA  ├───────────┤
│           │           │           │ From MSCB only: SM Far/huge items,
│           │           │MSCA6_DATA │  CLH: Items larger than threshold
│           │           ├───────────┤
│           │           │           │ From MSCB only: SM Far/huge items,
│           │           │MSCA5_DATA │  CLH: Items larger than threshold
│           ├───────────┼───────────┤
│           │           │           │ SC: All code, MLH: Run-time
│           │           │   TEXT    │  library code only
│           │           ├───────────┤
│           │   CODE    │           │ SC: Nonexistent, MLH: MSCB.C Code
│           │           │ MSCB_TEXT │
│           │           ├───────────┤
│           │           │           │ SC: Nonexistent, MLH: MSCA.C Code
│           │           │ MSCA_TEXT │
└───────────┴───────────┴───────────┘        ───────────────────────
                                    S = Small model    L = Large model
                                    M = Medium model   H = Huge model
                                    C = Compact model

    Figure 4-13. General structure of a Microsoft C program.


    Note that if the program declares an extremely large number of small
    data items, it can exceed the 64 KB size limit on the default data
    segment (_DATA) regardless of the memory model specified. This occurs
    because the data items all fall below the data-size-threshold limit
    (compiler /Gt switch), causing the compiler to place them in the _DATA
    segment. Lowering the data size threshold or explicitly using the far
    attribute within the source modules eliminates this problem.

Modifying the .EXE file header

    With most of its language compilers, Microsoft supplies a utility
    program called EXEMOD. See PROGRAMMING UTILITIES: EXEMOD. This utility
    allows the programmer to display and modify certain fields contained
    within the .EXE file header. Following are the header fields EXEMOD
    can modify (based on EXEMOD version 4.0):

    MAXALLOC This field can be modified by using EXEMOD's /MAX switch.
    Because EXEMOD operates on .EXE files that have already been linked,
    the /MAX switch can be used to modify the MAXALLOC field in existing
    .EXE programs that contain the default MAXALLOC value of FFFFH,
    provided the programs do not rely on MS-DOS's allocating all free
    memory to them. EXEMOD's /MAX switch functions in an identical manner
    to LINK's /CPARMAXALLOC switch.

    MINALLOC This field can be modified by using EXEMOD's /MIN switch.
    Unlike the case with the MAXALLOC field, most programs do not have an
    arbitrary value for MINALLOC. MINALLOC normally represents
    uninitialized memory and stack space the linker has compressed out of
    the .EXE file, so a programmer should never reduce the MINALLOC value
    within a .EXE program written by someone else. If a program requires
    some minimum amount of extra dynamic memory in addition to any static
    fields, MINALLOC can be increased to ensure that the program will have
    this extra memory before receiving control. If this is done, the
    program will not have to verify that MS-DOS allocated enough memory to
    meet program needs. Of course, the same result can be achieved without
    EXEMOD by declaring this minimum extra memory as an uninitialized
    field at the end of the program.

    Initial SP Value This field can be modified by using the /STACK switch
    to increase or decrease the size of a program's stack. However,
    modifying the initial SP value for programs developed using Microsoft
    language compiler versions earlier than the following may cause the
    programs to fail: C version 3.0, Pascal version 3.3, and FORTRAN
    version 3.3. Other language compilers may have the same restriction.
    The /STACK switch can also be used with programs developed using MASM,
    provided the stack space is linked at the end of the program, but it
    would probably be wise to change the size of the STACK segment
    declaration within the program instead. The linker also provides a
    /STACK switch that performs the same purpose.

    Note: With the /H switch set, EXEMOD displays the current values of
    the fields within the .EXE header. This switch should not be used with
    the other switches. EXEMOD also displays field values if no switches
    are used.

    Warning: EXEMOD also functions correctly when used with packed .EXE
    files created using EXEPACK or the /EXEPACK linker switch. However, it
    is important to use the EXEMOD version shipped with the linker or
    EXEPACK utility. Possible future changes in the packing method may
    result in incompatibilities between EXEMOD and nonassociated
    linker/EXEPACK versions.

Patching the .EXE program using DEBUG

    Every experienced programmer knows that programs always seem to have
    at least one unspotted error. If a program has been distributed to
    other users, the programmer will probably need to provide those users
    with corrections when such bugs come to light. One inexpensive
    updating approach used by many large companies consists of mailing out
    single-page instructions explaining how the user can patch the program
    to correct the problem.

    Program patching usually involves loading the program file into the
    DEBUG utility supplied with MS-DOS, storing new bytes into the program
    image, and then saving the program file back to disk. Unfortunately,
    DEBUG cannot load a .EXE program into memory and then save it back to
    disk in .EXE format. The programmer must trick DEBUG into patching
    .EXE program files, using the procedure outlined below. See
    PROGRAMMING UTILITIES: DEBUG.

    Note: Users should be reminded to make backup copies of their program
    before attempting the patching procedure.

    1. Rename the .EXE file using a filename extension that does not have
        special meaning for DEBUG. (Avoid .EXE, .COM, and .HEX.) For
        instance, MYPROG.BIN serves well as a temporary new name for
        MYPROG.EXE because DEBUG does not recognize a file with a .BIN
        extension as anything special. DEBUG will load the entire image of
        MYPROG.BIN, including the .EXE header and relocation table, into
        memory starting at offset 100H within a .COM-style program segment
        (as discussed previously).

    2. Locate the area within the load module section of the .EXE file
        image that requires patching. The previous discussion of the .EXE
        file image, together with compiler/ assembler listings and linker
        memory map reports, provides the information necessary to locate
        the error within the .EXE file image. DEBUG loads the file image
        starting at offset 100H within a .COM-style program segment, so the
        programmer must compensate for this offset when calculating
        addresses within the file image. Also, the compiler listings and
        linker memory map reports provide addresses relative to the start
        of the program image within the .EXE file, not relative to the
        start of the file itself. Therefore, the programmer must first
        check the information contained in the .EXE file header to
        determine where the load module (the program's image) starts within
        the file.

    3. Use DEBUG's E (Enter Data) or A (Assemble Machine Instructions
        command to insert the corrections. (Normally, patch instructions to
        users would simply give an address at which the user should apply
        the patch. The user need not know how to determine the address.)

    4. After the patch has been applied, simply issue the DEBUG W (Write
        File or Sectors) command to write the corrected image back to disk
        under the same filename, provided the patch has not increased the
        size of the program. If program size has increased, first
        change the appropriate size fields in then .EXE header at the start
        of the file and use the DEBUG R (Display or Modify Registers)
        command to modify the BX and CX registers so that they contain the
        file image's new size. Then use the W command to write the image
        back to disk under the same name.

    5. Use the DEBUG Q (Quit) command to return to MS-DOS command level,
        and then rename the file to the original .EXE filename extension.

.EXE summary

    To summarize, the .EXE program and file structures provide
    considerable flexibility in the design of programs, providing the
    programmer with the necessary freedom to produce large-scale
    applications. Programs written using Microsoft's high-level-language
    compilers have access to five standardized program structure models
    (small, medium, compact, large, and huge). These standardized models
    are excellent examples of ways to structure assembly-language
    programs.


The .COM Program

    The majority of differences between .COM and .EXE programs exist
    because .COM program files are not prefaced by header information.
    Therefore, .COM programs do not benefit from the features the .EXE
    header provides.

    The absence of a header leaves MS-DOS with no way of knowing how much
    memory the .COM program requires in addition to the size of the
    program's image. Therefore, MS-DOS must always allocate the largest
    free block of memory to the .COM program, regardless of the program's
    true memory requirements. As was discussed for .EXE programs, this
    allocation of the largest block of free memory usually results in
    MS-DOS's allocating all remaining free memory--an action that can
    cause problems for multitasking supervisor programs.

    The .EXE program header also includes the direct segment address
    relocation pointer table. Because they lack this table, .COM programs
    cannot make address references to the labels specified in SEGMENT
    directives, with the exception of SEGMENT AT address directives. If a
    .COM program did make these references, MS-DOS would have no way of
    adjusting the addresses to correspond to the actual segment address
    into which MS-DOS loaded the program. See Creating the .COM Program,
    below.

    The .COM program structure exists primarily to support the vast number
    of CP/M programs ported to MS-DOS. Currently, .COM programs are most
    often used to avoid adding the 512 bytes or more of .EXE header
    information onto small, simple programs that often do not exceed 512
    bytes by themselves.

    The .COM program structure has another advantage: Its memory
    organization places the PSP within the same address segment as the
    rest of the program. Thus, it is easier to access fields within the
    PSP in .COM programs.

Giving control to the .COM program

    After allocating the largest block of free memory to the .COM program,
    MS-DOS builds a PSP in the lowest 100H bytes of the block. No
    difference exists between the PSP MS-DOS builds for .COM programs and
    the PSP it builds for .EXE programs. Also with .EXE programs, MS-DOS
    determines the initial values for the AL and AH registers at this time
    and then loads the entire .COM-file image into memory immediately
    following the PSP. Because .COM files have no file-size header fields,
    MS-DOS relies on the size recorded in the disk directory to determine
    the size of the program image. It loads the program exactly as it
    appears in the file, without checking the file's contents.

    MS-DOS then sets the DS, ES, and SS segment registers to point to the
    start of the PSP. If able to allocate at least 64 KB to the program,
    MS-DOS sets the SP register to offset FFFFH + 1 (0000H) to establish
    an initial stack; if less than 64 KB are available for allocation to
    the program, MS-DOS sets the SP to 1 byte past the highest offset
    owned by the program. In either case, MS-DOS then pushes a single word
    of 0000H onto the program's stack for use in terminating the program.

    Finally, MS-DOS transfers control to the program by setting the CS
    register to the PSP's segment address and the IP register to 0100H.
    This means that the program's entry point must exist at the very start
    of the program's image, as shown in later examples.

    Figure 4-14 shows the overall structure of a .COM program as it
    receives control from MS-DOS.


                                .COM program memory image
                        ┌───────────┐
                        │     ┌───┬──┬───────────────┐              ─
            SP=FFEH  ────┘     │00H│00H│               │              
                                │ Remaining free memory │              │
                                │   within first 64 KB  │              │
                                │ allocated to .COM pro-│              │
                                │ gram (provided a full │              │
                                │  64 KB was available) │              │
                                │                       │          64 KB
                                ├───────────────────────┤              │
                            ┌─│  .COM program image   │              │
                            │  │       from file       │              │
    ┌───────────────────────┐│  │                       │              │
    │                       ││  ├───────────────────────┤ IP=0100H    │
    │  .COM program image   ├┘  │Program segment prefix │              
    └───────────────────────┘   └───────────────────────┘ CS,DS,ES,SS ─

    Figure 4-14. The .COM program: memory map diagram with register
    pointers.


Terminating the .COM program

    A .COM program can use all the termination methods described for .EXE
    programs but should still use the MS-DOS Interrupt 21H Terminate
    Process with Return Code function (4CH) as the preferred method. If
    the .COM program must remain compatible with versions of MS-DOS
    earlier than 2.0, it can easily use any of the older termination
    methods, including those described as difficult to use from .EXE
    programs, because .COM programs execute with the CS register pointing
    to the PSP as required by these methods.

Creating the .COM program

    A .COM program is created in the same manner as a .EXE program and
    then converted using the MS-DOS EXE2BIN utility. See PROGRAMMING
    UTILITIES: EXE2BIN.

    Certain restrictions do apply to .COM programs, however. First, .COM
    programs cannot exceed 64 KB minus 100H bytes for the PSP minus
    2 bytes for the zero word initially pushed on the stack.

    Next, only a single segment--or at least a single addressing group--
    should exist within the program. The following two examples show ways
    to structure a .COM program to satisfy both this restriction and
    MASM's need to have data fields precede program code in the source
    file.

    COMPROG1.ASM (Figure 4-15) declares only a single segment (COMSEG), so
    no special considerations apply when using the MASM OFFSET operator.
    See The MASM GROUP Directive above. COMPROG2.ASM (Figure 4-16)
    declares separate code (CSEG) and data (DSEG) segments, which the
    GROUP directive ties into a common addressing block. Thus, the
    programmer can declare data fields at the start of the source file and
    have the linker place the data fields segment (DSEG) after the code
    segment (CSEG) when it links the program, as discussed for the .EXE
    program structure. This second example simulates the program
    structuring provided under CP/M by Microsoft's old Macro-80 (M80)
    macro assembler and Link-80 (L80) linker. The design also expands
    easily to accommodate COMMON or other additional segments.

    ──────────────────────────────────────────────────────────────────────

    Figure 4-15. .COM program with data at start.

    ──────────────────────────────────────────────────────────────────────

    Figure 4-16. .COM program with data at end.

    ──────────────────────────────────────────────────────────────────────

    These examples demonstrate other significant requirements for
    producing a functioning .COM program. For instance, the ORG 0100H
    statement in both examples tells MASM to start assembling the code at
    offset 100H within the encompassing segment. This corresponds to
    MS-DOS's transferring control to the program at IP = 0100H. In
    addition, the entry-point label (BEGIN) immediately follows the ORG
    statement and appears again as a parameter to the END statement.
    Together, these factors satisfy the requirement that .COM programs
    declare their entry point at offset 100H. If any factor is missing,
    the MS-DOS EXE2BIN utility will not properly convert the .EXE file
    produced by the linker into a .COM file. Specifically, if a .COM
    program declares an entry point (as a parameter to the END statement)
    that is at neither offset 0100H nor offset 0000H, EXE2BIN rejects the
    .EXE file when the programmer attempts to convert it. If the program
    fails to declare an entry point or declares an entry point at offset
    0000H, EXE2BIN assumes that the .EXE file is to be converted to a
    binary image rather than to a .COM image. When EXE2BIN converts a .EXE
    file to a non-.COM binary file, it does not strip the extra 100H bytes
    the linker places in front of the code as a result of the ORG
    0100H instruction. Thus, the program actually begins at offset
    200H when MS-DOS loads it into memory, but all the program's address
    references will have been assembled and linked based on the 100H
    offset. As a result, the program--and probably the rest of the system
    as well--is likely to crash.

    A .COM program also must not contain direct segment address references
    to any segments that make up the program. Thus, the .COM program
    cannot reference any segment labels or reference any labels as long
    (FAR) pointers. (This rule does not prevent the program from
    referencing segment labels declared using the SEGMENT AT address
    directive.) Following are various examples of direct segment address
    references that are not permitted as part of .COM programs:

    PROC_A  PROC    FAR
    PROC_A  ENDP
            CALL    PROC_A          ;intersegment call
            JMP     PROC_A          ;intersegment jump

    or

            EXTRN   PROC_A:FAR
            CALL    PROC_A          ;intersegment call
            JMP     PROC_A          ;intersegment jump

    or

            MOV     AX,SEG SEG_A    ;segment address
            DD      LABEL_A         ;segment:offset pointer

    Finally, .COM programs must not declare any segments with the STACK
    combine type. If a program declares a segment with the STACK combine
    type, the linker will insert initial SS and SP values into the .EXE
    file header, causing EXE2BIN to reject the .EXE file. A .COM program
    does not have explicitly declared stacks, although it can reserve
    space in a non-STACK combine type segment to which it can initialize
    the SP register after it receives control. The absence of a stack
    segment will cause the linker to issue a harmless warning message.

    When the program is assembled and linked into a .EXE file, it must be
    converted into a binary file with a .COM extension by using the
    EXE2BIN utility as shown in the following example for the file
    YOURPROG.EXE:

    C&gt;EXE2BIN YOURPROG YOURPROG.COM  &lt;ENTER&gt;

    It is not necessary to delete or rename a .EXE file with the same
    filename as the .COM file before trying to execute the .COM file as
    long as both remain in the same directory, because MS-DOS's order of
    execution is .COM files first, then .EXE files, and finally .BAT
    files. However, the safest practice is to delete a .EXE file
    immediately after converting it to a .COM file in case the .COM file
    is later renamed or moved to a different directory. If a .EXE file
    designed for conversion to a .COM file is executed by accident, it is
    likely to crash the system.

Patching the .COM program using DEBUG

    As discussed for .EXE files, a programmer who distributes software to
    users will probably want to send instructions on how to patch in error
    corrections. This approach to software updates lends itself even
    better to .COM files than it does to .EXE files.

    For example, because .COM files contain only the code image, they need
    not be renamed in order to read and write them using DEBUG. The user
    need only be instructed on how to load the .COM file into DEBUG, how
    to patch the program, and how to write the patched image back to disk.
    Calculating the addresses and patch values is even easier, because no
    header exists in the .COM file image to cause complications. With the
    preceding exceptions, the details for patching .COM programs remain
    the same as previously outlined for .EXE programs.

.COM summary

    To summarize, the .COM program and file structures are a simpler but
    more restricted approach to writing programs than the .EXE structure
    because the programmer has only a single memory model from which to
    choose (the .COM program segment model). Also, .COM program files do
    not contain the 512-byte (or more) header inherent to .EXE files, so
    the .COM program structure is well suited to small programs for which
    adding 512 bytes of header would probably at least double the file's
    size.


Summary of Differences

    The following table summarizes the differences between .COM and .EXE
    programs.

╓┌─────────────────────┌────────────────────────────┌────────────────────────╖
                    .COM program                 .EXE program
    ─────────────────────────────────────────────────────────────────────
    Maximum size     65536 bytes minus 256 bytes  No limit
                    for PSP and 2 bytes for
                    stack

    Entry point      PSP:0100H                    Defined by END statement

    CS at entry      PSP                          Segment containing
                                                program's entry point

    IP at entry      0100H                        Offset of entry point
                                                within its segment

    DS at entry      PSP                          PSP

    ES at entry      PSP                          PSP

    SS at entry      PSP                          Segment with STACK
                                                attribute

    SP at entry      FFFEH or top word in         End of segment
                    available memory,            defined with
                    whichever is lower           STACK attribute

    Stack at entry   Zero word                    Initialized or
                                                uninitialized,
                                                depending on source

    Stack size       65536 bytes minus 256 bytes  Defined in
                    for PSP and size of          segment with
                    executable code and data     STACK attribute

    Subroutine calls NEAR                         NEAR or FAR

    Exit method      Interrupt 21H Function 4CH   Interrupt 21H Function
                    preferred; NEAR RET if       4CHpreferred;
                    MS-DOS versions 1.x          indirect jump to
                                                PSP:0000H if MS-DOS
                                                versions 1.x

    Size of file     Exact size of program        Size of program plus
                                                header (at least 512
                                                extra bytes)

    Which format the programmer uses for an application usually depends on
    the program's intended size, but the decision can also be influenced
    by a program's need to address multiple memory segments. Normally,
    small utility programs (such as CHKDSK and FORMAT) are designed as
    .COM programs; large programs (such as the Microsoft C Compiler) are
    designed as .EXE programs. The ultimate decision is, of course, the
    programmer's.

                                                            Keith Burgoyne



Article 5:  Character Device Input and Output


    All functional computer systems are composed of a central processing
    unit (CPU), some memory, and peripheral devices that the CPU can use
    to store data or communicate with the outside world. In MS-DOS
    systems, the essential peripheral devices are the keyboard (for
    input), the display (for output), and one or more disk drives (for
    nonvolatile storage). Additional devices such as printers, modems, and
    pointing devices extend the functionality of the computer or offer
    alternative methods of using the system.

    MS-DOS recognizes two types of devices: block devices, which are
    usually floppy-disk or fixed-disk drives; and character devices, such
    as the keyboard, display, printer, and communications ports.

    The distinction between block and character devices is not always
    readily apparent, but in general, block devices transfer information
    in chunks, or blocks, and character devices move data one character
    (usually 1 byte) at a time. MS-DOS identifies each block device by a
    drive letter assigned when the device's controlling software, the
    device driver, is loaded. A character device, on the other hand, is
    identified by a logical name (similar to a filename and subject to
    many of the same restrictions) built into its device driver. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Installable
    Device Drivers.


Background Information

    Versions 1.x of MS-DOS, first released for the IBM PC in 1981,
    supported peripheral devices with a fixed set of device drivers
    loaded during system initialization from the hidden file IO.SYS (or
    IBMBIO.COM with PC-DOS). These versions of MS-DOS offered application
    programs a high degree of input/output device independence by allowing
    character devices to be treated like files, but they did not provide
    an easy way to augment the built-in set of drivers if the user wished
    to add a third-party peripheral device to the system.

    With the release of MS-DOS version 2.0, the hardware flexibility of
    the system was tremendously enhanced. Versions 2.0 and later support
    installable device drivers that can reside in separate files on the
    disk and can be linked into the operating system simply by adding a
    DEVICE directive to the CONFIG.SYS file on the startup disk. See USER
    COMMANDS: CONFIG.SYS: DEVICE. A well-defined interface between
    installable drivers and the MS-DOS kernel allows such drivers to be
    written for most types of peripheral devices without the need for
    modification to the operating system itself.

    The CONFIG.SYS file can contain a number of different DEVICE commands
    to load separate drivers for pointing devices, magnetic-tape drives,
    network interfaces, and so on. Each driver, in turn, is specialized
    for the hardware characteristics of the device it supports. When the
    system is turned on or restarted, the installable device drivers are
    added to the chain, or linked list, of default device drivers loaded
    from IO.SYS during MS-DOS initialization. Thus, the need for the
    system's default set of device drivers to support a wide range of
    optional device types and features at an excessive cost of system
    memory is avoided.

    One important distinction between block and character devices is that
    MS-DOS always adds new block-device drivers to the tail of the driver
    chain but adds new character-device drivers to the head of the chain.
    Thus, because MS-DOS searches the chain sequentially and uses the
    first driver it finds that satisfies its search conditions, any
    existing character-device driver can be superseded by simply
    installing another driver with an identical logical device name.

    This article covers some of the details of working with MS-DOS
    character devices: displaying text, keyboard input, and other basic
    character I/O functions; the definition and use of standard input and
    output; redirection of the default character devices; and the use of
    the IOCTL function (Interrupt 21H Function 44H) to communicate
    directly with a character-device driver. Much of the information
    presented in this article is applicable only to MS-DOS versions 2.0
    and later.


Accessing Character Devices

    Application programs can use either of two basic techniques to access
    character devices in a portable manner under MS-DOS. First, a program
    can use the handle-type function calls that were added to MS-DOS in
    version 2.0. Alternatively, a program can use the so-called
    "traditional" character-device functions that were present in versions
    1.x and have been retained in the operating system for compatibility.
    Because the handle functions are more powerful and flexible, they are
    discussed first.

    A handle is a 16-bit number returned by the operating system whenever
    a file or device is opened or created by passing a name to MS-DOS
    Interrupt 21H Function 3CH (Create File with Handle), 3DH (Open File
    with Handle), 5AH (Create Temporary File), or 5BH (Create New File).
    After a handle is obtained, it can be used with Interrupt 21H Function
    3FH (Read File or Device) or Function 40H (Write File or Device) to
    transfer data between the computer's memory and the file or device.

    During an open or create function call, MS-DOS searches the device-
    driver chain sequentially for a character device with the specified
    name (the extension is ignored) before searching the disk directory.
    Thus, a file with the same name as any character device in the driver
    chain--for example, the file NUL.TXT--cannot be created, nor can an
    existing file be accessed if a device in the chain has the same name.

    The second method for accessing character devices is through the
    traditional MS-DOS character input and output functions, Interrupt 21H
    Functions 01H through 0CH. These functions are designed to communicate
    directly with the keyboard, display, printer, and serial port. Each of
    these devices has its own function or group of functions, so neither
    names nor handles need be used. However, in MS-DOS versions 2.0 and
    later, these function calls are translated within MS-DOS to make use
    of the same routines that are used by the handle functions, so the
    traditional keyboard and display functions are affected by I/O
    redirection and piping.

    Use of either the traditional or the handle-based method for character
    device I/O results in highly portable programs that can be used on any
    computer that runs MS-DOS. A third, less portable access method is to
    use the hardware-specific routines resident in the read-only memory
    (ROM) of a specific computer (such as the IBM PC ROM BIOS driver
    functions), and a fourth, definitely nonportable approach is to
    manipulate the peripheral device's adapter directly, bypassing the
    system software altogether. Although these latter hardware-dependent
    methods cannot be recommended, they are admittedly sometimes necessary
    for performance reasons.


The Basic MS-DOS Character Devices

    Every MS-DOS system supports at least the following set of logical
    character devices without the need for any additional installable
    drivers:

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Device      Meaning
    ──────────────────────────────────────────────────────────────────
    CON         Keyboard and display
    PRN         System list device, usually a parallel port
    AUX         Auxiliary device, usually a serial port
    CLOCK$      System real-time clock
    NUL         "Bit-bucket" device

    These devices can be opened by name or they can be addressed through
    the "traditional" function calls; strings can be read from or written
    to the devices according to their capabilities on any MS-DOS system.
    Data written to the NUL device is discarded; reads from the NUL device
    always return an end-of-file condition.

    PC-DOS and compatible implementations of MS-DOS typically also support
    the following logical character-device names:

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Device      Meaning
    ──────────────────────────────────────────────────────────────────
    COM1        First serial communications port
    COM2        Second serial communications port
    LPT1        First parallel printer port
    LPT2        Second parallel printer port
    LPT3        Third parallel printer port

    In such systems, PRN is an alias for LPT1 and AUX is an alias for
    COM1. The MODE command can be used to redirect an LPT device to
    another device. See USER COMMANDS: MODE.

    As previously mentioned, any of these default character-device drivers
    can be superseded by a user-installed device driver--for example, one
    that offers enhanced functionality or changes the device's apparent
    characteristics. One frequently used alternative character-device
    driver is ANSI.SYS, which replaces the standard MS-DOS CON device
    driver and allows ANSI escape sequences to be used to perform tasks
    such as clearing the screen, controlling the cursor position, and
    selecting character attributes. See USER COMMANDS: ANSI.SYS.

The standard devices

    Under MS-DOS versions 2.0 and later, each program owns five previously
    opened handles for character devices (referred to as the standard
    devices) when it begins executing. These handles can be used for input
    and output operations without further preliminaries. The five standard
    devices and their associated handles are

╓┌───────────────────────────────────────┌────────────┌──────────────────────╖
    Standard Device Name               Handle       Default Assignment
    ──────────────────────────────────────────────────────────────────
    Standard input (stdin)             0            CON
    Standard output (stdout)           1            CON
    Standard error (stderr)            2            CON
    Standard auxiliary (stdaux)        3            AUX
    Standard printer (stdprn)          4            PRN

    The standard input and standard output handles are especially
    important because they are subject to I/O redirection. Although these
    handles are associated by default with the CON device so that read and
    write operations are implemented using the keyboard and video display,
    the user can associate the handles with other character devices or
    with files by using redirection parameters in a program's command
    line:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Redirection      Result
    ──────────────────────────────────────────────────────────────────────
    &lt; file           Causes read operations from standard input to obtain
                    data from file.
    &gt; file           Causes data written to standard output to be placed
                    in file.
    &gt;&gt; file          Causes data written to standard output to be appended
                    to file.
    p1 | p2          Causes data written to standard output by program p1
                    to appear as the standard input of program p2.

    This ability to redirect I/O adds great flexibility and power to the
    system. For example, programs ordinarily controlled by keyboard
    entries can be run with "scripts" from files, the output of a program
    can be captured in a file or on a printer for later inspection, and
    general-purpose programs (filters) can be written that process text
    streams without regard to the text's origin or destination. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Writing
    MS-DOS Filters.

    Ordinarily, an application program is not aware that its input or
    output has been redirected, although a write operation to standard
    output will fail unexpectedly if standard output was redirected to a
    disk file and the disk is full. An application can check for the
    existence of I/O redirection with an IOCTL (Interrupt 21H Function
    44H) call, but it cannot obtain any information about the destination
    of the redirected handle except whether it is associated with a
    character device or with a file.

Raw versus cooked mode

    MS-DOS associates each handle for a character device with a mode that
    determines how I/O requests directed to that handle are treated. When
    a handle is in raw mode, characters are passed between the application
    program and the device driver without any filtering or buffering by
    MS-DOS. When a handle is in cooked mode, MS-DOS buffers any data that
    is read from or written to the device and takes special actions when
    certain characters are detected.

    During cooked mode input, MS-DOS obtains characters from the device
    driver one at a time, checking each character for a Control-C. The
    characters are assembled into a string within an internal MS-DOS
    buffer. The input operation is terminated when a carriage return (0DH)
    or an end-of-file mark (1AH) is received or when the number of
    characters requested by the application have been accumulated. If the
    source is standard input, lone linefeed characters are translated to
    carriage-return/linefeed pairs. The string is then copied from the
    internal MS-DOS buffer to the application program's buffer, and
    control returns to the application program.

    During cooked mode output, MS-DOS transfers the characters in the
    application program's output buffer to the device driver one at a
    time, checking after each character for a Control-C pending at the
    keyboard. If the destination is standard output and standard output
    has not been redirected, tabs are expanded to spaces using eight-
    column tab stops. Output is terminated when the requested number of
    characters have been written or when an end-of-file mark (1AH) is
    encountered in the output string.

    In contrast, during raw mode input or output, data is transferred
    directly between the application program's buffer and the device
    driver. Special characters such as carriage return and the end-of-file
    mark are ignored, and the exact number of characters in the
    application program's request are always read or written. MS-DOS does
    not break the strings into single-character calls to the device driver
    and does not check the keyboard buffer for Control-C entries during
    the I/O operation. Finally, characters read from standard input in raw
    mode are not echoed to standard output.

    As might be expected from the preceding description, raw mode input or
    output is usually much faster than cooked mode input or output,
    because each character is not being individually processed by the
    MS-DOS kernel. Raw mode also allows programs to read characters from
    the keyboard buffer that would otherwise be trapped by MS-DOS (for
    example, Control-C, Control-P, and Control-S). (If BREAK is on, MS-DOS
    will still check for Control-C entries during other function calls,
    such as disk operations, and transfer control to the Control-C
    exception handler if a Control-C is detected.) A program can use the
    MS-DOS IOCTL Get and Set Device Data services (Interrupt 21H Function
    44H Subfunctions 00H and 01H) to set the mode for a character-device
    handle. See IOCTL, below.

    Ordinarily, raw or cooked mode is strictly an attribute of a specific
    handle that was obtained from a previous open operation and affects
    only the I/O operations requested by the program that owns the handle.
    However, when a program uses IOCTL to select raw or cooked mode for
    one of the standard device handles, the selection has a global effect
    on the behavior of the system because those handles are never closed.
    Thus, some of the "traditional" keyboard input functions might behave
    in unexpected ways. Consequently, programs that change the mode on a
    standard device handle should save the handle's mode at entry and
    restore it before performing a final exit to MS-DOS, so that the
    operation of COMMAND.COM and other applications will not be disturbed.
    Such programs should also incorporate custom critical error and
    Control-C exception handlers so that the programs cannot be terminated
    unexpectedly. See PROGRAMMING IN THE MS-DOS ENVIRONMENT: CUSTOMIZING
    MS-DOS: Exception Handlers.

The keyboard

    Among the MS-DOS Interrupt 21H functions are two methods of checking
    for and receiving input from the keyboard: the traditional method,
    which uses MS-DOS character input Functions 01H, 06H, 07H, 08H, 0AH,
    0BH, and 0CH (Table 5-1); and the handle method, which uses Function
    3FH. Each of these methods has its own advantages and disadvantages.
    See SYSTEM CALLS.


    Table 5-1. Traditional MS-DOS Character Input Functions.

╓┌───────────────┌─────────────────────────────┌──────────────┌──────┌───────╖
                                            Read Multiple         Ctrl-C
    Function   Name                          Characters     Echo   Check
    ──────────────────────────────────────────────────────────────────────
    01H        Character Input with Echo     No             Yes    Yes
    06H        Direct Console I/O            No             No     No
    07H        Unfiltered Character Input
                Without Echo                  No             No     No
    08H        Character Input Without Echo  No             No     Yes
    0AH        Buffered Keyboard Input       Yes            Yes    Yes
    0BH        Check Keyboard Status         No             No     Yes
    0CH        Flush Buffer, Read Keyboard


    The first four traditional keyboard input calls are really very
    similar. They all return a character in the AL register; they differ
    mainly in whether they echo that character to the display and whether
    they are sensitive to interruption by the user's entry of a Control-C.
    Both Functions 06H and 0BH can be used to test keyboard status (that
    is, whether a key has been pressed and is waiting to be read by the
    program); Function 0BH is simpler to use, but Function 06H is immune
    to Control-C entries.

    Function 0AH is used to read a "buffered line" from the user, meaning
    that an entire line is accepted by MS-DOS before control returns to
    the program. The line is terminated when the user presses the Enter
    key or when the maximum number of characters (to 255) specified by the
    program have been received. While entry of the line is in progress,
    the usual editing keys (such as the left and right arrow keys and the
    function keys on IBM PCs and compatibles) are active; only the final,
    edited line is delivered to the requesting program.

    Function 0CH allows a program to flush the type-ahead buffer before
    accepting input. This capability is important for occasions when a
    prompt must be displayed unexpectedly (such as when a critical error
    occurs) and the user could not have typed ahead a valid response. This
    function should also be used when the user is being prompted for a
    critical decision (such as whether to erase a file), to prevent a
    character that was previously pressed by accident from triggering an
    irrecoverable operation. Function 0CH is unusual in that it is called
    with the number of one of the other keyboard input functions in
    register AL. After any pending input has been discarded, Function 0CH
    simply transfers to the other specified input function; thus, its
    other parameters (if any) depend on the function that ultimately will
    be executed.

    The primary disadvantage of the traditional function calls is that
    they handle redirected input poorly. If standard input has been
    redirected to a file, no way exists for a program calling the
    traditional input functions to detect that the end of the file has
    been reached-the input function will simply wait forever, and the
    system will appear to hang.

    A program that wishes to use handle-based I/O to get input from the
    keyboard must use the MS-DOS Read File or Device service, Interrupt
    21H Function 3FH. Ordinarily, the program can employ the predefined
    handle for standard input (0), which does not need to be opened and
    which allows the program's input to be redirected by the user to
    another file or device. If the program needs to circumvent redirection
    and ensure that its input is from the keyboard, it can open the CON
    device with Interrupt 21H Function 3DH and use the handle obtained
    from that open operation instead of the standard input handle.

    A program using the handle functions to read the keyboard can control
    the echoing of characters and sensitivity to Control-C entries by
    selecting raw or cooked mode with the IOCTL Get and Set Device Data
    services (default = cooked mode). To test the keyboard status, the
    program can either issue an IOCTL Check Input Status call (Interrupt
    21H Function 44H Subfunction 06H) or use the traditional Check
    Keyboard Status call (Interrupt 21H Function 0BH).

    The primary advantages of the handle method for keyboard input are its
    symmetry with file operations and its graceful handling of redirected
    input. The handle function also allows strings as long as 65535 bytes
    to be requested; the traditional Buffered Keyboard Input function
    allows a maximum of 255 characters to be read at a time. This
    consideration is important for programs that are frequently used with
    redirected input and output (such as filters), because reading and
    writing larger blocks of data from files results in more efficient
    operation. The only real disadvantage to the handle method is that it
    is limited to MS-DOS versions 2.0 and later (although this is no
    longer a significant restriction).

Role of the ROM BIOS
    When a key is pressed on the keyboard of an IBM PC or compatible, it
    generates a hardware interrupt (09H) that is serviced by a routine in
    the ROM BIOS. The ROM BIOS interrupt handler reads I/O ports assigned
    to the keyboard controller and translates the key's scan code into an
    ASCII character code. The result of this translation depends on the
    current state of the NumLock and CapsLock toggles, as well as on
    whether the Shift, Control, or Alt key is being held down. (The ROM
    BIOS maintains a keyboard flags byte at address 0000:0417H that gives
    the current status of each of these modifier keys.)

    After translation, both the scan code and the ASCII code are placed in
    the ROM BIOS's 32-byte (16-character) keyboard input buffer. In the
    case of "extended" keys such as the function keys or arrow keys, the
    ASCII code is a zero byte and the scan code carries all the
    information. The keyboard buffer is arranged as a circular, or ring,
    buffer and is managed as a first-in/first-out queue. Because of the
    method used to determine when the buffer is empty, one position in the
    buffer is always wasted; the maximum number of characters that can be
    held in the buffer is therefore 15. Keys pressed when the buffer is
    full are discarded and a warning beep is sounded.

    The ROM BIOS provides an additional module, invoked by software
    Interrupt 16H, that allows programs to test keyboard status, determine
    whether characters are waiting in the type-ahead buffer, and remove
    characters from the buffer. See Appendix O: IBM PC BIOS Calls. Its use
    by application programs should ordinarily be avoided, however, to
    prevent introducing unnecessary hardware dependence.

    On IBM PCs and compatibles, the keyboard input portion of the CON
    driver in the BIOS is a simple sequence of code that calls ROM BIOS
    Interrupt 16H to do the hardware-dependent work. Thus, calls to MS-DOS
    for keyboard input by an application program are subject to two layers
    of translation: The Interrupt 21H function call is converted by the
    MS-DOS kernel to calls to the CON driver, which in turn remaps the
    request onto a ROM BIOS call that obtains the character.

Keyboard programming examples
    Example: Use the ROM BIOS keyboard driver to read a character from the
    keyboard. The character is not echoed to the display.

        mov     ah,00h          ; subfunction 00H = read character
        int     16h             ; transfer to ROM BIOS
                                ; now AH = scan code, AL = character

    Example: Use the MS-DOS traditional keyboard input function to read a
    character from the keyboard. The character is not echoed to the
    display. The input can be interrupted with a Ctrl-C keystroke.

        mov     ah,08h          ; function 08H = character input
                                ;   without echo
        int     21h             ; transfer to MS-DOS
                                ; now AL = character

    Example: Use the MS-DOS traditional Buffered Keyboard Input function
    to read an entire line from the keyboard, specifying a maximum line
    length of 80 characters. All editing keys are active during entry, and
    the input is echoed to the display.

    kbuf    db      80              ; maximum length of read
            db      0               ; actual length of read
            db      80 dup (0)      ; keyboard input goes here
            .
            .
            .
            mov     dx,seg kbuf     ; set DS:DX = address of
            mov     ds,dx           ; keyboard input buffer
            mov     dx,offset kbuf
            mov     ah,0ah          ; function 0AH = read buffered line
            int     21h             ; transfer to MS-DOS
                                    ; terminated by a carriage return,
                                    ; and kbuf+1 = length of input,
                                    ; not including the carriage return

    Example: Use the MS-DOS handle-based Read File or Device function and
    the standard input handle to read an entire line from the keyboard,
    specifying a maximum line length of 80 characters. All editing keys
    are active during entry, and the input is echoed to the display. (The
    input will not terminate on a carriage return as expected if standard
    input is in raw mode.)

    kbuf    db      80 dup (0)      ; buffer for keyboard input
            .
            .
            .
            mov     dx,seg kbuf     ; set DS:DX = address of
            mov     ds,dx           ; keyboard input buffer
            mov     dx,offset kbuf
            mov     cx,80           ; CX = maximum length of input
            mov     bx,0            ; standard input handle = 0
            mov     ah,3fh          ; function 3FH = read file/device
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if function failed
                                    ; otherwise AX = actual
                                    ; length of keyboard input,
                                    ; including carriage-return and
                                    ; linefeed, and the data is
                                    ; in the buffer 'kbuf'

The display

    The output half of the MS-DOS logical character device CON is the
    video display. On IBM PCs and compatibles, the video display is an
    "option" of sorts that comes in several forms. IBM has introduced five
    video subsystems that support different types of displays: the
    Monochrome Display Adapter (MDA), the Color/Graphics Adapter (CGA),
    the Enhanced Graphics Adapter (EGA), the Video Graphics Array (VGA),
    and the Multi-Color Graphics Array (MCGA). Other, non-IBM-compatible
    video subsystems in common use include the Hercules Graphics Card and
    its variants that support downloadable fonts.

    Two portable techniques exist for writing text to the video display
    with MS-DOS function calls. The traditional method is supported by
    Interrupt 21H Functions 02H (Character Output), 06H (Direct Console
    I/O), and 09H (Display String). The handle method is supported by
    Function 40H (Write File or Device) and is available only in MS-DOS
    versions 2.0 and later. See SYSTEM CALLS: INTERRUPT 21H: Functions
    02H, 06H, 09H, 40H. All these calls treat the display essentially
    as a "glass teletype" and do not support bit-mapped graphics.

    Traditional Functions 02H and 06H are similar. Both are called with
    the character to be displayed in the DL register; they differ in that
    Function 02H is sensitive to interruption by the user's entry of a
    Control-C, whereas Function 06H is immune to Control-C but cannot be
    used to output the character 0FFH (ASCII rubout). Both calls check
    specifically for carriage return (0DH), linefeed (0AH), and backspace
    (08H) characters and take the appropriate action if these characters
    are detected.

    Because making individual calls to MS-DOS for each character to be
    displayed is inefficient and slow, the traditional Display String
    function (09H) is generally used in preference to Functions 02H and
    06H. Function 09H is called with the address of a string that is
    terminated with a dollar-sign character ($); it displays the entire
    string in one operation, regardless of its length. The string can
    contain embedded control characters such as carriage return and
    linefeed.

    To use the handle method for screen display, programs must call the
    MS-DOS Write File or Device service, Interrupt 21H Function 40H.
    Ordinarily, a program should use the predefined handle for standard
    output (1) to send text to the screen, so that any redirection
    requested by the user on the program's command line will be honored.
    If the program needs to circumvent redirection and ensure that its
    output goes to the screen, it can either use the predefined handle for
    standard error (2) or explicitly open the CON device with Interrupt
    21H Function 3DH and use the resulting handle for its write
    operations.

    The handle technique for displaying text has several advantages over
    the traditional calls. First, the length of the string to be displayed
    is passed as an explicit parameter, so the string need not contain a
    special terminating character and the $ character can be displayed as
    part of the string. Second, the traditional calls are translated to
    handle calls inside MS-DOS, so the handle calls have less internal
    overhead and are generally faster. Finally, use of the handle Write
    File or Device function to display text is symmetric with the methods
    the program must use to access its files. In short, the traditional
    functions should be avoided unless the program must be capable of
    running under MS-DOS versions 1.x.

Controlling the screen
    One of the deficiencies of the standard MS-DOS CON device driver is
    the lack of screen-control capabilities. The default CON driver has no
    built-in routines to support cursor placement, screen clearing,
    display mode selection, and so on.

    In MS-DOS versions 2.0 and later, an optional replacement CON driver
    is supplied in the file ANSI.SYS. This driver contains most of the
    screen-control capabilities needed by text-oriented application
    programs. The driver is installed by adding a DEVICE directive to the
    CONFIG.SYS file and restarting the system. When ANSI.SYS is active, a
    program can position the cursor, inquire about the current cursor
    position, select foreground and background colors, and clear the
    current line or the entire screen by sending an escape sequence
    consisting of the ASCII Esc character (1BH) followed by various
    function-specific parameters to the standard output device. See USER
    COMMANDS: ANSI.SYS.

    Programs that use the ANSI.SYS capabilities for screen control are
    portable to any MS-DOS implementation that contains the ANSI.SYS
    driver. Programs that seek improved performance by calling the ROM
    BIOS video driver or by assuming direct control of the hardware are
    necessarily less portable and usually require modification when new PC
    models or video subsystems are released.

Role of the ROM BIOS
    The video subsystems in IBM PCs and compatibles use a hybrid of
    memory-mapped and port-addressed I/O. A range of the machine's memory
    addresses is typically reserved for a video refresh buffer that holds
    the character codes and attributes to be displayed on the screen; the
    cursor position, display mode, palettes, and similar global display
    characteristics are governed by writing control values to specific I/O
    ports.

    The ROM BIOS of IBM PCs and compatibles contains a primitive driver
    for the MDA, CGA, EGA, VGA, and MCGA video subsystems. This driver
    supports the following functions:

    ■  Read or write characters with attributes at any screen position.
    ■  Query or set the cursor position.
    ■  Clear or scroll an arbitrary portion of the screen.
    ■  Select palette, background, foreground, and border colors.
    ■  Query or set the display mode (40-column text, 80-column text, all-
        points-addressable graphics, and so on).
    ■  Read or write a pixel at any screen coordinate.

    These functions are invoked by a program through software Interrupt
    10H. See Appendix O: IBM PC BIOS Calls. In PC-DOS-compatible
    implementations of MS-DOS, the display portions of the MS-DOS CON and
    ANSI.SYS drivers use these ROM BIOS routines. Video subsystems that
    are not IBM compatible either must contain their own ROM BIOS or must
    be used with an installable device driver that captures Interrupt 10H
    and provides appropriate support functions.

    Text-only application programs should avoid use of the ROM BIOS
    functions or direct access to the hardware whenever possible, to
    ensure maximum portability between MS-DOS systems. However, because
    the MS-DOS CON driver contains no support for bit-mapped graphics,
    graphically oriented applications usually must resort to direct
    control of the video adapter and its refresh buffer for speed and
    precision.

Display programming examples
    Example: Use the ROM BIOS Interrupt 10H function to write an asterisk
    character to the display in text mode. (In graphics mode, BL must also
    be set to the desired foreground color.)

            mov     ah,0eh          ; subfunction 0EH = write character
                                    ; in teletype mode
            mov     al,'*'          ; AL = character to display
            mov     bh,0            ; select display page 0
            int     10h             ; transfer to ROM BIOS video driver

    Example: Use the MS-DOS traditional function to write an asterisk
    character to the display. If the user's entry of a Control-C is
    detected during the output and standard output is in cooked mode,
    MS-DOS calls the Control-C exception handler whose address is found in
    the vector for Interrupt 23H.

            mov     ah,02h          ; function 02H = display character
            mov     dl,'*'          ; DL = character to display
            int     21h             ; transfer to MS-DOS

    Example: Use the MS-DOS traditional function to write a string to the
    display. The output is terminated by the $ character and can be
    interrupted when the user enters a Control-C if standard output is in
    cooked mode.

    msg     db      'This is a test message','$'
            .
            .
            .
            mov     dx,seg msg      ; DS:DX = address of text
            mov     ds,dx           ; to display
            mov     dx,offset msg
            mov     ah,09h          ; function 09H = display string
            int     21h             ; transfer to MS-DOS

    Example: Use the MS-DOS handle-based Write File or Device function and
    the predefined handle for standard output to write a string to the
    display. Output can be interrupted by the user's entry of a Control-C
    if standard output is in cooked mode.

    msg     db      'This is a test message'
    msg_len equ     $-msg
            .
            .
            .
            mov     dx,seg msg      ; DS:DX = address of text
            mov     ds,dx           ; to display
            mov     dx,offset msg
            mov     cx,msg_len      ; CX = length of text
            mov     bx,1            ; BX = handle for standard output
            mov     ah,40h          ; function 40H = write file/device
            int     21h             ; transfer to MS-DOS

The serial communications ports

    Through version 3.2, MS-DOS has built-in support for two serial
    communications ports, identified as COM1 and COM2, by means of three
    drivers named AUX, COM1, and COM2. (AUX is ordinarily an alias for
    COM1.)

    The traditional MS-DOS method of reading from and writing to the
    serial ports is through Interrupt 21H Function 03H for AUX input and
    Function 04H for AUX output. In MS-DOS versions 2.0 and later, the
    handle-based Read File or Device and Write File or Device functions
    (Interrupt 21H Functions 3FH and 40H) can be used to read from or
    write to the auxiliary device. A program can use the predefined handle
    for the standard auxiliary device (3) with Functions 3FH and 40H, or
    it can explicitly open the COM1 or COM2 devices with Interrupt 21H
    Function 3DH and use the handle obtained from that open operation to
    perform read and write operations.

    MS-DOS support for the serial communications port is inadequate in
    several respects for high-performance serial I/O applications. First,
    MS-DOS provides no portable way to test for the existence or the
    status of a particular serial port in a system; if a program "opens"
    COM2 and writes data to it and the physical COM2 adapter is not
    present in the system, the program may simply hang. Similarly, if the
    serial port exists but no character has been received and the program
    attempts to read a character, the program will hang until one is
    available; there is no traditional function call to check if a
    character is waiting as there is for the keyboard.

    MS-DOS also provides no portable method to initialize the
    communications adapter to a particular baud rate, word length, and
    parity. An application must resort to ROM BIOS calls, manipulate the
    hardware directly, or rely on the user to configure the port properly
    with the MODE command before running the application that uses it. The
    default settings for the serial port on PC-DOS-compatible systems are
    2400 baud, no parity, 1 stop bit, and 8 databits. See USER COMMANDS:
    MODE.

    A more serious problem with the default MS-DOS auxiliary device driver
    in IBM PCs and compatibles, however, is that it is not interrupt
    driven. Accordingly, when baud rates above 1200 are selected,
    characters can be lost during time-consuming operations performed by
    the drivers for other devices, such as clearing the screen or reading
    or writing a floppy-disk sector. Because the MS-DOS AUX device driver
    typically relies on the ROM BIOS serial port driver (accessed through
    software Interrupt 14H) and because the ROM BIOS driver is not
    interrupt driven either, bypassing MS-DOS and calling the ROM BIOS
    functions does not usually improve matters.

    Because of all the problems just described, telecommunications
    application programs commonly take over complete control of the serial
    port and supply their own interrupt handler and internal buffering for
    character read and write operations. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: Interrupt-Driven Communications.

Serial port programming examples
    Example: Use the ROM BIOS serial port driver to write a string to
    COM1.

    msg     db      'This is a test message'
    msg_len equ     $-msg
            .
            .
            .
            mov     bx,seg msg      ; DS:BX = address of message
            mov     ds,bx
            mov     bx,offset msg
            mov     cx,msg_len      ; CX = length of message
            mov     dx,0            ; DX = 0 for COM1
    L1:     mov     al,[bx]         ; get next character into AL
            mov     ah,01h          ; subfunction 01H = output
            int     14h             ; transfer to ROM BIOS
            inc     bx              ; bump pointer to output string
            loop    L1              ; and loop until all chars. sent

    Example: Use the MS-DOS traditional function for auxiliary device
    output to write a string to COM1.

    msg     db      'This is a test message'
    msg_len equ     $-msg
            .
            .
            .
            mov     bx,seg msg      ; set DS:BX = address of message
            mov     ds,bx
            mov     bx,offset msg
            mov     cx,msg_len      ; set CX = length of message
    L1:     mov     dl,[bx]         ; get next character into DL
            mov     ah,04h          ; function 04H = auxiliary output
            int     21h             ; transfer to MS-DOS
            inc     bx              ; bump pointer to output string
            loop    L1              ; and loop until all chars. sent

    Example: Use the MS-DOS handle-based Write File or Device function and
    the predefined handle for the standard auxiliary device to write a
    string to COM1.

    msg     db      'This is a test message'
    msg_len equ     $-msg
            .
            .
            .
            mov     dx,seg msg      ; DS:DX = address of message
            mov     ds,dx
            mov     dx,offset msg
            mov     cx,msg_len      ; CX = length of message
            mov     bx,3            ; BX = handle for standard aux.
            mov     ah,40h          ; function 40H = write file/device
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if write operation failed

The parallel port and printer

    Most MS-DOS implementations contain device drivers for four printer
    devices: LPT1, LPT2, LPT3, and PRN. PRN is ordinarily an alias for
    LPT1 and refers to the first parallel output port in the system. To
    provide for list devices that do not have a parallel interface, the
    LPT devices can be individually redirected with the MODE command to
    one of the serial communications ports. See USER COMMANDS: MODE.

    As with the keyboard, the display, and the serial port, MS-DOS allows
    the printer to be accessed with either traditional or handle-based
    function calls. The traditional function call is Interrupt 21H
    Function 05H, which accepts a character in DL and sends it to the
    physical device currently assigned to logical device name LPT1.

    A program can perform handle-based output to the printer with
    Interrupt 21H Function 40H (Write File or Device). The predefined
    handle for the standard printer (4) can be used to send strings to
    logical device LPT1. Alternatively, the program can issue an open
    operation for a specific printer device with Interrupt 21H Function
    3DH and use the handle obtained from that open operation with Function
    40H. This latter method also allows more than one printer to be used
    at a time from the same program.

    Because the parallel ports are assumed to be output only, no
    traditional call exists for input from the parallel port. In addition,
    no portable method exists to test printer port status under MS-DOS;
    programs that wish to avoid sending a character to the printer adapter
    when it is not ready or not physically present in the system must test
    the adapter's status by making a call to the ROM BIOS printer driver
    (by means of software Interrupt 17H; see Appendix O: IBM PC BIOS
    Calls) or by accessing the hardware directly.

Parallel port programming examples

    Example: Use the ROM BIOS printer driver to send a string to the first
    parallel printer port.

    msg     db      'This is a test message'
    msg_len equ     $-msg
            .
            .
            .
            mov     bx,seg msg      ; DS:BX = address of message
            mov     ds,bx
            mov     bx,offset msg
            mov     cx,msg_len      ; CX = length of message
            mov     dx,0            ; DX = 0 for LPT1
    L1:     mov     al,[bx]         ; get next character into AL
            mov     ah,00h          ; subfunction 00H = output
            int     17h             ; transfer to ROM BIOS
            inc     bx              ; bump pointer to output string
            loop    L1              ; and loop until all chars. sent

    Example: Use the traditional MS-DOS function call to send a string to
    the first parallel printer port.

    msg     db      'This is a test message'
    msg_len equ     $-msg
            .
            .
            .
            mov     bx,seg msg      ; DS:BX = address of message
            mov     ds,bx
            mov     bx,offset msg
            mov     cx,msg_len      ; CX = length of message
    L1:     mov     dl,[bx]         ; get next character into DL
            mov     ah,05h          ; function 05H = printer output
            int     21h             ; transfer to MS-DOS
            inc     bx              ; bump pointer to output string
            loop    L1              ; and loop until all chars. sent

    Example: Use the handle-based MS-DOS Write File or Device call and the
    predefined handle for the standard printer to send a string to the
    system list device.

    msg     db      'This is a test message'
    msg_len equ     $-msg
            .
            .
            .
            mov     dx,seg msg      ; DS:DX = address of message
            mov     ds,dx
            mov     dx,offset msg
            mov     cx,msg_len      ; CX = length of message
            mov     bx,4            ; BX = handle for standard printer
            mov     ah,40h          ; function 40H = write file/device
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if write operation failed


IOCTL

    In versions 2.0 and later, MS-DOS has provided applications with the
    ability to communicate directly with device drivers through a set of
    subfunctions grouped under Interrupt 21H Function 44H (IOCTL). See
    SYSTEM CALLS: INTERRUPT 21H: Function 44H. The IOCTL subfunctions that
    are particularly applicable to the character I/O needs of application
    programs are

╓┌────────────────────────────┌──────────────────────────────────────────────╖
    Subfunction             Name
    ──────────────────────────────────────────────────────────────────
    00H                     Get Device Data
    01H                     Set Device Data
    02H                     Receive Control Data from Character Device
    03H                     Send Control Data to Character Device
    06H                     Check Input Status
    07H                     Check Output Status
    0AH                     Check if Handle is Remote (version 3.1 or
                            later)
    0CH                     Generic I/O Control for Handles: Get/Set
                            Output Iteration Count

    Various bits in the device information word returned by Subfunction
    00H can be tested by an application to determine whether a specific
    handle is associated with a character device or a file and whether the
    driver for the device can process control strings passed by
    Subfunctions 02H and 03H. The device information word also allows the
    program to test whether a character device is the CLOCK$, standard
    input, standard output, or NUL device and whether the device is in raw
    or cooked mode. The program can then use Subfunction 01H to select raw
    mode or cooked mode for subsequent I/O performed with the handle.

    Subfunctions 02H and 03H allow control strings to be passed between
    the device driver and an application; they do not usually result in
    any physical I/O to the device. For example, a custom device driver
    might allow an application program to configure the serial port by
    writing a specific set of control parameters to the driver with
    Subfunction 03H. Similarly, the custom driver might respond to
    Subfunction 02H by passing the application a series of bytes that
    defines the current configuration and status of the serial port.

    Subfunctions 06H and 07H can be used by application programs to test
    whether a device is ready to accept an output character or has a
    character ready for input. These subfunctions are particularly
    applicable to the serial communications ports and parallel printer
    ports because MS-DOS does not supply traditional function calls to
    test their status.

    Subfunction 0AH can be used to determine whether the character device
    associated with a handle is local or remote--that is, attached to the
    computer the program is running on or attached to another computer on
    a local area network. A program should not ordinarily attempt to
    distinguish between local and remote devices during normal input and
    output, but the information can be useful in attempts to recover from
    error conditions. This subfunction is available only if Microsoft
    Networks is running.

    Finally, Subfunction 0CH allows a program to query or set the number
    of times a device driver tries to send output to the printer before
    assuming the device is not available.

IOCTL programming examples

    Example: Use IOCTL Subfunction 00H to obtain the device information
    word for the standard input handle and save it, and then use
    Subfunction 01H to place standard input into raw mode.

    info    dw      ?               ; save device information word here
            .
            .
            .
            mov     ax,4400h        ; AH = function 44H, IOCTL
                                    ; AL = subfunction 00H, get device
                                    ; information word
            mov     bx,0            ; BX = handle for standard input
            int     21h             ; transfer to MS-DOS
            mov     info,dx         ; save device information word
                                    ; (assumes DS = data segment)
            or      dl,20h          ; set raw mode bit
            mov     dh,0            ; and clear DH as MS-DOS requires
            mov     ax,4401h        ; AL = subfunction 01H, set device
                                    ; information word
                                    ; (BX still contains handle)
            int     21h             ; transfer to MS-DOS

    Example: Use IOCTL Subfunction 06H to test whether a character is
    ready for input on the first serial port. The function returns AL =
    0FFH if a character is ready and AL = 00H if not.

            mov     ax,4406H        ; AH = function 44H, IOCTL
                                    ; AL = subfunction 06H, get
                                    ; input status
            mov     bx,3            ; BX = handle for standard aux
            int     21h             ; transfer to MS-DOS
            or      al,al           ; test status of AUX driver
            jnz     ready           ; jump if input character ready
                                    ; else no character is waiting

                                                Jim Kyle
                                                Chip Rabinowitz



Article 6:  Interrupt-Driven Communications


    In the earliest days of personal-computer communications, when speeds
    were no faster than 300 bits per second, primitive programs that moved
    characters to and from the remote system were adequate. The PC had
    time between characters to determine what it ought to do next and
    could spend that time keeping track of the status of the remote
    system.

    Modern data-transfer rates, however, are four to eight times faster
    and leave little or no time to spare between characters. At 1200 bits
    per second, as many as three characters can be lost in the time
    required to scroll the display up one line. At such speeds, a
    technique to permit characters to be received and simultaneously
    displayed becomes necessary.

    Mainframe systems have long made use of hardware interrupts to
    coordinate such activities. The processor goes about its normal
    activity; when a peripheral device needs attention, it sends an
    interrupt request to the processor. The processor interrupts its
    activity, services the request, and then goes back to what it was
    doing. Because the response is driven by the request, this type of
    processing is known as interrupt-driven. It gives the effect of doing
    two things at the same time without requiring two separate processors.

    Successful telecommunication with PCs at modern data rates demands an
    interrupt-driven routine for data reception. This article discusses in
    detail the techniques for interrupt-driven communications and
    culminates in two sample program packages.

    The article begins by establishing the purpose of communications
    programs and then discusses the capability of the simple functions
    provided by MS-DOS to achieve this goal. To see what must be done to
    supplement MS-DOS functions, the hardware (both the modem and the
    serial port) is examined. This leads to a discussion of the method
    MS-DOS has provided since version 2.0 for solving the problems of
    special hardware interfacing: the installable device driver.

    With the background established, alternate paths to interrupt-driven
    communications are discussed--one following recommended MS-DOS
    techniques, the other following standard industry practice--and
    programs are developed for each.

    Throughout this article, the discussion is restricted to the
    architecture and BIOS of the IBM PC family. MS-DOS systems not totally
    compatible with this architecture may require substantially different
    approaches at the detailed level, but the same general principles
    apply.


Purpose of Communications Programs

    The primary purpose of any communications program is communicating--
    that is, transmitting information entered as keystrokes (or bytes read
    from a file) in a form suitable for transmission to a remote computer
    via phone lines and, conversely, converting information received from
    the remote computer into a display on the video screen (or data in a
    file).

    Some years ago, the most abstract form of all communications programs
    was dubbed a modem engine, by analogy to Babbage's analytical engine
    or the inference-engine model used in artificial-intelligence
    development. The functions of the modem engine are common to all kinds
    of communications programs, from the simplest to the most complex, and
    can be described in a type of pseudo-C as follows:

    The Modem Engine Pseudocode

        DO {  IF (input character is available)
                send_it_to_remote;
                IF (remote character is available)
                use_it_locally;
            } UNTIL (told_to_stop);

    The essence of this modem-engine code is that the absence of an input
    character, or of a character from the remote computer, does not hang
    the loop in a wait state. Rather, the engine continues to cycle: If it
    finds work to do, it does it; if not, the engine keeps looking.

    Of course, at times it is desirable to halt the continuous action of
    the modem engine. For example, when receiving a long message, it is
    nice to be able to pause and read the message before the lines scroll
    into oblivion. On the other hand, taking too long to study the screen
    means that incoming characters are lost. The answer is a technique
    called flow control, in which a special control character is sent to
    shut down transmission and some other character is later sent to start
    it up again.

    Several conventions for flow control exist. One of the most widespread
    is known as XON/XOFF, from the old Teletype-33 keycap legends for the
    two control codes involved. In the original use, XOFF halted the paper
    tape reader and XON started it going again. In mid-1967, the General
    Electric Company began using these signals in its time-sharing
    computer services to control the flow of data, and the practice
    rapidly spread throughout the industry.

    The sample program named ENGINE, shown later in this article, is an
    almost literal implementation of the modem-engine approach. This
    sample represents one extreme of simplicity in communications
    programs. The other sample program, CTERM.C, is much more complex, but
    the modem engine is still at its heart.


Using Simple MS-DOS Functions

    Because MS-DOS provides, among its standard service functions, the
    capability of sending output to or reading input from the device named
    AUX (which defaults to COM1, the first serial port on most machines),
    a first attempt at implementing the modem engine using MS-DOS
    functions might look something like the following incomplete fragment
    of Microsoft Macro Assembler (MASM) code:

    ;Incomplete (and Unworkable) Implementation

    LOOP:   MOV     AH,08h          ; read keyboard, no echo
            INT     21h
            MOV     DL,AL           ; set up to send
            MOV     AH,04h          ; send to AUX device
            INT     21h
            MOV     AH,03h          ; read from AUX device
            INT     21h
            MOV     DL,AL           ; set up to send
            MOV     AH,02h          ; send to screen
            INT     21h
            JMP     LOOP            ; keep doing it

    The problem with this code is that it violates the keep-looking
    principle both at the keyboard and at the AUX port: Interrupt 21H
    Function 08H does not return until a keyboard character is available,
    so no data from the AUX port can be read until a key is pressed
    locally. Similarly, Function 03H waits for a character to become
    available from AUX, so no more keys can be recognized locally until
    the remote system sends a character. If nothing is received, the loop
    waits forever.

    To overcome the problem at the keyboard end, Function 0BH can be used
    to determine if a key has been pressed before an attempt is made to
    read one, as shown in the following modification of the fragment:

    ;Improved, (but Still Unworkable) Implementation

    LOOP:   MOV     AH,0Bh          ; test keyboard for char
            INT     21h
            OR      AL,AL           ; test for zero
            JZ      RMT             ; no char avail, skip
            MOV     AH,08h          ; have char, read it in
            INT     21h
            MOV     DL,AL           ; set up to send
            MOV     AH,04h          ; send to AUX device
            INT     21h
    RMT:
            MOV     AH,03h          ; read from AUX device
            INT     21h
            MOV     DL,AL           ; set up to send
            MOV     AH,02h          ; send to screen
            INT     21h
            JMP     LOOP            ; keep doing it

    This code permits any input from AUX to be received without waiting
    for a local key to be pressed, but if AUX is slow about providing
    input, the program waits indefinitely before checking the keyboard
    again. Thus, the problem is only partially solved.

    MS-DOS, however, simply does not provide any direct method of making
    the required tests for AUX or, for that matter, any of the serial port
    devices. That is why communications programs must be treated
    differently from most other types of programs under MS-DOS and why
    such programs must be intimately involved with machine details despite
    all accepted principles of portable program design.


The Hardware Involved

    Personal-computer communications require at least two distinct pieces
    of hardware (separate devices, even though they are often combined on
    a single board). These hardware items are the serial port, which
    converts data from the computer's internal bus into a bit stream for
    transmission over a single external line, and the modem, which
    converts the bit stream into a form suitable for telephone-line (or,
    sometimes, radio) transmission.

The modem

    The modem (a word coined from MOdulator-DEModulator) is a device that
    converts a stream of bits, represented as sequential changes of
    voltage level, into audio frequency signals suitable for transmission
    over voice-grade telephone circuits (modulation) and converts these
    signals back into a stream of bits that duplicates the original input
    (demodulation).

    Specific characteristics of the audio signals involved were
    established by AT&amp;T when that company monopolized the modem industry,
    and those characteristics then evolved into de facto standards when
    the monopoly vanished. They take several forms, depending on the data
    rate in use; these forms are normally identified by the original Bell
    specification number, such as 103 (for 600 bps and below) or 212A (for
    the 1200 bps standard).

    The data rate is measured in bits per second (bps), often mistermed
    baud or even "baud per second." A baud measures the number of signals
    per second; as with knot (nautical miles per hour), the time reference
    is built in. If one signal change marks one bit, as is true for the
    Bell 103 standard, then baud and bps have equal values. However, they
    are not equivalent for more complex signals. For example, the Bell
    212A diphase standard for 1200 bps uses two tone streams, each
    operating at 600 baud, to transmit data at 1200 bits per second.

    For accuracy, this article uses bps, rather than baud, except where
    widespread industry misuse of baud has become standardized (as in
    "baud rate generator").

    Originally, the modem itself was a box connected to the computer's
    serial port via a cable. Characteristics of this cable, its
    connectors, and its signals were standardized in the 1960s by the
    Electronic Industries Association (EIA), in Standard RS232C. Like the
    Bell standards for modems, RS232C has survived almost unchanged. Its
    characteristics are listed in Table 6-1.


    Table 6-1. RS232C Signals.

╓┌─────────────────────┌──────────┌───────────┌──────────────────────────────╖
    DB25 Pin         232        Name        Description
    ──────────────────────────────────────────────────────────────────
    1                                      Safety Ground
    2               BA         TXD         Transmit Data
    3               BB         RXD         Receive Data
    4               CA         RTS         Request To Send
    5               CB         CTS         Clear To Send
    6               CC         DSR         Data Set Ready
    7               AB         GND         Signal Ground
    8               CF         DCD         Data Carrier Detected
    20               CD         DTR         Data Terminal Ready
    22               CE         RI          Ring Indicator


    With the increasing popularity of personal computers, internal modems
    that plug into the PC's motherboard and combine the modem and a serial
    port became available.

    The first such units were manufactured by Hayes Corporation, and like
    Bell and the EIA, they created a standard. Functionally, the internal
    modem is identical to the combination of a serial port, a connecting
    cable, and an external modem.

The serial port

    Each serial port of a standard IBM PC connects the rest of the system
    to a type INS8250 Universal Asynchronous Receiver Transmitter (UART)
    integrated circuit (IC) chip developed by National Semiconductor
    Corporation. This chip, along with associated circuits in the port,

    1. Converts data supplied via the system data bus into a sequence of
        voltage levels on the single TXD output line that represent binary
        digits.

    2. Converts data received as a sequence of binary levels on the single
        RXD input line into bytes for the data bus.

    3. Controls the modem's actions through the DTR and RTS output lines.

    4. Provides status information to the processor; this information
        comes from the modem, via the DSR, DCD, CTS, and RI input lines,
        and from within the UART itself, which signals data available, data
        needed, or error detected.

    The word asynchronous in the name of the IC comes from the Bell
    specifications. When computer data is transmitted, each bit's
    relationship to its neighbors must be preserved; this can be done in
    either of two ways. The most obvious method is to keep the bit stream
    strictly synchronized with a clock signal of known frequency and count
    the cycles to identify the bits. Such a transmission is known as
    synchronous, often abbreviated to synch or sometimes bisync for binary
    synchronous. The second method, first used with mechanical
    teleprinters, marks the start of each bit group with a defined start
    bit and the end with one or more defined stop bits, and it defines a
    duration for each bit time. Detection of a start bit marks the
    beginning of a received group; the signal is then sampled at each bit
    time until the stop bit is encountered. This method is known as
    asynchronous (or just asynch) and is the one used by the standard
    IBM PC.

    The start bit is, by definition, exactly the same as that used to
    indicate binary zero, and the stop bit is the same as that indicating
    binary one. A zero signal is often called SPACE, and a one signal is
    called MARK, from terms used in the teleprinter industry.

    During transmission, the least significant bit of the data is sent
    first, after the start bit. A parity bit, if used, appears as the most
    significant bit in the data group, before the stop bit or bits; it
    cannot be distinguished from a databit except by its position. Once
    the first stop bit is sent, the line remains in MARK (sometimes called
    idling) condition until a new start bit indicates the beginning of
    another group.

    In most PC uses, the serial port transfers one 8-bit byte at a time,
    and the term word specifies a 16-bit quantity. In the UART world,
    however, a word is the unit of information sent by the chip in each
    chunk. The word length is part of the control information set into the
    chip during setup operations and can be 5, 6, 7, or 8 bits. This
    discussion follows UART conventions and refers to words, rather than
    to bytes.

    One special type of signal, not often used in PC-to-PC communications
    but sometimes necessary in communicating with mainframe systems, is a
    BREAK. The BREAK is an all-SPACE condition that extends for more than
    one word time, including the stop-bit time. (Many systems require the
    BREAK to last at least 150 milliseconds regardless of data rate.)
    Because it cannot be generated by any normal data character
    transmission, the BREAK is used to interrupt, or break into, normal
    operation. The IBM PC's 8250 UART can generate the BREAK  signal, but
    its duration must be determined by a program, rather than by the chip.

The 8250 UART architecture

    The 8250 UART contains four major functional areas: receiver,
    transmitter, control circuits, and status circuits. Because these
    areas are closely related, some terms used in the following
    descriptions are, of necessity, forward references to subsequent
    paragraphs.

    The major parts of the receiver are a shift register and a data
    register called the Received Data Register. The shift register
    assembles sequentially received data into word-parallel form by
    shifting the level of the RXD line into its front end at each bit time
    and, at the same time, shifting previous bits over. When the shift
    register is full, all bits in it are moved over to the data register,
    the shift register is cleared to all zeros, and the bit in the status
    circuits that indicates data ready is set. If an error is detected
    during receipt of that word, other bits in the status circuits are
    also set.

    Similarly, the major parts of the transmitter are a holding register
    called the Transmit Holding Register and a shift register. Each word
    to be transmitted is transferred from the data bus to the holding
    register. If the holding register is not empty when this is done, the
    previous contents are lost. The transmitter's shift register converts
    word-parallel data into bit-serial form for transmission by shifting
    the most significant bit out to the TXD line once each bit time, at
    the same time shifting lower bits over and shifting in an idling bit
    at the low end of the register. When the last databit has been shifted
    out, any data in the holding register is moved to the shift register,
    the holding register is filled with idling bits in case no more data
    is forthcoming, and the bit in the status circuits that indicates the
    Transmit Holding Register is empty is set to indicate that another
    word can be transferred. The parity bit, if any, and stop bits are
    added to the transmitted stream after the last databit of each word is
    shifted out.

    The control circuits establish three communications features: first,
    line control values, such as word length, whether or not (and how)
    parity is checked, and the number of stop bits; second, modem control
    values, such as the state of the DTR and RTS output lines; and third,
    the rate at which data is sent and received. These control values are
    established by two 8-bit registers and one 16-bit register, which are
    addressed as four 8-bit registers. They are the Line Control Register
    (LCR), the Modem Control Register (MCR), and the 16-bit BRG Divisor
    Latch, addressed as Baud0 and Baud1.

    The BRG Divisor Latch sets the data rate by defining the bit time
    produced by the Programmable Baud Rate Generator (PBRG), a major part
    of the control circuits. The PBRG can provide any data speed from a
    few bits per second to 38400 bps; in the BIOS of the IBM PC, PC/XT,
    and PC/AT, though, only the range 110 through 9600 bps is supported.
    How the LCR and the MCR establish their control values, how the PBRG
    is programmed, and how interrupts are enabled are discussed later.

    The fourth major area in the 8250 UART, the status circuits, records
    (in a pair of status registers) the conditions in the receive and
    transmit circuits, any errors that are detected, and any change in
    state of the RS232C input lines from the modem. When any status
    register's content changes, an interrupt request, if enabled, is
    generated to notify the rest of the PC system. This approach lets the
    PC attend to other matters without having to continually monitor the
    status of the serial port, yet it assures immediate action when
    something does occur.

The 8250 programming interface
    Not all the registers mentioned in the preceding section are
    accessible to programmers. The shift registers, for example, can be
    read from or written to only by the 8250's internal circuits. There
    are 10 registers available to the programmer, and they are accessed by
    only seven distinct addresses (shown in Table 6-2). The Received Data
    Register and the Transmit Holding Register share a single address (a
    read gets the received data; a write goes to the holding register). In
    addition, both this address and that of the Interrupt Enable Register
    (IER) are shared with the PBRG Divisor Latch. A bit in the Line
    Control Register called the Divisor Latch Access Bit (DLAB) determines
    which register is addressed at any specific time.

    In the IBM PC, the seven addresses used by the 8250 are selected by
    the low 3 bits of the port number (the higher bits select the specific
    port). Thus, each serial port occupies eight positions in the address
    space. However, only the lowest address used--the one in which the low
    3 bits are all 0--need be remembered in order to access all eight
    addresses.

    Because of this, any serial port in the PC is referred to by an
    address that, in hexadecimal notation, ends with either 0 or 8: The
    COM1 port normally uses address 03F8H, and COM2 uses 02F8H. This
    lowest port address is usually called the base port address, and each
    addressable register is then referenced as an offset from this base
    value, as shown in Table 6-2.


    Table 6-2. 8250 Port Offsets from Base Address.

╓┌────────────────┌──────────────────────┌───────────────────────────────────╖
    Offset      Name                   Description
    ──────────────────────────────────────────────────────────────────
    If DLAB bit in LCR = 0:
    00H         DATA                   Received Data Register if
                                        read from, Transmit Holding
                                        Register if written to
    01H         IER                    Interrupt Enable Register

    If DLAB bit in LCR = 1:
    00H         Baud0                  BRG Divisor Latch, low byte
    01H         Baud1                  BRG Divisor Latch, high byte

    Not affected by DLAB bit:
    02H         IID                    Interrupt Identifier Register
    03H         LCR                    Line Control Register
    04H         MCR                    Modem Control Register
    05H         LSR                    Line Status Register
    06H         MSR                    Modem Status Register


The control circuits
    The control circuits of the 8250 include the Programmable Baud Rate
    Generator (PBRG), the Line Control Register (LCR), the Modem Control
    Register (MCR), and the Interrupt Enable Register (IER).

    The PBRG establishes the bit time used for both transmitting and
    receiving data by dividing an external clock signal. To select a
    desired bit rate, the appropriate divisor is loaded into the PBRG's
    16-bit Divisor Latch by setting the Divisor Latch Access Bit (DLAB) in
    the Line Control Register to 1 (which changes the functions of
    addresses 0 and 1) and then writing the divisor into Baud0 and Baud1.
    After the bit rate is selected, DLAB is changed back to 0, to permit
    normal operation of the DATA registers and the IER.

    With the 1.8432 MHz external UART clock frequency used in standard IBM
    systems, divisor values (in decimal notation) for bit rates between
    45.5 and 38400 bps are listed in Table 6-3. These speeds are
    established by a crystal contained in the serial port (or internal
    modem) and are totally unrelated to the speed of the processor's
    clock.


    Table 6-3. Bit Rate Divisor Table for 8250/IBM.

╓┌─────────────────┌─────────────────────────────────────────────────────────╖
    BPS          Divisor
    ──────────────────────────────────────────────────────────────────
        45.5      2532
        50        2304
        75        1536
    110        1047
    134.5       857
    150         768
    300         384
    600         192
    1200          96
    1800          64
    2000          58
    2400          48
    4800          24
    9600          12
    19200           6
    38400           3


    The remaining control circuits are the Line Control Register, the
    Modem Control Register, and the Interrupt Enable Register. Bits in the
    LCR control the assignment of offsets 0 and 1, transmission of the
    BREAK signal, parity generation, the number of stop bits, and the word
    length sent and received, as shown in Table 6-4.


    Table 6-4. 8250 Line Control Register Bit Values.

╓┌─────────────────┌─────────┌─────────────┌─────────────────────────────────╖
    Bit             Name      Binary     Meaning
    ──────────────────────────────────────────────────────────────────
    Address Control:
    7               DLAB      0xxxxxxx   Offset 0 refers to DATA;
                                        offset 1 refers to IER
                            1xxxxxxx   Offsets 0 and 1 refer to BRG
                                        Divisor Latch

    BREAK Control:
    6               SETBRK    x0xxxxxx   Normal UART operation
                            x1xxxxxx   Send BREAK signal

    Parity Checking:
    5,4,3           GENPAR    xxxx0xxx   No parity bit
                            xx001xxx   Parity bit is ODD
                            xx011xxx   Parity bit is EVEN
                            xx101xxx   Parity bit is 1
                            xx111xxx   Parity bit is 0

    Stop Bits:
    2               XSTOP     xxxxx0xx   Only 1 stop bit
                            xxxxx1xx   2 stop bits(1.5 if WL = 5)

    Word Length:
    1,0             WD5       xxxxxx00   Word length = 5
                    WD6       xxxxxx01   Word length = 6
                    WD7       xxxxxx10   Word length = 7
                    WD8       xxxxxx11   Word length = 8


    Two bits in the MCR (Table 6-5) control output lines DTR and RTS; two
    other MCR bits (OUT1 and OUT2) are left free by the UART to be
    assigned by the user; a fifth bit (TEST) puts the UART into a self-
    test mode of operation. The upper 3 bits have no effect on the UART.
    The MCR can be both read from and written to.

    Both of the user-assignable bits are defined in the IBM PC. OUT1 is
    used by Hayes internal modems to cause a power-on reset of their
    circuits; OUT2 controls the passage of UART-generated interrupt
    request signals to the rest of the PC. Unless OUT2 is set to 1,
    interrupt signals from the UART cannot reach the rest of the PC, even
    though all other controls are properly set. This feature is
    documented, but obscurely, in the IBM Technical Reference manuals and
    the asynchronous-adapter schematic; it is easy to overlook when
    writing an interrupt-driven program for these machines.


    Table 6-5. 8250 Modem Control Register Bit Values.

╓┌────────────┌───────────┌──────────────────────────────────────────────────╖
    Name    Binary      Description
    ──────────────────────────────────────────────────────────────────
    TEST    xxx1xxxx    Turns on UART self-test configuration.
    OUT2    xxxx1xxx    Controls 8250 interrupt signals (User2 Output).
    OUT1    xxxxx1xx    Resets Hayes 1200b internal modem (User1 Output).
    RTS     xxxxxx1x    Sets RTS output to RS232C connector.
    DTR     xxxxxxx1    Sets DTR output to RS232C connector.


    The 8250 can generate any or all of four classes of interrupts, each
    individually enabled or disabled by setting the appropriate control
    bit in the Interrupt Enable Register (Table 6-6). Thus, setting the
    IER to 00H disables all the UART interrupts within the 8250 without
    regard to any other settings, such as OUT2, system interrupt masking,
    or the CLI/STI commands. The IER can be both read from and written to.
    Only the low 4 bits have any effect on the UART.


    Table 6-6. 8250 Interrupt Enable Register Constants.

╓┌─────────────────┌─────────────────────────────────────────────────────────╖
    Binary       Action
    ──────────────────────────────────────────────────────────────────
    xxxx1xxx     Enable Modem Status Interrupt.
    xxxxx1xx     Enable Line Status Interrupt.
    xxxxxx1x     Enable Transmit Register Interrupt.
    xxxxxxx1     Enable Received Data Ready Interrupt.


The status circuits
    The status circuits of the 8250 include the Line Status Register
    (LSR), the Modem Status Register (MSR), the Interrupt Identifier (IID)
    Register, and the interrupt-request generation system.

    The 8250 includes circuitry that detects a received BREAK signal and
    also detects three classes of data-reception errors. Separate bits in
    the LSR (Table 6-7) are set to indicate that a BREAK has been received
    and to indicate any of the following: a parity error (if lateral
    parity is in use), a framing error (incoming bit = 0 at stop-bit
    time), or an overrun error (word not yet read from receive buffer by
    the time the next word must be moved into it).

    The remaining bits of the LSR indicate the status of the Transmit
    Shift Register, the Transmit Holding Register, and the Received Data
    Register; the most significant bit of the LSR is not used and is
    always 0. The LSR is a read-only register; writing to it has no
    effect.


    Table 6-7. 8250 Line Status Register Bit Values.

╓┌──────────────┌────────────────┌───────────────────────────────────────────╖
    Bit       Binary           Meaning
    ──────────────────────────────────────────────────────────────────
    7         0xxxxxxx         Always zero
    6         x1xxxxxx         Transmit Shift Register empty
    5         xx1xxxxx         Transmit Holding Register empty
    4         xxx1xxxx         BREAK received
    3         xxxx1xxx         Framing error
    2         xxxxx1xx         Parity error
    1         xxxxxx1x         Overrun error
    0         xxxxxxx1         Received data ready


    The MSR (Table 6-8) monitors the four RS232C lines that report modem
    status. The upper 4 bits of this register indicate the voltage level
    of the associated RS232C line; the lower 4 bits indicate that the
    voltage level has changed since the register was last read.


    Table 6-8. 8250 Modem Status Register Bit Values.

╓┌──────────────┌──────────────────┌─────────────────────────────────────────╖
    Bit       Binary             Meaning
    ──────────────────────────────────────────────────────────────────
    7         1xxxxxxx           Data Carrier Detected (DCD) level
    6         x1xxxxxx           Ring Indicator (RI) level
    5         xx1xxxxx           Data Set Ready (DSR) level
    4         xxx1xxxx           Clear To Send (CTS) level
    3         xxxx1xxx           DCD change
    2         xxxxx1xx           RI change
    1         xxxxxx1x           DSR change
    0         xxxxxxx1           CTS change


    As mentioned previously, four types of interrupts are generated. The
    four types are identified by flag values in the IID Register (Table
    6-9). These flags are set as follows:

    ■  Change of any bit value in the MSR sets the modem status flag.

    ■  Setting of the BREAK Received bit or any of the three error bits in
        the LSR sets the line status flag.

    ■  Setting of the Transmit Holding Register Empty bit in the LSR sets
        the transmit flag.

    ■  Setting of the Received Data Ready bit in the LSR sets the receive
        flag.

    The IID register indicates the interrupt type, even though the IER may
    be disabling that type of interrupt from generating any request. The
    IID is a read-only register; attempts to write to it have no effect.


    Table 6-9. 8250 Interrupt Identification and Causes.

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    IID content      Meaning
    ──────────────────────────────────────────────────────────────────
    xxxxxxx1B        No interrupt active

    xxxxx000B        Modem Status Interrupt; bit changed in MSR

    xxxxx010B        Transmit Register Interrupt; Transmit Holding
                    Register empty, bitset in LSR

    xxxxx100B        Received Data Ready Interrupt; Data Register full,
                    bit set in LSR

    xxxxx110B        Line Status Interrupt; BREAK or error bit set in LSR


    As shown in Table 6-9, an all-zero value (which in most of the other
    registers is a totally disabling condition) means that a Modem Status
    Interrupt condition has not yet been serviced. A modem need not be
    connected, however, for a Modem Status Interrupt condition to occur;
    all that is required is for one of the RS232C non-data input lines to
    change state, thus changing the MSR.

    Whenever a flag is set in the IID, the UART interrupt-request
    generator will, if enabled by the UART programming, generate an
    interrupt request to the processor. Two or more interrupts can be
    active at the same time; if so, more than one flag in the IID register
    is set.

    The IID flag for each interrupt type (and the LSR or MSR bits
    associated with it) clears when the corresponding register is read
    (or, in one case, written to). For example, reading the content of the
    MSR clears the modem status flag; writing a byte to the DATA register
    clears the transmit flag; reading the DATA register clears the receive
    flag; reading the LSR clears the line status flag. The LSR or MSR bit
    does not clear until it has been read; the IID flag clears with the
    LSR or MSR bit.

Programming the UART
    Each time power is applied, any serial-interface device must be
    programmed before it is used. This programming can be done by the
    computer's bootstrap sequence or as a part of the port initialization
    routines performed when a port driver is installed. Often, both
    techniques are used: The bootstrap provides default conditions, and
    these can be modified during initialization to meet the needs of each
    port driver used in a session.

    When the 8250 chip is programmed, the BRG Divisor Latch should be set
    for the proper baud rate, the LCR and MCR should be loaded, the IER
    should be set, and all internal interrupt requests and the receive
    buffer should be cleared. The sequence in which these are done is not
    especially critical, but any pending interrupt requests should be
    cleared before they are permitted to pass on to the rest of the PC.

    The following sample code performs these startup actions, setting up
    the chip in device COM1 (at port 03F8H) to operate at 1200 bps with a
    word length of 8 bits, no parity checking, and all UART interrupts
    enabled. (In practical code, all values for addresses and operating
    conditions would not be built in; these values are included in the
    example to clarify what is being done at each step.)

            MOV     DX,03FBh        ; base port COM1 (03F8) + LCR (3)
            MOV     AL,080h         ; enable Divisor Latch
            OUT     DX,AL
            MOV     DX,03F8h        ; set for Baud0
            MOV     AX,96           ; set divisor to 1200 bps
            OUT     DX,AL
            INC     DX              ; to offset 1 for Baud1
            MOV     AL,AH           ; high byte of divisor
            OUT     DX,AL
            MOV     DX,03FBh        ; back to the LCR offset
            MOV     AL,03           ; DLAB = 0, Parity = N, WL = 8
            OUT     DX,AL
            MOV     DX,03F9h        ; offset 1 for IER
            MOV     AL,0Fh          ; enable all ints in 8250
            OUT     DX,AL
            MOV     DX,03FCh        ; COM1 + MCR (4)
            MOV     AL,0Bh          ; OUT2 + RTS + DTR bits
            OUT     DX,AL
    CLRGS:
            MOV     DX,03FDh        ; clear LSR
            IN      AL,DX
            MOV     DX,03F8h        ; clear RX reg
            IN      AL,DX
            MOV     DX,03FEh        ; clear MSR
            IN      AL,DX
            MOV     DX,03FAh        ; IID reg
            IN      AL,DX
            IN      AL,DX           ; repeat to be sure
            TEST    AL,1            ; int pending?
            JZ      CLRGS           ; yes, repeat

    Note: This code does not completely set up the IBM serial port.
    Although it fully programs the 8250 itself, additional work remains to
    be done. The system interrupt vectors must be changed to provide
    linkage to the interrupt service routine (ISR) code, and the 8259
    Priority Interrupt Controller (PIC) chip must also be programmed to
    respond to interrupt requests from the UART channels. See PROGRAMMING
    IN THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Hardware Interrupt
    Handlers.


Device Drivers

    All versions of MS-DOS since 2.0 have permitted the installation of
    user-provided device drivers. From the standpoint of operating-system
    theory, using such drivers is the proper way to handle generic
    communications interfacing. The following paragraphs are intended as a
    refresher and to explain this article's departure from standard
    device-driver terminology. See PROGRAMMING IN THE MS-DOS ENVIRONMENT:
    CUSTOMIZING MS-DOS: Installable Device Drivers.

    An installable device driver consists of (1) a driver header that
    links the driver to others in the chain maintained by MS-DOS, tells
    the system the characteristics of this specific driver, provides
    pointers to the two major routines contained in the driver, and (for a
    character-device driver) identifies the driver by name; (2) any data
    and storage space the driver may require; and (3) the two major code
    routines.

    The code routines are called the Strategy routine and the Interrupt
    routine in normal device-driver descriptions. Neither has any
    connection with the hardware interrupts dealt with by the drivers
    presented in this article. Because of this, the term Request routine
    is used instead of Interrupt routine, so that hardware interrupt code
    can be called an interrupt service routine (ISR) with minimal chances
    for confusion.

    MS-DOS communicates with a device driver by reserving space for a
    command packet of as many as 22 bytes and by passing this packet's
    address to the driver with a call to the Strategy routine. All data
    transfer between MS-DOS and the driver, in both directions, occurs via
    this command packet and the Request routine. The operating system
    places a command code and, optionally, a byte count and a buffer
    address into the packet at the specified locations, then calls the
    Request routine. The driver performs the command and returns the
    status (and sometimes a byte count) in the packet.


Two Alternative Approaches

    Now that the factors involved in creating interrupt-driven
    communications programs have been discussed, they can be put together
    into practical program packages. Doing so brings out not only general
    principles but also minor details that make the difference between
    success and failure of program design in this hardware-dependent and
    time-critical area.

The traditional way: Going it alone

    Because MS-DOS provides no generic functions suitable for
    communications use, virtually all popular communications programs
    provide and install their own port driver code, and then remove it
    before returning to MS-DOS. This approach entails the creation of a
    communications handler for each program and requires the
    "uninstallation" of the handler on exit from the program that uses it.
    Despite the extra requirements, most communications programs use this
    method.

The alternative: Creating a communications device driver

    Instead of providing temporary interface code that must be removed
    from the system before returning to the command level, an installable
    device driver can be built as a replacement for COMx so that every
    program can have all features. However, this approach is not
    compatible with existing terminal programs because it has never been a
    part of MS-DOS.

Comparison of the two methods

    The traditional approach has several advantages, the most obvious
    being that the driver code can be fully tailored to the needs of the
    program. Because only one program will ever use the driver, no general
    cases need be considered.

    However, if a user wants to keep communications capability available
    in a terminate-and-stay-resident (TSR) module for background use and
    also wants a different type of communications program running in the
    foreground (not, of course, while the background task is using the
    port), the background program and the foreground job must each have
    its own  separate driver code. And, because such code usually includes
    buffer areas, the duplicated drivers represent wasted resources.

    A single communications device driver that is installed when the
    system powers up and that remains active until shutdown avoids wasting
    resources by allowing both the background and foreground tasks to
    share the driver code. Until such drivers are common, however, it is
    unlikely that commercial software will be able to make use of them. In
    addition, such a driver must either provide totally general
    capabilities or it must include control interfaces so each user
    program can dynamically alter the driver to suit its needs.

    At this time, the use of a single driver is an interesting exercise
    rather than a practical application, although a possible exception is
    a dedicated system in which all software is either custom designed or
    specially modified. In such a system, the generalized driver can
    provide significant improvement in the efficiency of resource
    allocation.


A Device-Driver Program Package

    Despite the limitations mentioned in the preceding section, the first
    of the two complete packages in this article uses the concept of a
    separate device driver. The driver handles all hardware-dependent
    interfacing and thus permits extreme simplicity in all other modules
    of the package. This approach is presented first because it is
    especially well suited for introducing the concepts of communications
    programs. However, the package is not merely a tutorial device: It
    includes some features that are not available in most commercial
    programs.

    The package itself consists of three separate programs. First is the
    device driver, which becomes a part of MS-DOS via the CONFIG.SYS file.
    Second is the modem engine, which is the actual terminal program. (A
    functionally similar component forms the heart of every communications
    program, whether it is written in assembly language or a high-level
    language and regardless of the machine or operating system in use.)
    Third is a separately executed support program that permits changing
    such driver characteristics as word length, parity, and baud rate.

    In most programs that use the traditional approach, the driver and the
    support program are combined with the modem engine in a single unit
    and the resulting mass of detail obscures the essential simplicity of
    each part. Here, the parts are presented as separate modules to
    emphasize that simplicity.

The device driver: COMDVR.ASM

    The device driver is written to augment the default COM1 and COM2
    devices with other devices named ASY1 and ASY2 that use the same
    physical hardware but are logically separate. The driver (COMDVR.ASM)
    is implemented in MASM and is shown in the listing in Figure 6-1.
    Although the driver is written basically as a skeleton, it is designed
    to permit extensive expansion and can be used as a general-purpose
    sample of device-driver source code.

The code

    ──────────────────────────────────────────────────────────────────────

    Figure 6-1. COMDVR.ASM.

    ──────────────────────────────────────────────────────────────────────


    The first part of the driver source code (after the necessary MASM
    housekeeping details in lines 1 through 8) is a commented-out macro
    definition (lines 10 through 32). This macro is used only during
    debugging and is part of a debugging technique that requires no
    sophisticated hardware and no more complex debugging program than the
    venerable DEBUG.COM. (Debugging techniques are discussed after the
    presentation of the driver program itself.)

    Definitions
    The actual driver source program consists of three sets of EQU
    definitions (lines 34 through 194), followed by the modular code and
    data areas (lines 197 through 900). The first set of definitions
    (lines 34 through 82) gives symbolic names to the permissible values
    for MS-DOS device-driver control bits and the device-driver
    structures.

    The second set of definitions (lines 84 through 145) assigns names to
    the ports and bit values that are associated with the IBM hardware--
    both the 8259 PIC and the 8250 UART. The third set of definitions
    (lines 147 through 194) assigns names to the control values and
    structures associated with this driver.

    The definition method used here is recommended for all drivers. To
    move this driver from the IBM architecture to some other hardware, the
    major change required to the program would be reassignment of the port
    addresses and bit values in lines 84 through 145.

    The control values and structures for this specific driver (defined in
    the third EQU set) provide the means by which the separate support
    program can modify the actions of each of the two logical drivers.
    They also permit the driver to return status information to both the
    support program and the using program as necessary. Only a few
    features are implemented, but adequate space for expansion is
    provided. The addition of a few more definitions in this area and one
    or two extra procedures in the code section would do all that is
    necessary to extend the driver's capabilities to such features as
    automatic expansion of tab characters, case conversion, and so forth,
    should they be desired.

    Headers and structure tables
    The driver code itself starts with a linked pair of device-driver
    header blocks, one for ASY1 (lines 201 through 207) and the other for
    ASY2 (lines 208 through 213). Following the headers, in lines 215
    through 236, are a commented-out space reservation used by the
    debugging procedure (line 215), the pointer to the command packet
    (line 219), and the baud-rate conversion table (lines 221 through
    236).

    The conversion table is followed by structure tables containing all
    data unique to ASY1 (lines 239 through 242) and ASY2 (lines 244
    through 247). After the structure tables, buffer areas are reserved in
    lines 249 through 254. One input buffer and one output buffer are
    reserved for each port. All buffers are the same size; for simplicity,
    buffer size is given a name (at line 249) so that it can be changed by
    editing a single line of the program.

    The size is arbitrary in this case, but if file transfers are
    anticipated, the buffer should be able to hold at least 2 seconds'
    worth of data (240 bytes at 1200 bps) to avoid data loss during writes
    to disk. Whatever size is chosen should be a power of 2 for simple
    pointer arithmetic and, if video display is intended, should not be
    less than 8 bytes, to prevent losing characters when the screen
    scrolls.

    If additional ports are desired, more headers can be added after line
    213; corresponding structure tables for each driver, plus matching
    pairs of buffers, would also be necessary. The final part of this area
    is the dispatch table (lines 256 through 284), which lists offsets of
    all request routines in the driver; its use is discussed below.

    Strategy and Request routines
    With all data taken care of, the program code begins at the Strategy
    routine (lines 289 through 296), which is used by both ports. This
    code saves the command packet address passed to it by MS-DOS for use
    by the Request routine and returns to MS-DOS.

    The Request routines (lines 298 through 567) are also shared by both
    ports, but the two drivers are distinguished by the address placed
    into the SI register. This address points to the structure table that
    is unique to each port and contains such data as the port's base
    address, the associated hardware interrupt vector, the interrupt
    service routine offset within the driver's segment, the base offsets
    of the input and output buffers for that port, two pointers for each
    of the buffers, and the input and output status conditions (including
    baud rate) for the port. The only difference between one port's driver
    and the other's is the data pointed to by SI; all Request routine code
    is shared by both ports.

    Each driver's Request routine has a unique entry point (at line 298
    for ASY1 and at line 303 for ASY2) that saves the original content of
    the SI register and then loads it with the address of the structure
    table for that driver. The routines then join as a common stream at
    line 307 (Gen_request).

    This common code preserves all other registers used (lines 309 through
    318), sets DS equal to CS (lines 319 and 320), retrieves the command-
    packet pointer saved by the Strategy routine (line 321), uses the
    pointer to get the command code (line 323), uses the code to calculate
    an offset into a table of addresses (lines 324 through 326), and
    performs an indexed jump (lines 322 and 327) by way of the dispatch
    table (lines 256 through 284) to the routine that executes the
    requested command (at line 336, 360, 389, 404, 414, 421, 441, 453,
    500, or 829).

    Although the device-driver specifications for MS-DOS version 3.2 list
    command request codes ranging from 0 to 24, not all are used. Earlier
    versions of MS-DOS permitted only 0 to 12 (versions 2.x) or 0 to 16
    (versions 3.0 and 3.1) codes. In this driver, all 24 codes are
    accounted for; those not implemented in this driver return a DONE and
    NO ERROR status to the caller. Because the Request routine is called
    only by MS-DOS itself, there is no check for invalid codes. Actually,
    because the header attribute bits are not set to specify that codes 13
    through 24 are valid, the 24 bytes occupied by their table entries
    (lines 273 through 284) could be saved by omitting the entries. They
    are included only to show how nonexistent commands can be
    accommodated.

    Immediately following the dispatch indexed jump, at lines 329 through
    353 within the same PROC declaration, is the common code used by all
    Request routines to store status information in the command packet,
    restore the registers, and return to the caller. The alternative entry
    points for BUSY status (line 332), NO ERROR status (line 338), or an
    error code (in the AX register at entry to Exit, line 339) not only
    save several bytes of redundant code but also improve readability of
    the code by providing unique single labels for BUSY, NO ERROR, and
    ERROR return conditions.

    All of the Request routines, except for the Init code at line 829,
    immediately follow the dispatching shell in lines 358 through 568.
    Each is simplified to perform just one task, such as read data in or
    write data out. The Read routine (lines 360 through 385) is typical:
    First, the requested byte count and user's buffer address are obtained
    from the command packet. Next, the pointer to the command packet is
    saved with a PUSH instruction, so that the ES and BX registers can be
    used for a pointer to the port's input buffer.

    Before the Get_in routine that actually accesses the input buffer is
    called, the input status byte is checked (line 368). If an error
    condition is flagged, lines 370 through 373 clear the status flag,
    flush the saved pointers from the stack, and jump to the error-return
    exit from the driver. If no error exists, line 375 calls Get_in to
    access the input buffer and lines 376 and 377 determine whether a byte
    was obtained. If a byte is found, it is stored in the user's buffer by
    line 378, and line 379 loops back to get another byte until the
    requested count has been obtained or until no more bytes are
    available. In practice, the count is an upper limit and the loop is
    normally broken when data runs out.

    No matter how it happens, control eventually reaches the Got_all
    routine and lines 381 and 382, where the saved pointers to the command
    packet are restored from the stack. Lines 383 and 384 adjust the count
    value in the packet to reflect the actual number of bytes obtained.
    Finally, line 385 jumps to the normal, no-error exit from the driver.

    Buffering
    Both buffers for each driver are of the type known as circular, or
    ring, buffers. Effectively, such a buffer is endless; it is accessed
    via pointers, and when a pointer increments past the end of the
    buffer, the pointer returns to the buffer's beginning. Two pointers
    are used here for each buffer, one to put data into it and one to get
    data out. The get pointer always points to the next byte to be read;
    the put pointer points to where the next byte will be written, just
    past the last byte written to the buffer.

    If both pointers point to the same byte, the buffer is empty; the next
    byte to be read has not yet been written. The full-buffer condition is
    more difficult to test for: The put pointer is incremented and
    compared with the get pointer; if they are equal, doing a write would
    force a false buffer-empty condition, so the buffer must be full.

    All buffer manipulation is done via four procedures (lines 569 through
    674). Put_out (lines 572 through 596) writes a byte to the driver's
    output buffer or returns a buffer-full indication by setting AH to
    0FFH. Get_out (lines 598 through 622) gets a byte from the output
    buffer or returns 0FFH in AH to indicate that no byte is available.
    Put_in (lines 624 through 648) and Get_in (lines 650 through 674) do
    exactly the same as Put_out and Get_out, but for the input buffer.
    These procedures are used both by the Request routines and by the
    hardware interrupt service routine (ISR).

    Interrupt service routines
    The most complex part of this driver is the ISR (lines 676 through
    806), which decides which of the four possible services for a port is
    to be performed and where. Like the Request routines, the ISR provides
    unique entry points for each port (line 679 for ASY1 and line 685 for
    ASY2); these entry points first preserve the SI register and then load
    it with the address of the port's structure table. With SI indicating
    where the actions are to be performed, the two entries then merge at
    line 690 into common code that first preserves all registers to be
    used by the ISR (lines 690 through 698) and then tests for each of the
    four possible types of service and performs each requested action.

    Much of the complexity of the ISR is in the decoding of modem-status
    conditions. Because the resulting information is not used by this
    driver (although it could be used to prevent attempts to transmit
    while off line), these ISR options can be removed so that only the
    Transmit and Receive interrupts are serviced. To do this, AllInt (at
    line 145) should be changed from the OR of all four bits to include
    only the transmit and receive bits (03H, or 00000011B).

    The transmit and receive portions of the ISR incorporate XON/XOFF flow
    control (for transmitted data only) by default. This control is done
    at the ISR level, rather than in the using program, to minimize the
    time required to respond to an incoming XOFF signal. Presence of the
    flow-control decisions adds complexity to what would otherwise be
    extremely simple actions.

    Flow control is enabled or disabled by setting the OutSpec word in the
    structure table with the Driver Status utility (presented later) via
    the IOCTL function (Interrupt 21H Function 44H). When flow control is
    enabled, any XOFF character (11H) that is received halts all outgoing
    data until XON (13H) is received. No XOFF or XON is retained in the
    input buffer to be sent on to any program, although all patterns other
    than XOFF and XON are passed through by the driver. When flow
    control is disabled, the driver passes all patterns in both
    directions. For binary file transfer, flow control must be disabled.

    The transmit action is simple: The code merely calls the Start_output
    procedure at line 750. Start_output is described in detail below.

    The receive action is almost as simple as transmit, except for the
    flow-control testing. First, the ISR takes the received byte from the
    UART (lines 758 and 759) to avoid any chance of an overrun error. The
    ISR then tests the input specifier (at line 760) to determine whether
    flow control is in effect. If it is not, processing jumps directly to
    line 784 to store the received byte in the input buffer with Put_in
    (line 785).

    If flow control is active, however, the received byte is compared with
    the XOFF character (lines 762 through 765). If the byte matches,
    output is disabled and the byte is ignored. If the byte is not XOFF,
    it is compared with XON (lines 766 through 768). If it is not XON
    either, control jumps to line 784. If the byte is XON, output is re-
    enabled if it was disabled. Regardless, the XON byte itself is
    ignored.

    When control reaches Stuff_in at line 784, Put_in is called to store
    the received byte in the input buffer. If there is no room for it, a
    lost-databit is set in the input status flags (line 788); otherwise,
    the receive routine is finished.

    If the interrupt was a line-status action, the LSR is read (lines 776
    through 779). If the input specifier so directs, the content is
    converted to an IBM PC extended graphics character by setting bit 7 to
    1 and the character is stored in the input buffer as if it were a
    received byte. Otherwise, the Line Status interrupt merely sets the
    generic BadInp error bit in the input status flags, which can be read
    with the IOCTL Read function of the driver.

    When all ISR action is complete, lines 794 through 806 restore machine
    conditions to those existing at the time of the interrupt and return
    to the interrupted procedure.

    The Start_output routine
    Start_output (lines 808 through 824) is a routine that, like the four
    buffer procedures, is used by both the Request routines and the ISR.
    Its purpose is to initiate transmission of a byte, provided that
    output is not blocked by flow control, the UART Transmit Holding
    Register is empty, and a byte to be transmitted exists in the output
    ring buffer. This routine uses the Get_out buffer routine to access
    the buffer and determine whether a byte is available. If all
    conditions are met, the byte is sent to the UART holding register by
    lines 819 and 820.

    The Initialization Request routine
    The Initialization Request routine (lines 829 through 897) is critical
    to successful operation of the driver. This routine is placed last in
    the package so that it can be discarded as soon as it has served its
    purpose by installing the driver. It is essential to clear each
    register of the 8250 by reading its contents before enabling the
    interrupts and to loop through this action until the 8250 finally
    shows no requests pending. The strange Clc jnc $+2 sequence that
    appears repeatedly in this routine is a time delay required by high-
    speed machines (6 MHz and up) so that the 8250 has time to settle
    before another access is attempted; the delay does no harm on slower
    machines.

    Using COMDVR
    The first step in using this device driver is assembling it with the
    Microsoft Macro Assembler (MASM). Next, use the Microsoft Object
    Linker (LINK) to create a .EXE file. Convert the .EXE file into a
    binary image file with the EXE2BIN utility. Finally, include the line
    DEVICE=COMDVR.SYS in the CONFIG.SYS file so that COMDVR will be
    installed when the system is restarted.

    Note: The number and colon at the beginning of each line in the
    program listings in this article are for reference only and should not
    be included in the source file.

    Figure 6-2 shows the sequence of actions required, assuming that EDLIN
    is used for modifying (or creating) the CONFIG.SYS file and that all
    commands are issued from the root directory of the boot drive.

    C&gt;Creating the driver:

    C&gt;MASM COMDVR;  &lt;Enter&gt;
    C&gt;LINK COMDVR;  &lt;Enter&gt;
    C&gt;EXE2BIN COMDVR.EXE COMDVR.SYS  &lt;Enter&gt;

    Modifying CONFIG.SYS (^Z = press Ctrl-Z):

    C&gt;EDLIN CONFIG.SYS  &lt;Enter&gt;
    *#I  &lt;Enter&gt;
    *DEVICE=COMDVR.SYS  &lt;Enter&gt;
    *^Z  &lt;Enter&gt;
    *E  &lt;Enter&gt;

    Figure 6-2. Assembling, linking, and installing COMDVR.


    Because the devices installed by COMDVR do not use the standard MS-DOS
    device names, no conflict occurs with any program that uses
    conventional port references. Such a program will not use the driver,
    and no problems should result if the program is well behaved and
    restores all interrupt vectors before returning to MS-DOS.

Device-driver debugging techniques
    The debugging of device drivers, like debugging for any part of MS-DOS
    itself, is more difficult than normal program checking because the
    debugging program, DEBUG.COM or DEBUG.EXE, itself uses MS-DOS
    functions to display output. When these functions are being checked,
    their use by DEBUG destroys the data being examined. And because
    MS-DOS always saves its return address in the same location, any call
    to a function from inside the operating system usually causes a system
    lockup that can be cured only by shutting the system down and powering
    up again.

    One way to overcome this difficulty is to purchase costly debugging
    tools. An easier way is to bypass the problem: Instead of using MS-DOS
    functions to track program operation, write data directly to video
    RAM, as in the macro DBG (lines 10 through 32 of COMDVR.ASM).

    This macro is invoked with a three-character parameter string at each
    point in the program a progress report is desired. Each invocation has
    its own unique three-character string so that the sequence of actions
    can be read from the screen. When invoked, DBG expands into code that
    saves all registers and then writes the three-character string to
    video RAM. Only the top 10 lines of the screen (800 characters, or
    1600 bytes) are used: The macro uses a single far pointer to the area
    and treats the video RAM like a ring buffer.

    The pointer, Dbgptr (line 215), is set up for use with the monochrome
    adapter and points to location B000:0000H; to use a CGA or EGA (in CGA
    mode), the location should be changed to B800:0000H.

    Most of the frequently used Request routines, such as Read and Write,
    have calls to DBG as their first lines (for example, lines 361 and
    422). As shown, these calls are commented out, but for debugging, the
    source file should be edited so that all the calls and the macro
    itself are enabled.

    With DBG active, the top 10 lines of the display are overwritten with
    a continual sequence of reports, such as RR Tx , put directly into
    video RAM. Because MS-DOS functions are not used, no interference with
    the driver itself can occur.

    Although this technique prevents normal use of the system during
    debugging, it greatly simplifies the problem of knowing what is
    happening in time-critical areas, such as hardware interrupt service.
    In addition, all invocations of DBG in the critical areas are in
    conditional code that is executed only when the driver is working as
    it should.

    Failure to display the pi message, for instance, indicates that the
    received-data hardware interrupt is not being serviced, and absence of
    go after an Ix report shows that data is not being sent out as it
    should.

    Of course, once debugging is complete, the calls to DBG should be
    deleted or commented out. Such calls are usually edited out of the
    source code before release. In this case, they remain to demonstrate
    the technique and, most particularly, to show placement of the calls
    to provide maximum information with minimal clutter on the screen.

A simple modem engine

    The second part of this package is the modem engine itself
    (ENGINE.ASM), shown in the listing in Figure 6-3. The main loop of
    this program consists of only a dozen lines of code (lines 9 through
    20). Of these, five (lines 9 through 13) are devoted to establishing
    initial contact between the program and the serial-port driver and two
    (lines 19 and 20) are for returning to command level at the program's
    end.

    Thus, only five lines of code (lines 14 through 18) actually carry out
    the bulk of the program as far as the main loop is concerned. Four of
    these lines are calls to subroutines that get and put data from and to
    the console and the serial port; the fifth is the JMP that closes the
    loop. This structure underscores the fact that a basic modem engine is
    simply a data-transfer loop.

    ──────────────────────────────────────────────────────────────────────

    Figure 6-3. ENGINE.ASM.

    ──────────────────────────────────────────────────────────────────────

    Because the details of timing and data conversion are handled by the
    driver code, each of the four subroutines is--to show just how simple
    the whole process is--essentially a buffered interface to the MS-DOS
    Read File or Device or Write File or Device routine.

    For example, the getmdm procedure (lines 22 through 31) asks MS-DOS to
    read a maximum of 256 bytes from the serial device and then stores the
    number actually read in a word named mdlen. The driver returns
    immediately, without waiting for data, so the normal number of bytes
    returned is either 0 or 1. If screen scrolling causes the loop to be
    delayed, the count might be higher, but it should never exceed about a
    dozen characters.

    When called, the putcrt procedure (lines 63 through 72) checks the
    value in mdlen. If the value is zero, putcrt does nothing; otherwise,
    it asks MS-DOS to write that number of bytes from mbufr (where getmdm
    put them) to the display, and then it returns.

    Similarly, getkbd gets keystrokes from the keyboard, stores them in
    kbufr, and posts a count in kblen; putmdm checks kblen and, if the
    count is not zero, sends the required number of bytes from kbufr to
    the serial device.

    Note that getkbd does not use the Read File or Device function,
    because that would wait for a keystroke and the loop must never wait
    for reception. Instead, it uses the MS-DOS functions that test
    keyboard status (0BH) and read a key without echo (07H). In addition,
    special treatment is given to the Enter key (lines 45 through 48): A
    linefeed is inserted in kbufr immediately behind Enter and kblen is
    set to 2.

    A Ctrl-C keystroke ends program operation; it is detected in getkbd
    (line 41) and causes immediate transfer to the quit label (line 19) at
    the end of the main loop. Because ENGINE uses only permanently
    resident routines, there is no need for any uninstallation before
    returning to the MS-DOS command prompt.

    ENGINE.ASM is written to be used as a .COM file. Assemble and link it
    the same as COMDVR.SYS (Figure 6-2) but use the extension COM instead
    of SYS; no change to CONFIG.SYS is needed.

The driver-status utility: CDVUTL.C

    The driver-status utility program CDVUTL.C, presented in Figure 6-4,
    permits either of the two drivers (ASY1 and ASY2) to be reconfigured
    after being installed, to suit different needs. After one of the
    drivers has been specified (port 1 or port 2), the baud rate, word
    length, parity, and number of stop bits can be changed; each change is
    made independently, with no effect on any of the other
    characteristics. Additionally, flow control can be switched between
    two types of hardware handshaking--the software XON/XOFF control or
    disabled--and error reporting can be switched between character-
    oriented and message-oriented operation.

    ──────────────────────────────────────────────────────────────────────

    Figure 6-4. CDVUTL.C

    ──────────────────────────────────────────────────────────────────────


    Although CDVUTL appears complicated, most of the complexity is
    concentrated in the routines that map driver bit settings into on-
    screen display text. Each such mapping requires several lines of
    source code to generate only a few words of the display report. Table
    6-10 summarizes the functions found in this program.


    Table 6-10. CDVUTL Program Functions.

╓┌─────────────────────┌──────────┌──────────────────────────────────────────╖
    Lines            Name       Description
    ──────────────────────────────────────────────────────────────────
    42-45           main()     Conventional entry point.
    47-150          disp()     Main dispatching loop.
    152-158          center()   Centers text on CRT.
    160-166          iocwr()    Writes control string to driver with IOCTL
                                Write.
    168-170          onoff()    Returns pointer to ON or OFF.
    172-233          report()   Reads driver status and reports it on
                                display.


    The long list of #define operations at the start of the listing (lines
    11 through 33) helps make the bitmapping comprehensible by assigning a
    symbolic name to each significant bit in the four UART registers.

    The main() procedure of CDVUTL displays a banner line and then calls
    the dispatcher routine, disp(), to start operation. CDVUTL makes no
    use of either command-line parameters or the environment, so the usual
    argument declarations are omitted.

    Upon entry to disp(), the first action is to establish the default
    driver as ASY1 by setting u = 1 and opening ASY1 (line 50); the
    program then enters an apparent infinite loop (lines 51 through 149).

    With each repetition, the loop first prompts for a command (line 52)
    and then gets the next keystroke and uses it to control a huge
    switch() statement (lines 53 through 145). If no case matches the key
    pressed, the switch() statement does nothing; the program simply
    displays a report of all current conditions at the selected driver
    (lines 146 through 148) and then closes the loop back to issue a new
    prompt and get another keystroke.

    However, if the key pressed matches one of the cases in the switch()
    statement, the corresponding command is executed. The digits 1 (line
    55) and 2 (line 61) select the driver to be affected. The ? key (line
    105) causes the list of valid command keys to be displayed. The q key
    (line 142) causes the program to terminate by calling exit( 0 ) and is
    the only exit from the infinite loop. The other valid keys all change
    one or more bits in the IOCTL control string to modify corresponding
    attributes of the driver and then send the string to the driver by
    using the MS-DOS IOCTL Write function (Interrupt 21H Function 44H
    Subfunction 03H) via function iocwr() (lines 160 through 166).

    After the command is executed (except for the q command, which
    terminates operation of CDVUTL and returns to MS-DOS command level,
    and the ? command, which displays the command list), the report()
    function (lines 172 through 233) is called (at line 148) to display
    all of the driver's attributes, including those just changed. This
    function issues an IOCTL Read command (Interrupt 21H Function 44H
    Subfunction 02H, in lines 174 through 178) to get new status
    information into the control string and then uses a sequence of bit
    filtering (lines 179 through 232) to translate the obtained status
    information into words for display.

    The special console I/O routines provided in Microsoft C libraries
    have been used extensively in this routine. Other compilers may
    require changes in the names of such library routines as getch or
    dosint as well as in the names of #include files (lines 6 through 9).

    Each of the actual command sequences changes only a few bits in one of
    the 10 bytes of the command string and then writes the string to the
    driver. A full-featured communications program might make several
    changes at one time--for example, switching from 7-bit, even parity,
    XON/XOFF flow control to 8-bit, no parity, without flow control to
    prevent losing any bytes with values of 11H or 13H while performing a
    binary file transfer with error-correcting protocol. In such a case,
    the program could make all required changes to the control string
    before issuing a single IOCTL Write to put them into effect.


The Traditional Approach

    Because the necessary device driver has never been a part of MS-DOS,
    most communications programs are written to provide and install their
    own port driver code and remove it before returning to MS-DOS. The
    second sample program package in this article illustrates this
    approach. Although the major part of the package is written in
    Microsoft C, three assembly-language modules are required to provide
    the hardware interrupt service routines, the exception handler, and
    faster video display. They are discussed first.

The hardware ISR module

    The first module is a handler to service UART interrupts. Code for
    this handler, including routines to install it at entry and remove it
    on exit, appears in CH1.ASM, shown in Figure 6-5.

    ──────────────────────────────────────────────────────────────────────

    Figure 6-5. CH1.ASM

    ──────────────────────────────────────────────────────────────────────

    The routines in CH1 are set up to work only with port COM2; to use
    them with COM1, the three symbolic constants BPORT (base address),
    GETIV, and PUTIV must be changed to match the COM1 values. Also, as
    presented, this code is for use with the Microsoft C small memory
    model only; for use with other memory models, the C compiler manuals
    should be consulted for making the necessary changes. See also
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS:
    Structure of an Application Program.

    The parts of CH1 are listed in Table 6-11, as they occur in the
    listing. The leading underscore that is part of the name for each of
    the six functions is supplied by the C compiler; within the C program
    that calls the function, the underscore is omitted.


    Table 6-11. CH1 Module Functions.

╓┌────────────────┌──────────────┌───────────────────────────────────────────╖
    Lines       Name           Description
    ──────────────────────────────────────────────────────────────────
    1-26                     Administrative details.

    27-46                     Data areas.

    48-84      _set_mdm       Initializes UART as specified by parameter
                                passed from C.

    86-114     _wrtmdm        Outputs character to UART.

    87         _Send_Byte     Entry point for use if flow control is
                                added to system.

    116-140     _rdmdm         Gets character from buffer where ISR put
                                it, or signals that no character available.

    142-155     w_tmr          Wait timer; internal routine used to
                                prevent infinite wait in case of problems.

    157-182     rts_m          Hardware ISR; installed by _i_m and removed
                                by _u_m.

    184-240     _i_m           Installs ISR, saving old interrupt vector.

    242-265     _u_m           Uninstalls ISR, restoring saved interrupt
                                vector.


    For simplest operation, the ISR used in this example (unlike the
    device driver) services only the received-data interrupt; the other
    three types of IRQ are disabled at the UART. Each time a byte is
    received by the UART, the ISR puts it into the buffer. The _rdmdm
    code, when called by the C program, gets a byte from the buffer if one
    is available. If not, _rdmdm returns the C EOF code (-1) to indicate
    that no byte can be obtained.

    To send a byte, the C program can call either _Send_Byte or _wrtmdm;
    in the package as shown, these are alternative names for the same
    routine. In the more complex program from which this package was
    adapted, _Send_Byte is called when flow control is desired and the
    flow-control routine calls _wrtmdm. To implement flow control, line 87
    should be deleted from CH1.ASM and a control function named
    Send_Byte() should be added to the main C program. Flow-control tests
    must occur in Send_Byte(); _wrtmdm performs the actual port
    interfacing.

    To set the modem baud rate, word length, and parity, _set_mdm is
    called from the C program, with a setup parameter passed as an
    argument. The format of this parameter is shown in Table 6-12 and is
    identical to the IBM BIOS Interrupt 14H Function 00H (Initialization).


    Table 6-12. set_mdm() Parameter Coding.

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Binary           Meaning
    ──────────────────────────────────────────────────────────────────
    000xxxxx         Set to 110 bps
    001xxxxx         Set to 150 bps
    010xxxxx         Set to 300 bps
    011xxxxx         Set to 600 bps
    100xxxxx         Set to 1200 bps
    101xxxxx         Set to 2400 bps
    110xxxxx         Set to 4800 bps
    111xxxxx         Set to 9600 bps
    xxxx0xxx         No parity
    xxx01xxx         ODD Parity
    xxx11xxx         EVEN Parity
    xxxxx0xx         1 stop bit
    xxxxx1xx         2 stop bits (1.5 if WL = 5)
    xxxxxx00         Word length = 5
    xxxxxx01         Word length = 6
    xxxxxx10         Word length = 7
    xxxxxx11         Word length = 8


    The CH1 code provides a 512-byte ring buffer for incoming data; the
    buffer size should be adequate for reception at speeds up to 2400 bps
    without loss of data during scrolling.

The exception-handler module

    For the ISR handler of CH1 to be usable, an exception handler is
    needed to prevent return of control to MS-DOS before _u_m restores the
    ISR vector to its original value. If a program using this code returns
    to MS-DOS without calling _u_m, the system is virtually certain to
    crash when line noise causes a received-data interrupt and the ISR
    code is no longer in memory.

    A replacement exception handler (CH1A.ASM), including routines for
    installation, access, and removal, is shown in Figure 6-6. Like the
    ISR, this module is designed to work with Microsoft C (again, the
    small memory model only).

    Note: This module does not provide for fatal disk errors; if one
    occurs, immediate restarting is necessary. See PROGRAMMING IN THE MS-
    DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Exception Handlers.

    ──────────────────────────────────────────────────────────────────────

    Figure 6-6. CH1A.ASM.

    ──────────────────────────────────────────────────────────────────────

    The three functions in CH1A are _set_int, which saves the old vector
    value for Interrupt 1BH (ROM BIOS Control-Break) and then resets both
    that vector and the one for Interrupt 23H (Control-C Handler Address)
    to internal ISR code; _rst_int, which restores the original value for
    the Interrupt 1BH vector; and _broke, which returns the present value
    of an internal flag (and always clears the flag, just in case it had
    been set). The internal flag is set to a nonzero value in response to
    either of the revectored interrupts and is tested from the main C
    program via the _broke function.

The video display module

    The final assembly-language module (CH2.ASM) used by the second
    package is shown in Figure 6-7. This module provides convenient screen
    clearing and cursor positioning via direct calls to the IBM BIOS, but
    this can be eliminated with minor rewriting of the routines that call
    its functions. In the original, more complex program (DT115.EXE,
    available from DL6 in the CLMFORUM of CompuServe) from which CTERM was
    derived, this module provided windowing capability in addition to
    improved display speed.

    ──────────────────────────────────────────────────────────────────────

    Figure 6-7. CH2.ASM.

    ──────────────────────────────────────────────────────────────────────

The sample smarter terminal emulator: CTERM.C

    Given the interrupt handler (CH1), exception handler (CH1A), and video
    handler (CH2), a simple terminal emulation program (CTERM.C) can be
    presented. The major functions of the program are written in Microsoft
    C; the listing is shown in Figure 6-8.

    ──────────────────────────────────────────────────────────────────────

    Figure 6-8. CTERM.C.

    ──────────────────────────────────────────────────────────────────────


    CTERM features file-capture capabilities, a simple yet effective
    script language, and a number of stub (that is, incompletely
    implemented) actions, such as emulation of the VT52 and VT100 series
    terminals, indicating various directions in which it can be developed.

    The names of a script file and a capture file can be passed to CTERM
    in the command line. If no filename extensions are included, the
    default for the script file is .SCR and that for the capture file is
    .CAP. If extensions are given, they override the default values. The
    capture feature can be invoked only if a filename is supplied in the
    command line, but a script file can be called at any time via the Esc
    command sequence, and one script file can call for another with the
    same feature.

    The functions included in CTERM.C are listed and summarized in Table
    6-13.


    Table 6-13. CTERM.C Functions.

╓┌─────────────────────┌──────────────────────┌──────────────────────────────╖
    Lines            Name                   Description
    ──────────────────────────────────────────────────────────────────
    1-5                                     Program documentation.

    7-11                                    Include files.

    12-20                                   Definitions.

    22-43                                   Global data areas.

    45                                      External prototype
                                            declaration.

    47-49            Wants_To_Abort()       Checks for Ctrl-Break or Ctrl-
                                            C being pressed.

    52-165           main()                 Main program loop; includes
                                            modem engine and sequential
                                            state machine to decode
                                            remote commands.

    167-297          docmd()                Gets, interprets, and performs
                                            local (console or script)
                                            command.

    299-304          kbd_wait()             Waits for input from console
                                            or script file.

    306-334          kb_file()              Gets keystroke from console or
                                            script; returns EOF if no
                                            character available.

    336-362          esc()                  Translates script escape
                                            sequence.

    364-370          getfil()               Gets name of script file and
                                            opens the file.

    372-382          getnam()               Gets string from console or
                                            script into designated
                                            buffer.

    384-393          addext()               Checks buffer for extension;
                                            adds one if none given.

    395-398          put_cap()              Writes character to capture
                                            file if capture in effect.

    400-406          cap_flush()            Closes capture file and
                                            terminates capture mode if
                                            capture in effect.

    408-411                                 Timer data locations.

    413-425          getmr()                Returns time since midnight,
                                            in milliseconds.

    427-432          Delay()                Sleeps n milliseconds.

    434-436          Start_Timer()          Sets timer for n seconds.

    438-440          Timer_Expired()        Checks timer versus clock.

    442-445          Set_Vid()              Initializes video data.

    447-452          locate()               Positions cursor on display.

    454-456          deol()                 Deletes to end of line.

    458-468          deos()                 Deletes to end of screen.

    470-472          cls()                  Clears screen.

    474-478          cursor()               Turns cursor on or off.

    480-485          revvid()               Toggles inverse/normal video
                                            display attributes.

    487-492          putchx()               Writes char to display using
                                            putch() (Microsoft C
                                            library).

    494-500          Read_Keyboard()        Gets keystroke from keyboard.

    502-504                                 Modem data areas.

    506-512          Init_Comm()            Installs ISR and so forth and
                                            initializes modem.

    514-515                                 Baud-rate definitions.

    517-529          Set_Baud()             Changes bps rate of UART.

    531-537                                 Parity, WL definitions.

    539-557          Set_Parity()           Establishes UART parity mode.

    559-562          Write_Modem()          Sends character to UART.

    564-566          Read_Modem()           Gets character from ISR's
                                            buffer.

    568-570          Term_Comm()            Uninstalls ISR and so forth
                                            and restores original
                                            vectors.


    For communication with the console, CTERM uses the special Microsoft C
    library functions defined by CONIO.H, augmented with the functions in
    the CH2.ASM handler. Much of the code may require editing if used with
    other compilers. CTERM also uses the function prototype file CTERM.H,
    listed in Figure 6-9, to optimize function calling within the program.

    ──────────────────────────────────────────────────────────────────────

    Figure 6-9. CTERM.H.

    ──────────────────────────────────────────────────────────────────────

    Program execution begins at the entry to main(), line 52. CTERM first
    checks (lines 56 through 59) whether any filenames were passed in the
    command line; if they were, CTERM opens the corresponding files. Next,
    the program installs the exception handler (line 60), initializes the
    video handler (line 61), clears the display (line 62), and announces
    its presence (lines 63 and 64). The serial driver is installed and
    initialized to 1200 bps and no parity (lines 65 through 67), and the
    program enters its main modem-engine loop (lines 68 through 159).

    This loop is functionally the same as that used in ENGINE, but it has
    been extended to detect an Esc from the keyboard as signalling the
    start of a local command sequence (lines 70 through 73) and to include
    a state-machine technique (lines 80 through 153) to recognize incoming
    escape sequences, such as the VT52 or VT100 codes. To specify a local
    command from the keyboard, press the Escape (Esc) key, then the first
    letter of the local command desired. After the local command has been
    selected, press any key (such as Enter or the spacebar) to continue.
    To get a listing of all the commands available, press Esc-H.

    The kb_file() routine of CTERM (called in the main loop at line 69)
    can get its input from either a script file or the keyboard. If a
    script file is open (lines 308 through 330), it is used until EOF is
    reached or until the operator presses Ctrl-C to stop script-file
    input. Otherwise, input is taken from the keyboard (lines 331 and
    332). If a script file is in use, its input is echoed to the display
    (lines 325 through 329) if the V command has been given.

    To permit the Esc character itself to be placed in script files, the
    backslash (\) character serves as a secondary escape signal. When a
    backslash is detected (lines 323 and 324) in the input stream, the
    next character input is translated according to the following rules:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Character        Interpretation
    ──────────────────────────────────────────────────────────────────
    E or e           Translates to Esc.
    N or n           Translates to Linefeed.
    R or r           Translates to Enter (CR).
    T or t           Translates to Tab.
    ^                Causes the next character input to be converted into
                    a control character.

    Any other character, including another \, is not translated at all.

    When the Esc character is detected from either the console or a script
    file, the docmd() function (lines 167 through 297) is called to prompt
    for and decode the next input character as a command and to perform
    appropriate actions. Valid command characters, and the actions they
    invoke, are as follows:

╓┌────────────────────────────┌──────────────────────────────────────────────╖
    Command Character       Action
    ──────────────────────────────────────────────────────────────────
    D                       Delay 0-9 seconds, then proceed. Must be
                            followed by a decimal digit that indicates
                            how long to delay.
    E                       Set EVEN parity.
    F                       Set (fast) 1200 baud.
    H                       Display list of valid commands.
    N                       Set no parity.
    O                       Set ODD parity.
    Q                       Quit; return to MS-DOS command prompt.
    R                       Reset modem.
    S                       Set (slow) 300 baud.
    U                       Use script file (CTERM prompts for filename).
    V                       Verify file input. Echoes each script-file
                            byte.
    W                       Wait for character; the next input character
                            is the one that must be matched.

    Any other character input after an Esc and the resulting Command
    prompt generates the message Don't know X (where X stands for the
    actual input character) followed by the prompt Use `H' command for
    Help.

    If input is taken from a script and the V flag is off, docmd()
    performs its task quietly, with no output to the screen. If input is
    received from the console, however, the command letter, followed by a
    descriptive phrase, is echoed to the screen. Input, detection, and
    execution of the local commands are accomplished much as in CDVUTL, by
    way of a large switch() statement (lines 178 through 290).

    Although the listed commands are only a subset of the features
    available in CDVUTL for the device-driver program, they are more than
    adequate for creating useful scripts. The predecessor of CTERM
    (DT115.EXE), which included the CompuServe B-Protocol file-transfer
    capability but had no additional commands, has been in use since early
    1986 to handle automatic uploading and downloading of files from the
    CompuServe Information Service by means of script files. In
    conjunction with an auto-dialing modem, DT115.EXE handles the entire
    transaction, from login through logout, without human intervention.

    All the bits and pieces of CTERM are put together by assembling the
    three handlers with MASM, compiling CTERM with Microsoft C, and
    linking all four object modules into an executable file. Figure 6-10
    shows the complete sequence and also the three ways of using the
    finished program.


    Compiling:

    MASM CH1;
    MASM CH1A;
    MASM CH2;
    MSC CTERM;

    Linking:

    LINK CTERM+CH1+CH1A+CH2;

    Use:
    (no files)

    CTERM

    or
    (script only)

    CTERMscriptfile

    or

    CTERMscriptfile capturefile

    Figure 6-10. Putting CTERM together and using it.

                                                Jim Kyle
                                                Chip Rabinowitz



Article 7:  File and Record Management


    The core of most application programs is the reading, processing, and
    writing of data stored on magnetic disks. This data is organized into
    files, which are identified by name; the files, in turn, can be
    organized by grouping them into directories. Operating systems provide
    application programs with services that allow them to manipulate these
    files and directories without regard to the hardware characteristics
    of the disk device. Thus, applications can concern themselves solely
    with the form and content of the data, leaving the details of the
    data's location on the disk and of its retrieval to the operating
    system.

    The disk storage services provided by an operating system can be
    categorized into file functions and record functions. The file
    functions operate on entire files as named entities, whereas the
    record functions provide access to the data contained within files.
    (In some systems, an additional class of directory functions allows
    applications to deal with collections of files as well.) This article
    discusses the MS-DOS function calls that allow an application program
    to create, open, close, rename, and delete disk files; read data from
    and write data to disk files; and inspect or change the information
    (such as attributes and date and time stamps) associated with disk
    filenames in disk directories. See also PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: STRUCTURE OF MS-DOS: MS-DOS Storage Devices; PROGRAMMING
    FOR MS-DOS: Disk Directories and Volume Labels.


Historical Perspective

    Current versions of MS-DOS provide two overlapping sets of file and
    record management services to support application programs: the handle
    functions and the file control block (FCB) functions. Both sets are
    available through Interrupt 21H (Table 7-1). See SYSTEM CALLS:
    INTERRUPT 21H. The reasons for this surprising duplication are
    strictly historical.

    The earliest versions of MS-DOS used FCBs for all file and record
    access because CP/M, which was the dominant operating system on 8-bit
    microcomputers, used FCBs. Microsoft chose to maintain compatibility
    with CP/M to aid programmers in converting the many existing CP/M
    application programs to the 16-bit MS-DOS environment; consequently,
    MS-DOS versions 1.x included a set of FCB functions that were a
    functional superset of those present in CP/M. As personal computers
    evolved, however, the FCB access method did not lend itself well to
    the demands of larger, faster disk drives.

    Accordingly, MS-DOS version 2.0 introduced the handle functions to
    provide a file and record access method similar to that found in
    UNIX/XENIX. These functions are easier to use and more flexible than
    their FCB counterparts and fully support a hierarchical (tree-like)
    directory structure. The handle functions also allow character
    devices, such as the console or printer, to be treated for some
    purposes as though they were files. MS-DOS version 3.0 introduced
    additional handle functions, enhanced some of the existing handle
    functions for use in network environments, and provided improved error
    reporting for all functions.

    The handle functions, which offer far more capability and performance
    than the FCB functions, should be used for all new applications.
    Therefore, they are discussed first in this article.


    Table 7-1. Interrupt 21H Function Calls for File and Record
                Management.

╓┌───────────────────────────────────────┌────────────┌──────────────────────╖
                                        Handle       FCB
    Operation                          Function     Function
    ──────────────────────────────────────────────────────────────────
    Create file.                       3CH          16H
    Create new file.                   5BH
    Create temporary file.             5AH
    Open file.                         3DH          0FH
    Close file.                        3EH          10H
    Delete file.                       41H          13H
    Rename file.                       56H          17H
    Perform sequential read.           3FH          14H
    Perform sequential write.          40H          15H
    Perform random record read.        3FH          21H
    Perform random record write.       40H          22H
    Perform random block read.                      27H
    Perform random block write.                     28H
    Set disk transfer area address.                 1AH
    Get disk transfer area address.                 2FH
    Parse filename.                                 29H
    Position read/write pointer.       42H
    Set random record number.                       24H
    Get file size.                     42H          23H
    Get/Set file attributes.           43H
    Get/Set date and time stamp.       57H
    Duplicate file handle.             45H
    Redirect file handle.              46H


Using the Handle Functions

    The initial link between an application program and the data stored on
    disk is the name of a disk file in the form

    drive:path\filename.ext

    where drive designates the disk on which the file resides, path
    specifies the directory on that disk in which the file is located, and
    filename.ext identifies the file itself. If drive and/or path is
    omitted, MS-DOS assumes the default disk drive and current directory.
    Examples of acceptable pathnames include

    C:\PAYROLL\TAXES.DAT
    LETTERS\MEMO.TXT
    BUDGET.DAT

    Pathnames can be hard-coded into a program as part of its data. More
    commonly, however, they are entered by the user at the keyboard,
    either as a command-line parameter or in response to a prompt from the
    program. If the pathname is provided as a commandline parameter, the
    application program must extract it from the other information in the
    command line. Therefore, to allow a program to distinguish between
    pathnames and other parameters when the two are combined in a command
    line, the other parameters, such as switches, usually begin with a
    slash (/) or dash (-) character.

    All handle functions that use a pathname require the name to be in the
    form of an ASCIIZ string--that is, the name must be terminated by a
    null (zero) byte. If the pathname is hard-coded into a program, the
    null byte must be part of the ASCIIZ string. If the pathname is
    obtained from keyboard input or from a command-line parameter, the
    null byte must be appended by the program. See Opening an Existing
    File, below.

    To use a disk file, a program opens or creates the file by calling the
    appropriate MS-DOS function with the ASCIIZ pathname. MS-DOS checks
    the pathname for invalid characters and, if the open or create
    operation is successful, returns a 16-bit handle, or identification
    code, for the file. The program uses this handle for subsequent
    operations on the file, such as record reads and writes.

    The total number of handles for simultaneously open files is limited
    in two ways. First, the per-process limit is 20 file handles. The
    process's first five handles are always assigned to  the standard
    devices, which default to the CON, AUX, and PRN character devices:

╓┌──────────────┌───────────────────┌────────────────────────────────────────╖
    Handle    Service             Default
    ──────────────────────────────────────────────────────────────────
    0         Standard input      Keyboard (CON)
    1         Standard output     Video display (CON)
    2         Standard error      Video display (CON)
    3         Standard auxiliary  First communications port (AUX)
    4         Standard list       First parallel printer port (PRN)

    Ordinarily, then, a process has only 15 handles left from its initial
    allotment of 20; however, when necessary, the 5 standard device
    handles can be redirected to other files and devices or closed and
    reused.

    In addition to the per-process limit of 20 file handles, there is a
    system-wide limit. MS-DOS maintains an internal table that keeps track
    of all the files and devices opened with file handles for all
    currently active processes. The table contains such information as the
    current file pointer for read and write operations and the time and
    date of the last write to the file. The size of this table, which is
    set when MS-DOS is initially loaded into memory, determines the
    system-wide limit on how many files and devices can be open
    simultaneously. The default limit is 8 files and devices; thus, this
    system-wide limit usually overrides the per-process limit.

    To increase the size of MS-DOS's internal handle table, the statement
    FILES=nnn can be included in the CONFIG.SYS file. (CONFIG.SYS settings
    take effect the next time the system is turned on or restarted.) The
    maximum value for FILES is 99 in MS-DOS versions 2.x and 255 in
    versions 3.x. See USER COMMANDS: CONFIG.SYS: FILES.

Error handling and the handle functions

    When a handle-based file function succeeds, MS-DOS returns to the
    calling program with the carry flag clear. If a handle function fails,
    MS-DOS sets the carry flag and returns an error code in the AX
    register. The program should check the carry flag after each operation
    and take whatever action is appropriate when an error is encountered.
    Table 7-2 lists the most frequently encountered error codes for file
    and record I/O (exclusive of network operations).


    Table 7-2. Frequently Encountered Error Diagnostics for File and
                Record Management.

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Code        Error
    ──────────────────────────────────────────────────────────────────
    02          File not found
    03          Path not found
    04          Too many open files (no handles left)
    05          Access denied
    06          Invalid handle
    11          Invalid format
    12          Invalid access code
    13          Invalid data
    15          Invalid disk drive letter
    17          Not same device
    18          No more files


    The error codes used by MS-DOS in versions 3.0 and later are a
    superset of the MS-DOS version 2.0 error codes. See APPENDIX B:
    CRITICAL ERROR CODES; APPENDIX C: EXTENDED ERROR CODES. Most MS-DOS
    version 3 error diagnostics relate to network operations, which
    provide the program with a greater chance for error than does a
    single-user system.

    Programs that are to run in a network environment need to anticipate
    network problems. For example, the server can go down while the
    program is using shared files.

    Under MS-DOS versions 3.x, a program can also use Interrupt 21H
    Function 59H (Get Extended Error Information) to obtain more details
    about the cause of an error after a failed handle function. The
    information returned by Function 59H includes the type of device that
    caused the error and a recommended recovery action.

    Warning: Many file and record I/O operations discussed in this article
    can result in or be affected by a hardware (critical) error. Such
    errors can be intercepted by the program if it contains a custom
    critical error exception handler (Interrupt 24H).See PROGRAMMING IN
    THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Exception Handlers.

Creating a file

    MS-DOS provides three Interrupt 21H handle functions for creating
    files:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Function         Name
    ──────────────────────────────────────────────────────────────────
    3CH              Create File with Handle (versions 2.0 and later)
    5AH              Create Temporary File (versions 3.0 and later)
    5BH              Create New File (versions 3.0 and later)

    Each function is called with the segment and offset of an ASCIIZ
    pathname in the DS:DX registers and the attribute to be assigned to
    the new file in the CX register. The possible attribute values are

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Code        Attribute
    ──────────────────────────────────────────────────────────────────
    00H         Normal file
    01H         Read-only file
    02H         Hidden file
    04H         System file

    Files with more than one attribute can be created by combining the
    values listed above. For example, to create a file that has both the
    read-only and system attributes, the value 05H is placed in the CX
    register.

    If the file is successfully created, MS-DOS returns a file handle in
    AX that must be used for subsequent access to the new file and sets
    the file read/write pointer to the beginning of the file; if the file
    is not created, MS-DOS sets the carry flag (CF) and returns an error
    code in AX.

    Function 3CH is the only file-creation function available under MS-DOS
    versions 2.x. It must be used with caution, however, because if a file
    with the specified name already exists, Function 3CH will open it and
    truncate it to zero length, eradicating the previous contents of the
    file. This complication can be avoided by testing for the previous
    existence of the file with an open operation before issuing the create
    call.

    Under MS-DOS versions 3.0 and later, Function 5BH is the preferred
    function in most cases because it will fail if a file with the same
    name already exists. In networking environments, this function can be
    used to implement semaphores, allowing the synchronization of programs
    running in different network nodes.

    Function 5AH is used to create a temporary work file that is
    guaranteed to have a unique name. This capability is important in
    networking environments, where several copies of the same program,
    running in different nodes, may be accessing the same logical disk
    volume on a server. The function is passed the address of a buffer
    that can contain a drive and/or path specifying the location for the
    created file. MS-DOS generates a name for the created file that is a
    sequence of alphanumeric characters derived from the current time and
    returns the entire ASCIIZ pathname to the program in the same buffer,
    along with the file's handle in AX. The program must save the filename
    so that it can delete the file later, if necessary; the file created
    with Function 5AH is not destroyed when the program exits.

    Example: Create a file named MEMO.TXT in the \LETTERS directory on
    drive C using Function 3CH. Any existing file with the same name is
    truncated to zero length and opened.

    fname   db      'C:\LETTERS\MEMO.TXT',0
    fhandle dw      ?
            .
            .
            .
            mov     dx,seg fname    ; DS:DX = address of
            mov     ds,dx           ; pathname for file
            mov     dx,offset fname
            xor     cx,cx           ; CX = normal attribute
            mov     ah,3ch          ; Function 3CH = create
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if create failed
            mov     fhandle,ax      ; else save file handle
            .
            .
            .

    Example: Create a temporary file using Function 5AH and place it in
    the \TEMP directory on drive C. MS-DOS appends the filename it
    generates to the original path in the buffer named fname. The
    resulting file specification can be used later to delete the file.

    fname   db      'C:\TEMP\'      ; generated ASCIIZ filename
            db      13 dup (0)      ; is appended by MS-DOS

    fhandle dw      ?
            .
            .
            .
            mov     dx,seg fname    ; DS:DX = address of
            mov     ds,dx           ; path for temporary file
            mov     dx,offset fname
            xor     cx,cx           ; CX = normal attribute
            mov     ah,5ah          ; Function 5AH = create
                                    ; temporary file
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if create failed
            mov     fhandle,ax      ; else save file handle
            .
            .
            .

Opening an existing file

    Function 3DH (Open File with Handle) opens an existing normal, system,
    or hidden file in the current or specified directory. When calling
    Function 3DH, the program supplies a pointer to the ASCIIZ pathname in
    the DS:DX registers and a 1-byte access code in the AL register. This
    access code includes the read/write permissions, the file-sharing
    mode, and an inheritance flag. The bits of the access code are
    assigned as follows:

╓┌──────────────┌────────────────────────────────────────────────────────────╖
    Bit(s)    Description
    ──────────────────────────────────────────────────────────────────
    0-2       Read/write permissions (versions 2.0 and later)
    3         Reserved
    4-6       File-sharing mode (versions 3.0 and later)
    7         Inheritance flag (versions 3.0 and later)

    The read/write permissions field of the access code specifies how the
    file will be used and can take the following values:

╓┌──────────────┌────────────────────────────────────────────────────────────╖
    Bits 0-2  Description
    ──────────────────────────────────────────────────────────────────
    000       Read permission desired
    001       Write permission desired
    010       Read and write permission desired

    For the open to succeed, the permissions field must be compatible with
    the file's attribute byte in the disk directory. For example, if the
    program attempts to open an existing file that has the read-only
    attribute when the permissions field of the access code byte is set to
    write or read/write, the open function will fail and an error code
    will be returned in AX.

    The sharing-mode field of the access code byte is important in a
    networking environment. It determines whether other programs will also
    be allowed to open the file and, if so, what operations they will be
    allowed to perform. Following are the possible values of the file-
    sharing mode field:

╓┌──────────────┌────────────────────────────────────────────────────────────╖
    Bits 4-6  Description
    ──────────────────────────────────────────────────────────────────
    000       Compatibility mode. Other programs can open the file and
            perform read or write operations as long as no process
            specifies any sharing mode other than compatibility mode.

    001       Deny all. Other programs cannot open the file.

    010       Deny write. Other programs cannot open the file in
            compatibility mode or with write permission.

    011       Deny read. Other programs cannot open the file in
            compatibility mode or with read permission.

    100       Deny none. Other programs can open the file and perform both
            read and write operations but cannot open the file in
            compatibility mode.

    When file-sharing support is active (that is, SHARE.EXE has previously
    been loaded), the result of any open operation depends on both the
    contents of the permissions and file-sharing fields of the access code
    byte and the permissions and file-sharing requested by other processes
    that have already successfully opened the file.

    The inheritance bit of the access code byte controls whether a child
    process will inherit that file handle. If the inheritance bit is
    cleared, the child can use the inherited handle to access the file
    without performing its own open operation. Subsequent operations
    performed by the child process on inherited file handles also affect
    the file pointer associated with the parent's file handle. If the
    inheritance bit is set, the child process does not inherit the handle.

    If the file is opened successfully, MS-DOS returns its handle in AX
    and sets the file read/write pointer to the beginning of the file; if
    the file is not opened, MS-DOS sets the carry flag and returns an
    error code in AX.

    Example: Copy the first parameter from the program's command tail in
    the program segment prefix (PSP) into the array fname and append a
    null character to form an ASCIIZ filename. Attempt to open the file
    with compatibility sharing mode and read/write access. If the file
    does not already exist, create it and assign it a normal attribute.

    cmdtail equ     80h             ; PSP offset of command tail
    fname   db      64 dup (?)
    fhandle dw      ?

            .
            .
            .
                                    ; assume that DS already
                                    ; contains segment of PSP
                                    ; prepare to copy filename...
            mov     si,cmdtail      ; DS:SI = command tail
            mov     di,seg fname    ; ES:DI = buffer to receive
            mov     es,di           ; filename from command tail
            mov     di,offset fname
            cld                     ; safety first!

            lodsb                   ; check length of command tail
            or      al,al
            jz      error           ; jump, command tail empty

    label1:                         ; scan off leading spaces
            lodsb                   ; get next character
            cmp     al,20h          ; is it a space?
            jz      label1          ; yes, skip it

    label2:
            cmp     al,0dh          ; look for terminator
            jz      label3          ; quit if return found
            cmp     al,20h
            jz      label3          ; quit if space found
            stosb                   ; else copy this character
            lodsb                   ; get next character
            jmp     label2

    label3:
            xor     al,al           ; store final NULL to
            stosb                   ; create ASCIIZ string

                                    ; now open the file...
            mov     dx,seg fname    ; DS:DX = address of
            mov     ds,dx           ; pathname for file
            mov     dx,offset fname
            mov     ax,3d02h        ; Function 3DH = open r/w
            int     21h             ; transfer to MS-DOS
            jnc     label4          ; jump if file found

            cmp     ax,2            ; error 2 = file not found
            jnz     error           ; jump if other error
                                    ; else make the file...
            xor     cx,cx           ; CX = normal attribute
            mov     ah,3ch          ; Function 3CH = create
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if create failed

    label4:
            mov     fhandle,ax      ; save handle for file
            .
            .
            .

Closing a file

    Function 3EH (Close File) closes a file created or opened with a file
    handle function. The program must place the handle of the file to be
    closed in BX. If a write operation was performed on the file, MS-DOS
    updates the date, time, and size in the file's directory entry.

    Closing the file also flushes the internal MS-DOS buffers associated
    with the file to disk and causes the disk's file allocation table
    (FAT) to be updated if necessary.

    Good programming practice dictates that a program close files as soon
    as it finishes using them. This practice is particularly important
    when the file size has been changed, to ensure that data will not be
    lost if the system crashes or is turned off unexpectedly by the user.
    A method of updating the FAT without closing the file is outlined
    below under Duplicating and Redirecting Handles.

Reading and writing with handles

    Function 3FH (Read File or Device) enables a program to read data from
    a file or device that has been opened with a handle. Before calling
    Function 3FH, the program must set the DS:DX registers to point to the
    beginning of a data buffer large enough to hold the requested
    transfer, put the file handle in BX, and put the number of bytes to be
    read in CX. The length requested can be a maximum of 65535 bytes. The
    program requesting the read operation is responsible for providing the
    data buffer.

    If the read operation succeeds, the data is read, beginning at the
    current position of the file read/write pointer, to the specified
    location in memory. MS-DOS then increments its internal read/write
    pointer for the file by the length of the data transferred and returns
    the length to the calling program in AX with the carry flag cleared.
    The only indication that the end of the file has been reached is that
    the length returned is less than the length requested. In contrast,
    when Function 3FH is used to read from a character device that is not
    in raw mode, the read will terminate at the requested length or at the
    receipt of a carriage return character, whichever comes first. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS:
    Character Device Input and Output. If the read operation fails, MS-DOS
    returns with the carry flag set and an error code in AX.

    Function 40H (Write File or Device) writes from a buffer to a file (or
    device) using a handle previously obtained from an open or create
    operation. Before calling Function 40H, the program must set DS:DX to
    point to the beginning of the buffer containing the source data, put
    the file handle in BX, and put the number of bytes to write in CX. The
    number of bytes to write can be a maximum of 65535.

    If the write operation is successful, MS-DOS puts the number of bytes
    written in AX and increments the read/write pointer by this value; if
    the write operation fails, MS-DOS sets the carry flag and returns an
    error code in AX.

    Records smaller than one sector (512 bytes) are not written directly
    to disk. Instead, MS-DOS stores the record in an internal buffer and
    writes it to disk when the internal buffer is full, when the file is
    closed, or when a call to Interrupt 21H Function 0DH (Disk Reset) is
    issued.

    Note: If the destination of the write operation is a disk file and the
    disk is full, the only indication to the calling program is that the
    length returned in AX is not the same as the length requested in CX.
    Disk full is not returned as an error with the carry flag set.

    A special use of the Write function is to truncate or extend a file.
    If Function 40H is called with a record length of zero in CX, the file
    size will be adjusted to the current location of the file read/write
    pointer.

    Example: Open the file MYFILE.DAT, create the file MYFILE.BAK, copy
    the contents of the .DAT file into the .BAK file using 512-byte reads
    and writes, and then close both files.

    file1   db      'MYFILE.DAT',0
    file2   db      'MYFILE.BAK',0

    handle1 dw      ?               ; handle for MYFILE.DAT
    handle2 dw      ?               ; handle for MYFILE.BAK

    buff    db      512 dup (?)     ; buffer for file I/O
            .
            .
            .
                                    ; open MYFILE.DAT...
            mov     dx,seg file1    ; DS:DX = address of filename
            mov     ds,dx
            mov     dx,offset file1
            mov     ax,3d00h        ; Function 3DH = open (read-only)
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if open failed
            mov     handle1,ax      ; save handle for file

                                    ; create MYFILE.BAK...
            mov     dx,offset file2 ; DS:DX = address of filename
            mov     cx,0            ; CX = normal attribute
            mov     ah,3ch          ; Function 3CH = create
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if create failed
            mov     handle2,ax      ; save handle for file

    loop:                           ; read MYFILE.DAT
            mov     dx,offset buff  ; DS:DX = buffer address
            mov     cx,512          ; CX = length to read
            mov     bx,handle1      ; BX = handle for MYFILE.DAT
            mov     ah,3fh          ; Function 3FH = read
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if read failed
            or      ax,ax           ; were any bytes read?
            jz      done            ; no, end of file reached

                                    ; write MYFILE.BAK
            mov     dx,offset buff  ; DS:DX = buffer address
            mov     cx,ax           ; CX = length to write
            mov     bx,handle2      ; BX = handle for MYFILE.BAK
            mov     ah,40h          ; Function 40H = write
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if write failed
            cmp     ax,cx           ; was write complete?
            jne     error           ; jump if disk full
            jmp     loop            ; continue to end of file
    done:                           ; now close files...
            mov     bx,handle1      ; handle for MYFILE.DAT
            mov     ah,3eh          ; Function 3EH = close file
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if close failed

            mov     bx,handle2      ; handle for MYFILE.BAK
            mov     ah,3eh          ; Function 3EH = close file
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if close failed

            .
            .
            .

Positioning the read/write pointer

    Function 42H (Move File Pointer) sets the position of the read/write
    pointer associated with a given handle. The function is called with a
    signed 32-bit offset in the CX and DX registers (the most significant
    half in CX), the file handle in BX, and the positioning mode in AL:

╓┌──────────────┌────────────────────────────────────────────────────────────╖
    Mode      Significance
    ──────────────────────────────────────────────────────────────────
    00        Supplied offset is relative to beginning of file.
    01        Supplied offset is relative to current position of
            read/write pointer.
    02        Supplied offset is relative to end of file.

    If Function 42H succeeds, MS-DOS returns the resulting absolute offset
    (in bytes) of the file pointer relative to the beginning of the file
    in the DX and AX registers, with the most significant half in DX; if
    the function fails, MS-DOS sets the carry flag and returns an error
    code in AX.

    Thus, a program can obtain the size of a file by calling Function 42H
    with an offset of zero and a positioning mode of 2. The function
    returns a value in DX:AX that represents the offset of the end-of-file
    position relative to the beginning of the file.

    Example: Assume that the file MYFILE.DAT was previously opened and its
    handle is saved in the variable fhandle. Position the file pointer
    32768 bytes from the beginning of the file and then read 512 bytes of
    data starting at that file position.

    fhandle dw      ?               ; handle from previous open
    buff    db      512 dup (?)     ; buffer for data from file

            .
            .
            .
                                    ; position the file pointer...
            mov     cx,0            ; CX = high part of file offset
            mov     dx,32768        ; DX = low part of file offset
            mov     bx,fhandle      ; BX = handle for file
            mov     al,0            ; AL = positioning mode
            mov     ah,42h          ; Function 42H = position
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if function call failed

                                    ; now read 512 bytes from file
            mov     dx,offset buff  ; DS:DX = address of buffer
            mov     cx,512          ; CX = length of 512 bytes
            mov     bx,fhandle      ; BX = handle for file
            mov     ah,3fh          ; Function 3FH = read
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if read failed
            cmp     ax,512          ; was 512 bytes read?
            jne     error           ; jump if partial rec. or EOF
            .
            .
            .

    Example: Assume that the file MYFILE.DAT was previously opened and its
    handle is saved in the variable fhandle. Find the size of the file in
    bytes by positioning the file pointer to zero bytes relative to the
    end of the file. The returned offset, which is relative to the
    beginning of the file, is the file's size.

    fhandle dw      ?               ; handle from previous open

            .
            .
            .
                                    ; position the file pointer
                                    ; to the end of file...
            mov     cx,0            ; CX = high part of offset
            mov     dx,0            ; DX = low part of offset
            mov     bx,fhandle      ; BX = handle for file
            mov     al,2            ; AL = positioning mode
            mov     ah,42h          ; Function 42H = position
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if function call failed

                                    ; if call succeeded, DX:AX
                                    ; now contains the file size
            .
            .
            .

Other handle operations

    MS-DOS provides other handle-oriented functions to rename (or move) a
    file, delete a file, read or change a file's attributes, read or
    change a file's date and time stamp, and duplicate or redirect a file
    handle. The first three of these are "file-handle-like" because they
    use an ASCIIZ string to specify the file; however, they do not return
    a file handle.

Renaming a file
    Function 56H (Rename File) renames an existing file and/or moves the
    file from one location in the hierarchical file structure to another.
    The file to be renamed cannot be a hidden or system file or a
    subdirectory and must not be currently open by any process; attempting
    to rename an open file can corrupt the disk. MS-DOS renames a file by
    simply changing its directory entry; it moves a file by removing its
    current directory entry and creating a new entry in the target
    directory that refers to the same file. The location of the file's
    actual data on the disk is not changed.

    Both the current and the new filenames must be ASCIIZ strings and can
    include a drive and path specification; wildcard characters (* and ?)
    are not permitted in the filenames. The program calls Function 56H
    with the address of the current pathname in the DS:DX registers and
    the address of the new pathname in ES:DI. If the path elements of the
    two strings are not the same and both paths are valid, the file
    "moves" from the source directory to the target directory. If the
    paths match but the filenames differ, MS-DOS simply modifies the
    directory entry to reflect the new filename.

    If the function succeeds, MS-DOS returns to the calling program with
    the carry flag clear. The function fails if the new filename is
    already in the target directory; in that case, MS-DOS sets the carry
    flag and returns an error code in AX.

    Example: Change the name of the file MYFILE.DAT to MYFILE.OLD. In the
    same operation, move the file from the \WORK directory to the \BACKUP
    directory.

    file1   db      '\WORK\MYFILE.DAT',0
    file2   db      '\BACKUP\MYFILE.OLD',0
            .
            .
            .
            mov     dx,seg file1    ; DS:DX = old filename
            mov     ds,dx
            mov     es,dx
            mov     dx,offset file1
            mov     di,offset file2 ; ES:DI = new filename
            mov     ah,56h          ; Function 56H = rename
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if rename failed
            .
            .
            .

Deleting a file
    Function 41H (Delete File) effectively deletes a file from a disk.
    Before calling the function, a program must set the DS:DX registers to
    point to the ASCIIZ pathname of the file to be deleted. The supplied
    pathname cannot specify a subdirectory or a read-only file, and the
    file must not be currently open by any process.

    If the function is successful, MS-DOS deletes the file by simply
    marking the first byte of its directory entry with a special character
    (0E5H), making the entry subsequently unrecognizable. MS-DOS then
    updates the disk's FAT so that the clusters that previously belonged
    to the file are "free" and returns to the program with the carry flag
    clear. If the delete function fails, MS-DOS sets the carry flag and
    returns an error code in AX.

    The actual contents of the clusters assigned to the file are not
    changed by a delete operation, so for security reasons sensitive
    information should be overwritten with spaces or some other constant
    character before the file is deleted with Function 41H.

    Example: Delete the file MYFILE.DAT, located in the \WORK directory on
    drive C.

    fname   db      'C:\WORK\MYFILE.DAT',0
            .
            .
            .
            mov     dx,seg fname    ; DS:DX = address of filename
            mov     ds,dx
            mov     dx,offset fname
            mov     ah,41h          ; Function 41H = delete
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if delete failed
            .
            .
            .

Getting/setting file attributes
    Function 43H (Get/Set File Attributes) obtains or modifies the
    attributes of an existing file. Before calling Function 43H, the
    program must set the DS:DX registers to point to the ASCIIZ pathname
    for the file. To read the attributes, the program must set AL to zero;
    to set the attributes, it must set AL to 1 and place an attribute code
    in CX. See Creating a File, above.

    If the function is successful, MS-DOS reads or sets the attribute byte
    in the file's directory entry and returns with the carry flag clear
    and the file's attribute in CX. If the function fails, MS-DOS sets the
    carry flag and returns an error code in AX.

    Function 43H cannot be used to set the volume-label bit (bit 3) or the
    subdirectory bit (bit 4) of a file. It also should not be used on a
    file that is currently open by any process.

    Example: Change the attributes of the file MYFILE.DAT in the \BACKUP
    directory on drive C to read-only. This prevents the file from being
    accidentally deleted from the disk.

    fname   db      'C:\BACKUP\MYFILE.DAT',0
            .
            .
            .
            mov     dx,seg fname    ; DS:DX = address of filename
            mov     ds,dx
            mov     dx,offset fname
            mov     cx,1            ; CX = attribute (read-only)
            mov     al,1            ; AL = mode (0 = get, 1 = set)
            mov     ah,43h          ; Function 43H = get/set attr
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if set attrib. failed
            .
            .
            .

Getting/setting file date and time
    Function 57H (Get/Set Date/Time of File) reads or sets the directory
    time and date stamp of an open file. To set the time and date to a
    particular value, the program must call Function 57H with the desired
    time in CX, the desired date in DX, the handle for the file (obtained
    from a previous open or create operation) in BX, and the value 1 in
    AL. To read the time and date, the function is called with AL
    containing 0 and the file handle in BX; the time is returned in the CX
    register and the date is returned in the DX register. As with other
    handle-oriented file functions, if the function succeeds, the carry
    flag is returned cleared; if the function fails, MS-DOS returns the
    carry flag set and an error code in AX.

    The formats used for the file time and date are the same as those used
    in disk directory entries and FCBs. See Structure of the File Control
    Block, below.

    The main uses of Function 57H are to force the time and date entry for
    a file to be updated when the file has not been changed and to
    circumvent MS-DOS's modification of a file date and time when the file
    has been changed. In the latter case, a program can use this function
    with AL = 0 to obtain the file's previous date and time stamp, modify
    the file, and then restore the original file date and time by re-
    calling the function with AL = 1 before closing the file.

Duplicating and redirecting handles
    Ordinarily, the disk FAT and directory are not updated until a file is
    closed, even when the file has been modified. Thus, until the file is
    closed, any new data added to the file can be lost if the system
    crashes or is turned off unexpectedly. The obvious defense against
    such loss is simply to close and reopen the file every time the file
    is changed. However, this is a relatively slow procedure and in a
    network environment can cause the program to lose control of the file
    to another process.

    Use of a second file handle, created by using Function 45H (Duplicate
    File Handle) to duplicate the original handle of the file to be
    updated, can protect data added to a disk file before the file is
    closed. To use Function 45H, the program must put the handle to be
    duplicated in BX. If the operation is successful, MS-DOS clears the
    carry flag and returns the new handle in AX; if the operation fails,
    MS-DOS sets the carry flag and returns an error code in AX.

    If the function succeeds, the duplicate handle can simply be closed in
    the usual manner with Function 3EH. This forces the desired update of
    the disk directory and FAT. The original handle remains open and the
    program can continue to use it for file read and write operations.

    Note: While the second handle is open, moving the read/write pointer
    associated with either handle moves the pointer associated with the
    other.

    Example: Assume that the file MYFILE.DAT was previously opened and the
    handle for that file has been saved in the variable fhandle. Duplicate
    the handle and then close the duplicate to ensure that any data
    recently written to the file is saved on the disk and that the
    directory entry for the file is updated accordingly.

    fhandle dw      ?               ; handle from previous open

            .
            .
            .
                                    ; duplicate the handle...
            mov     bx,fhandle      ; BX = handle for file
            mov     ah,45h          ; Function 45H = dup handle
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if function call failed

                                    ; now close the new handle...
            mov     bx,ax           ; BX = duplicated handle
            mov     ah,3eh          ; Function 3EH = close
            int     21h             ; transfer to MS-DOS
            jc      error           ; jump if close failed
            mov     bx,fhandle      ; replace closed handle with
                                    ; active handle
            .
            .
            .

    Function 45H is sometimes also used in conjunction with Function 46H
    (Force Duplicate File Handle). Function 46H forces a handle to be a
    duplicate for another open handle--in other words, to refer to the
    same file or device at the same file read/write pointer location. The
    handle is then said to be redirected.

    The most common use of Function 46H is to change the meaning of the
    standard input and standard output handles before loading a child
    process with the EXEC function. In this manner, the input for the
    child program can be redirected to come from a file or its output can
    be redirected into a file, without any special knowledge on the part
    of the child program. In such cases, Function 45H is used to also
    create duplicates of the standard input and standard output handles
    before they are redirected, so that their original meanings can be
    restored after the child exits. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: CUSTOMIZING MS-DOS: Writing MS-DOS Filters.


Using the FCB Functions

    A file control block is a data structure, located in the application
    program's memory space, that contains relevant information about an
    open disk file: the disk drive, the filename and extension, a pointer
    to a position within the file, and so on. Each open file must have its
    own FCB. The information in an FCB is maintained cooperatively by both
    MS-DOS and the application program.

    MS-DOS moves data to and from a disk file associated with an FCB by
    means of a data buffer called the disk transfer area (DTA). The
    current address of the DTA is under the control of the application
    program, although each program has a 128-byte default DTA at offset
    80H in its program segment prefix (PSP). See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: Structure of an Application
    Program.

    Under early versions of MS-DOS, the only limit on the number of files
    that can be open simultaneously with FCBs is the amount of memory
    available to the application to hold the FCBs and their associated
    disk buffers. However, under MS-DOS versions 3.0 and later, when file-
    sharing support (SHARE.EXE) is loaded, MS-DOS places some restrictions
    on the use of FCBs to simplify the job of maintaining network
    connections for files. If the application attempts to open too many
    FCBs, MS-DOS simply closes the least recently used FCBs to keep the
    total number within a limit.

    The CONFIG.SYS file directive FCBS allows the user to control the
    allowed maximum number of FCBs and to specify a certain number of FCBs
    to be protected against automatic closure by the system. The default
    values are a maximum of four files open simultaneously using FCBs and
    zero FCBs protected from automatic closure by the system. See USER
    COMMANDS: CONFIG.SYS: FCBS.

    Because the FCB operations predate MS-DOS version 2.0 and because FCBs
    have a fixed structure with no room to contain a path, the FCB file
    and record services do not support the hierarchical directory
    structure. Many FCB operations can be performed only on files in the
    current directory of a disk. For this reason, the use of FCB file and
    record operations should be avoided in new programs.

Structure of the file control block

    Each FCB is a 37-byte array allocated from its own memory space by the
    application program that will use it. The FCB contains all the
    information needed to identify a disk file and access the data within
    it: drive identifier, filename, extension, file size, record size,
    various file pointers, and date and time stamps. The FCB structure is
    shown in Table 7-3.


    Table 7-3. Structure of a Normal File Control Block.

╓┌──────────────────────┌───────────┌──────────────┌─────────────────────────╖
                    Offset      Size
    Maintained by     (bytes)     (bytes)        Description
    ──────────────────────────────────────────────────────────────────
    Program           00H         1              Drive identifier
    Program           01H         8              Filename
    Program           09H         3              File extension
    MS-DOS            0CH         2              Current block number
    Program           0EH         2              Record size (bytes)
    MS-DOS            10H         4              File size (bytes)
    MS-DOS            14H         2              Date stamp
    MS-DOS            16H         2              Time stamp
    MS-DOS            18H         8              Reserved
    MS-DOS            20H         1              Current record number
    Program           21H         4              Random record number


    Drive identifier: Initialized by the application to designate the
    drive on which the file to be opened or created resides. 0 = default
    drive, 1 = drive A, 2 = drive B, and so on. If the application
    supplies a zero in this byte (to use the default drive), MS-DOS alters
    the byte during the open or create operation to reflect the actual
    drive used; that is, after an open or create operation, this drive
    will always contain a value of 1 or greater.

    Filename: Standard eight-character filename; initialized by the
    application; must be left justified and padded with blanks if the name
    has fewer than eight characters. A device name (for example, PRN) can
    be used; note that there is no colon after a device name.

    File extension: Three-character file extension; initialized by the
    application; must be left justified and padded with blanks if the
    extension has fewer than three characters.

    Current block number: Initialized to zero by MS-DOS when the file is
    opened. The block number and the record number together make up the
    record pointer during sequential file access.

    Record size: The size of a record (in bytes) as used by the program.
    MS-DOS sets this field to 128 when the file is opened or created; the
    program can modify the field afterward to any desired record size. If
    the record size is larger than 128 bytes, the default DTA in the PSP
    cannot be used because it will collide with the program's own code or
    data.

    File size: The size of the file in bytes. MS-DOS initializes this
    field from the file's directory entry when the file is opened. The
    first 2 bytes of this 4-byte field are the least significant bytes of
    the file size.

    Date stamp: The date of the last write operation on the file. MS-DOS
    initializes this field from the file's directory entry when the file
    is opened. This field uses the same format used by file handle
    Function 57H (Get/Set/Date/Time of File):


                                    Date Format

    Bit:   15   14  13  12  11  10   9   8 ║ 7   6   5   4   3   2   1   0
                                        ║
Content:   ┌───╥───╥───╥───╥───╥───╥───╥───╫───╥───╥───╥───╥───╥───╥───╥───┐
        │ Y ║ Y ║ Y ║ Y ║ Y ║ Y ║ Y ║ M ║ M ║ M ║ M ║ D ║ D ║ D ║ D ║ D │
        └───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───┘


╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Bits        Contents
    ──────────────────────────────────────────────────────────────────
    0-4         Day of month (1-31)
    5-8         Month (1-12)
    9-15        Year (relative to 1980)

    Time stamp: The time of the last write operation on the file. MS-DOS
    initializes this field from the file's directory entry when the file
    is opened. This field uses the same format used by file handle
    Function 57H (Get/Set/Date/Time of File):


                                    Time Format

    Bit:   15   14  13  12  11  10   9   8 ║ 7   6   5   4   3   2   1   0
                                        ║
Content:   ┌───╥───╥───╥───╥───╥───╥───╥───╫───╥───╥───╥───╥───╥───╥───╥───┐
        │ H ║ H ║ H ║ H ║ H ║ M ║ M ║ M ║ M ║ M ║ M ║ S ║ S ║ S ║ S ║ S │
        └───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───╨───┘


╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Bits        Contents
    ──────────────────────────────────────────────────────────────────
    0-4        Number of 2-second increments (0-29)
    5-10       Minutes (0-59)
    11-15       Hours (0-23)

    Current record number: Together with the block number, constitutes the
    record pointer used during sequential read and write operations. MS-
    DOS does not initialize this field when a file is opened. The record
    number is limited to the range 0 through 127; thus, there are 128
    records per block. The beginning of a file is record 0 of block 0.

    Random record pointer: A 4-byte field that identifies the record to be
    transferred by the random record functions 21H, 22H, 27H, and 28H. If
    the record size is 64 bytes or larger, only the first 3 bytes of this
    field are used. MS-DOS updates this field after random block reads and
    writes (Functions 27H and 28H) but not after random record reads and
    writes (Functions 21H and 22H).

    An extended FCB, which is 7 bytes longer than a normal FCB, can be
    used to access files with special attributes such as hidden, system,
    and read-only. The extra 7 bytes of an extended FCB are simply
    prefixed to the normal FCB format (Table 7-4). The first byte of an
    extended FCB always contains 0FFH, which could never be a legal drive
    code and therefore serves as a signal to MS-DOS that the extended
    format is being used. The next 5 bytes are reserved and must be zero,
    and the last byte of the prefix specifies the attributes of the file
    being manipulated. The remainder of an extended FCB has exactly the
    same layout as a normal FCB. In general, an extended FCB can be used
    with any MS-DOS function call that accepts a normal FCB.


    Table 7-4. Structure of an Extended File Control Block.

╓┌──────────────────────┌─────────────┌───────────┌──────────────────────────╖
                    Offset        Size
    Maintained by     (bytes)       (bytes)     Description
    ──────────────────────────────────────────────────────────────────
    Program           00H           1           Extended FCB flag = 0FFH
    MS-DOS            01H           5           Reserved
    Program           06H           1           File attribute byte
    Program           07H           1           Drive identifier
    Program           08H           8           Filename
    Program           10H           3           File extension
    MS-DOS            13H           2           Current block number
    Program           15H           2           Record size (bytes)
    MS-DOS            17H           4           File size (bytes)
    MS-DOS            1BH           2           Date stamp
    MS-DOS            1DH           2           Time stamp
    MS-DOS            1FH           8           Reserved
    MS-DOS            27H           1           Current record number
    Program           28H           4           Random record number


    Extended FCB flag: When 0FFH is present in the first byte of an FCB,
    it is a signal to MS-DOS that an extended FCB (44 bytes) is being used
    instead of a normal FCB (37 bytes).

    File attribute byte: Must be initialized by the application when an
    extended FCB is used to open or create a file. The bits of this field
    have the following significance:

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Bit         Meaning
    ──────────────────────────────────────────────────────────────────
    0           Read-only
    1           Hidden
    2           System
    3           Volume label
    4           Directory
    5           Archive
    6           Reserved
    7           Reserved


FCB functions and the PSP

    The PSP contains several items that are of interest when using the FCB
    file and record operations: two FCBs called the default FCBs, the
    default DTA, and the command tail for the program. The following table
    shows the size and location of these elements:

╓┌──────────────────────────┌─────────────────┌──────────────────────────────╖
    PSP Offset            Size
    PSP Offset            Size
    (bytes)               (bytes)           Description
    ──────────────────────────────────────────────────────────────────
    5CH                    16               Default FCB #1
    6CH                    20               Default FCB #2
    80H                     1               Length of command tail
    81H                   127               Command-tail text
    80H                   128               Default disk transfer area
                                            (DTA)

    When MS-DOS loads a program into memory for execution, it copies the
    command tail into the PSP at offset 81H, places the length of the
    command tail in the byte at offset 80H, and parses the first two
    parameters in the command tail into the default FCBs at PSP offsets
    5CH and 6CH. (The command tail consists of the command line used to
    invoke the program minus the program name itself and any redirection
    or piping characters and their associated filenames or device names.)
    MS-DOS then sets the initial DTA address for the program to PSP:0080H.

    For several reasons, the default FCBs and the DTA are often moved to
    another location within the program's memory area. First, the default
    DTA allows processing of only very small records. In addition, the
    default FCBs overlap substantially, and the first byte of the default
    DTA and the last byte of the first FCB conflict. Finally, unless
    either the command tail or the DTA is moved beforehand, the first FCB-
    related file or record operation will destroy the command tail.

    Function 1AH (Set DTA Address) is used to alter the DTA address. It is
    called with the segment and offset of the new buffer to be used as the
    DTA in DS:DX. The DTA address remains the same until another call to
    Function 1AH, regardless of other file and record management calls; it
    does not need to be reset before each read or write.

    Note: A program can use Function 2FH (Get DTA Address) to obtain the
    current DTA address before changing it, so that the original address
    can be restored later.

Parsing the filename

    Before a file can be opened or created with the FCB function calls,
    its drive, filename, and extension must be placed within the proper
    fields of the FCB. The filename can be coded into the program itself,
    or the program can obtain it from the command tail in the PSP or by
    prompting the user and reading it in with one of the several function
    calls for character device input.

    MS-DOS automatically parses the first two parameters in the program's
    command tail into the default FCBs at PSP:005CH and PSP:006CH. It does
    not, however, attempt to differentiate between switches and filenames,
    so the pre-parsed FCBs are not necessarily useful to the application
    program. If the filenames were preceded by any switches, the program
    itself has to extract the filenames directly from the command tail.
    The program is then responsible for determining which parameters are
    switches and which are filenames, as well as where each parameter
    begins and ends.

    After a filename has been located, Function 29H (Parse Filename) can
    be used to test it for invalid characters and separators and to insert
    its various components into the proper fields in an FCB. The filename
    must be a string in the standard form drive:filename.ext. Wildcard
    characters are permitted in the filename and/or extension; asterisk
    (*) wildcards are expanded to question mark (?) wildcards.

    To call Function 29H, the DS:SI registers must point to the candidate
    filename, ES:DI must point to the 37-byte buffer that will become the
    FCB for the file, and AL must hold the parsing control code. See
    SYSTEM CALLS: INTERRUPT 21H: Function 29H.

    If a drive code is not included in the filename, MS-DOS inserts the
    drive number of the current drive into the FCB. Parsing stops at the
    first terminator character encountered in the filename. Terminators
    include the following:

    ; , = +  / " [] | &lt; &gt; | space tab

    If a colon character (:) is not in the proper position to delimit the
    disk drive identifier or if a period (.) is not in the proper position
    to delimit the extension, the character will also be treated as a
    terminator. For example, the filename C:MEMO.TXT will be parsed
    correctly; however, ABC:DEF.DAY will be parsed as ABC.

    If an invalid drive is specified in the filename, Function 29H returns
    0FFH in AL; if the filename contains any wildcard characters, it
    returns 1. Otherwise, AL contains zero upon return, indicating a
    valid, unambiguous filename.

    Note that this function simply parses the filename into the FCB. It
    does not initialize any other fields of the FCB (although it does zero
    the current block and record size fields), and it does not test
    whether the specified file actually exists.

Error handling and FCB functions

    The FCB-related file and record functions do not return much in the
    way of error information when a function fails. Typically, an FCB
    function returns a zero in AL if the function succeeded and 0FFH if
    the function failed. Under MS-DOS versions 2.x, the program is left to
    its own devices to determine the cause of the error. Under MS-DOS
    versions 3.x, however, a failed FCB function call can be followed by a
    call to Interrupt 21H Function 59H (Get Extended Error Information).
    Function 59H will return the same descriptive codes for the error,
    including the error locus and a suggested recovery strategy, as would
    be returned for the counterpart handle-oriented file or record
    function.

Creating a file

    Function 16H (Create File with FCB) creates a new file and opens it
    for subsequent read/write operations. The function is called with
    DS:DX pointing to a valid, unopened FCB. MS-DOS searches the current
    directory for the specifed filename. If the filename is found, MS-DOS
    sets the file length to zero and opens the file, effectively
    truncating it to a zero-length file; if the filename is not found,
    MS-DOS creates a new file and opens it. Other fields of the FCB are
    filled in by MS-DOS as described below under Opening a File.

    If the create operation succeeds, MS-DOS returns zero in AL; if the
    operation fails, it returns 0FFH in AL. This function will not
    ordinarily fail unless the file is being created in the root directory
    and the directory is full.

    Warning: To avoid loss of existing data, the FCB open function should
    be used to test for file existence before creating a file.

Opening a file

    Function 0FH opens an existing file. DS:DX must point to a valid,
    unopened FCB containing the name of the file to be opened. If the
    specified file is found in the current directory, MS-DOS opens the
    file, fills in the FCB as shown in the list below, and returns with AL
    set to 00H; if the file is not found, MS-DOS returns with AL set to
    0FFH, indicating an error.

    When the file is opened, MS-DOS

    ■  Sets the drive identifier (offset 00H) to the actual drive (01 = A,
        02 = B, and so on).

    ■  Sets the current block number (offset 0CH) to zero.

    ■  Sets the file size (offset 10H) to the value found in the directory
        entry for the file.

    ■  Sets the record size (offset 0EH) to 128.

    ■  Sets the date and time stamp (offsets 14H and 16H) to the values
        found in the directory entry for the file.

    The program may need to adjust the FCB--change the record size and the
    random record pointer, for example--before proceeding with record
    operations.

    Example: Display a prompt and accept a filename from the user. Parse
    the filename into an FCB, checking for an illegal drive identifier or
    the presence of wildcards. If a valid, unambiguous filename has been
    entered, attempt to open the file. Create the file if it does not
    already exist.

    kbuf    db      64,0,64 dup (0)
    prompt  db      0dh,0ah,'Enter filename: $'
    myfcb   db      37 dup (0)

            .
            .
            .
                                    ; display the prompt...
            mov     dx,seg prompt   ; DS:DX = prompt address
            mov     ds,dx
            mov     es,dx
            mov     dx,offset prompt
            mov     ah,09h          ; Function 09H = print string
            int     21h             ; transfer to MS-DOS

                                    ; now input filename...
            mov     dx,offset kbuf  ; DS:DX = buffer address
            mov     ah,0ah          ; Function 0AH = enter string
            int     21h             ; transfer to MS-DOS

                                    ; parse filename into FCB...
            mov     si,offset kbuf+2 ; DS:SI = address of filename
            mov     di,offset myfcb ; ES:DI = address of fcb
            mov     ax,2900h        ; Function 29H = parse name
            int     21h             ; transfer to MS-DOS
            or      al,al           ; jump if bad drive or
            jnz     error           ; wildcard characters in name
                                    ; try to open file...
            mov     dx,offset myfcb ; DS:DX = FCB address
            mov     ah,0fh          ; Function 0FH = open file
            int     21h             ; transfer to MS-DOS
            or      al,al           ; check status
            jz      proceed         ; jump if open successful

                                    ; else create file...
            mov     dx,offset myfcb ; DS:DX = FCB address
            mov     ah,16h          ; Function 16H = create
            int     21h             ; transfer to MS-DOS
            or      al,al           ; did create succeed?
            jnz     error           ; jump if create failed

    proceed:
            .                       ; file has been opened or
            .                       ; created, and FCB is valid
            .                       ; for read/write operations...

Closing a file

    Function 10H (Close File with FCB) closes a file previously opened
    with an FCB. As usual, the function is called with DS:DX pointing to
    the FCB of the file to be closed. MS-DOS updates the directory, if
    necessary, to reflect any changes in the file's size and the date and
    time last written.

    If the operation succeeds, MS-DOS returns 00H in AL; if the operation
    fails, MS-DOS returns 0FFH.

Reading and writing files with FCBs

    MS-DOS offers a choice of three FCB access methods for data within
    files: sequential, random record, and random block.

    Sequential operations step through the file one record at a time.
    MS-DOS increments the current record and current block numbers after
    each file access so that they point to the beginning of the next
    record. This method is particularly useful for copying or listing
    files.

    Random record access allows the program to read or write a record from
    any location in the file, without sequentially reading all records up
    to that point in the file. The program must set the random record
    number field of the FCB appropriately before the read or write is
    requested. This method is useful in database applications, in which a
    program must manipulate fixed-length records.

    Random block operations combine the features of sequential and random
    record access methods. The program can set the record number to point
    to any record within a file, and MS-DOS updates the record number
    after a read or write operation. Thus, sequential operations can
    easily be initiated at any file location. Random block operations with
    a record length of 1 byte simulate file-handle access methods.

    All three methods require that the FCB for the file be open, that
    DS:DX point to the FCB, that the DTA be large enough for the specified
    record size, and that the DTA address be previously set with Function
    1AH if the default DTA in the program's PSP is not being used.

    MS-DOS reports the success or failure of any FCB-related read
    operation (sequential, random record, or random block) with one of
    four return codes in register AL:

╓┌──────────────┌────────────────────────────────────────────────────────────╖
    Code      Meaning
    ──────────────────────────────────────────────────────────────────────
    00H       Successful read

    01H       End of file reached; no data read into DTA

    02H       Segment wrap (DTA too close to end of segment); no data read
            into DTA

    03H       End of file reached; partial record read into DTA

    MS-DOS reports the success or failure of an FCB-related write
    operation as one of three return codes in register AL:

╓┌──────────────┌────────────────────────────────────────────────────────────╖
    Code      Meaning
    ──────────────────────────────────────────────────────────────────────
    00H       Successful write
    01H       Disk full; partial or no write
    02H       Segment wrap (DTA too close to end of segment); write failed

    For FCB write operations, records smaller than one sector (512 bytes)
    are not written directly to disk. Instead, MS-DOS stores the record in
    an internal buffer and writes the data to disk only when the internal
    buffer is full, when the file is closed, or when a call to Interrupt
    21H Function 0DH (Disk Reset) is issued.

Sequential access: reading
    Function 14H (Sequential Read) reads records sequentially from the
    file to the current DTA address, which must point to an area at least
    as large as the record size specified in the file's FCB. After each
    read operation, MS-DOS updates the FCB block and record numbers
    (offsets 0CH and 20H) to point to the next record.

Sequential access: writing
    Function 15H (Sequential Write) writes records sequentially from
    memory into the file. The length written is specified by the record
    size field (offset 0EH) in the FCB; the memory address of the record
    to be written is determined by the current DTA address. After each
    sequential write operation, MS-DOS updates the FCB block and record
    numbers (offsets 0CH and 20H) to point to the next record.

Random record access: reading
    Function 21H (Random Read) reads a specific record from a file. Before
    requesting the read operation, the program specifies the record to be
    transferred by setting the record size and random record number fields
    of the FCB (offsets 0EH and 21H). The current DTA address must also
    have been previously set with Function 1AH to point to a buffer of
    adequate size if the default DTA is not large enough.

    After the read, MS-DOS sets the current block and current record
    number fields (offsets 0CH and 20H) to point to the same record. Thus,
    the program is set up to change to sequential reads or writes.
    However, if the program wants to continue with random record access,
    it must continue to update the random record field of the FCB before
    each random record read or write operation.

Random record access: writing
    Function 22H (Random Write) writes a specific record from memory to a
    file. Before issuing the function call, the program must ensure that
    the record size and random record pointer fields at FCB offsets 0EH
    and 21H are set appropriately and that the current DTA address points
    to the buffer containing the data to be written.

    After the write, MS-DOS sets the current block and current record
    number fields (offsets 0CH and 20H) to point to the same record. Thus,
    the program is set up to change to sequential reads or writes. If the
    program wants to continue with random record access, it must continue
    to update the random record field of the FCB before each random record
    read or write operation.

Random block access: reading
    Function 27H (Random Block Read) reads a block of consecutive records.
    Before issuing the read request, the program must specify the file
    location of the first record by setting the record size and random
    record number fields of the FCB (offsets 0EH and 21H) and must put the
    number of records to be read in CX. The DTA address must have already
    been set with Function 1AH to point to a buffer large enough to
    contain the group of records to be read if the default DTA was not
    large enough. The program can then issue the Function 27H call with
    DS:DX pointing to the FCB for the file.

    After the random block read operation, MS-DOS resets the FCB random
    record pointer (offset 21H) and the current block and current record
    number fields (offsets 0CH and 20H) to point to the beginning of the
    next record not read and returns the number of records actually read
    in CX.

    If the record size is set to 1 byte, Function 27H reads the number of
    bytes specified in CX, beginning with the byte position specified in
    the random record pointer. This simulates (to some extent) the handle
    type of read operation (Function 3FH).

Random block access: writing
    Function 28H (Random Block Write) writes a block of consecutive
    records from memory to disk. The program specifies the file location
    of the first record to be written by setting the record size and
    random record pointer fields in the FCB (offsets 0EH and 21H). If the
    default DTA is not being used, the program must also ensure that the
    current DTA address is set appropriately by a previous call to
    Function 1AH. When Function 28H is called, DS:DX must point to the FCB
    for the file and CX must contain the number of records to be written.

    After the random block write operation, MS-DOS resets the FCB random
    record pointer (offset 21H) and the current block and current record
    number fields (offsets 0CH and 20H) to point to the beginning of the
    next block of data and returns the number of records actually written
    in CX.

    If the record size is set to 1 byte, Function 28H writes the number of
    bytes specified in CX, beginning with the byte position specified in
    the random record pointer. This simulates (to some extent) the handle
    type of write operation (Function 40H).

    Calling Function 28H with a record count of zero in register CX causes
    the file length to be extended or truncated to the current value in
    the FCB random record pointer field (offset 21H) multiplied by the
    contents of the record size field (offset 0EH).

    Example: Open the file MYFILE.DAT and create the file MYFILE.BAK on
    the current disk drive, copy the contents of the .DAT file into the
    .BAK file using 512-byte reads and writes, and then close both files.

    fcb1    db      0               ; drive = default
            db      'MYFILE  '      ; 8 character filename
            db      'DAT'           ; 3 character extension
            db      25 dup (0)      ; remainder of fcb1
    fcb2    db      0               ; drive = default
            db      'MYFILE  '      ; 8 character filename
            db      'BAK'           ; 3 character extension
            db      25 dup (0)      ; remainder of fcb2
    buff    db      512 dup (?)     ; buffer for file I/O
            .
            .
            .
                                    ; open MYFILE.DAT...
            mov     dx,seg fcb1     ; DS:DX = address of FCB
            mov     ds,dx
            mov     dx,offset fcb1
            mov     ah,0fh          ; Function 0FH = open
            int     21h             ; transfer to MS-DOS
            or      al,al           ; did open succeed?
            jnz     error           ; jump if open failed
                                    ; create MYFILE.BAK...
            mov     dx,offset fcb2  ; DS:DX = address of FCB
            mov     ah,16h          ; Function 16H = create
            int     21h             ; transfer to MS-DOS
            or      al,al           ; did create succeed?
            jnz     error           ; jump if create failed
                                    ; set record length to 512
            mov     word ptr fcb1+0eh,512
            mov     word ptr fcb2+0eh,512
                                    ; set DTA to our buffer...
            mov     dx,offset buff  ; DS:DX = buffer address
            mov     ah,1ah          ; Function 1AH = set DTA
            int     21h             ; transfer to MS-DOS
    loop:                           ; read MYFILE.DAT
            mov     dx,offset fcb1  ; DS:DX = FCB address
            mov     ah,14h          ; Function 14H = seq. read
            int     21h             ; transfer to MS-DOS
            or      al,al           ; was read successful?
            jnz     done            ; no, quit
                                    ; write MYFILE.BAK...
            mov     dx,offset fcb2  ; DS:DX = FCB address
            mov     ah,15h          ; Function 15H = seq. write
            int     21h             ; transfer to MS-DOS
            or      al,al           ; was write successful?
            jnz     error           ; jump if write failed
            jmp     loop            ; continue to end of file
    done:                           ; now close files...
            mov     dx,offset fcb1  ; DS:DX = FCB for MYFILE.DAT
            mov     ah,10h          ; Function 10H = close file
            int     21h             ; transfer to MS-DOS
            or      al,al           ; did close succeed?
            jnz     error           ; jump if close failed
            mov     dx,offset fcb2  ; DS:DX = FCB for MYFILE.BAK
            mov     ah,10h          ; Function 10H = close file
            int     21h             ; transfer to MS-DOS
            or      al,al           ; did close succeed?
            jnz     error           ; jump if close failed
            .
            .
            .

Other FCB file operations

    As it does with file handles, MS-DOS provides FCB-oriented functions
    to rename or delete a file. Unlike the other FCB functions and their
    handle counterparts, these two functions accept wildcard characters.
    An additional FCB function allows the size or existence of a file to
    be determined without actually opening the file.

Renaming a file
    Function 17H (Rename File) renames a file (or files) in the current
    directory. The file to be renamed cannot have the hidden or system
    attribute. Before calling Function 17H, the program must create a
    special FCB that contains the drive code at offset 00H, the old
    filename at offset 01H, and the new filename at offset 11H. Both the
    current and the new filenames can contain the ? wildcard character.

    When the function call is made, DS:DX must point to the special FCB
    structure. MS-DOS searches the current directory for the old filename.
    If it finds the old filename, MS-DOS then searches for the new
    filename and, if it finds no matching filename, changes the directory
    entry for the old filename to reflect the new filename. If the old
    filename field of the special FCB contains any wildcard characters,
    MS-DOS renames every matching file. Duplicate filenames are not
    permitted; the process will fail at the first duplicate name.

    If the operation is successful, MS-DOS returns zero in AL; if the
    operation fails, it returns 0FFH. The error condition may indicate
    either that no files were renamed or that at least one file was
    renamed but the operation was then terminated because of a duplicate
    filename.

    Example: Rename all the files with the extension .ASM in the current
    directory of the default disk drive to have the extension .COD.

    renfcb  db      0               ; default drive
            db      '????????'      ; wildcard filename
            db      'ASM'           ; old extension
            db      5 dup (0)       ; reserved area
            db      '????????'      ; wildcard filename
            db      'COD'           ; new extension
            db      15 dup (0)      ; remainder of FCB

            .
            .
            .
            mov     dx,seg renfcb   ; DS:DX = address of
            mov     ds,dx           ; "special" FCB
            mov     dx,offset renfcb
            mov     ah,17h          ; Function 17H = rename
            int     21h             ; transfer to MS-DOS
            or      al,al           ; did function succeed?
            jnz     error           ; jump if rename failed
            .
            .
            .

Deleting a file
    Function 13H (Delete File) deletes a file from the current directory.
    The file should not be currently open by any process. If the file to
    be deleted has special attributes, such as read-only, the program must
    use an extended FCB to remove the file. Directories cannot be deleted
    with this function, even with an extended FCB.

    Function 13H is called with DS:DX pointing to an unopened, valid FCB
    containing the name of the file to be deleted. The filename can
    contain the ? wildcard character; if it does, MS-DOS deletes all files
    matching the specified name. If at least one file matches the FCB and
    is deleted, MS-DOS returns 00H in AL; if no matching filename is
    found, it returns 0FFH.

    Note: This function, if it succeeds, does not return any information
    about which and how many files were deleted. When multiple files must
    be deleted, closer control can be exercised by using the Find File
    functions (Functions 11H and 12H) to inspect candidate filenames. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: Disk
    Directories and Volume Labels. The files can then be deleted
    individually.

    Example: Delete all the files in the current directory of the current
    disk drive that have the extension .BAK and whose filenames have A as
    the first character.

    delfcb  db      0               ; default drive
            db      'A???????'      ; wildcard filename
            db      'BAK'           ; extension
            db      25 dup (0)      ; remainder of FCB
            .
            .
            .
            mov     dx,seg delfcb   ; DS:DX = FCB address
            mov     ds,dx
            mov     dx,offset delfcb
            mov     ah,13h          ; Function 13H = delete
            int     21h             ; transfer to MS-DOS
            or      al,al           ; did function succeed?
            jnz     error           ; jump if delete failed
            .
            .
            .

Finding file size and testing for existence
    Function 23H (Get File Size) is used primarily to find the size of a
    disk file without opening it, but it may also be used instead of
    Function 11H (Find First File) to simply test for the existence of a
    file. Before calling Function 23H, the program must parse the filename
    into an unopened FCB, initialize the record size field of the FCB
    (offset 0EH), and set the DS:DX registers to point to the FCB.

    When Function 23H returns, AL contains 00H if the file was found in
    the current directory of the specified drive and 0FFH if the file was
    not found.

    If the file was found, the random record field at FCB offset 21H
    contains the number of records (rounded upward) in the target file, in
    terms of the value in the record size field (offset 0EH) of the FCB.
    If the record size is at least 64 bytes, only the first 3 bytes of the
    random record field are used; if the record size is less than 64
    bytes, all 4 bytes are used. To obtain the size of the file in bytes,
    the program must set the record size field to 1 before the call. This
    method is not any faster than simply opening the file, but it does
    avoid the overhead of closing the file afterward (which is necessary
    in a networking environment).


Summary

    MS-DOS supports two distinct but overlapping sets of file and record
    management services. The handle-oriented functions operate in terms of
    null-terminated (ASCIIZ) filenames and 16-bit file identifiers, called
    handles, that are returned by MS-DOS after a file is opened or
    created. The filenames can include a full path specifying the file's
    location in the hierarchical directory structure. The information
    associated with a file handle, such as the current read/write pointer
    for the file, the date and time of the last write to the file, and the
    file's read/write permissions, sharing mode, and attributes, is
    maintained in a table internal to MS-DOS.

    In contrast, the FCB-oriented functions use a 37-byte structure called
    a file control block, located in the application program's memory
    space, to specify the name and location of the file. After a file is
    opened or created, the FCB is used by both MS-DOS and the application
    to hold other information about the file, such as the current
    read/write file pointer, while that file is in use. Because FCBs
    predate the hierarchical directory structure that was introduced in
    MS-DOS version 2.0 and do not have room to hold the path for a file,
    the FCB functions cannot be used to access files that are not in the
    current directory of the specified drive.

    In addition to their lack of support for pathnames, the FCB functions
    have much poorer error reporting capabilities than handle functions
    and are nearly useless in networking environments because they do not
    support file sharing and locking. Consequently, it is strongly
    recommended that the handle-related file and record functions be used
    exclusively in all new applications.

                                                        Robert Byers
                                                Code by Ray Duncan



Article 8:  Disk Directories and Volume Labels


    MS-DOS, being a disk operating system, provides facilities for
    cataloging disk files. The data structure used by MS-DOS for this
    purpose is the directory, a linear list of names in which each name is
    associated with a physical location on the disk. Directories are
    accessed and updated implicitly whenever files are manipulated, but
    both directories and their contents can also be manipulated explicitly
    using several of the MS-DOS Interrupt 21H service functions.

    MS-DOS versions 1.x support only one directory on each disk. Versions
    2.0 and later, however, support multiple directories linked in a two-
    way, hierarchical tree structure (Figure 8-1), and the complete
    specification of the name of a file or directory thus must describe
    the location in the directory hierarchy in which the name appears.
    This specification, or path, is created by concatenating a disk drive
    specifier (for example, A: or C:), the names of the directories in
    hierarchical order starting with the root directory, and finally the
    name of the file or directory. For example, in Figure 8-1, the
    complete pathname for FILE5.COM is C:\ALPHA\GAMMA\FILE5.COM. The two
    instances of FILE1.COM, in the root directory and in the directory
    EPSILON, are distinguished by their pathnames: C:\FILE1.COM in the
    first instance and C:\BETA\EPSILON\FILE1.COM in the second.


C:\  (root directory)
┌─────────────────────┐
│subdirect. ALPHA     │
│subdirect. BETA      │
│file       FILE1.COM │
│file       FILE2.COM │
│                     │
└───────────┬─────────┘
            ├────────────────────────────────────────────────┐
        C:\ALPHA                                        C:\BETA
┌─────────────────────┐                           ┌─────────────────────┐
│subdirect. ∙         │                           │subdirect. ∙         │
│subdirect. ∙∙        │                           │subdirect. ∙∙        │
│subdirect. GAMMA     │                           │file       EPSILON   │
│subdirect. DELTA     │                           │file       FILE4.COM │
│file       FILE3.COM │                           │                     │
└───────────┬─────────┘                           └──────────┬──────────┘
            │                                                │
            ├───────────────────────┐                        │
            │                       │                        │
    C:\ALPHA\GAMMA           C:\ALPHA\DELTA           C:\BETA\EPSILON
┌─────────────────────┐  ┌─────────────────────┐  ┌─────────────────────┐
│subdirect. ∙         │  │subdirect. ∙         │  │subdirect. ∙         │
│subdirect. ∙∙        │  │subdirect. ∙∙        │  │subdirect. ∙∙        │
│file       FILE5.COM │  │                     │  │file       FILE1.COM │
│                     │  │                     │  │                     │
│                     │  │                     │  │                     │
└─────────────────────┘  └─────────────────────┘  └─────────────────────┘

    Figure 8-1. Typical hierarchical directory structure (MS-DOS versions
    2.0 and later).


    Note: If no drive is specified, the current drive is assumed. Also, if
    the first name in the specification is not preceded by a backslash,
    the specification is assumed to be relative to the current directory.
    For example, if the current directory is C:\BETA\EPSILON, the
    specification \FILE1.COM indicates the file FILE1.COM in the root
    directory and the specification FILE1.COM indicates the file FILE1.COM
    in the directory C:\BETA\EPSILON. See Figure 8-1.

    Although the casual user of MS-DOS need not be concerned with how this
    hierarchical directory structure is implemented, MS-DOS programmers
    should be familiar with the internal structure of directories and with
    the Interrupt 21H functions available for manipulating directory
    contents and maintaining the links between directories. This article
    provides that information.


Logical Structure of MS-DOS Directories

    An MS-DOS directory consists of a list of 32-byte directory entries,
    each of which contains a name and descriptive information. In MS-DOS
    versions 1.x, each name must be a filename; in versions 2.0 and later,
    volume labels and directory names can also appear in directory
    entries.

Directory searches

    Directory entries are not sorted, nor are they maintained as a linked
    list. Thus, when MS-DOS searches a directory for a name, the search
    must proceed linearly from the first name in the directory. In MS-DOS
    versions 1.x, a directory search continues until the specified name is
    found or until every entry in the directory has been examined. In
    versions 2.0 and later, the search continues until the specified name
    is found or until a null directory entry (that is, one whose first
    byte is zero) is encountered. This null entry indicates the logical
    end of the directory.

Adding and deleting directory entries

    MS-DOS deletes a directory entry by marking it with 0E5H in the first
    byte rather than by erasing it or excising it from the directory. New
    names are added to the directory by reusing the first deleted entry in
    the list. If no deleted entries are available, MS-DOS appends the new
    entry to the list.

The current directory

    When more than one directory exists on a disk, MS-DOS keeps track of a
    default search directory known as the current directory. The current
    directory is the directory used for all implicit directory searches,
    such as those occasioned by a request to open a file, if no
    alternative path is specified. At startup, MS-DOS makes the root
    directory the current directory, but any other directory can be
    designated later, either interactively by using the CHDIR command or
    from within an application by using Interrupt 21H Function 3BH (Change
    Current Directory).


Directory Format

    The root directory is created by the MS-DOS FORMAT program. See USER
    COMMANDS: FORMAT. The FORMAT program places the root directory
    immediately after the disk's file allocation tables (FATs). FORMAT
    also determines the size of the root directory. The size depends on
    the capacity of the storage medium: FORMAT places larger root
    directories on high-capacity fixed disks and smaller root directories
    on floppy disks. In contrast, the size of subdirectories is limited
    only by the storage capacity of the disk because disk space for
    subdirectories is allocated dynamically, as it is for any MS-DOS file.
    The size and physical location of the root directory can be derived
    from data in the BIOS parameter block (BPB) in the disk boot sector.
    See PROGRAMMING IN THE MS-DOS ENVIRONMENT: STRUCTURE OF MS-DOS: MS-DOS
    Storage Devices.

    Because space for the root directory is allocated only when the disk
    is formatted, the root directory cannot be deleted or moved.
    Subdirectories, whose disk space is allocated dynamically, can be
    added or deleted as needed.

Directory entry format

    Each 32-byte directory entry consists of seven fields, including a
    name, an attribute byte, date and time stamps, and information that
    describes the file's size and physical location on the disk (Figure
    8-2). The fields are formatted as described in the following
    paragraphs.


Byte   0     0BH        0CH         16H   18H   1AH               1CH   1FH
    ┌─────┬──────────┬───────────┬─────┬─────┬─────────────────┬─────────┐
    │Name │Attribute │(Reserved) │Time │Date │Starting cluster │File size│
    └─────┴──────────┴───────────┴─────┴─────┴─────────────────┴─────────┘

    Figure 8-2. Format of a directory entry.


    The name field (bytes 0-0AH) contains an 11-byte name unless the first
    byte of the field indicates that the directory entry is deleted or
    null. The name can be an 11-byte filename (8-byte name followed by a
    3-byte extension), an 11-byte subdirectory name (8-byte name followed
    by a 3-byte extension), or an 11-byte volume label. Names less than 8
    bytes and extensions less than 3 bytes are padded to the right with
    blanks so that the extension always appears in bytes 08-0AH of the
    name field. The first byte of the name field can contain certain
    reserved values that affect the way MS-DOS processes the directory
    entry:

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Value       Meaning
    ──────────────────────────────────────────────────────────────────────
    0           Null directory entry (logical end of directory in MS-DOS
                versions 2.0 and later)

    5           First character of name to be displayed as the character
                represented by 0E5H (MS-DOS version 3.2 )

    0E5H        Deleted directory entry

    When MS-DOS creates a subdirectory, it always includes two aliases as
    the first two entries in the newly created directory. The name . (an
    ASCII period) is an alias for the name of the current directory; the
    name .. (two ASCII periods) is an alias for the directory's parent
    directory--that is, the directory in which the entry containing the
    name of the current directory is found.

    The attribute field (byte 0BH) is an 8-bit field that describes the
    way MS-DOS processes the directory entry (Figure 8-3). Each bit in the
    attribute field designates a particular attribute of that directory
    entry; more than one of the bits can be set at a time.


Bit        7           6         5        4      3      2       1      0
    ┌───────────┬───────────┬────────┬───────┬─────┬───────┬───────┬─────┐
    │(Reserved) │(Reserved) │Archive │Sub-   │Vol- │System │Hidden │Read-│
    │           │           │        │direc- │ume  │file   │file   │only │
    │           │           │        │tory   │label│       │       │file │
    └───────────┴───────────┴────────┴───────┴─────┴───────┴───────┴─────┘

    Figure 8-3. Format of the attribute field in a directory entry.


    The read-only bit (bit 0) is set to 1 to mark a file read-only.
    Interrupt 21H Function 3DH (Open File with Handle) will fail if it is
    used in an attempt to open this file for writing. The hidden bit (bit
    1) is set to 1 to indicate that the entry is to be skipped in normal
    directory searches--that is, in directory searches that do not
    specifically request that hidden entries be included in the search.
    The system bit (bit 2) is set to 1 to indicate that the entry refers
    to a file used by the operating system. Like the hidden bit, the
    system bit excludes a directory entry from normal directory searches.
    The volume label bit (bit 3) is set to 1 to indicate that the
    directory entry represents a volume label. The subdirectory bit (bit
    4) is set to 1 when the directory entry contains the name and location
    of another directory. This bit is always set for the directory entries
    that correspond to the current directory (.) and the parent directory
    (..). The archive bit (bit 5) is set to 1 by MS-DOS functions that
    close a file that has been written to. Simply opening and closing a
    file is not sufficient to update the archive bit in the file's
    directory entry.

    The time and date fields (bytes 16-17H and 18-19H) are initialized by
    MS-DOS when the directory entry is created. These fields are updated
    whenever a file is written to. The formats of these fields are shown
    in Figures 8-4 and 8-5.


Bit  15                      10                      4                  0
    ┌──────────────────────┬───────────────────────┬───────────────────┐
    │    Hours (0-23)      │     Minutes (0-59)    │     2-second      │
    │                      │                       │ increments (0-29) │
    └──────────────────────┴───────────────────────┴───────────────────┘

    Figure 8-4. Format of the time field in a directory entry.


Bit  15                               8              4                  0
    ┌───────────────────────────────┬──────────────┬───────────────────┐
    │   Year (relative to 1980)     │ Month (1-12) │     Day (1-31)    │
    │                               │              │                   │
    └───────────────────────────────┴──────────────┴───────────────────┘

    Figure 8-5. Format of the date field in a directory entry.


    The starting cluster field (bytes 1A-1BH) indicates the disk location
    of the first cluster assigned to the file. This cluster number can be
    used as an entry point to the file allocation table (FAT) for the
    disk. (Cluster numbers can be converted to logical sector numbers with
    the aid of the information in the disk's BPB.)

    For the . entry (the alias for the directory that contains the entry),
    the starting cluster field contains the starting cluster number of the
    directory itself. For the .. entry (the alias for the parent
    directory), the value in the starting cluster field refers to the
    parent directory unless the parent directory is the root directory, in
    which case the starting cluster number is zero.

    The file size field (bytes 1C-1FH) is a 32-bit integer that indicates
    the file size in bytes.


Volume Labels

    The generic term volume refers to a unit of auxiliary storage such as
    a floppy disk, a fixed disk, or a reel of magnetic tape. In computer
    environments where many different volumes might be used, the operating
    system can uniquely identify each volume by initializing it with a
    volume label.

    Volume labels are implemented in MS-DOS versions 2.0 and later as a
    specific type of directory entry specified by setting bit 3 in the
    attribute field to 1. In a volume label directory entry, the name
    field contains an 11-byte string specifying a name for the disk
    volume. A volume label can appear only in the root directory of a
    disk, and only one volume label can be present on any given disk.

    In MS-DOS versions 2.0 and later, the FORMAT command can be used with
    the /V switch to initialize a disk with a volume label. In versions
    3.0 and later, the LABEL command can be used to create, update, or
    delete a volume label. Several commands can display a disk's volume
    label, including VOL, DIR, LABEL, TREE, and CHKDSK. See USER COMMANDS.

    In MS-DOS versions 2.x, volume labels are simply a convenience for the
    user; no MS-DOS routine uses a volume label for any other purpose. In
    MS-DOS versions 3.x, however, the SHARE command examines a disk's
    volume label when it attempts to verify whether a disk volume has been
    inadvertently replaced in the midst of a file read or write operation.
    Removable disk volumes should therefore be assigned unique volume
    names if they are to contain shared files.


Functional Support for MS-DOS Directories

    Several Interrupt 21H service routines can be useful to programmers
    who need to manipulate directories and their contents (Table 8-1). The
    routines can be broadly grouped into two categories: those that use a
    modified file control block (FCB) to pass filenames to and from the
    Interrupt 21H service routines (Functions 11H, 12H, 17H, and 23H) and
    those that use hierarchical path specifications (Functions 39H, 3AH,
    3BH, 43H, 47H, 4EH, 4FH, 56H, and 57H). See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: File and Record Management;
    SYSTEM CALLS: INTERRUPT 21H.

    The functions that use an FCB require that the calling program
    reserve enough memory for an extended FCB before the Interrupt 21H
    function is called. The calling program initializes the filename and
    extension fields of the FCB and passes the address of the FCB to the
    MS-DOS service routine in DS:DX. The functions that use pathnames
    expect all pathnames to be in ASCIIZ format--that is, the last
    character of the name must be followed by a zero byte.

    Names in pathnames passed to Interrupt 21H functions can be separated
    by either a backslash (\) or a forward slash (/). (The forward slash
    is the separator character used in pathnames in UNIX/XENIX systems.)
    For example, the pathnames C:/MSP/SOURCE/ROSE.PAS and
    C:\MSP\SOURCE\ROSE.PAS are equivalent when passed to an Interrupt 21H
    function. The forward slash can thus be used in a pathname in a
    program that must run on both MSDOS and UNIX/XENIX. However, the MS-
    DOS comand processor (COMMAND.COM) recognizes only the backslash as a
    pathname separator character, so forward slashes cannot be used as
    separators in the command line.


    Table 8-1. MS-DOS Functions for Accessing Directories.

╓┌────────────────────────┌───────────────────┌──────────────────────┌───────────────╖
    Function            Call With           Returns                Comment
    ───────────────────────────────────────────────────────────────────────────
    Find First File     AH = 11H            AL = 0 (directory      If default not
                        DS:DX = pointer       entry found) or        satisfactory,
                        to unopened FCB     0FFH (not found)       DTA must be
                        INT 21H               DTA updated (if        set before
                                            directory entry        using this
                                            found)                 function.

    Find Next File      AH = 12H            AL = 0 (directory      Use the same
                        DS:DX = pointer       entry found) or        FCB for Func-
                        to unopened FCB     0FFH (not found)       tion 11H and
                        INT 21H             DTA updated (if          Function 12H.
                                            directory entry
                                            found)

    Rename File         AH = 17H            AL = 0 (file renamed)
                        DS:DX = pointer       or 0FFH (no directory
                        to modified FCB     entry or duplicate
                        INT 21H               filename)

    Get File Size       AH = 23H            AL = 0 (directory
                        DS:DX = pointer       entry found) or
                        to unopened FCB     0FFH (not found)
                        INT 21H             FCB updated with
                                            number of records
                                            in file

    Create              AH = 39H            Carry flag set
    Directory           DS:DX = pointer       (if error)
                        to ASCIIZ         AX = error code
                        pathname            (if error)
                        INT 21H

    Remove              AH = 3AH            Carry flag set
    Directory           DS:DX = pointer       (if error)
                        to ASCIIZ         AX = error code
                        pathname            (if error)
                        INT 21H

    Change Current      AH = 3BH            Carry flag set
    Directory           DS:DX = pointer       (if error)
                        to ASCIIZ         AX = error code
                        pathname            (if error)
                        INT 21H

    Get/Set File        AH = 43H            Carry flag set         Cannot be
    Attributes          AL = 0 (get           (if error)             used to
                        attributes)       AX = error code          modify the
                            1 (set           (if error)             volume label
                        attributes)       CX = attribute           or subdirec-
                        CX = attributes       field from direc-      tory bits.
                        (if AL = 1)         tory entry (if
                        DS:DX = pointer       called with AL = 0)
                        to ASCIIZ
                        pathname
                        INT 21H

    Get Current         AH - 47H            Carry flag set
    Directory           DS:SI = pointer       (if error)
                        to 64-byte        AX = error code
                        buffer              (if error)
                        DL = drive          Buffer updated with
                        number              pathname of current
                        INT 21H               directory

    Find First File     AH = 4EH            Carry flag set         If default
                        DS:DX = pointer       (if error)             not satisfac-
                        to ASCIIZ         AX = error code          tory, DTA
                        pathname            (if error)             must be set
                        CX = file           DTA updated              before using
                        attributes to                              this
                        match                                      function.
                        INT 21H

    Find Next File      AH = 4FH            Carry flag set
                        INT 21H               (if error)
                                            AX = error code
                                            (if error)
                                            DTA updated

    Rename File         AH = 56H            Carry flag set
                        DS:DX = pointer      (if error)
                        to ASCIIZ         AX = error code
                        pathname            (if error)
                        ES:DI = pointer
                        to new ASCIIZ
                        pathname
                        INT 21H

    Get/Set Date        AH = 57H            Carry flag set
    /Time of File       AL = 0 (get           (if error)
                        date/time)        AX = error code
                            1 (set           (if error)
                        date/time)        CX = time
                        BX = handle           (if AL = 0)
                        CX = time           DX = date
                        (if AL = 1)         (if AL = 0)
                        DX = date
                        (if AL = 1)
                        INT 21H


Searching a directory

    Two pairs of Interrupt 21H functions are available for directory
    searches. Functions 11H and 12H use FCBs to transfer filenames to
    MS-DOS; these functions are available in all versions of MS-DOS, but
    they cannot be used with pathnames. Functions 4EH and 4FH support
    pathnames, but these functions are unavailable in MS-DOS versions 1.x.
    All four functions require the address of the disk transfer area (DTA)
    to be initialized appropriately before the function is invoked. When
    Function 12H or 4FH is used, the current DTA must be the same as the
    DTA for the preceding call to Function 11H or 4EH.

    The Interrupt 21H directory search functions are designed to be used
    in pairs. The Find First File functions return the first matching
    directory entry in the current directory (Function 11H) or in the
    specified directory (Function 4EH). The Find Next File functions
    (Functions 12H and 4FH) can be called repeatedly after a successful
    call to the corresponding Find First File function. Each call to one
    of the Find Next File functions returns the next directory entry that
    matches the name originally specified to the Find First File function.
    A directory search can thus be summarized as follows:

    call "find first file" function

    while ( matching directory entry returned )
        call "find next file" function

Wildcard characters

    This search strategy is used because name specifications can include
    the wildcard characters ?, which matches any single character, and *
    (see below). When one or more wildcard characters appear in the name
    specified to one of the Find First File functions, only the
    nonwildcard characters in the name participate in the directory
    search. Thus, for example, the specification FOO? matches the
    filenames FOO1, FOO2, and so on; the specification FOO?????.???
    matches FOO4.COM, FOOBAR.EXE, and FOONEW.BAK, as well as FOO1 and
    FOO2; the specification ????????.TXT matches all files whose extension
    is .TXT; the specification ????????.??? matches all files in the
    directory.

    Function 4EH also recognizes the wildcard character *, which matches
    any remaining characters in a filename or extension. MS-DOS expands
    the * wildcard character internally to question marks. Thus, for
    example, the specification FOO* is the same as FOO?????; the
    specification FOO*.* is the same as FOO?????.???; and, of course, the
    specification *.* is the same as ????????.???.

Examining a directory entry

    All four Interrupt 21H directory search functions return the name,
    attribute, file size, time, and date fields for each directory entry
    found during a directory search. The current DTA is used to return
    this data, although the format is different for the two pairs of
    functions: Functions 11H and 12H return a copy of the 32-byte
    directory entry--including the cluster number--in the DTA; Functions
    4EH and 4FH return a 43-byte data structure that does not include the
    starting cluster number. See SYSTEM CALLS: INTERRUPT 21H: Function
    4EH.

    The attribute field of a directory entry can be examined using
    Function 43H (Get/Set File Attributes). Also, Function 57H (Get/Set
    Date/Time of File) can be used to examine a file's time or date.
    However, unlike the other functions discussed here, Function 57H is
    intended only for files that are being actively used within an
    application--that is, Function 57H can be called to examine the file's
    time or date stamp only after the file has been opened or created
    using an Interrupt 21H function that returns a handle (Function 3CH,
    3DH, 5AH, or 5BH).

Modifying a directory entry

    Four Interrupt 21H functions can modify the contents of a directory
    entry. Function 17H (Rename File) can be used to change the name field
    in any directory entry, including hidden or system files,
    subdirectories, and the volume label. Related Function 56H (Rename
    File) also changes the name field of a filename but cannot rename a
    volume label or a hidden or system file. However, it can be used to
    move a directory entry from one directory to another. (This capability
    is restricted to filenames only; subdirectory entries cannot be moved
    with Function 56H.)

    Functions 43H (Get/Set File Attributes) and 57H (Get/Set Date/Time of
    File) can be used to modify specific fields in a directory entry.
    Function 43H can mark a directory entry as a hidden or system file,
    although it cannot modify the volume label or subdirectory bits.
    Function 57H, as noted above, can be used only with a previously
    opened file; it provides a way to read or update a file's time and
    date stamps without writing to the file itself.

Creating and deleting directories

    Function 39H (Create Directory) exists only to create directories--
    that is, directory entries with the subdirectory bit set to 1.
    (Interrupt 21H functions that create files, such as Function 3CH,
    cannot assign the subdirectory attribute to a directory entry.) The
    converse function, 3AH (Remove Directory), deletes a subdirectory
    entry from a directory. (The subdirectory must be completely empty.)
    Again, Interrupt 21H functions that delete files from directories,
    such as Function 41H, cannot be used to delete subdirectories.

Specifying the current directory

    A call to Interrupt 21H Function 47H (Get Current Directory) returns
    the pathname of the current directory in use by MS-DOS to a user-
    supplied buffer. The converse operation, in which a new current
    directory can be specified to MS-DOS, is performed by Function 3BH
    (Change Current Directory).

Programming examples: Searching for files

    The subroutines in Figure 8-6 below illustrate Functions 4EH and 4FH,
    which use path specifications passed as ASCIIZ strings to search for
    files. Figure 8-7 applies these assembly-language subroutines in a
    simple C program that lists the attributes associated with each entry
    in the current directory. Note how the directory search is performed
    in the WHILE loop in Figure 8-7 by using a global wildcard file
    specification (*.*) and by repeatedly executing FindNextFile() until
    no further matching filenames are found. (See Programming Example:
    Updating a Volume Label for examples of the FCB-related search
    functions, 11H and 21H.)

    ──────────────────────────────────────────────────────────────────────

    Figure 8-6. Subroutines illustrating Interrupt 21H Functions 4EH and
    4FH.

    ──────────────────────────────────────────────────────────────────────

    Figure 8-7. The complete DIRDUMP.C program.

    ──────────────────────────────────────────────────────────────────────

Programming example: Updating a volume label

    To create, modify, or delete a volume-label directory entry, the
    Interrupt 21H functions that work with FCBs should be used. Figure 8-8
    contains four subroutines that show how to search for, rename, create,
    or delete a volume label in MS-DOS versions 2.0 and later.

    ──────────────────────────────────────────────────────────────────────

    Figure 8-8. Subroutines for manipulating volume labels.

    ──────────────────────────────────────────────────────────────────────


                                                Richard Wilton



Article 9:  Memory Management


    Personal computers that are MS-DOS compatible can be outfitted with as
    many as three kinds of random-access memory (RAM): conventional
    memory, expanded memory, and extended memory.

    All MS-DOS machines have at least some conventional memory, but the
    presence of expanded or extended memory depends on the installed
    hardware options and the model of microprocessor on which the computer
    is based. Each storage class has its own capabilities,
    characteristics, and limitations. Each also has its own management
    techniques, which are the subject of this chapter.


Conventional Memory

    Conventional memory is the term for the up to 1 MB of memory that is
    directly addressable by an Intel 8086/8088 microprocessor or by an
    80286 or 80386 microprocessor running in real mode (8086-emulation
    mode). Physical addresses for references to conventional memory are
    generated by a 16-bit segment register, which acts as a base register
    and holds a paragraph address, combined with a 16-bit offset contained
    in an index register or in the instruction being executed.

    On IBM PCs and compatibles, MS-DOS and the programs that run under its
    control occupy the bottom 640 KB or less of the conventional memory
    space. The memory space above the 640 KB mark is partitioned among ROM
    (read-only memory) chips on the system board that contain various
    primitive device handlers and test programs and among RAM and ROM
    chips on expansion boards that are used for input and output buffers
    and for additional device-dependent routines.

    The bottom 640 KB of memory administered by MS-DOS is divided into
    three zones (Figure 9-1):

    ■  The interrupt vector table
    ■  The operating system area
    ■  The transient program area


    ┌────────────────────────┐  100000H  (1 MB)
    │       ROM BIOS         │
    │  additional ROM code   │
    │  on expansion boards,  │
    │   memory-mapped I/O    │
    └───┐   buffers          │
    ┌──┐└─────┐              │
    │  └─────┐└──────┐       │
    │        └──────┐└───────┘
    │               └────────┐
    ├────────────────────────┤  A0000H  (640 KB)
    │                        │
    │                        │
    │       Transient        │
    │     program area       │
    │                        │
    │                        │
    │                        │
    ├────────────────────────┤  Boundary varies
    │       MS-DOS and       │
    │  its buffers, tables,  │
    │   and device drivers   │
    ├────────────────────────┤  00400H  (1 KB)
    │ Interrupt vector table │
    └────────────────────────┘  00000H

    Figure 9-1. A diagram showing conventional memory in an IBM PC-
    compatible MS-DOS system. The bottom 1024 bytes of memory are used for
    the interrupt vector table. The memory above the vector table, up to
    the 640 KB boundary, is available for use by MS-DOS and the programs
    that run under its control. The top 384 KB are used for the ROM BIOS,
    other device-control and diagnostic routines, and memory-mapped input
    and output.


    The interrupt vector table occupies the lowest 1024 bytes of memory
    (locations 00000003FFH); its address and length are hard-wired into
    the processor and cannot be changed. Each doubleword position in the
    table is called an interrupt vector and contains the segment and
    offset of an interrupt handler routine for the associated hardware or
    software interrupt number. Interrupt handler routines are usually
    built into the operating system, but in special cases application
    programs can contain handler routines of their own. Vectors for
    interrupt numbers that are not used for software linkages or by some
    hardware device are usually initialized by the operating system to
    point to a simple interrupt return (IRET) instruction or to a routine
    that displays an error message.

    The operating-system area begins immediately above the interrupt
    vector table and holds the operating system proper, its tables and
    buffers, any additional installable device drivers specified in the
    CONFIG.SYS file, and the resident portion of the COMMAND.COM command
    interpreter. The amount of memory occupied by the operating-system
    area varies with the version of MS-DOS being used, the number of disk
    buffers, and the number and size of installed device drivers.

    The transient program area (TPA) is the remainder of RAM above the
    operating-system area, extending to the 640 KB limit or to the end of
    installed RAM (whichever is smaller). External MS-DOS commands (such
    as CHKDSK) and other programs are loaded into the TPA for execution.
    The transient portion of COMMAND.COM also runs in this area.

    The TPA is organized into a structure called the memory arena, which
    is divided into portions called arena entries (or memory blocks).
    These entries are allocated in paragraph (16-byte) multiples and can
    be as small as one paragraph or as large as the entire TPA. Each arena
    entry is preceded by a control structure called an arena entry header,
    which contains information indicating the size and status of the arena
    entry.

    MS-DOS inspects the arena entry headers whenever a function requesting
    a memory-block allocation, modification, or release is issued; when a
    program is loaded and executed with the EXEC function (Interrupt 21H
    Function 4BH); or when a program is terminated. If any of the arena
    entry headers appear to be damaged, MS-DOS returns an error to the
    calling process. If that process is COMMAND.COM, COMMAND.COM then
    displays the message Memory allocation error and halts the system.

MS-DOS support for conventional memory management

    The MS-DOS kernel supports three memory-management functions, invoked
    with Interrupt 21H, that operate on the TPA:

    ■  Function 48H (Allocate Memory Block)
    ■  Function 49H (Free Memory Block)
    ■  Function 4AH (Resize Memory Block)

    These three functions (Table 9-1) can be called by application
    programs, by the command processor, and by MS-DOS itself to
    dynamically allocate, resize, and release arena entries as they are
    needed. See SYSTEM CALLS: INTERRUPT 21H: Functions 48H; 49H; 4AH.


    Table 9-1. MS-DOS Memory-Management Functions.

╓┌───────────────────────────┌───────────────────────┌───────────────────────╖
    Function Name          Call With               Returns
    ──────────────────────────────────────────────────────────────────
    Allocate Memory Block  AH = 48H                AX = segment of
                            BX = paragraphs              allocated block
                                needed             If failed:
                                                    BX = size of largest
                                                        available block in
                                                        paragraphs

    Free Memory Block      AH = 49H                nothing
                            ES = segment of block
                                to release

    Resize (Allocated)     AH = 4AH                If failed:
    Memory Block           BX = new size of        BX = maximum size
                                block in paragraphs     for block in para-
                            ES = segment of block        graphs
                                to resize

    Get/Set Allocation     AH = 58H                If getting:
    Strategy               AL = 00H (get strategy) AX = strategy code
                            = 01H (set strategy)
                            If setting:
                            BX = strategy:
                                00H = first fit
                                01H = best fit
                                02H = last fit


    When the MS-DOS kernel receives a memory-allocation request, it
    inspects the chain of arena entry headers to find a free arena entry
    that can satisfy the request. The memory manager can use any of three
    allocation strategies:

    ■  First fit-the arena entry at the lowest address that is large
        enough to satisfy the request

    ■  Best fit-the smallest available arena entry that satisfies the
        request, regardless of its position

    ■  Last fit-the arena entry at the highest address that is large
        enough to satisfy the request

    If the arena entry selected is larger than the size needed to fulfill
    the request, the arena entry is divided and the program is given an
    arena entry exactly the size it requires. A new arena entry header is
    then created for the remaining portion of the original arena entry; it
    is marked "unowned" and can be used to satisfy subsequent allocation
    calls.

    Research on allocation strategies has demonstrated that the first-fit
    approach is most efficient, and this is the default strategy used by
    MS-DOS. However, in MS-DOS versions 3.0 and later, an application
    program can select a different strategy for the memory manager with
    Interrupt 21H Function 58H (Get/Set Allocation Strategy). See SYSTEM
    CALLS: INTERRUPT 21H: Function 58H.

Using the memory-management functions

    When a program begins executing, it already owns two arena entries
    allocated on its behalf by the MS-DOS EXEC function (Interrupt 21H
    Function 4BH). The first entry holds the program's environment and is
    just large enough to contain this information; the second entry
    (called the program block in this article) contains the program's PSP,
    code, data, and stack.

    The amount of memory MS-DOS allocates to the program block for a newly
    loaded transient program depends on its type (.COM or .EXE). Under
    typical conditions, a .COM program is allocated all of the first arena
    entry that is large enough to hold the contents of its file, plus 256
    bytes for the PSP and at least 2 bytes for the stack. Because the TPA
    is seldom fragmented into more than one arena entry before a program
    is loaded, a .COM program usually ends up owning all the memory in the
    system that does not belong to the operating system itself--memory
    divided between a relatively small environment and a comparatively
    immense program block.

    The amount of memory allocated to a .EXE program, on the other hand,
    is controlled by two fields called MINALLOC and MAXALLOC in the .EXE
    program file header. The MINALLOC field tells the MS-DOS loader how
    many paragraphs of memory, in addition to the memory required to hold
    the initialized code and the data present in the file, must be
    available for the program to execute at all. The MAXALLOC field
    contains the maximum number of excess paragraphs, if available, to
    allocate to the program.

    The default value placed in MAXALLOC by the Microsoft Object Linker is
    FFFFH paragraphs, corresponding to 1 MB. Consequently, a .EXE program
    is typically allocated all of available memory when it is loaded, as
    is a .COM file. Although it is possible to set the MAXALLOC field to
    other, smaller values with the linker's /CPARMAXALLOC switch or with
    the EXEMOD utility supplied with Microsoft language compilers, few
    programmers bother to do so.

    In short, when a program begins executing, it usually owns all of
    available memory-frequently much more memory than it needs. If the
    program wants to be well behaved in its use of memory and, possibly,
    load child programs as well, it should immediately release any extra
    memory. In assembly-language programs, the extra memory is released by
    calling Interrupt 21H Function 4AH (Resize Memory Block) with the
    segment of the program's PSP in the ES register and the number of
    paragraphs of memory to retain for the program's use in the BX
    register. (See Figures 9-2 and 9-3.) In most high-level languages,
    such as Microsoft C, excess memory is released by the run-time
    library's startup module.

    ──────────────────────────────────────────────────────────────────────

    Figure 9-2. An example of a .COM program releasing excess memory after
    it receives control from MS-DOS. Interrupt 21H Function 4AH is called
    with the segment address of the program's PSP in register ES and the
    number of paragraphs of memory to retain in register BX.

    ──────────────────────────────────────────────────────────────────────

    Figure 9-3. An example of a .EXE program releasing excess memory after
    it receives control from MS-DOS. This particular code sequence depends
    on the segment order shown. When a .EXE program is linked from many
    different object modules, other techniques may be needed to determine
    the amount of memory occupied by the program at run time.

    ──────────────────────────────────────────────────────────────────────

    Later, if the transient program needs additional memory for a buffer,
    table, or other work area, it can call Interrupt 21H Function 48H
    (Allocate Memory Block) with the desired number of paragraphs. If a
    sufficiently large block of memory is available, MS-DOS creates a new
    arena entry of the requested size and returns a pointer to its base in
    the form of a segment address in the AX register. If an arena entry of
    the requested size cannot be created, MS-DOS returns an error code in
    the AX register and the size in paragraphs of the largest available
    block of memory in the BX register. The application program can
    inspect this value to determine whether it can continue in a degraded
    fashion with a smaller amount of memory.

    When a program finishes using an allocated arena entry, it should
    promptly call Interrupt 21H Function 49H to release it. This allows
    MS-DOS to collect small blocks of freed memory into contiguous arena
    entries and reduces the chance that future allocation requests by the
    same program will fail because of memory fragmentation. In any case,
    all arena entries owned by a program are released when the program
    terminates with Interrupt 20H or with Interrupt 21H Function 00H or
    4CH.

    A program skeleton demonstrating the use of dynamic memory allocation
    services is shown in Figure 9-4.

    ──────────────────────────────────────────────────────────────────────

    Figure 9-4. A skeleton example of dynamic memory allocation. The
    program requests a 32 KB memory block, uses it to copy its working
    file to a backup file, and then releases the memory block. Note the
    use of ASSUME directives to force the assembler to generate proper
    segment overrides on references to variables containing file handles.

    ──────────────────────────────────────────────────────────────────────

Expanded Memory

    The original Expanded Memory Specification (EMS) version 3.0 was
    developed as a joint effort of Lotus Development Corporation and Intel
    Corporation and was announced at the Spring COMDEX in 1985. The EMS
    was designed to provide a uniform means for applications running on
    8086/8088-based personal computers, or on 80286/80386-based computers
    in real mode, to circumvent the 1 MB limit on conventional memory,
    thus providing such programs with much larger amounts of fast random-
    access storage. The EMS version 3.2, modified from 3.0 to add support
    for multitasking operating systems, was released shortly afterward as
    a joint effort of Lotus, Intel, and Microsoft.

    The EMS is a functional definition of a bank-switched memory
    subsystem; it consists of user-installable boards that plug into the
    IBM PC's expansion bus and a resident driver program called the
    Expanded Memory Manager (EMM) that is provided by the board
    manufacturer. As much as 8 MB of expanded memory can be installed in a
    single machine. Expanded memory is made available to application
    software in 16 KB pages, which are mapped by the EMM into a contiguous
    64 KB area called the page frame somewhere above the conventional
    memory area used by MS-DOS (0-640 KB). An application program can thus
    access as many as four 16 KB expanded memory pages simultaneously. The
    location of the page frame is user configurable so that it will not
    conflict with other hardware options (Figure 9-5).


                                                Expanded memory
                                                ┌────────────────┐ 8 MB
                        Conventional memory  ┌──├────────────────┤
                    1 MB ┌────────────────┐  │  ├────────────────┤
                        │                │  │  ├───────────┬────┘
                        │ ROM BIOS etc.  │  │  ├────┬──────┘┌───┐
                        ├────────────────┤  │  └────┘┌──────┴───┤
                        │                │  │┌─┌─────┴──────────┤
                        ├────────────────┤  ││ ├────────────────┤
                        ▒├────────────────┤─┘│ ├────────────────┤
        EMS page frame  ─▒├────────────────┤──┘ ├────────────────┤
    (four 16 KB pages)   ▒├────────────────┤──┐ ├────────────────┤
                        ├────────────────┤─┐│ ├────────────────┤
                        │                │  │└─├────────────────┤
                    640 KB ├────────────────┤  │  ├────────────────┤
                        │   Transient    │  │  ├────────────────┤
                        │  program area  │  │  ├────────────────┤
                        │                │  │  ├────────────────┤
                        ├────────────────┤  │  ├────────────────┤
                        │                │  │  ├────────────────┤
                        │     MS-DOS     │  │  ├────────────────┤
                    00400H ├────────────────┤  │  ├────────────────┤
                        │   Interrupt    │  └──├────────────────┤
                        │  vector table  │     ├────────────────┤
                        0 └────────────────┘     └────────────────┘ 0

    Figure 9-5. A sketch of the relationship of expanded memory to
    conventional memory; 16 KB pages of expanded memory are mapped into a
    64 KB area, called the page frame, above the 640 KB boundary. The
    location of the page frame can be configured by the user to eliminate
    conflicts with ROMs or I/O buffers on expansion boards.


The Expanded Memory Manager

    The Expanded Memory Manager provides a hardware-independent interface
    between application programs and the expanded memory board(s). The EMM
    is supplied by the board manufacturer in the form of an installable
    character-device driver and is linked into MS-DOS by a DEVICE
    directive added to the CONFIG.SYS file on the system startup disk.

    Internally, the EMM is divided into two distinct components that can
    be referred to as the driver and the manager. The driver portion
    mimics some of the actions of a genuine installable device driver, in
    that it includes Initialization and Output Status subfunctions and a
    valid device header. See PROGRAMMING IN THE MS-DOS ENVIRONMENT:
    CUSTOMIZING MS-DOS: Installable Device Drivers.

    The second, and major, element of the EMM is the true interface
    between application software and the expanded memory hardware. Several
    classes of services provide

    ■  Status of the expanded memory subsystem
    ■  Allocation of expanded memory pages
    ■  Mapping of logical pages into physical memory
    ■  Deallocation of expanded memory pages
    ■  Support for multitasking operating systems
    ■  Diagnostic routines

    Application programs communicate with the EMM directly by means of a
    software interrupt (Interrupt 67H). The MS-DOS kernel does not take
    part in expanded memory manipulations and does not use expanded memory
    for its own purposes.

Checking for expanded memory
    Before it attempts to use expanded memory for storage, an application
    program must establish that the EMM is present and functional, and
    then it must use the manager portion of the EMM to check the status of
    the memory boards themselves. There are two methods a program can use
    to test for the existence of the EMM.

    The first method is to issue an Open File or Device request (Interrupt
    21H Function 3DH) using the guaranteed device name of the EMM driver:
    EMMXXXX0. If the open operation succeeds, one of two conditions is
    indicated--either the driver is present or a file with the same name
    exists in the current directory of the default disk drive. To rule out
    the latter possibility, the application can issue IOCTL Get Device
    Information (Interrupt 21H Function 44H Subfunction 00H) and Check
    Output Status (Interrupt 21H Function 44H Subfunction 07H) requests to
    determine whether the handle returned by the open operation is
    associated with a file or with a device. In either case, the handle
    that was obtained from the open function should then be closed
    (Interrupt 21H Function 3EH) so that it can be reused for another file
    or device.

    The second method of testing for the driver is to use the address that
    is found in the vector for Interrupt 67H to inspect the device header
    of the presumed EMM. (The contents of the vector can be obtained
    conveniently with Interrupt 21H Function 35H.) If the EMM is present,
    the name field at offset 0AH of the device header contains the string
    EMMXXXX0. This method is nearly foolproof, and it avoids the
    relatively high overhead of an MS-DOS open function. However, it is
    somewhat less well behaved because it involves inspection of memory
    that does not belong to the application.

    The two methods of testing for the existence of the EMM are
    illustrated in Figures 9-6 and 9-7.

    ──────────────────────────────────────────────────────────────────────

    Figure 9-6. Testing for the presence of the Expanded Memory
    Manager with the MS-DOS Open File or Device (Interrupt 21H Function
    3DH) and IOCTL (Interrupt 21H Function 44H) functions.

    ──────────────────────────────────────────────────────────────────────

    Figure 9-7. Testing for the presence of the Expanded Memory
    Manager by inspecting the name field in the device driver header.

    ──────────────────────────────────────────────────────────────────────

Using expanded memory
    After establishing that the EMM is present, the application program
    can bypass MS-DOS and communicate with the EMM directly by means of
    software Interrupt 67H. The calling sequence is as follows:

        mov     ah,function       ; AH selects EMM function

        .                         ; Load other registers with
        .                         ; values specific to the
        .                         ; requested service

        int     67h               ; Transfer to EMM

    In general, the ES:DI registers are used to pass the address of a
    buffer or an array, and the DX register is used to hold an expanded
    memory "handle." Some EMM functions also use other registers (chiefly
    AL and BX) to pass such information as logical and physical page
    numbers. Table 9-2 summarizes the services available from the EMM.

    Upon return from an EMM function call, the AH register contains zero
    if the function was successful; otherwise, AH contains an error code
    with the most significant bit set (Table 9-3). Other values are
    typically returned in the AL and BX registers or in a user-specified
    buffer.


    Table 9-2. MS-DOS Summary of the Software Interface to
    Application Programs Provided by the EMM.

╓┌───────────────────────┌────────────────────────┌─────────────────────┌────────────────────────┌────────────────────────────────────────────────────────────────╖
    Function                                    Call
    Name               Action                   With                  Returns                  Comments
    ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
    Get Manager        Test whether the         AH - 40H              AH = status              This call is used after the program has established, with
    Status             expanded memory                                                         one of the techniques presented in Figures 9-6  and 9-7 ,
                        software and hardware                                                   that the EMM is present.
                        are functional.

    Get Page           Obtain the segment       AH = 41H              AH = status              The page frame is divided into four 16 KB pages that are
    Frame Segment      address of the EMM page                        BX = segment of page     used to map logical expanded memory pages into the
                        frame.                                              frame, if AH = 00H  physical memory space of the 8086/8088 processor.

    Get Expanded       Obtain an EMM handle     AH = 43H              AH = status              The application need not have already acquired an EMM
    Memory Pages       of logical expanded                            BX = unallocated EMM     handle to use this function.
                        memory pages present                                pages, if AH = 00H
                        in the system and the                          DX = total EMM pages in
                        number of pages that are                            system
                        not already allocated.

    Allocate           Obtain an EMM handle     AH = 43H              AH = status              This function is equivalent to a file-open function for the
    Expanded           and allocate logical     BX = logical pages    DX = handle, if          EMM. The handle returned is analogous to a file handle
    Memory             pages to be controlled        to allocate           AH = 00H            and owns a certain number of EMM pages. The handle
                        by that handle.                                                         must be used with every subsequent request to map
                                                                                                memory and must be released by a close operation when
                                                                                                the application is finished.

                                                                                                This function can fail because either the available EMM
                                                                                                handles or the EMM pages have been exhausted.
                                                                                                Function 42H can be called by the application to
                                                                                                determine the actual number of pages available.

    Map Memory         Map one of the logical   AH = 44H              AH = status              The logical page number must be in the range 0-n-1,
                        pages of expanded        AL = physical page                             where n is the number of logical pages previously
                        memory assigned to a          (0-3)                                     allocated to the EMM handle with Function 43H.
                        handle onto one of the   BX = logical page
                        four physical pages           (0...n-1)                                 To access the memory after it has been mapped to a
                        within the EMM's page    DX = EMM handle                                physical page, the application also needs the segment of
                        frame.                                                                  the EMM's page frame, which can be obtained with
                                                                                                Function 41H.

    Release Handle     Deallocate the logical   AH = 45H              AH = status              This function is the equivalent of a close operation on
    and Memory         pages of expanded        DX = EMM handle                                a file. It notifies the EMM that the application will not be
                        memory currently                                                        making further use of the data it may have stored within
                        assigned to a handle                                                    expanded memory pages.
                        and then release the
                        handle itself for reuse.

    Get EMM            Return the version       AH = 46H              AH = status              The returned value is the version of the EMM with which
    Version            number of the EMM                              AL = EMM version,        the driver complies. The version number is encoded as
                        software.                                           if AH = 00H         BCD, with the integer part in the upper 4 bits and the
                                                                                                fractional part in the lower 4 bits.

    Save Mapping       Save the contents of     AH = 47H              AH = status              This function is designed for use by interrupt handlers
    Context            the expanded memory      DX = EMM handle                                and resident drivers or utilities that must access expanded
                        page-mapping registers                                                  memory. The handle supplied to the function is the
                        on the expanded memory                                                  handle that was assigned to the interrupt handler during
                        boards, associating                                                     its initialization sequence, not to the program that was
                        those contents with a                                                   interrupted.
                        specific EMM handle.

    Restore            Restore the contents     AH = 48H              AH = status              Use of this function must be balanced by a previous call
    Mapping            of all expanded memory   DX = EMM handle                                to EMM Function 47H. It allows an interrupt handler or a
    Context            hardware page-mapping                                                   resident driver that used expanded memory to restore the
                        registers to the values                                                 mapping context to its state at the point of interruption.
                        associated with the
                        given handle.

    Get Number of      Return the number of     AH = 4BH              AH = status              If the number of handles returned is zero, none of the
    EMM Handles        active EMM handles.                            BX = number of EMM       expanded memory is in use. The number of active EMM
                                                                            handles, if         handles never exceeds 255.
                                                                            AH =00H
                                                                                                A single program can make several allocation requests
                                                                                                and therefore own several EMM handles.

    Get Pages          Return the number        AH = 4CH              AH = status              The number of pages returned if the function is success-
    Owned by           of logical expanded      DX = EMM handle       BX = logical pages,      ful is always in the range 1-512. An EMM handle never
    Handle             memory pages allocated                              if AH = 00H         has zero pages of memory allocated to it.
                        to a specific handle.

    Get Pages for      Return an array that     AH = 4DH              AH = status              The array is filled in with doubleword entries. The first
    All Handles        contains all the active  DI = offset of array  BX = number of active    word of each entry contains a handle; the second word
                        handles and the number        to receive            EMM handles         contains the number of pages associated with that handle.
                        of logical expanded           information                               The value returned in BX gives the number of valid
                        memory pages associated  ES = array segment    If AH = 00H, array is    doubleword entries in the array.
                        with each handle.                                   filled in as
                                                                            described in        Because 255 is the maximum number of EMM handles,
                                                                            comments column.    the array need not be larger than 1020 bytes.

    Get/Set            Save or set the          AH = 4EH              AH = status              Subfunctions:
    Page Map           contents of the EMM      AL = subfunction      AL = bytes in page-      00H = get mapping registers into array
                        page-mapping registers        number                mapping array       01H = set mapping registers from array
                        on the expanded memory   DS:SI = array              (Subfunction 03H)   02H = get and set mapping registers in one operation
                        boards.                       holding mapping                           03H = return needed size of page-mapping array
                                                    information      Array pointed to by
                                                    (Subfunctions    ES:DI receives map-      This function was added in EMM version 3.2 and is
                                                    01H, 02H)        ping information for     designed to support multitasking. It should not ordinarily
                                                ES:DI = array to      Subfunctions 00H and     be used by application programs.
                                                receive information   02H
                                                (Subfunctions 00H,                             The content of the array is hardware and EMM software
                                                02H)                                           dependent. In addition to the contents of the page-
                                                                                                mapping registers, it may contain other information that
                                                                                                is necessary to restore the expanded memory subsystem
                                                                                                to its previous state.

    Table 9-3. The Expanded Memory Manager (EMM) Error Codes.

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Error Code       Significance
    ──────────────────────────────────────────────────────────────────
    00H              Function was successful.

    80H              Internal error in the EMM software. Possible causes
                    include an error in the driver itself or damage to
                    its memory image.

    81H              Malfunction in the expanded memory hardware.

    82H              EMM is busy.

    83H              Invalid expanded memory handle.

    84H              Function requested by the application is not
                    supported by the EMM.

    85H              No more expanded memory handles available.

    86H              Error in save or restore of mapping context.

    87H              Allocation request specified more logical pages than
                    are available in the system; no pages were
                    allocated.

    88H              Allocation request specified more logical pages than
                    are currently available in the system (the request
                    does not exceed the physical pages that exist, but
                    some are already allocated to other handles); no
                    pages were allocated.

    89H              Zero pages cannot be allocated.

    8AH              Logical page requested for mapping is outside the
                    range of pages assigned to the handle.

    8BH              Illegal physical page number in mapping request (not
                    in the range 0-3).

    8CH              Save area for mapping contexts is full.

    8DH              Save of mapping context failed because save area
                    already contains a context associated with the
                    requested handle.

    8EH              Restore of mapping context failed because save area
                    does not contain a context for the requested handle.

    8FH              Subfunction parameter not defined.


    An application program that uses expanded memory should regard that
    memory as a system resource, such as a file or a device, and use only
    the documented EMM services to allocate, access, and release expanded
    memory pages. Here is the general strategy that can be used by such a
    program:

    1. Establish the presence of the EMM by one of the two methods
        demonstrated in Figures 9-6 and 9-7.

    2. After the driver is known to be present, check its operational
        status with EMM Function 40H.

    3. Check the version number of the EMM with EMM Function 46H to ensure
        that all services the application will request are available.

    4. Obtain the segment of the page frame used by the EMM with EMM
        Function 41H.

    5. Allocate the desired number of expanded memory pages with EMM
        Function 43H. If the allocation is successful, the EMM returns a
        handle in DX that is used by the application to refer to the
        expanded memory pages it owns. This step is exactly analogous to
        opening a file and using the handle obtained from the open function
        for subsequent read/write operations on the file.

    6. If the requested number of pages is not available, query the EMM
        for the actual number of pages available (EMM Function 42H) and
        determine whether the program can continue.

    7. After successfully allocating the number of expanded memory pages
        needed, use EMM Function 44H to map logical pages in and out of the
        physical page frame, to store and retrieve data in expanded memory.

    8. When finished using the expanded memory pages, release them by
        calling EMM Function 45H. Otherwise, the pages will not be
        available for use by other programs until the system is restarted.

    A program skeleton that illustrates this general approach to the use
    of expanded memory is shown in Figure 9-8.

    ──────────────────────────────────────────────────────────────────────

    Figure 9-8. A program skeleton for the use of expanded memory. This
    code assumes that the presence of the Expanded Memory Manager has
    already been verified with one of the techniques shown in Figures 9-6
    and 9-7.

    ──────────────────────────────────────────────────────────────────────

    An interrupt handler or resident driver that uses the EMM follows the
    same general procedure outlined in steps 1 through 8, with a few minor
    variations. It may need to acquire an EMM handle and allocate pages
    before the operating system is fully functional; in particular, the
    MS-DOS services Open File or Device (Interrupt 21H Function 3DH),
    IOCTL (Interrupt 21H Function 44H), and Get Interrupt Vector
    (Interrupt 21H Function 35H) cannot be assumed to be available. Thus,
    such a handler or driver must use a modified version of the "get
    interrupt vector" technique to test for the existence of the EMM,
    fetching the contents of the Interrupt 67H vector directly instead of
    using MS-DOS Interrupt 21H Function 35H.

    A device driver or interrupt handler typically owns its expanded
    memory pages on a permanent basis (until the system is restarted) and
    never deallocates them. Such a program must also take care to save
    (EMM Function 47H) and restore (EMM Function 48H) the EMM's page-
    mapping context (the EMM pages mapped into the page frame at the time
    the device driver or interrupt handler takes control of the system) so
    that use of the expanded memory by a foreground program will not be
    disturbed.

    The EMM relies heavily on the good behavior of application software to
    avoid the corruption of expanded memory. If several applications that
    use expanded memory are running under a multitasking manager, such as
    Microsoft Windows, and one or more of those applications does not
    abide strictly by the EMM's conventions, the data stored in expanded
    memory can be corrupted.


Extended Memory

    Extended memory is that storage at addresses above 1 MB (100000H) that
    can be accessed by an 80286 or 80386 microprocessor running in
    protected mode. IBM PC/AT-compatible machines can (theoretically) have
    as much as 15 MB of extended memory installed, in addition to the
    usual 1 MB of conventional memory address space. Unlike expanded
    memory, extended memory is linearly addressable: The address of each
    memory cell is fixed, so no special manager program is required.

    Protected-mode operating systems, such as Microsoft XENIX and MS OS/2,
    can use extended memory for execution of programs. MS-DOS, on the
    other hand, runs in real mode on an 80286 or 80386, and programs
    running under its control cannot ordinarily execute from extended
    memory or even address that memory for storage of data.

    To provide some access to extended memory for real-mode programs, IBM
    PC/ATcompatible machines contain two routines in their ROM BIOS
    (Tables 9-4 and 9-5) that allow the amount of extended memory present
    to be determined (Interrupt 15H Function 88H) and that transfer blocks
    of data between conventional memory and extended memory (Interrupt
    15H Function 87H). These routines can be used by electronic disks
    (RAMdisks) and by other programs that wish to use extended memory for
    fast storage and retrieval of information that would otherwise have to
    be written to a slower physical disk drive.


    Table 9-4. IBM PC/AT ROM BIOS Interrupt 15H Functions for
    Access to Extended Memory.

╓┌─────────────────────────────┌─────────────────────────┌───────────────────╖
    Interrupt 15H Function   Call With                 Returns
    ──────────────────────────────────────────────────────────────────────
    Move Extended            AH = 87H                  Carry flag =
    Memory Block             CX = length (words)         0 if successful
                                                        1 if error
                            ES:SI = address of block  AH = status:
                                    = move descriptor     00H no error
                                    = table               01H RAM parity
                                                        error
                                                        02H exception
                                                        interrupt error
                                                        03H gate address
                                                        line 20 failed
    Obtain Size of           AH = 88H                  AX = kilobytes of
    Extended Memory                                      memory installed
                                                        above 1 MB


    Table 9-5. Block Move Descriptor Table Format for IBM PC/AT ROM BIOS
    Interrupt 15H Function 87H (Move Extended Memory Block).

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Bytes       Contents
    ──────────────────────────────────────────────────────────────────
    00-0FH      Zero
    10-11H      Segment length in bytes (2*CX-1 or greater)
    12-14H      24-bit source address
    15H         Access rights byte (93H)
    16-17H      Zero
    18-19H      Segment length in bytes (2*CX-1 or greater)
    1A-1CH      24-bit destination address
    1DH         Access rights byte (93H)
    1E-1FH      Zero
    20-2FH      Zero


    Note: This data structure actually constitutes a global descriptor
    table (GDT) to be used by the CPU while it is running in protected
    mode; the zero bytes at offsets 0-0FH and 20-2FH are filled in by the
    ROM BIOS code before the mode transition. The supplied 24-bit address
    is a linear address in the range 000000-FFFFFFH (not a segment and
    offset), with the least significant byte first and the most
    significant byte last.

    Programmers should use these ROM BIOS routines with caution. Data
    stored in extended memory is volatile; it is lost if the machine is
    turned off. The transfer of data to or from extended memory involves a
    switch from real mode to protected mode and back again. This is a
    relatively slow process on 80286-based machines; in some cases it is
    only marginally faster than actually reading the data from a fixed
    disk. In addition, programs that use the ROM BIOS extended memory
    functions are not compatible with the MS-DOS 3.x Compatibility Box of
    MS OS/2, nor are they reliable if used for communications or
    networking.

    Finally, a major deficit in these ROM BIOS functions is that they do
    not make any attempt to arbitrate between two or more programs or
    device drivers that are using extended memory for temporary storage.
    For example, if an application program and an installed RAMdisk driver
    attempt to put data in the same area of extended memory, no error is
    returned to either program, but the data belonging to one or both may
    be destroyed.

    Figure 9-9 demonstrates the use of the ROM BIOS routines to transfer a
    block of data from extended memory to conventional memory.

    ──────────────────────────────────────────────────────────────────────

    Figure 9-9. Demonstration of a block move from extended memory to
    conventional memory using the ROM BIOS routine. The procedure
    getblk accepts a source address in extended memory, a destination
    address in conventional memory, a length in bytes, and the segment
    and offset of a block move descriptor table. The extended-memory
    address is a linear 32-bit address, of which only the lower 24 bits
    are significant; the conventional-memory address is a segment and
    offset. The getblk routine converts the destination segment and offset
    to a linear address, builds the appropriate fields in the block move
    descriptor table, invokes the ROM BIOS routine to perform the
    transfer, and returns the status in the AH register.

    ──────────────────────────────────────────────────────────────────────

Summary

    Personal computers that run MS-DOS can support as many as three
    different types of fast, random-access memory (RAM). Each type has
    specific characteristics and requires different techniques for its
    management.

    Conventional memory is the term used for the 1 MB of linear address
    space that can be accessed by an 8086 or 8088 microprocessor or by an
    80286 or 80386 microprocessor running in real mode. MS-DOS and the
    programs that execute under its control run in this address space.
    MS-DOS provides application programs with services to dynamically
    allocate and release blocks of conventional memory.

    As much as 8 MB of expanded memory can be installed in a PC and used
    for electronic disks, disk caching, and storage of application program
    data. The memory is made available in 16 KB pages and is administered
    by a driver program called the Expanded Memory Manager, which provides
    allocation, mapping, deallocation, and multitasking support.

    Extended memory refers to the memory at addresses above 1 MB that can
    be accessed by an 80286-based or 80386-based microprocessor running in
    protected mode; it is not available in PCs based on the 8086 or 8088
    microprocessors. As much as 15 MB of extended memory can be installed;
    however, the ROM BIOS services to access the memory are primitive and
    slow, and no manager is provided to arbitrate between multiple
    programs that attempt to use the same extended memory addresses for
    storage.

                                                Ray Duncan



Article 10: The MS-DOS EXEC Function


    The MS-DOS system loader, which brings .COM or .EXE files from disk
    into memory and executes them, can be invoked by any program with the
    MS-DOS EXEC function (Interrupt 21H Function 4BH). The default MS-DOS
    command interpreter, COMMAND.COM, uses the EXEC function to load and
    run its external commands, such as CHKDSK, as well as other
    application programs. Many popular commercial programs, such as
    databases and word processors, use EXEC to load and run subsidiary
    programs (spelling checkers, for example) or to load and run a second
    copy of COMMAND.COM. This allows a user to run subsidiary programs or
    enter MS-DOS commands without losing his or her current working
    context.

    When EXEC is used by one program (called the parent) to load and run
    another (called the child), the parent can pass certain information to
    the child in the form of a set of strings called the environment, a
    command line, and two file control blocks. The child program also
    inherits the parent program's handles for the MS-DOS standard devices
    and for any other files or character devices the parent has opened
    (unless the open operation was performed with the "noninheritance"
    option). Any operations performed by the child on inherited handles,
    such as seeks or file I/O, also affect the file pointers associated
    with the parent's handles. A child program can, in turn, load another
    program, and the cycle can be repeated until the system's memory area
    is exhausted.

    Because MS-DOS is not a multitasking operating system, a child program
    has complete control of the system until it has finished its work; the
    parent program is suspended. This type of processing is sometimes
    called synchronous execution. When the child terminates, the parent
    regains control and can use another system function call (Interrupt
    21H Function 4DH) to obtain the child's return code and determine
    whether the program terminated normally, because of a critical
    hardware error, or because the user entered a Control-C.

    In addition to loading a child program, EXEC can also be used to load
    subprograms and overlays for application programs written in assembly
    language or in a high-level language that does not include an overlay
    manager in its run-time library. Such overlays typically cannot be run
    as self-contained programs; most require "helper" routines or data in
    the application's root segment.

    The EXEC function is available only with MS-DOS versions 2.0 and
    later. With MS-DOS versions 1.x, a parent program can use Interrupt
    21H Function 26H to create a program segment prefix for a child but
    must carry out the loading, relocation, and execution of the child's
    code and data itself, without any assistance from the operating
    system.


How EXEC Works

    When the EXEC function receives a request to execute a program, it
    first attempts to locate and open the specified program file. If the
    file cannot be found, EXEC fails immediately and returns an error code
    to the caller.

    If the file exists, EXEC opens the file, determines its size, and
    stop inspects the first block of the file. If the first 2 bytes of the
    block are the ASCII characters MZ, the file is assumed to contain a
    .EXE load module, and the sizes of the program's code, data, and stack
    segments are obtained from the .EXE file header. Otherwise, the entire
    file is assumed to be an absolute load image (a .COM program). The
    actual filename extension (.COM or .EXE) is ignored in this
    determination.

    At this point, the amount of memory needed to load the program is
    known, so EXEC attempts to allocate two blocks of memory: one to hold
    the new program's environment and one to contain the program's code,
    data, and stack segments. Assuming that enough memory is available to
    hold the program itself, the amount actually allocated to the program
    varies with its type. Programs of the .COM type are usually given all
    the free memory in the system (unless the memory area has previously
    become fragmented), whereas the amount assigned to a .EXE program is
    controlled by two fields in the file header, MINALLOC and MAXALLOC,
    that are set by the Microsoft Object Linker (LINK). See PROGRAMMING IN
    THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: Structure of an
    Application Program; PROGRAMMING TOOLS: The Microsoft Object Linker;
    PROGRAMMING UTILITIES: LINK.

    EXEC then copies the environment from the parent into the memory
    allocated for child's environment, builds a program segment prefix
    (PSP) at the base of the child's program memory block, and copies into
    the child's PSP the command tail and the two default file control
    blocks passed by the parent. The previous contents of the terminate
    (Interrupt 22H), Control-C (Interrupt 23H), and critical error
    (Interrupt 24H) vectors are saved in the new PSP, and the terminate
    vector is updated so that control will return to the parent program
    when the child terminates or is aborted.

    The actual code and data portions of the child program are then read
    from the disk file into the program memory block above the newly
    constructed PSP. If the child is a .EXE program, a relocation table in
    the file header is used to fix up segment references within the
    program to reflect its actual load address.

    Finally, the EXEC function sets up the CPU registers and stack
    according to the program type and transfers control to the program.
    The entry point for a .COM file is always offset 100H within the
    program memory block (the first byte following the PSP). The entry
    point for a .EXE file is specified in the file header and can be
    anywhere within the program. See also PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: Structure of an Application
    Program.

    When EXEC is used to load and execute an overlay rather than a child
    program, its operation is much simpler than described above. For an
    overlay, EXEC does not attempt to allocate memory or build a PSP or
    environment. It simply loads the contents of the file at the address
    specified by the calling program and performs any necessary
    relocations (if the overlay file has a .EXE header), using a segment
    value that is also supplied by the caller. EXEC then returns to the
    program that invoked it, rather than transferring control to the code
    in the newly loaded file. The requesting program is responsible for
    calling the overlay at the appropriate location.


Using EXEC to Load a Program

    When one program loads and executes another, it must follow these
    steps:

    1. Ensure that enough free memory is available to hold the code, data,
        and stack of the child program.

    2. Set up the information to be passed to EXEC and the child program.

    3. Call the MS-DOS EXEC function to run the child program.

    4. Recover and examine the child program's termination and return
        codes.

Making memory available

    MS-DOS typically allocates all available memory to a .COM or .EXE
    program when it is loaded. (The infrequent exceptions to this rule
    occur when the transient program area is fragmented by the presence of
    resident data or programs or when a .EXE program is loaded that was
    linked with the /CPARMAXALLOC switch or modified with EXEMOD.)
    Therefore, before a program can load another program, it must free any
    memory it does not need for its own code, data, and stack.

    The extra memory is released with a call to the MS-DOS Resize Memory
    Block function (Interrupt 21H Function 4AH). In this case, the segment
    address of the parent's PSP is passed in the ES register, and the BX
    register holds the number of paragraphs of memory the program must
    retain for its own use. If the prospective parent is a .COM program,
    it must be certain to move its stack to a safe area if it is reducing
    its memory allocation to less than 64 KB.

Preparing parameters for EXEC

    When used to load and execute a program, the EXEC function must be
    supplied with two principal parameters:

    ■  The address of the child program's pathname
    ■  The address of a parameter block

    The parameter block, in turn, contains the addresses of information to
    be passed to the child program.

The program name

    The pathname for the child program must be an unambiguous, null-
    terminated (ASCIIZ) file specification (no wildcard characters). If
    a path is not included, the current directory is searched for the
    program; if a drive specifier is not present, the default drive is
    used.

The parameter block

    The parameter block contains the addresses of four data items
    Figure 10-1):

    ■  The environment block
    ■  The command tail
    ■  The two default file control blocks (FCBs)

    The position reserved in the parameter block for the pointer to an
    environment is only 2 bytes and contains a segment address, because an
    environment is always paragraph aligned (its address is always evenly
    divisible by 16); a value of 0000H indicates the parent program's
    environment should be inherited unchanged. The remaining three
    addresses are all doubleword addresses in the standard Intel format,
    with an offset value in the lower word and a segment value in the
    upper word.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 10-1 is found on page 324      ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 10-1. Synopsis of calling conventions for the MS-DOS EXEC
    function (Interrupt 21H Function 4BH), which can be used to load and
    execute child processes or overlays.


    The environment
    An environment always begins on a paragraph boundary and is composed
    of a series of null-terminated (ASCIIZ) strings of the form:

    name = variable

    The end of the entire set of strings is indicated by an additional
    null byte.

    If the environment pointer in the parameter block supplied to an EXEC
    call contains zero, the child simply acquires a copy of the parent's
    environment. The parent can, however, provide a segment pointer to a
    different or expanded set of strings. In either case, under MS-DOS
    versions 3.0 and later, EXEC appends the child program's fully
    qualified pathname to its environment block. The maximum size of an
    environment is 32 KB, so very large amounts of information can be
    passed between programs by this mechanism.

    The original, or master, environment for the system is owned by the
    command processor that is loaded when the system is turned on or
    restarted (usually COMMAND.COM). Strings are placed in the system's
    master environment by COMMAND.COM as a result of PATH, SHELL, PROMPT,
    and SET commands, with default values always present for the first
    two. For example, if an MS-DOS version 3.2 system is started from
    drive C and a PATH command is not present in the AUTOEXEC.BAT file nor
    a SHELL command in the CONFIG.SYS file, the master environment will
    contain the two strings:

    PATH =
    COMSPEC = C:\COMMAND.COM

    These specifications are used by COMMAND.COM to search for executable
    "external" commands and to find its own executable file on the disk so
    that it can reload its transient portion when necessary. When the
    PROMPT string is present (as a result of a previous PROMPT or SET
    PROMPT command), COMMAND.COM uses it to tailor the prompt displayed to
    the user.


    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F 0123456789ABCDEF
0000 43 4F 4D 53 50 45 43 3D 43 3A 5C 43 4F 4D 4D 41 COMSPEC=C:\COMMA
0010 4E 44 2E 43 4F 4D 00 50 52 4F 4D 50 54 3D 24 70 ND.COM.PROMPT=$p
0020 24 5F 24 64 20 20 20 24 74 24 68 24 68 24 68 24 $$d   $t$h$h$h$
0030 68 24 68 24 68 20 24 71 24 71 24 67 00 50 41 54 h$h$h $q$q$g.PAT
0040 48 3D 43 3A 5C 53 59 53 54 45 4D 3B 43 3A 5C 41 H=C:\SYSTEM;C:\A
0050 53 4D 3B 43 3A 5C 57 53 3B 43 3A 5C 45 54 48 45 SM;C:\WS;C:\ETHE
0060 52 4E 45 54 3B 43 3A 5C 46 4F 52 54 48 5C 50 43 RNET;C:\FORTH\PC
0070 33 31 3B 00 00 01 00 43 3A 5C 46 4F 52 54 48 5C 31;....C:\FORTH\
0080 50 43 33 31 5C 46 4F 52 54 48 2E 43 4F 4D 00    PC31\FORTH.COM.

    Figure 10-2. Dump of a typical environment under MS-DOS version
    3.2. This particular example contains the default COMSPEC parameter
    and two relatively complex PATH and PROMPT control strings that were
    set up by entries in the user's AUTOEXEC file. Note the two null bytes
    at offset 73H, which indicate the end of the environment. These bytes
    are followed by the pathname of the program that owns the environment.


    Other strings in the environment are used only for informational
    purposes by transient programs and do not affect the operation of the
    operating system proper. For example, the Microsoft C Compiler and the
    Microsoft Object Linker look in the environment for INCLUDE, LIB, and
    TMP strings that specify the location of include files, library files,
    and temporary working files. Figure 10-2 contains a hex dump of a
    typical environment block.

    The command tail
    The command tail to be passed to the child program takes the form of a
    byte indicating the length of the remainder of the command tail,
    followed by a string of ASCII characters terminated with an ASCII
    carriage return (0DH); the carriage return is not included in the
    length byte. The command tail can include switches, filenames, and
    other parameters that can be inspected by the child program and used
    to influence its operation. It is copied into the child program's PSP
    at offset 80H.

    When COMMAND.COM uses EXEC to run a program, it passes a command tail
    that includes everything the user typed in the command line except the
    name of the program and any redirection parameters. I/O redirection is
    processed within COMMAND.COM itself and is manifest in the behavior of
    the standard device handles that are inherited by the child program.
    Any other program that uses EXEC to run a child program must try to
    perform any necessary redirection on its own and must supply an
    appropriate command tail so that the child program will behave as
    though it had been loaded by COMMAND.COM.

    The default file control blocks
    The two default FCBs pointed to by the EXEC parameter block are copied
    into the child program's PSP at offsets 5CH and 6CH. See also
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: File
    and Record Management.

    Few of the currently popular application programs use FCBs for file
    and record I/O because FCBs do not support the hierarchical directory
    structure. But some programs do inspect the default FCBs as a quick
    way to isolate the first two switches or other parameters from the
    command tail. Therefore, to make its own identity transparent to the
    child program, the parent should emulate the action of COMMAND.COM by
    parsing the first two parameters of the command tail into the default
    FCBs. This can be conveniently accomplished with the MS-DOS function
    Parse Filename (Interrupt 21H Function 29H).

    If the child program does not require one or both of the default FCBs,
    the corresponding address in the parameter block can be initialized to
    point to two dummy FCBs in the application's memory space. These dummy
    FCBs should consist of 1 zero byte followed by 11 bytes containing
    ASCII blank characters (20H).

Running the child program

    After the parent program has constructed the necessary parameters, it
    can invoke the EXEC function by issuing Interrupt 21H with the
    registers set as follows:

    AH          = 4BH
    AL          = 00H (EXEC subfunction to load and execute program)
    DS:DX       = segment:offset of program pathname
    ES:BX       = segment:offset of parameter block

    Upon return from the software interrupt, the parent must test the
    carry flag to determine whether the child program did, in fact, run.
    If the carry flag is clear, the child program was successfully loaded
    and given control. If the carry flag is set, the EXEC function failed,
    and the error code returned in AX can be examined to determine why.
    The usual reasons are

    ■  The specified file could not be found.
    ■  The file was found, but not enough memory was free to load it.

    Other causes are uncommon and can be symptoms of more severe problems
    in the system as a whole (such as damage to disk files or to the
    memory image of MS-DOS). With MS-DOS versions 3.0 and later,
    additional details about the cause of an EXEC failure can be obtained
    by subsequently calling Interrupt 21H Function 59H (Get Extended Error
    Information).

    In general, supplying either an invalid address for an EXEC parameter
    block or invalid addresses within the parameter block itself does not
    cause a failure of the EXEC function, but may result in the child
    program behaving in unexpected ways.

Special considerations

    With MS-DOS versions 2.x, the previous contents of all the parent
    registers except for CS:IP can be destroyed after an EXEC call,
    including the stack pointer in SS:SP. Consequently, before issuing the
    EXEC call, the parent must push onto the stack the contents of any
    registers that it needs to preserve, and then it must save the stack
    segment and offset in a location that is addressable with the CS
    segment register. Upon return, the stack segment and offset can be
    loaded into SS:SP with code segment overrides, and then the other
    registers can be restored by popping them off the stack. With MS-DOS
    versions 3.0 and later, registers are preserved across an EXEC call in
    the usual fashion.

    Note: The code segments of Windows applications that use this
    technique should be given the IMPURE attribute.

    In addition, a bug in MS-DOS version 2.0 and in PC-DOS versions 2.0
    and 2.1 causes an arbitrary doubleword in the parent's stack segment
    to be destroyed during an EXEC call. When the parent is a .COM program
    and SS = PSP, the damaged location falls within the PSP and does no
    harm; however, in the case of a .EXE parent where DS = SS, the
    affected location may overlap the data segment and cause aberrant
    behavior or even a crash after the return from EXEC. This bug was
    fixed in MS-DOS versions 2.11 and later and in PC-DOS versions 3.0
    and later.

Examining the child program's return codes

    If the EXEC function succeeds, the parent program can call Interrupt
    21H Function 4DH (Get Return Code of Child Process) to learn whether
    the child executed normally to completion and passed back a return
    code or was terminated by the operating system because of an external
    event. Function 4DH returns

    AH   = termination type:

        = 00H   Child terminated normally (that is, exited via
                Interrupt 20H or Interrupt 21H Function 00H or Function
                4CH).

        = 01H   Child was terminated by user's entry of a Ctrl-C.

        = 02H   Child was terminated by critical error handler (either
                the user responded with A to the Abort, Retry, Ignore
                prompt from the system's default Interrupt 24H handler,
                or a custom Interrupt 24H handler returned to MS-DOS with
                action code = 02H in register AL).

        = 03H   Child terminated normally and stayed resident (that is,
                exited via Interrupt 21H Function 31H or Interrupt 27H).

    AL   = return code:

        = Value passed by the child program in register AL when it
            terminated with Interrupt 21H Function 4CH or 31H.

        = 00H if the child terminated using Interrupt 20H, Interrupt
            27H, or Interrupt 21H Function 00H.

    These values are only guaranteed to be returned once by Function 4DH.
    Thus, a subsequent call to Function 4DH, without an intervening EXEC
    call, does not necessarily return any useful information.
    Additionally, if Function 4DH is called without a preceding successful
    EXEC call, the returned values are meaningless.

Using COMMAND.COM with EXEC

    An application program can "shell" to MS-DOS--that is, provide the
    user with an MS-DOS prompt without terminating--by using EXEC to load
    and execute a secondary copy of COMMAND.COM with an empty command
    tail. The application can obtain the location of the COMMAND.COM disk
    file by inspecting its own environment for the COMSPEC string. The
    user returns to the application from the secondary command processor
    by typing exit at the COMMAND.COM prompt.

    Batch-file interpretation is carried out by COMMAND.COM, and a batch
    (.BAT) file cannot be called using the EXEC function directly.
    Similarly, the sequential search for .COM, .EXE, and .BAT files in all
    the locations specified in the environment's PATH variable is a
    function of COMMAND.COM, rather than of EXEC. To execute a batch file
    or search the system path for a program, an application program can
    use EXEC to load and execute a secondary copy of COMMAND.COM to use as
    an intermediary. The application finds the location of COMMAND.COM as
    described in the preceding paragraph, but it passes a command tail in
    the form:

    /C program parameter1 parameter2 ...

    where program is the .EXE, .COM, or .BAT file to be executed. When
    program terminates, the secondary copy of COMMAND.COM exits and
    returns control to the parent.

A parent and child example

    The source programs PARENT.ASM in Figure 10-3 and CHILD.ASM in Figure
    10-4 illustrate how one program uses EXEC to load another.

    ──────────────────────────────────────────────────────────────────────

    Figure 10-3. PARENT.ASM, source code for PARENT.EXE.

    ──────────────────────────────────────────────────────────────────────

    Figure 10-4. CHILD.ASM, source code for CHILD.EXE.

    ──────────────────────────────────────────────────────────────────────

    PARENT.ASM can be assembled and linked into the executable program
    PARENT.EXE with the following commands:

    C&gt;MASM PARENT;  &lt;Enter&gt;
    C&gt;LINK PARENT;  &lt;Enter&gt;

    Similarly, CHILD.ASM can be assembled and linked into the file
    CHILD.EXE as follows:

    C&gt;MASM CHILD;  &lt;Enter&gt;
    C&gt;LINK CHILD;  &lt;Enter&gt;

    When PARENT.EXE is executed with the command

    C&gt;PARENT  &lt;Enter&gt;

    PARENT reduces the size of its main memory block with a call to
    Interrupt 21H Function 4AH, to maximize the amount of free memory in
    the system, and then calls the EXEC function to load and execute
    CHILD.EXE.

    CHILD.EXE runs exactly as though it had been loaded directly by
    COMMAND.COM. CHILD resets the DS segment register to point to its own
    data segment, uses Interrupt 21H Function 40H to display a message on
    standard output, and then terminates using Interrupt 21H Function 4CH,
    passing a return code of zero.

    When PARENT.EXE regains control, it first checks the carry flag to
    determine whether the EXEC call succeeded. If the EXEC call failed,
    PARENT displays an error message and terminates with Interrupt 21H
    Function 4CH, itself passing a nonzero return code to COMMAND.COM to
    indicate an error.

    Otherwise, PARENT uses Interrupt 21H Function 4DH to obtain
    CHILD.EXE's termination type and return code, which it converts
    to ASCII and displays. PARENT then terminates using Interrupt 21H
    Function 4CH and passes a return code of zero to COMMAND.COM to
    indicate success. COMMAND.COM in turn receives control and displays
    a new user prompt.


Using EXEC to Load Overlays

    Loading overlays with the EXEC function is much less complex than
    using EXEC to run another program. The main program, called the root
    segment, must carry out the following steps to load and execute an
    overlay:

    1. Make a memory block available to receive the overlay.

    2. Set up the overlay parameter block to be passed to the EXEC
        function.

    3. Call the EXEC function to load the overlay.

    4. Execute the code within the overlay by transferring to it with a
        far call.

    The overlay itself can be constructed as either a memory image (.COM)
    or a relocatable (.EXE) file and need not be the same type as the root
    program. In either case, the overlay should be designed so that the
    entry point (or a pointer to the entry point) is at the beginning of
    the module after it is loaded. This allows the root and overlay mod-
    ules to be maintained separately and avoids a need for the root
    to have "magical" knowledge of addresses within the overlay.

    To prevent users from inadvertently running an overlay directly from
    the command line, overlay files should be assigned an extension other
    than .COM or .EXE. The most convenient method relates overlays to
    their root segment by assigning them the same filename but an
    extension such as .OVL or .OV1, .OV2, and so on.

Making memory available

    If EXEC is to load a child program successfully, the parent must
    release memory. In contrast, EXEC loads an overlay into memory that
    belongs to the calling program. If the root segment is a .COM program
    and has not explicitly released extra memory, the root segment program
    need only ensure that the system contains enough memory to load the
    overlay and that the overlay load address does not conflict with its
    own code, data, or stack areas.

    If the root segment program was loaded from a .EXE file, no
    straightforward way exists for it to determine unequivocally how much
    memory it already owns. The simplest course is for the program to
    release all extra memory, as discussed earlier in the section on
    loading a child program, and then use the MS-DOS memory allocation
    function (Interrupt 21H Function 48H) to obtain a new block of memory
    that is large enough to hold the overlay.

Preparing overlay parameters

    When it is used to load an overlay, the EXEC function requires two
    major parameters:

    ■  The address of the pathname for the overlay file
    ■  The address of an overlay parameter block

    As for a child program, the pathname for the overlay file must be an
    unambiguous ASCIIZ file specification (again, no wildcard characters),
    and it must include an explicit extension. As before, if a path and/or
    drive are not included in the pathname, the current directory and
    default drive are used.

    The overlay parameter block contains the segment address at which the
    overlay should be loaded and a fixup value to be applied to any
    relocatable items within the overlay file. If the overlay file is in
    .EXE format, the fixup value is typically the same as the load
    address; if the overlay is in memory-image (.COM) format, the fixup
    value should be zero. The EXEC function does not attempt to validate
    the load address or the fixup value or to ensure that the load address
    actually belongs to the calling program.

Loading and executing the overlay

    After the root segment program has prepared the filename of the
    overlay file and the overlay parameter block, it can invoke the EXEC
    function to load the overlay by issuing an Interrupt 21H with the
    registers set as follows:

    AH          = 4BH
    AL          = 03H (EXEC subfunction to load overlay)
    DS:DX       = segment:offset of overlay file pathname
    ES:BX       = segment:offset of overlay parameter block

    Upon return from Interrupt 21H, the root segment must test the carry
    flag to determine whether the overlay was loaded. If the carry flag is
    clear, the overlay file was located and brought into memory at the
    requested address. The overlay can then be entered by a far call and
    should exit back to the root segment with a far return.

    If the carry flag is set, the overlay file was not found or some other
    (probably severe) system problem was encountered, and the AX register
    contains an error code. With MS-DOS versions 3.0 and later, Interrupt
    21H Function 59H can be used to get more information about the EXEC
    failure. An invalid load address supplied in the overlay parameter
    block does not (usually) cause the EXEC function itself to fail but
    may result in the disconcerting message Memory Allocation Error,
    System Halted when the root program terminates.

An overlay example

    The source programs ROOT.ASM in Figure 10-5 and OVERLAY.ASM in Figure
    10-6 demonstrate the use of EXEC to load a program overlay. The
    program ROOT.EXE is executable from the MS-DOS prompt; it represents
    the root segment of an application. OVERLAY is constructed as a .EXE
    file (although it is named OVERLAY.OVL because it cannot be run alone)
    and represents a subprogram that can be loaded by the root segment
    when and if it is needed.

    ──────────────────────────────────────────────────────────────────────

    Figure 10-5. ROOT.ASM, source code for ROOT.EXE.

    ──────────────────────────────────────────────────────────────────────

    Figure 10-6. OVERLAY.ASM, source code for OVERLAY.OVL.

    ──────────────────────────────────────────────────────────────────────

    ROOT.ASM can be assembled and linked into the executable program
    ROOT.EXE with the following commands:

    C&gt;MASM ROOT;  &lt;Enter&gt;
    C&gt;LINK ROOT;  &lt;Enter&gt;

    OVERLAY.ASM can be assembled and linked into the file OVERLAY.OVL by
    typing

    C&gt;MASM OVERLAY;  &lt;Enter&gt;
    C&gt;LINK OVERLAY,OVERLAY.OVL;  &lt;Enter&gt;

    The Microsoft Object Linker will display the message

    Warning: no stack segment

    but this message can be ignored.

    When ROOT.EXE is executed with the command

    C&gt;ROOT  &lt;Enter&gt;

    it first shrinks its main memory block with a call to Interrupt 21H
    Function 4AH and then allocates a separate block for the overlay with
    Interrupt 21H Function 48H. Next, ROOT calls the EXEC function to load
    the file OVERLAY.OVL into the newly allocated memory block. If the
    EXEC function fails, ROOT displays an error message and terminates
    with Interrupt 21H Function 4CH, passing a nonzero return code to
    COMMAND.COM to indicate an error. If the EXEC function succeeds, ROOT
    saves the contents of its DS segment register and then enters the
    overlay through an indirect far call.

    The overlay resets the DS segment register to point to its own data
    segment, displays a message using Interrupt 21H Function 40H, and then
    returns. Note that the main procedure of the overlay is declared with
    the far attribute to force the assembler to generate the opcode for a
    far return.

    When ROOT regains control, it restores the DS segment register to
    point to its own data segment again and displays an additional
    message, also using Interrupt 21H Function 40H, to indicate that the
    overlay executed successfully. ROOT then terminates using Interrupt
    21H Function 4CH, passing a return code of zero to indicate success,
    and control returns to COMMAND.COM.

                                                Ray Duncan



───────────────────────────────────────────────────────────────────────────

Part C  Customizing MS-DOS



Article 11: Terminate-and-Stay-Resident Utilities


    The MS-DOS Terminate and Stay Resident system calls (Interrupt 21H
    Function 31H and Interrupt 27H) allow the programmer to install
    executable code or program data in a reserved block of RAM, where it
    resides while other programs execute. Global data, interrupt handlers,
    and entire applications can be made RAM-resident in this way. Programs
    that use the MS-DOS terminate-and-stay-resident capability are
    commonly known as TSR programs or TSRs.

    This article describes how to install a TSR in RAM, how to communicate
    with the resident program, and how the resident program can interact
    with MS-DOS. The discussion proceeds from a general description of the
    MS-DOS functions useful to TSR programmers to specific details about
    certain MS-DOS structural elements necessary to proper functioning of
    a TSR utility and concludes with two programming examples.

    Note: Microsoft cannot guarantee that the information in this article
    will be valid for future versions of MS-DOS.


Structure of a Terminate-and-Stay-Resident Utility

    The executable code and data in TSRs can be separated into RAM-
    resident and transient portions (Figure 11-1). The RAM-resident
    portion of a TSR contains executable code and data for an application
    that performs some useful function on demand. The transient portion
    installs the TSR; that is, it initializes data and interrupt handlers
    contained in the RAM-resident portion of the program and executes an
    MS-DOS Terminate and Stay Resident function call that leaves the RAM-
    resident portion in memory and frees the memory used by the transient
    portion. The code in the transient portion of a TSR runs when the .EXE
    or .COM file containing the program is executed; the code in the RAM-
    resident portion runs only when it is explicitly invoked by a fore-
    ground program or by execution of a hardware or software interrupt.


    Higher addresses ┌───────────────────────────┐
                    │                           │▒
                    │Initialization code &amp; data │▒─ Transient portion
                    │                           │▒   (executed when
                    ├───────────────────────────┤    .EXE file runs)
                    │                           │▒
                    │  Application code &amp; data  │▒
                    │                           │▒
                    ├───────────────────────────┤▒─ RAM-resident portion
                    │                           │▒
                    │     Monitor routines      │▒
                    │                           │▒
                    ├───────────────────────────┤
                    │  Program segment prefix   │
    Lower addresses └───────────────────────────┘

    Figure 11-1. Organization of a TSR program in memory.


    TSRs can be broadly classified as passive or active, depending on the
    method by which control is transferred to the RAM-resident program. A
    passive TSR executes only when another program explicitly transfers
    control to it, either through a software interrupt or by means of a
    long JMP or CALL. The calling program is not interrupted by the TSR,
    so the status of MS-DOS, the system BIOS, and the hardware is well
    defined when the TSR program starts to execute.

    In contrast, an active TSR is invoked by the occurrence of some event
    external to the currently running (foreground) program, such as a
    sequence of user keystrokes or a predefined hardware interrupt.
    Therefore, when it is invoked, an active TSR almost always
    interrupts some other program and suspends its execution. To avoid
    disrupting the interrupted program, an active TSR must monitor the
    status of MS-DOS, the ROM BIOS, and the hardware and take control of
    the system only when it is safe to do so.

    Passive TSRs are generally simpler in their construction than active
    TSRs because a passive TSR runs in the context of the calling program;
    that is, when the TSR executes, it assumes that it can use the calling
    program's program segment prefix (PSP), open files, current directory,
    and so on. See PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR
    MS-DOS: Structure of an Application Program. It is the calling
    program's responsibility to ensure that the hardware and MS-DOS are in
    a stable state before it transfers control to a passive TSR.

    An active TSR, on the other hand, is invoked asynchronously; that is,
    the status of the hardware, MS-DOS, and the executing foreground
    program is indeterminate when the event that invokes the TSR occurs.
    Therefore, active TSRs require more complex code. The RAM-resident
    portion of an active TSR must contain modules that monitor the
    operating system to determine when control can safely be transferred
    to the application portion of the TSR. The monitor routines typically
    test the status of keyboard input, ROM BIOS interrupt processing,
    hardware interrupt processing, and MS-DOS function processing. The TSR
    activates the application (the part of the RAM-resident portion that
    performs the TSR's main task) only when it detects the appropriate
    keyboard input and determines that the application will not interfere
    with interrupt and MS-DOS function processing.

Keyboard input

    An active TSR usually contains a RAM-resident module that examines
    keyboard input for a predetermined keystroke sequence called a "hot-
    key" sequence. A user executes the RAM-resident application by
    entering this hot-key sequence at the keyboard.

    The technique used in the TSR to monitor keyboard input depends on the
    keyboard hardware implementation. On computers in the IBM PC and PS/2
    families, the keyboard coprocessor generates an Interrupt 09H for each
    keypress. Therefore, a TSR can monitor user keystrokes by installing
    an interrupt handler (interrupt service routine, or ISR) for Interrupt
    09H. This handler can thus detect a specified hot-key sequence.

ROM BIOS interrupt processing

    The ROM BIOS routines in IBM PCs and PS/2s are not reentrant. An
    active TSR that calls the ROM BIOS must ensure that its code does not
    attempt to execute a ROM BIOS function that was already being executed
    by the foreground process when the TSR program took control of the
    system.

    The IBM ROM BIOS routines are invoked through software interrupts, so
    an active TSR can monitor the status of the ROM BIOS by replacing the
    default interrupt handlers with custom interrupt handlers that
    intercept the appropriate BIOS interrupts. Each of these interrupt
    handlers can maintain a status flag, which it increments before
    transferring control to the corresponding ROM BIOS routine and
    decrements when the ROM BIOS routine has finished executing. Thus, the
    TSR monitor routines can test these flags to determine when non-
    reentrant BIOS routines are executing.

Hardware interrupt processing

    The monitor routines of an active TSR, which may themselves be
    executed as the result of a hardware interrupt, should not activate
    the application portion of the TSR if any other hardware interrupt is
    being processed. On IBM PCs, for example, hardware interrupts are
    processed in a prioritized sequence determined by an Intel 8259A
    Programmable Interrupt Controller. The 8259A does not allow a hardware
    interrupt to execute if a previous interrupt with the same or higher
    priority is being serviced. All hardware interrupt handlers include
    code that signals the 8259A when interrupt processing is completed.
    (The programming interface to the 8259A is described in IBM's
    Technical Reference manuals and in Intel's technical literature.)

    If a TSR were to interrupt the execution of another hardware interrupt
    handler before the handler signaled the 8259A that it had completed
    its interrupt servicing, subsequent hardware interrupts could be
    inhibited indefinitely. Inhibition of high-priority hardware
    interrupts such as the timer tick (Interrupt 08H) or keyboard
    interrupt (Interrupt 09H) could cause a system crash. For this reason,
    an active TSR must monitor the status of all hardware interrupt
    processing by interrogating the 8259A to ensure that control is
    transferred to the RAM-resident application only when no other
    hardware interrupts are being serviced.

MS-DOS function processing

    Unlike the IBM ROM BIOS routines, MS-DOS is reentrant to a limited
    extent. That is, there are certain times when MS-DOS's servicing of an
    Interrupt 21H function call invoked by a foreground process can be
    suspended so that the RAM-resident application can make an Interrupt
    21H function call of its own. For this reason, an active TSR must
    monitor operating system activity to determine when it is safe for the
    TSR application to make its calls to MS-DOS.

MS-DOS Support for Terminate-and-Stay-Resident Programs

    Several MS-DOS system calls are useful for supporting terminate-and-
    stay-resident utilities. These are listed in Table 11-1. See SYSTEM
    CALLS.


    Table 11-1. MS-DOS Functions Useful in TSR Programs.

╓┌─────────────────────┌─────────────────────┌───────────────┌───────────────╖
    Function Name    Call With             Returns         Comment
    ──────────────────────────────────────────────────────────────────
    Terminate and    AH = 31H              Nothing         Preferred over
    Stay Resident    AL = return code                        Interrupt 27H
                    DX = size of resident                   with MS-DOS
                        program (in 16-byte                   versions 2.x
                        paragraphs)                           and later
                    INT 21H

    Terminate and    CS = PSP              Nothing         Provided for
    Stay Resident    DX = size of resident                   compatibility
                        program (bytes)                       with MS-DOS
                                                            versions 1.x
                    INT 27H

    Set Interrupt    AH = 25H              Nothing
    Vector           AL = interrupt number
                    DS:DX = address of
                        interrupt handler
                    INT 21H

    Get Interrupt    AH = 35H              ES:BX = address
    Vector           AL = interrupt number   of interrupt
                    INT 21H                 handler

    Set PSP Address  AH = 50H              Nothing
                    BX = PSP segment
                    INT 21H

    Get PSP Address  AH = 51H              BX = PSP segment
                    INT 21H

    Set Extended     AX = 5D0AH            Nothing         MS-DOS versions
    Error            DS:DX = address of 11-                  3.1 and
    Information        word data structure:                  later
                        word 0: register AX
                        as returned by
                        Function 59H
                        word 1: register BX
                        word 2: register CX
                        word 3: register DX
                        word 4: register SI
                        word 5: register DI
                        word 6: register DS
                        word 7: register ES
                        words 8-0AH: reserved;
                        should be 0
                    INT 21H

    Get Extended     AH = 59H              AX = extended
    Error            BX = 0                  error code
    Information      INT 21H               BH = error class
                                            BL = suggested
                                            action
                                            CH = error locus

    Set Disk         AH = 1AH              Nothing
    Transfer Area    DS:DX = address
    Address            of DTA

    Get Disk         AH = 2FH              ES:BX = address
    Transfer Area    INT 21H                 of current DTA
    Address

    Get InDOS Flag   AH = 34H              ES:BX = address
    Address          INT 21H                 of InDOS flag


Terminate-and-stay-resident functions

    MS-DOS provides two mechanisms for terminating the execution of a
    program while leaving a portion of it resident in RAM. The preferred
    method is to execute Interrupt 21H Function 31H.

Interrupt 21H Function 31H
    When this Interrupt 21H function is called, the value in DX specifies
    the amount of RAM (in paragraphs) that is to remain allocated after
    the program terminates, starting at the program segment prefix (PSP).
    The function is similar to Function 4CH (Terminate Process with Return
    Code) in that it passes a return code in AL, but it differs in that
    open files are not automatically closed by Function 31H.

Interrupt 27H
    When Interrupt 27H is executed, the value passed in DX specifies the
    number of bytes of memory required for the RAM-resident program. MS-
    DOS converts the value passed in DX from bytes to paragraphs, sets AL
    to zero, and jumps to the same code that would be executed for
    Interrupt 21H Function 31H. Interrupt 27H is less flexible than
    Interrupt 21H Function 31H because it limits the size of the program
    that can remain resident in RAM to 64 KB, it requires that CS point to
    the base of the PSP, and it does not pass a return code. Later
    versions of MS-DOS support Interrupt 27H primarily for compatibility
    with versions 1.x.

TSR RAM management
    In addition to the RAM explicitly allocated to the TSR by means of the
    value in DX, the RAM allocated to the TSR's environment remains
    resident when the installation portion of the TSR program terminates.
    (The paragraph address of the environment is found at offset 2CH in
    the TSR's PSP.) Moreover, if the installation portion of a TSR program
    has used Interrupt 21H Function 48H (Allocate Memory Block) to
    allocate additional RAM, this memory also remains allocated when the
    program terminates. If the RAM-resident program does not need this
    additional RAM, the installation portion of the TSR program should
    free it explicitly by using Interrupt 21H Function 49H (Free Memory
    Block) before executing Interrupt 21H Function 31H.

Set and Get Interrupt Vector functions

    Two Interrupt 21H function calls are available to inspect or update
    the contents of a specified 8086-family interrupt vector. Function 25H
    (Set Interrupt Vector) updates the vector of the interrupt number
    specified in the AL register with the segment and offset values
    specified in DS:DX. Function 35H (Get Interrupt Vector) performs the
    inverse operation: It copies the current vector of the interrupt
    number specified in AL into the ES:BX register pair.

    Although it is possible to manipulate interrupt vectors directly, the
    use of Interrupt 21H Functions 25H and 35H is generally more
    convenient and allows for upward compatibility with future versions of
    MS-DOS.

Set and Get PSP Address functions

    MS-DOS uses a program's PSP to keep track of certain data unique to
    the program, including command-line parameters and the segment address
    of the program's environment. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: Structure of an Application
    Program. To access this information, MS-DOS maintains an internal
    variable that always contains the location of the PSP associated with
    the foreground process. When a RAM-resident application is activated,
    it should use Interrupt 21H Functions 50H (Set Program Segment Prefix
    Address) and 51H (Get Program Segment Prefix Address) to preserve the
    current contents of this variable and to update the variable with the
    location of its own PSP. Function 50H (Set Program Segment Prefix
    Address) updates an internal MS-DOS variable that locates the PSP
    currently in use by the foreground process. Function 51H (Get Program
    Segment Prefix Address) returns the contents of the internal MS-DOS
    variable to the caller.

Set and Get Extended Error Information functions

    In MS-DOS versions 3.1 and later, the RAM-resident program should
    preserve the foreground process's extended error information so that,
    if the RAM-resident application encounters an MS-DOS error, the
    extended error information pertaining to the foreground process will
    still be available and can be restored. Interrupt 21H Functions 59H
    and 5D0AH provide a mechanism for the RAM-resident program to save and
    restore this information during execution of a TSR application.

    Function 59H (Get Extended Error Information), which became available
    in version 3.0, returns detailed information on the most recently
    detected MS-DOS error. The inverse operation is performed by Function
    5D0AH (Set Extended Error Information), which can be used only in
    MS-DOS versions 3.1 and later. This function copies extended error
    information to MS-DOS from a data structure defined in the calling
    program.

Set and Get Disk Transfer Area Address functions

    Several MS-DOS data transfer functions, notably Interrupt 21H
    Functions 21H, 22H, 27H, and 28H (the Random Read and Write functions)
    and Interrupt 21H Functions 14H and 15H (the Sequential Read and Write
    functions), require a program to specify a disk transfer area (DTA).
    By default, a program's DTA is located at offset 80H in its program
    segment prefix. If a RAM-resident application calls an MS-DOS function
    that uses a DTA, the TSR should save the DTA address belonging to the
    interrupted program by using Interrupt 21H Function 2FH (Get Disk
    Transfer Area Address), supply its own DTA address to MS-DOS using
    Interrupt 21H Function 1AH (Set Disk Transfer Area Address), and then,
    before terminating, restore the interrupted program's DTA.

The MS-DOS idle interrupt (Interrupt 28H)

    Several of the first 12 MS-DOS functions (01H through 0CH) must wait
    for the occurrence of an expected event such as a user keypress. These
    functions contain an "idle loop" in which looping continues until the
    event occurs. To provide a mechanism for other system activity to take
    place while the idle loop is executing, these MS-DOS functions execute
    an Interrupt 28H from within the loop.

    The default MS-DOS handler for Interrupt 28H is only an IRET
    instruction. By supplying its own handler for Interrupt 28H, a TSR can
    perform some useful action at times when MS-DOS is otherwise idle.
    Specifically, a custom Interrupt 28H handler can be used to examine
    the current status of the system to determine whether or not it is
    safe to activate the RAM-resident application.


Determining MS-DOS Status

    A TSR can infer the current status of MS-DOS from knowledge of its
    internal use of stacks and from a pair of internal status flags. This
    status information is essential to the proper execution of an active
    TSR because a RAM-resident application can make calls to MS-DOS only
    when those calls will not disrupt an earlier call made by the
    foreground process.

MS-DOS internal stacks

    MS-DOS versions 2.0 and later may use any of three internal stacks:
    the I/O stack (IOStack), the disk stack (DiskStack), and the auxiliary
    stack (AuxStack). In general, IOStack is used for Interrupt 21H
    Functions 01H through 0CH and DiskStack is used for the remaining
    Interrupt 21H functions; AuxStack is normally used only when MS-DOS
    has detected a critical error and subsequently executed an Interrupt
    24H. See PROGRAMMING IN THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS:
    Exception Handlers. Specifically, MS-DOS's internal stack use depends
    on which MS-DOS function is being executed and on the value of the
    critical error flag.

The critical error flag

    The critical error flag (ErrorMode) is a 1-byte flag that MS-DOS uses
    to indicate whether or not a critical error has occurred. During
    normal, errorless execution, the value of the critical error flag
    is zero. Whenever MS-DOS detects a critical error, it sets this flag
    to a nonzero value before it executes Interrupt 24H. If an Interrupt
    24H handler subsequently invokes an MS-DOS function by using Interrupt
    21H, the nonzero value of the critical error flag tells MS-DOS to use
    its auxiliary stack for Interrupt 21H Functions 01H through 0CH
    instead of using the I/O stack as it normally would.

    In other words, when control is transferred to MS-DOS through
    Interrupt 21H, the function number and the critical error flag
    together determine MS-DOS stack use for the function. Figure 11-2
    outlines the internal logic used on entry to an MS-DOS function to
    select which stack is to be used during processing of the function.
    AS stated above, for Functions 01H through 0CH, MS-DOS uses IOStack if
    the critical error flag is zero and AuxStack if the flag is nonzero.
    For function numbers greater than 0CH, MS-DOS usually uses DiskStack,
    but Functions 50H, 51H, and 59H are important exceptions. Functions
    50H and 51H use either IOStack (in versions 2.x) or the stack supplied
    by the calling program (in versions 3.x). In version 3.0, Function 59H
    uses either IOStack or AuxStack, depending on the value of the
    critical error flag, but in versions 3.1 and later, Function 59H
    always uses AuxStack.


    MS-DOS versions 2.x

    if   (FunctionNumber &gt;= 01H and FunctionNumber &lt;= 0CH)
        or
        FunctionNumber = 50H
        or
        FunctionNumber = 51H

    then if   ErrorMode = 0
        then use IOStack
        else use AuxStack

    else ErrorMode = 0
        use DiskStack

    MS-DOS version 3.0

    if   FunctionNumber = 50H
        or
        FunctionNumber = 51H
        or
        FunctionNumber = 62H

    then use caller's stack

    else if   (FunctionNumber &gt;= 01H and FunctionNumber &lt;= 0CH)
            or
            Function Number = 59H

        then if   ErrorMode = 0
            then use IOStack
            else use AuxStack

        else ErrorMode = 0
            use DiskStack

    MS-DOS versions 3.1 and later

    if   FunctionNumber = 33H
        or
        FunctionNumber = 50H
        or
        FunctionNumber = 51H
        or
        FunctionNumber = 62H

    then use caller's stack

    else if   (FunctionNumber &gt;= 01H and FunctionNumber &lt;= 0CH)

        then if   ErrorMode = 0
            then use IOStack
            else use AuxStack

        else if   FunctionNumber = 59H
            then use AuxStack
            else ErrorMode = 0
                    use DiskStack

    Figure 11-2. Strategy for use of MS-DOS internal stacks.


    This scheme makes Functions 01H through 0CH reentrant in a limited
    sense, in that a substitute critical error (Interrupt 24H) handler
    invoked while the critical error flag is nonzero can still use these
    Interrupt 21H functions. In this situation, because the flag is
    nonzero, AuxStack is used for Functions 01H through 0CH instead of
    IOStack. Thus, if IOStack is in use when the critical error is
    detected, its contents are preserved during the handler's subsequent
    calls to these functions.

    The stack-selection logic differs slightly between MS-DOS versions 2
    and 3. In versions 3.x, a few functions--notably 50H and 51H--avoid
    using any of the MS-DOS stacks. These functions perform uncomplicated
    tasks that make minimal demands for stack space, so the calling
    program's stack is assumed to be adequate for them.

The InDOS flag

    InDOS is a 1-byte flag that is incremented each time an Interrupt 21H
    function is invoked and decremented when the function terminates. The
    flag's value remains nonzero as long as code within MS-DOS is being
    executed. The value of InDOS does not indicate which internal stack
    MS-DOS is using.

    Whenever MS-DOS detects a critical error, it zeros InDOS before it
    executes Interrupt 24H. This action is taken to accommodate substitute
    Interrupt 24H handlers that do not return control to MS-DOS. If InDOS
    were not zeroed before such a handler gained control, its value would
    never be decremented and would therefore be incorrect during
    subsequent calls to MS-DOS.

    The address of the 1-byte InDOS flag can be obtained from MS-DOS by
    using Interrupt 21H Function 34H (Return Address of InDOS Flag). In
    versions 3.1 and later, the 1-byte critical error flag is located in
    the byte preceding InDOS, so, in effect, the address of both flags can
    be found using Function 34H. Unfortunately, there is no easy way to
    find the critical error flag in other versions. The recommended
    technique is to scan the MS-DOS segment, which is returned in the ES
    register by Function 34H, for one of the following sequences of
    instructions:

            test    ss:[CriticalErrorFlag],0FFH      ;(versions 3.1 and
                                                    ;later)
            jne     NearLabel
            push    ss:[NearWord]
            int     28H

    or

            cmp     ss:[CriticalErrorFlag],00        ;(versions earlier
                                                    ;than 3.1)
            jne     NearLabel
            int     28H

    When the TEST or CMP instruction has been identified, the offset of
    the critical error flag can be obtained from the instruction's operand
    field.


The Multiplex Interrupt

    The MS-DOS multiplex interrupt (Interrupt 2FH) provides a general
    mechanism for a program to verify the presence of a TSR and
    communicate with it. A program communicates with a TSR by placing an
    identification value in AH and a function number in AL and issuing an
    Interrupt 2FH. The TSR's Interrupt 2FH handler compares the value in
    AH to its own predetermined ID value. If they match, the TSR's handler
    keeps control and performs the function specified in the AL register.
    If they do not match, the TSR's handler relinquishes control to the
    previously installed Interrupt 2FH handler. (Multiplex ID values 00H
    through 7FH are reserved for use by MS-DOS; therefore, user multiplex
    numbers should be in the range 80H through 0FFH.)

    The handler in the following example recognizes only one function,
    corresponding to AL = 00H. In this case, the handler returns the value
    0FFH in AL, signifying that the handler is indeed resident in RAM.
    Thus, a program can detect the presence of the handler by executing
    Interrupt 2FH with the handler's ID value in H and 00H in AL.

            mov     ah,MultiplexID
            mov     al,00H
            int     2FH
            cmp     al,0FFH
            je      AlreadyInstalled

    To ensure that the identification byte is unique, its value should be
    determined at the time the TSR is installed. One way to do this is to
    pass the value to the TSR program as a command-line parameter when the
    TSR program is installed. Another approach is to place the
    identification value in an environment variable. In this way, the
    value can be found in the environment of both the TSR and any other
    program that calls Interrupt 2FH to verify the TSR's presence.

    In practice, the multiplex interrupt can also be used to pass
    information to and from a RAM-resident program in the CPU registers,
    thus providing a mechanism for a program to share control or status
    information with a TSR.


TSR Programming Examples

    One effective way to become familiar with TSRs is to examine
    functional programs. Therefore, the subsequent pages present two
    examples: a simple passive TSR and a more complex active TSR.

HELLO.ASM

    The "bare-bones" TSR in Figure 11-3 is a passive TSR. The RAM-resident
    application, which simply displays the message Hello, World, is
    invoked by executing a software interrupt. This example illustrates
    the fundamental interactions among a RAM-resident program, MS-DOS, and
    programs that execute after the installation of the RAM-resident
    utility.

    ──────────────────────────────────────────────────────────────────────

    Figure 11-3. HELLO.ASM, a passive TSR.

    ──────────────────────────────────────────────────────────────────────

    The transient portion of the program (in the segments TRANSIENT_TEXT
    and TRANSIENT_STACK) runs only when the file HELLO.EXE is executed.
    This installation code updates an interrupt vector to point to the
    resident application (the procedure TSRAction) and then calls
    Interrupt 21H Function 31H to terminate execution, leaving the
    segments RESIDENT_TEXT and RESIDENT_DATA in RAM.

    The order in which the code and data segments appear in the listing is
    important. It ensures that when the program is executed as a .EXE
    file, the resident code and data are placed in memory at lower
    addresses than the transient code and data. Thus, when Interrupt 21H
    Function 31H is called, the memory occupied by the transient portion
    of the program is freed without disrupting the code and data in the
    resident portion.

    The RAM containing the resident portion of the utility is left intact
    by MS-DOS during subsequent execution of other programs. Thus, after
    the TSR has been installed, any program that issues the software
    interrupt recognized by the TSR (in this example, Interrupt 64H) will
    transfer control to the routine TSRAction, which uses Interrupt 21H
    Function 40H to display a simple message on standard output.

    Part of the reason this example is so short is that it performs no
    error checking. A truly reliable version of the program would check
    the version of MS-DOS in use, verify that the program was not already
    installed in memory, and chain to any previously installed interrupt
    handlers that use the same interrupt vector. (The next program,
    SNAP.ASM, illustrates these techniques.)  However, the primary reason
    the program is small is that it makes the basic assumption that MS-
    DOS, the ROM BIOS, and the hardware interrupts are all stable at the
    time the resident utility is executed.

SNAP.ASM

    The preceding assumption is a reliable one in the case of the passive
    TSR in Figure 11-3, which executes only when it is explicitly invoked
    by a software interrupt. However, the situation is much more
    complicated in the case of the active TSR in Figure 11-4. This program
    is relatively long because it makes no assumptions about the stability
    of the operating environment. Instead, it monitors the status of
    MS-DOS, the ROM BIOS, and the hardware interrupts to decide when the
    RAM-resident application can safely execute.

    ──────────────────────────────────────────────────────────────────────


    Figure 11-4. SNAP.ASM, a video snapshot TSR.

    ──────────────────────────────────────────────────────────────────────

    When installed, the SNAP program monitors keyboard input until the
    user types the hot-key sequence Alt-Enter. When the hot-key sequence
    is detected, the monitoring routine waits until the operating
    environment is stable and then activates the RAM-resident application,
    which dumps the current contents of the computer's video buffer into
    the file SNAP.IMG. Figure 11-5 is a block diagram of the RAM-resident
    and transient components of this TSR.


Higher addresses ┌─────────────────────────────┐
                │       Transient data        │ TRANSIENT _DATA segment
                ├─────────────────────────────┤
                │       InstallSnapTSR        │ TRANSIENT _TEXT segment
                │ Initialization code &amp; data  │
                ├─────────────────────────────┤
                │     RAM-resident stack      │ RESIDENT _STACK segment
                ├─────────────────────────────┤
                │      RAM-resident data      │ RESIDENT _DATA segment
                ├─────────────────────────────┤
                │           TSRapp            │▒
                │  RAM-resident application   │▒
                ├─────────────────────────────┤▒
                │       ISR2F$--INT 2FH       │▒
                │(multiplex interrupt) handler│▒
                ├─────────────────────────────┤▒
                │       ISR28--INT 28H        │▒
                │(DOS idle interrupt) handler │▒
                ├─────────────────────────────┤▒
                │       ISR24--INT 24H        │▒
                │  (critical error) handler   │▒
                ├─────────────────────────────┤▒
                │       ISR23--INT 23H        │▒
Middle addresses │     (Control-C) handler     │▒ RESIDENT _TEXT segment
                ├─────────────────────────────┤▒
                │       ISR1B--INT 1BH        │▒
                │   (Control-Break) handler   │▒
                ├─────────────────────────────┤▒
                │       ISR13--INT 13H        │▒
                │(BIOS fixed-disk I/O) handler│▒
                ├─────────────────────────────┤▒
                │       ISR10--INT 10H        │▒
                │  (BIOS video I/O) handler   │▒
                ├─────────────────────────────┤▒
                │        ISR9--INT 09H        │▒
                │(keyboard interrupt) handler │▒
                ├─────────────────────────────┤▒
                │        ISR8--INT 08H        │▒
                │  (timer interrupt) handler  │▒
                ├─────────────────────────────┤▒
                │        ISR5--INT 05H        │▒
                │ (BIOS print screen) handler │▒
Lower addresses └─────────────────────────────┘

    Figure 11-5. Block structure of the TSR program SNAP.EXE when loaded
    into memory. (Compare with Figure 11-1.)


Installing the program
    When SNAP.EXE is run, only the code in the transient portion of the
    program is executed. The transient code performs several operations
    before it finally executes Interrupt 21H Function 31H (Terminate and
    Stay Resident). First it determines which MS-DOS version is in use.
    Then it executes the multiplex interrupt (Interrupt 2FH) to discover
    whether the resident portion has already been installed. If an MS-DOS
    version earlier than 2.0 is in use or if the resident portion has
    already been installed, the program aborts with an error message.

    Otherwise, installation continues. The addresses of the InDOS and
    critical error flags are saved in the resident data segment. The
    interrupt service routines in the RAM-resident portion of the program
    are installed by updating all relevant interrupt vectors. The
    transient code then frees the RAM occupied by the program's
    environment, because the resident portion of this program never uses
    the information contained there. Finally, the transient portion of the
    program, which includes the TRANSIENT_TEXT and TRANSIENT_DATA
    segments, is discarded and the program is terminated using Interrupt
    21H Function 31H.

Detecting a hot key
    The SNAP program detects the hot-key sequence (Alt-Enter) by
    monitoring each keypress. On IBM PCs and PS/2s, each keystroke
    generates a hardware interrupt on IRQ1 (Interrupt 09H). The TSR's
    Interrupt 09H handler compares the keyboard scan code corresponding to
    each keypress with a predefined sequence. The TSR's handler also
    inspects the shift-key status flags maintained by the ROM BIOS
    Interrupt 09H handler. When the predetermined sequence of keypresses
    is detected at the same time as the proper shift keys are pressed, the
    handler sets a global status flag (HotFlag).

    Note how the TSR's handler transfers control to the previous Interrupt
    09H ISR before it performs its own work. If the TSR's Interrupt 09H
    handler did not chain to the previous handler(s), essential system
    processing of keystrokes (particularly in the ROM BIOS Interrupt 09H
    handler) might not be performed.

Activating the application
    The TSR monitors the status of HotFlag by regularly testing its value
    within a timer-tick handler. On IBM PCs and PS/2s, the timer-tick
    interrupt occurs on IRQ0 (Interrupt 08H) roughly 18.2 times per
    second. This hardware interrupt occurs regardless of what else the
    system is doing, so an Interrupt 08H ISR a convenient place to check
    whether HotFlag has been set.

    As in the case of the Interrupt 09H handler, the TSR's Interrupt 08H
    handler passes control to previous Interrupt 08H handlers before it
    proceeds with its own work. This procedure is particularly important
    with Interrupt 08H because the ROM BIOS Interrupt 08H handler, which
    maintains the system's time-of-day clock and resets the system's Intel
    8259A Programmable Interrupt Controller, must execute before the next
    timer tick can occur. The TSR's handler therefore defers its own work
    until control has returned after previous Interrupt 08H handlers have
    executed.

    The only function of the TSR's Interrupt 08H handler is to attempt to
    transfer control to the RAM-resident application. The routine
    VerifyTSRState performs this task. It first examines the contents of
    HotFlag to determine whether a hot-key sequence has been detected. If
    so, it examines the state of the MS-DOS InDOS and critical error
    flags, the current status of hardware interrupts, and the current
    status of any non-reentrant ROM BIOS routines that might be executing.

    If HotFlag is nonzero, the InDOS and critical error flags are both
    zero, no hardware interrupts are currently being serviced, and no non-
    reentrant ROM BIOS code has been interrupted, the Interrupt 08H
    handler activates the RAM-resident utility. Otherwise, nothing happens
    until the next timer tick, when the handler executes again.

    While HotFlag is nonzero, the Interrupt 08H handler continues to
    monitor system status until MS-DOS, the ROM BIOS, and the hardware
    interrupts are all in a stable state. Often the system status is
    stable at the time the hot-key sequence is detected, so the RAM-
    resident application runs immediately. Sometimes, however, system
    activities such as prolonged disk reads or writes can preclude the
    activation of the RAM-resident utility for several seconds after the
    hot-key sequence has been detected. The handler could be designed to
    detect this situation (for example, by decrementing HotFlag on each
    timer tick) and return an error status or display a message to the
    user.

    A more serious difficulty arises when the MS-DOS default command
    processor (COMMAND.COM) is waiting for keyboard input. In this
    situation, Interrupt 21H Function 01H (Character Input with Echo) is
    executing, so InDOS is nonzero and the Interrupt 08H handler can never
    detect a state in which it can activate the RAM-resident utility. This
    problem is solved by providing a custom handler for Interrupt 28H (the
    MS-DOS idle interrupt), which is executed by Interrupt 21H Function
    01H each time it loops as it waits for a keypress. The only difference
    between the Interrupt 28H handler and the Interrupt 08H handler is
    that the Interrupt 28H handler can activate the RAM-resident
    application when the value of InDOS is 1, which is reasonable because
    InDOS must have been incremented when Interrupt 21H Function 01H
    started to execute.

    The interrupt service routines for ROM BIOS Interrupts 05H, 10H, and
    13H do nothing more than increment and decrement flags that indicate
    whether these interrupts are being processed by ROM BIOS routines.
    These flags are inspected by the TSR's Interrupt 08H and 28H handlers.

Executing the RAM-resident application
    When the RAM-resident application is first activated, it runs in the
    context of the program that was interrupted; that is, the contents of
    the registers, the video display mode, the current PSP, and the
    current DTA all belong to the interrupted program. The resident
    application is responsible for preserving the registers and updating
    MS-DOS with its PSP and DTA values.

    The RAM-resident application preserves the previous contents of the
    CPU registers on its own stack to avoid overflowing the interrupted
    program's stack. It then installs its own handlers for Control-Break
    (Interrupt 1BH), Control-C (Interrupt 23H), and critical error
    (Interrupt 24H). (Otherwise, the interrupted program's handlers would
    take control if the user pressed Ctrl-Break or Ctrl-C or if an MS-DOS
    critical error occurred.) These handlers perform no action other than
    setting flags that can be inspected later by the RAM-resident
    application, which could then take appropriate action.

    The application uses Interrupt 21H Functions 50H and 51H to update MS-
    DOS with the address of its PSP. If the application is running under
    MS-DOS versions 2.x, the critical error flag is set before Functions
    50H and 51H are executed so that AuxStack is used for the call instead
    of IOStack, to avoid corrupting IOStack in the event that InDOS is 1.

    The application preserves the current extended error information with
    a call to Interrupt 21H Function 59H. Otherwise, the RAM-resident
    application might be activated immediately after a critical error
    occurred in the interrupted program but before the interrupted program
    had executed Function 59H and, if a critical error occurred in the TSR
    application, the interrupted program's extended error information
    would inadvertently be destroyed.

    This example also shows how to update the MS-DOS default DTA using
    Interrupt 21H Functions 1AH and 2FH, although in this case this step
    is not necessary because the DTA is never used within the application.
    In practice, the DTA should be updated only if the RAM-resident
    application includes calls to Interrupt 21H functions that use a DTA
    (Functions 11H, 12H, 14H, 15H, 21H, 22H, 27H, 28H, 4EH, and 4FH).

    After the resident interrupt handlers are installed and the PSP, DTA,
    and extended error information have been set up, the RAM-resident
    application can safely execute any Interrupt 21H function calls except
    those that use IOStack (Functions 01H through 0CH). These functions
    cannot be used within a RAM-resident application even if the
    application sets the critical error flag to force the use of the
    auxiliary stack, because they also use other non-reentrant data
    structures such as input/output buffers. Thus, a RAM-resident utility
    must rely either on user-written console input/output functions or, as
    in the example, on ROM BIOS functions.

    The application terminates by returning the interrupted program's
    extended error information, DTA, and PSP to MS-DOS, restoring the
    previous Interrupt 1BH, 23H, and 24H handlers, and restoring the
    previous CPU registers and stack.

                                                Richard Wilton



Article 12: Exception Handlers


    Exceptions are system events directly related to the execution of an
    application program; they ordinarily cause the operating system to
    abort the program. Exceptions are thus different from errors, which
    are minor unexpected events (such as failure to find a file on disk)
    that the program can be expected to handle appropriately. Likewise,
    they differ from external hardware interrupts, which are triggered by
    events (such as a character arriving at the serial port) that are not
    directly related to the program's execution.

    The computer hardware assists MS-DOS in the detection of some
    exceptions, such as an attempt to divide by zero, by generating an
    internal hardware interrupt. Exceptions related to peripheral devices,
    such as an attempt to read from a disk drive that is not ready or does
    not exist, are called critical errors. Instead of causing a hardware
    interrupt, these exceptions are typically reported to the operating
    system by device drivers. MS-DOS also supports a third type of
    exception, which is triggered by the entry of a Control-C or
    ControlBreak at the keyboard and allows the user to signal that the
    current program should be terminated immediately.

    MS-DOS contains built-in handlers for each type of exception and so
    guarantees a minimum level of system stability that requires no effort
    on the part of the application programmer. For some applications,
    however, these default handlers are inadequate. For example, if a
    communications program that controls the serial port directly with
    custom interrupt handlers is terminated by the operating system
    without being given a chance to turn off serial-port interrupts, the
    next character that arrives on the serial line will trigger an
    interrupt for which a handler is no longer present in memory. The
    result will be a system crash. Accordingly, MS-DOS allows application
    programs to install custom exception handlers so that they can shut
    down operations in an orderly way when an exception occurs.

    This article examines the default exception handlers provided by
    MS-DOS and discusses methods programmers can use to replace those
    routines with handlers that are more closely matched to specific
    application requirements.


Overview

    Two major exception handlers of importance to application programmers
    are supported under all versions of MS-DOS. The first, the Control-C
    exception handler, terminates the program and is invoked when the user
    enters a Ctrl-C or Ctrl-Break keystroke; the address of this handler
    is found in the vector for Interrupt 23H. The second, the critical
    error exception handler, is invoked if MS-DOS detects a critical error
    while servicing an I/O request. (A critical error is a hardware error
    that makes normal completion of the request impossible.) This
    exception handler displays the familiar Abort, Retry, Ignore prompt;
    its address is saved in the vector for Interrupt 24H.

    When a program begins executing, the addresses in the Interrupt 23H
    and 24H vectors usually point to the system's default Control-C and
    critical error handlers. If the program is a child process, however,
    the vectors might point to exception handlers that belong to the
    parent process, if the immediate parent is not COMMAND.COM. In any
    case, the application program can install its own custom handler for
    Control-C or critical error exceptions simply by changing the address
    in the vector for Interrupt 23H or Interrupt 24H so that the vector
    points to the application's own routine. When the program performs a
    final exit by means of Interrupt 21H Function 00H (Terminate Process),
    Function 31H (Terminate and Stay Resident), Function 4CH (Terminate
    Process with Return Code), Interrupt 20H (Terminate Process), or
    Interrupt 27H (Terminate and Stay Resident), MS-DOS restores the
    previous contents of the Interrupt 23H and 24H vectors.

    Note that Interrupts 23H and 24H never occur as externally generated
    hardware interrupts in an MS-DOS system. The vectors for these
    interrupts are used simply as storage areas for the addresses of the
    exception handlers.

    MS-DOS also contains default handlers for the Control-Break event
    detected by the ROM BIOS in IBM PCs and compatible computers and for
    some of the Intel microprocessor exceptions that generate actual
    hardware interrupts. These exception handlers are not replaced by
    application programs as often as the Control-C and critical error
    handlers. The interrupt vectors that contain the addresses of these
    handlers are not restored by MS-DOS when a program exits.

    The address of the Control-Break handler is saved in the vector for
    Interrupt 1BH and is invoked by the ROM BIOS whenever the Ctrl-Break
    key combination is detected. The default MS-DOS handler normally
    flushes the keyboard input buffer and substitutes Control-C for
    Control-Break, and the Control-C is later handled by the Control-C
    exception handler. The default handlers for exceptions that generate
    hardware interrupts either abort the current program (as happens with
    Divide by Zero) or bring the entire system to a halt (as for a memory
    parity error).


The Control-C Handler

    The vector for Interrupt 23H points to code that is executed whenever
    MS-DOS detects a Control-C character in the keyboard input buffer.
    When the character is detected, MS-DOS executes a software Interrupt
    23H.

    In response to Interrupt 23H, the default Control-C exception handler
    aborts the current process. Files that were opened with handles are
    closed (FCB-based files are not), but no other cleanup is performed.
    Thus, unsaved data can be left in buffers, some files might not be
    processed, and critical addresses, such as the vectors for custom
    interrupt handlers, might be left pointing into free RAM. If more
    complete control over process termination is wanted, the application
    should replace the default Control-C handler with custom code. See
    Customizing Control-C Handling below.

    The Control-Break exception handler, pointed to by the vector for
    Interrupt 1BH, is closely related to the Control-C exception handler
    in MS-DOS systems on the IBM PC and close compatibles but is called by
    the ROM BIOS keyboard driver on detection of the Ctrl-Break keystroke
    combination. Because the Control-Break exception is generated by the
    ROM BIOS, it is present only on IBM PC-compatible machines and is not
    a standard feature of MS-DOS. The default ROM BIOS handler for
    Control-Break is a simple interrupt return--in other words, no action
    is taken to handle the keystroke itself, other than converting the
    Ctrl-Break scan code to an extended character and passing it through
    to MS-DOS as normal keyboard input.

    To account for as many hardware configurations as possible, MS-DOS
    redirects the ROM BIOS Control-Break interrupt vector to its own
    Control-Break handler during system initialization. The MS-DOS
    Control-Break handler sets an internal flag that causes the Ctrl-Break
    keystroke to be interpreted as a Ctrl-C keystroke and thus causes
    Interrupt 23H to occur.

Customizing Control-C handling

    The exception handlers most often neglected by application
    programmers--and most often responsible for major program failures--
    are the default exception handlers invoked by the Ctrl-C and Ctrl-
    Break keystrokes. Although the user must be able to recover from a
    runaway condition (the reason for Ctrl-C capability in the first
    place), any exit from a complex program must also be orderly, with
    file buffers flushed to disk, directories and indexes updated, and so
    on. The default Control-C and Control-Break handlers do not provide
    for such an orderly exit.

    The simplest and most direct way to deal with Ctrl-C and Ctrl-Break
    keystrokes is to install new exception handlers that do nothing more
    than an IRET and thus take MS-DOS out of the processing loop entirely.
    This move is not as drastic as it sounds: It allows an application to
    check for and handle the Ctrl-C and Ctrl-Break keystrokes at its
    convenience when they arrive through the normal keyboard input
    functions and prevents MS-DOS from terminating the program
    unexpectedly.

    The following example sets the Interrupt 23H and Interrupt 1BH vectors
    to point to an IRET instruction. When the user presses Ctrl-C or Ctrl-
    Break, the keystroke combination is placed into the keyboard buffer
    like any other keystroke. When it detects the Ctrl-C or Ctrl-Break
    keystroke, the executing program should exit properly (if that is the
    desired action) after an appropriate shutdown procedure.

    To install the new exception handlers, the following procedure (set_
    int) should be called while the main program is initializing:

    _DATA   segment para public 'DATA'
    oldint1b dd     0               ; original INT 1BH vector
    oldint23 dd     0               ; original INT 23H vector
    _DATA   ends
    _TEXT   segment byte public 'CODE'
            assume cs:_TEXT,ds:_DATA,es:NOTHING
    myint1b:                        ; handler for Ctrl-Break
    myint23:                        ; handler for Ctrl-C
            iret

    set_int proc    near
            mov     ax,351bh        ; get current contents of
            int     21h             ; Int 1BH vector and save it
            mov     word ptr oldint1b,bx
            mov     word ptr oldint1b+2,es
            mov     ax,3523h        ; get current contents of
            int     21h             ; Int 23H vector and save it
            mov     word ptr oldint23,bx
            mov     word ptr oldint23+2,es
            push    ds              ; save our data segment
            push    cs              ; let DS point to our
            pop     ds              ; code segment
            mov     dx,offset myint1b
            mov     ax,251bh        ; set interrupt vector 1BH
            int     21h             ; to point to new handler
            mov     dx,offset myint23
            mov     ax,2523h        ; set interrupt vector 23H
            int     21h             ; to point to new handler
            pop     ds              ; restore our data segment
            ret                     ; back to caller
    set_int endp
    _TEXT   ends

    The application can use the following routine to restore the original
    contents of the vectors pointing to the Control-C and Control-Break
    exception handlers before making a final exit back to MS-DOS. Note
    that, although MS-DOS restores the Interrupt 23H vector to its
    previous contents, the application must restore the Interrupt 1BH
    vector itself.

    rest_int proc   near
            push    ds              ; save our data segment
            mov     dx,word ptr oldint23
            mov     ds,word ptr oldint23+2
            mov     ax,2523h        ; restore original contents
            int     21h             ; of Int 23H vector
            pop     ds              ; restore our data segment
            push    ds              ; then save it again
            mov     dx,word ptr oldint1B
            mov     ds,word ptr oldint1B+2
            mov     ax,251Bh        ; restore original contents
            int     21h             ; of Int 1BH vector
            pop     ds              ; get back our data segment
            ret                     ; return to caller
    rest_int endp

    The preceding example simply prevents MS-DOS from terminating an
    application when a Ctrl-C or Ctrl-Break keystroke is detected. Program
    termination is still often the ultimate goal, but after a more orderly
    shutdown than is provided by the MS-DOS default Control-C handler. The
    following exception handler allows the program to exit more
    gracefully:

    myint1b:                        ; Control-Break exception handler
            iret                    ; do nothing
    myint23:                        ; Control-C exception handler
            call    safe_shut_down  ; release interrupt vectors,
                                    ; close files, etc.
            jmp     program_exit_point

    Note that because the Control-Break handler is invoked by the ROM BIOS
    keyboard driver and MS-DOS is not reentrant, MS-DOS services (such as
    closing files and terminating with return code) cannot be invoked
    during processing of a Control-Break exception. In contrast, any
    MS-DOS Interrupt 21H function call can be used during the processing
    of a Control-C exception. Thus, the Control-Break handler in the
    preceding example does nothing, whereas the Control-C handler performs
    orderly shutdown of the application.

    Most often, however, neither a handler that does nothing nor a handler
    that shuts down and terminates is sufficient for processing a Ctrl-C
    (or Ctrl-Break) keystroke. Rather than simply prevent Control-C
    processing, software developers usually prefer to have a Ctrl-C
    keystroke signal some important action without terminating the
    program. Using methods similar to those above, the programmer can
    replace Interrupts 1BH and 23H with a routine like the following:

    myint1b:                        ; Control-Break exception handler
    myint23:                        ; Control-C exception handler
            call    control_c_happened
            iret

Notes on processing Control-C

    The preceding examples assume the programmer wants to treat Control-C
    and Control-Break the same way, but this is not always desirable.
    Control-C and Control-Break are not the same, and the difference
    between the two should be kept in mind: The Control-Break handler is
    invoked by a keyboard-input interrupt and can be called at any time;
    the Control-C handler is called only at "safe" points during the
    processing of MS-DOS Interrupt 21H functions. Also, even though MS-DOS
    restores the Interrupt 23H vector on exit from a program, the
    application must restore the previous contents of the Interrupt 1BH
    vector before exiting. If this interrupt vector is not restored, the
    next Ctrl-Break keystroke will cause the machine to attempt to execute
    an undetermined piece of code or data and will probably crash the
    system.

    Although it is generally desirable to take control of the Control-C
    and Control-Break interrupts, control should be retained only as long
    as necessary. For example, a RAM-resident pop-up application should
    take over Control-C and Control-Break handling only when it is
    activated, and it should restore the previous contents of the
    Interrupt 1BH and Interrupt 23H vectors before it returns control to
    the foreground process.


The Critical Error Handler

    When MS-DOS detects a critical error--an error that prevents
    successful completion of an I/O operation--it calls the exception
    handler whose address is stored in the vector for Interrupt 24H.
    Information about the operation in progress and the nature of the
    error is passed to the exception handler in the CPU registers. In
    addition, the contents of all the registers at the point of the
    original MS-DOS call are pushed onto the stack for inspection by the
    exception handler.

    The action of MS-DOS's default critical error handler is to present a
    message such as

    Error type error action device
    Abort, Retry, Ignore?

    This message signals a hardware error from which MS-DOS cannot recover
    without user intervention. For example, if the user enters the command

    C&gt;DIR A:  &lt;ENTER&gt;

    but drive A either does not contain a disk or the disk drive door is
    open, the MS-DOS critical error handler displays the message

    Not ready error reading drive A
    Abort, Retry, Ignore?

    I (Ignore) simply tells MS-DOS to forget that an error occurred and
    continue on its way. (Of course, if the error occurred during the
    writing of a file to disk, the file is generally corrupted; if the
    error occurred during reading, the data might be incorrect.)

    R (Retry) gives the application a second chance to access the device.
    The critical error handler returns information to MS-DOS that says, in
    effect, "Try again; maybe it will work this time." Sometimes, the
    attempt succeeds (as when the user closes an open drive door), but
    more often the same or another critical error occurs.

    A (Abort) is the problem child of Interrupt 24H. If the user responds
    with A, the application is terminated immediately. The directory
    structure is not updated for open files, interrupt vectors are left
    pointing to inappropriate locations, and so on. In many cases,
    restarting the system is the only safe thing to do at this point.

    Note: Beginning with version 3.3, an F (Fail) option appears in the
    message displayed by MS-DOS's default critical error handler. When
    Fail is selected, the current MS-DOS function is terminated and an
    error condition is returned to the calling program. For example, if a
    program calls Interrupt 21H Function 3DH to open a file on drive A but
    the drive door is open, choosing F in response to the error message
    causes the function call to return with the carry flag set, indicating
    that an error occurred but processing continues.

    Like the Control-C exception handler, the default critical error
    exception handler can and should be replaced by an application program
    when complete control of the system is desired. The program installs
    its own handler simply by placing the address of the new handler in
    the vector for Interrupt 24H; MS-DOS restores the previous contents of
    the Interrupt 24H vector when the program terminates.

    Unlike the Control-C handler, however, the critical error handler must
    be kept within carefully defined limits to preserve the stability of
    the operating system. Programmers must rigidly adhere to the structure
    described in the following pages for passing information to and from
    an Interrupt 24H handler.

Mechanics of critical error handling

    MS-DOS critical error handling has two components: the exception
    handler, whose address is saved in the Interrupt 24H vector and which
    can be replaced by an application program; and an internal routine
    inside MS-DOS. The internal routine sets up the information to be
    passed to the exception handler on the stack and in registers and, in
    turn, calls the exception handler itself. The internal routine also
    responds to the values returned by the critical error handler when
    that handler executes an IRET to return to the MS-DOS kernel.

    Before calling the exception handler, MS-DOS arranges the stack
    (Figure 12-1) so the handler can inspect the location of the error
    and register contents at the point in the original MS-DOS function
    call that led to the critical error.


    ┌───────────────┐
    │     Flags     │▒
    ├───────────────┤▒
    │      CS       │▒ Flags and CS:IP pushed on stack
    ├───────────────┤▒  by original Interrupt 21H call
    │      IP       │▒
    ├───────────────┤──SP on entry to Interrupt 21H handler
    │      ES       │▒
    ├───────────────┤▒
    │      DS       │▒
    ├───────────────┤▒
    │      BP       │▒
    ├───────────────┤▒
    │      DI       │▒
    ├───────────────┤▒ Registers at point of
    │      SI       │▒  original Interrupt 21H call
    ├───────────────┤▒
    │      DX       │▒
    ├───────────────┤▒
    │      CX       │▒
    ├───────────────┤▒
    │      BX       │▒
    ├───────────────┤▒
    │      AX       │▒
    ├───────────────┤
    │     Flags     │▒
    ├───────────────┤▒
    │      CS       │▒ Return address from
    ├───────────────┤▒  Interrupt 24H handler
    │      IP       │▒
    └───────────────┘──SP on entry to Interrupt 24H handler

    Figure 12-1. The stack contents at entry to a critical error exception
    handler.


    When the critical error handler is called by the internal routine,
    four registers may contain important information: AX, DI, BP, and SI.
    (With MS-DOS versions 1.x, only the AX and DI registers contain
    significant information.) The information passed to the handler in the
    registers differs somewhat, depending on whether a character device or
    a block device is causing the error.

Block-device (disk-based) errors

    If the critical error handler is entered in response to a block-device
    (disk-based) error, registers BP:SI contain the segment:offset of the
    device driver header for the device causing the error and bit 7 (the
    high-order bit) of the AH register is zero. The remaining bits of the
    AH register contain the following information (bits 3 through 5 apply
    only to MS-DOS versions 3.1 and later):

╓┌────────────────┌───────────┌──────────────────────────────────────────────╖
    Bit         Value       Meaning
    ──────────────────────────────────────────────────────────────────
    0            0          Read operation
                1          Write operation
    1-2                     Indicate the affected disk area:
                00              MS-DOS
                01              File allocation table
                10              Root directory
                11              Files area
    3            0          Fail response not allowed
                1          Fail response allowed
    4            0          Retry response not allowed
                1          Retry response allowed
    5            0          Ignore response not allowed
                1          Ignore response allowed
    6            0          Undefined

    The AL register contains the designation of the drive where the error
    occurred; for example, AL = 00H (drive A), AL = 01H (drive B), and so
    on.

    The lower half of the DI register contains the following error codes
    (the upper half of this register is undefined):

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Error Code       Meaning
    ──────────────────────────────────────────────────────────────────
    00H              Write-protected disk
    01H              Unknown unit
    02H              Drive not ready
    03H              Invalid command
    04H              Data error (CRC)
    05H              Length of request structure invalid
    06H              Seek error
    07H              Non-MS-DOS disk
    08H              Sector not found
    09H              Printer out of paper
    0AH              Write fault
    0BH              Read fault
    0CH              General failure
    0FH              Invalid disk change (version 3.0 or later)

    Note: With versions 1.x, the only valid error codes are 00H, 02H, 04H,
    06H, 08H, 0AH, and 0CH.

    Before calling the critical error handler for a disk-based error, MS-
    DOS tries from one to five times to perform the requested read or
    write operation, depending on the type of operation. Critical disk
    errors result only from Interrupt 21H operations, not from failed
    sector-read and sector-write operations attempted with Interrupts 25H
    and 26H.

Character-device errors

    If the critical error handler is called from the MS-DOS kernel with
    bit 7 of the AH register set to 1, either an error occurred on a
    character device or the memory image of the file allocation table is
    bad (a rare occurrence). Again, registers BP:SI contain the segment
    and offset of the device driver header for the device causing the
    critical error. The exception handler can inspect bit 15 of the device
    attribute word at offset 04H in the device header to confirm that the
    error was caused by a character device--this bit is 0 for block
    devices and 1 for character devices. See also PROGRAMMING IN THE MS-
    DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Installable Device Drivers.

    If the error was caused by a character device, the lower half of the
    DI register contains error codes as described above and the contents
    of the AL register are undefined. The exception handler can inspect
    the other fields of the device header to obtain the logical name of
    the character device; to determine whether that device is the standard
    input, standard output, or both; and so on.

Critical error processing

    The critical error exception handler is entered from MS-DOS with
    interrupts disabled. Because an MS-DOS system call is already in
    progress and MS-DOS is not reentrant, the handler cannot request any
    MS-DOS system services other than Interrupt 21H Functions 01 through
    0CH (character I/O functions), Interrupt 21H Function 30H (Get MS-DOS
    Version Number), and Interrupt 21H Function 59H (Get Extended Error
    Information). These functions use a special stack so that they can be
    called during error processing.

    In general, the critical error handler must preserve all but the AL
    register. It must not change the contents of the device header pointed
    to by BP:SI. The handler must return to the MS-DOS kernel with an
    IRET, passing an action code in register AL as follows:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Value in AL      Meaning
    ──────────────────────────────────────────────────────────────────
    00H              Ignore
    01H              Retry
    02H              Terminate process
    03H              Fail current system call

    These values correspond to the options presented by the MS-DOS default
    critical error handler. The default handler prompts the user for
    input, places the appropriate return information in the AL register,
    and immediately issues an IRET instruction.

    Note: Although the Fail option is displayed by the MS-DOS default
    critical error handler in versions 3.3 and later, the Fail option
    inside the handler was added in version 3.1.

    With MS-DOS versions 3.1 and later, if the handler returns an action
    code in AL that is not allowed for the error in question (bits 3
    through 5 of the AH register at the point of call), MS-DOS reacts
    according to the following rules:

    If Ignore is specified by AL = 00H but is not allowed because bit 5 of
    AH = 0, the response defaults to Fail (AL = 03H).

    If Retry is specified by AL = 01H but is not allowed because bit 4 of
    AH = 0, the response defaults to Fail (AL = 03H).

    If Fail is specified by AL = 03H but is not allowed because bit 3 of
    AH = 0, the response defaults to Abort.

Custom critical error handlers

    Each time it receives control, COMMAND.COM restores the Interrupt 24H
    vector to point to the system's default critical error handler and
    displays a prompt to the user. Consequently, a single custom handler
    cannot terminate and stay resident to provide critical error handling
    services for subsequent application programs. Each program that needs
    better critical error handling than MS-DOS provides must contain its
    own critical error handler.

    Figure 12-2 contains a simple critical error handler, INT24.ASM,
    written in assembly language. In the form shown, INT24.ASM is no more
    than a functional replacement for the MS-DOS default critical error
    handler, but it can be used as the basis for more sophisticated
    handlers that can be incorporated into application programs.

    ──────────────────────────────────────────────────────────────────────

    Figure 12-2. INT24.ASM, a replacement Interrupt 24 handler.

    ──────────────────────────────────────────────────────────────────────

    INT24.ASM contains three routines:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Routine          Action
    ──────────────────────────────────────────────────────────────────
    get24            Saves the previous contents of the Interrupt 24H
                    critical error handler vector and stores the address
                    of the new critical error handler into the vector.

    res24            Restores the address of the previous critical error
                    handler, which was saved by a call to get24, into
                    the Interrupt 24 vector.

    int24            Replaces the MS-DOS critical error handler.

    A program wishing to substitute the new critical error handler for the
    system's default handler should call the get24 routine during its
    initialization sequence. If the program wishes to revert to the
    system's default handler during execution, it can accomplish this with
    a call to the res24 routine. Otherwise, a call to res24 (and the
    presence of the routine itself in the program) is not necessary,
    because MS-DOS automatically restores the Interrupt 24H vector to its
    previous value when the program exits, from information stored in the
    program segment prefix (PSP).

    The replacement critical error handler, int24, is simple. First it
    saves all registers; then it displays a message that a critical error
    has occurred and prompts the user to enter a key selecting one of the
    four possible options: Abort, Retry, Ignore, or Fail. If an illegal
    key is entered, the prompt is displayed again; otherwise, the action
    code corresponding to the key is extracted from a table and placed in
    the AL register, the other registers are restored, and control is
    returned to the MS-DOS kernel with an IRET instruction.

    Note that the handle read and write functions (Interrupt 21H Functions
    3FH and 40H), which would normally be preferred for interaction with
    the display and keyboard, cannot be used in a critical error handler.


Hardware-generated Exception Interrupts

    Intel reserved the vectors for Interrupts 00H through 1FH (Table 12-1)
    for exceptions generated by the execution of various machine
    instructions. Handling of these chip-dependent internal interrupts can
    vary from one make of MS-DOS machine to another; some such differences
    are mentioned in the discussion.


    Table 12-1. Intel Reserved Exception Interrupts.

╓┌──────────────────────┌────────────────────────────────────────────────────╖
    Interrupt Number  Definition
    ──────────────────────────────────────────────────────────────────
    00H               Divide by Zero
    01H               Single-Step
    02H               Nonmaskable Interrupt (NMI)
    03H               Breakpoint Trap
    04H               Overflow Trap
    05H               BOUND Range Exceeded
    06H               Invalid Opcode
    07H               Coprocessor not Available
    08H               Double-Fault Exception
    09H               Coprocessor Segment Overrun
    0AH               Invalid Task State Segment (TSS)
    0BH               Segment not Present
    0CH               Stack Exception
    0DH               General Protection Exception
    0EH               Page Fault
    0FH               (Reserved)
    10H               Coprocessor Error
    11-1FH            (Reserved)


    Note: A number of these reserved exception interrupts generally do not
    occur in MS-DOS because they are generated only when the 80286 or
    80386 microprocessor is operating in protected mode. The following
    discussions do not cover these interrupts.

Divide by Zero (Interrupt 00H)

    An Interrupt 00H occurs whenever a DIV or IDIV operation fails to
    terminate within a reasonable period of time. The interrupt is
    triggered by a mathematical anomaly: Division by zero is inherently
    undefined. To handle such situations, Intel built special processing
    into the DIV and IDIV instructions to ensure that the condition does
    not cause the processor to lock up. Although the assumption underlying
    Interrupt 00H is an attempt to divide by zero (a condition that will
    never terminate), the interrupt can also be triggered by other error
    conditions, such as a quotient that is too large to fit in the
    designated register (AX or AL).

    The ROM BIOS handler for Interrupt 00H in the IBM PC and close
    compatibles is a simple IRET instruction. During the MS-DOS startup
    process, however, MS-DOS modifies the interrupt vector to point to its
    own handler--a routine that issues the warning message Divide by Zero
    and aborts the current application. This abort procedure can leave the
    computer and operating system in an extremely unstable state. If the
    default handler is used, the system should be restarted immediately
    and an attempt should be made to find and eliminate the cause of the
    error. A better approach, however, is to provide a replacement handler
    that treats Interrupt 00H much as MS-DOS treats Interrupt 24H.

Single-Step (Interrupt 01H)

    If the trap flag (bit 8 of the microprocessor's 16-bit flags register)
    is set, Interrupt 01H occurs at the end of every instruction executed
    by the processor. By default, Interrupt 01H points to a simple IRET
    instruction, so the net effect is as if nothing happened. However,
    debugging programs, which are the only applications that use this
    interrupt, modify the interrupt vector to point to their own handlers.
    The interrupt can then be used to allow a debugger to single-step
    through the machine instructions of the program being debugged, as
    DEBUG does with its T (Trace) command.

Nonmaskable Interrupt, or NMI (Interrupt 02H)

    In the hardware architecture of IBM PCs and close compatibles,
    Interrupt 02H is invoked whenever a memory parity error is detected.
    MS-DOS provides no handler, because this error, as a hardware-related
    problem, is in the domain of the ROM BIOS.

    In response to the Interrupt 02H, the default ROM BIOS handler
    displays a message and locks the machine, on the assumption that bad
    memory prevents reliable system operation. Many programmers, however,
    prefer to include code that permits orderly shutdown of the system.
    Replacing the ROM BIOS parity trap routine can be dangerous, though,
    because a parity error detected in memory means the contents of RAM
    are no longer reliable--even the memory locations containing the NMI
    handler itself might be defective.

Breakpoint Trap (Interrupt 03H)

    Interrupt 03H, which is used in conjunction with Interrupt 01H for
    debugging, is invoked by a special 1-byte opcode (0CCH). During a
    debugging session, a debugger modifies the vector for Interrupt 03H to
    point to its own handler and then replaces 1 byte of program opcode
    with the 0CCH opcode at any location where a breakpoint is needed.

    When a breakpoint is reached, the 0CCH opcode triggers Interrupt 03H
    and the debugger regains control. The debugger then restores the
    original opcode in the program being debugged and issues a prompt so
    that the user can display or alter the contents of memory or
    registers. The use of Interrupt 03H is illustrated by DEBUG and
    SYMDEB's breakpoint capabilities.

Overflow Trap (Interrupt 04H)

    If the overflow bit (bit 11) in the microprocessor's flags register is
    set, Interrupt 04H occurs when the INTO (Interrupt on Overflow)
    instruction is executed. The overflow bit can be set during prior
    execution of any arithmetic instruction (such as MUL or IMUL) that can
    produce an overflow error.

    The ROM BIOS of the IBM PC and close compatibles initializes the
    Interrupt 04H vector to point to an IRET, so this interrupt becomes
    invisible to the user if it is executed. MS-DOS does not have its own
    handler for Interrupt 04H. However, because the Intel microprocessors
    also include JO (Jump if Overflow) and JNO (Jump if No Overflow)
    instructions, applications rarely need the INTO instruction and,
    hence, seldom have to provide their own Interrupt 04H handlers.

BOUND Range Exceeded (Interrupt 05H)

    Interrupt 05H is generated on 80186, 80286, and 80386 microprocessors
    if a BOUND instruction is executed to test the value of an array index
    and the index falls outside the limits specified by the instruction's
    operand. The exception handler is expected to alter the index so that
    it is correct--when the handler performs an interrupt return (IRET),
    the CPU reexecutes the BOUND instruction that caused the interrupt.

    On IBM PC/AT-compatible machines, the ROM BIOS assignment of the PrtSc
    (print screen) routine to Interrupt 05H is in conflict with the CPU's
    use of Interrupt 05H for BOUND exceptions.

Invalid opcode (Interrupt 06H)

    Interrupt 06H is generated by the 80186, 80286, and 80386
    microprocessors if the current instruction is not a valid opcode--for
    example, if the machine tries to execute a data statement.

    On IBM PC/ATs, Interrupt 06H simply points to an IRET instruction. The
    ROM BIOS routines of some IBM PC/AT-compatibles, however, provide an
    interrupt handler that reports an unexpected software Interrupt 06H
    and asks if the user wants to continue. A Y response causes the
    interrupt handler to skip over the invalid opcode. Unfortunately,
    because the succeeding opcode is often invalid as well, the user may
    have the feeling of being trapped in a loop.


Extended Error Information

    Under MS-DOS versions 1.x, the operating system provided limited
    information about errors that occurred during calls to the Interrupt
    21H system functions. For example, if a program called Function 0FH to
    open a file, there were only two possible results: On return, the AL
    register either contained 00H for a successful open or 0FFH for
    failure. No further detail was available from the operating system.
    Although some of these early system calls (such as the read and write
    functions) returned somewhat more information, the 1.x versions of MS-
    DOS were essentially limited to success/failure return codes.

    Beginning with version 2.0 and the introduction of the handle concept,
    additional error information became available. See PROGRAMMING IN THE
    MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: File and Record
    Management. For example, if a program attempts to open a file with
    Interrupt 21H Function 3DH (Open File with Handle), it can check the
    status of the carry flag on return to detect whether an error
    occurred. If the carry flag is not set, the call was successful and
    the AX register contains the file handle. If the carry flag is set,
    the AX register contains one of the following possible error codes:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Error Code       Meaning
    ──────────────────────────────────────────────────────────────────
    01H              Invalid function code
    02H              File not found
    03H              Path not found
    04H              Too many open files (no more handles available)
    05H              Access denied
    0CH              Invalid access code

    In some circumstances, however, even these error codes do not provide
    enough information. Therefore, beginning with version 3.0, MS-DOS made
    extended error information available through Interrupt 21H Function
    59H (Get Extended Error Information). This function can be called
    after any other Interrupt 21H function fails, or it can be called from
    a critical error handler. The extended error codes, briefly described
    below, maintain compatibility with the MS-DOS versions 2.x error
    returns and are grouped as follows:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Error Code       Error Group
    ──────────────────────────────────────────────────────────────────────
    00H              No error encountered.

    01-12H           MS-DOS versions 2.x and 3.x Interrupt 21H errors.
                    These error codes are identical to those returned in
                    the AX register by Functions 38H through 57H if the
                    carry flag is set on return from the function call.

    13-1FH           MS-DOS versions 2.x and 3.x Interrupt 24H errors.
                    These error codes are 13H (19) greater than the
                    codes passed to a critical error handler in the
                    lower half of the DI register; that is, if the
                    critical error handler receives error code 04H (CRC
                    error), Interrupt 21H Function 59H returns 17H.

    20-58H           Extended error codes, many related to networking and
                    file sharing, for MS-DOS versions 3.0 and later.

    Note: The contents of the CPU registers (except CS:IP and SS:SP) are
    destroyed by a call to Function 59H. Also, as mentioned earlier, this
    function is available only with MS-DOS versions 3.x, even though it
    maintains compatibility with error returns in versions 2.x.

    On return, Function 59H provides the extended error code in the AX
    register, the error class (type) in the BH register, a code for the
    suggested corrective action in the BL register, and the locus of the
    error in the CH register. These values are defined in the following
    paragraphs. With MS-DOS or PC-DOS versions 3.x, if an error 22H
    (invalid disk change) occurs and if the capability is supported by the
    system's block-device drivers, ES:DI points to an ASCIIZ volume label
    that designates the disk to be inserted in the drive before the
    operation is retried.

    Error Code (AX register). This value is defined as follows:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Value in AX      Meaning
    ──────────────────────────────────────────────────────────────────
    Interrupt 21H errors (MS-DOS versions 2.0 and later):
    01H              Invalid function number
    02H              File not found
    03H              Path not found
    04H              Too many open files (no handles available)
    05H              Access denied
    06H              Invalid handle
    07H              Memory control blocks destroyed
    08H              Insufficient memory
    09H              Invalid memory-block address
    0AH              Invalid environment
    0BH              Invalid format
    0CH              Invalid access code
    0DH              Invalid data
    0EH              Reserved
    0FH              Invalid disk drive specified
    10H              Attempt to remove the current directory
    11H              Not same device
    12H              No more files
    ──────────────────────────────────────────────────────────────────
    Interrupt 24H errors (MS-DOS versions 2.0 and later):
    13H              Attempt to write on write-protected disk
    14H              Unknown unit
    15H              Drive not ready
    16H              Invalid command
    17H              Data error based on cyclic redundancy check (CRC)
    18H              Length of request structure invalid
    19H              Seek error
    1AH              Unknown media type (non-MS-DOS disk)
    1BH              Sector not found
    1CH              Printer out of paper
    10H              Write fault
    1EH              Read fault
    1FH              General failure
    ──────────────────────────────────────────────────────────────────
    MS-DOS versions 3.x extended errors:
    20H              Sharing violation
    21H              Lock violation
    22H              Invalid disk change
    23H              FCB unavailable
    24H              Sharing buffer exceeded
    25H-31H          Reserved
    32H              Network request not supported
    33H              Remote computer not listening
    34H              Duplicate name on network
    35H              Network name not found
    36H              Network busy
    37H              Device no longer exists on network
    38H              Net BIOS command limit exceeded
    39H              Error in network adapter hardware
    3AH              Incorrect response from network
    3BH              Unexpected network error
    3CH              Incompatible remote adapter
    3DH              Print queue full
    3EH              Queue not full
    3FH              Not enough room for print file
    40H              Network name deleted
    41H              Access denied
    42H              Incorrect network device type
    43H              Network name not found
    44H              Network name limit exceeded
    45H              Net BIOS session limit exceeded
    46H              Temporary pause
    47H              Network request not accepted
    48H              Print or disk redirection paused
    49H-4FH          Reserved
    50H              File already exists
    51H              Reserved
    52H              Cannot make directory
    53H              Failure on Interrupt 24H
    54H              Out of structures
    55H              Already assigned
    56H              Invalid password
    57H              Invalid parameter
    58H              Network write fault

    Locus (CH register). This value provides information on the location
    of the error:

╓┌────────────────────────┌──────────────────────────────────────────────────╖
    Value in CH         Meaning
    ──────────────────────────────────────────────────────────────────
    01H                 Location unknown
    02H                 Block device; generally caused by a disk error
    03H                 Network
    04H                 Serial device; generally caused by a timeout from
                        a character device
    05H                 Memory; caused by an error in RAM

    Error Class (BH register). This value gives the general category of
    the error:

╓┌────────────────────────┌──────────────────────────────────────────────────╖
    Value in BH         Meaning
    ──────────────────────────────────────────────────────────────────
    01H                 Out of resource; out of storage space or I/O
                        channels.

    02H                 Temporary situation; expected to clear, as in a
                        file or record lock--generally occurs only in a
                        network environment.

    03H                 Authorization; a problem with permission to access
                        the requested device.

    04H                 Internal error in system software; generally
                        reflects a system software bug rather than an
                        application or system failure.

    05H                 Hardware failure; a serious hardware-related
                        problem not the fault of the user program.

    06H                 System failure; a serious failure of the system
                        software, not directly the fault of the
                        application--generally occurs if configuration
                        files are missing or incorrect.

    07H                 Application-program error; generally caused by
                        inconsistent function requests from the user
                        program.

    08H                 File or item not found.

    09H                 File or item of invalid format or type detected,
                        or an otherwise unsuitable or invalid item
                        requested.

    0AH                 File or item interlocked by the system.

    0BH                 Media failure; generally occurs with a bad disk in
                        a drive, a bad spot on the disk, or the like.

    0CH                 Already exists; generally occurs when application
                        tries to declare a machine name or device that
                        already exists.

    0DH                 Unknown.

    Suggested Action (BL register). One of the most useful returns from
    Function 59H, this value suggests a corrective action to try:

╓┌────────────────────────┌──────────────────────────────────────────────────╖
    Value in BL         Meaning
    ──────────────────────────────────────────────────────────────────
    01H                 Retry a few times before prompting the user to
                        choose Ignore for the program to continue or
                        Abort to terminate.

    02H                 Pause for a few seconds between retries and then
                        prompt user as above.

    03H                 Ask user to reenter the input. In most cases, this
                        solution applies when an incorrect drive
                        specifier or filename was entered. Of course, if
                        the value was hard-coded into the program, the
                        user should not be prompted for input.

    04H                 Clean up as well as possible, then abort the
                        application. This solution applies when the error
                        is destructive enough that the application cannot
                        safely proceed, but the system is healthy enough
                        to try an orderly shutdown of the application.

    05H                 Exit from the application as soon as possible,
                        without trying to close files and clean up. This
                        means something is seriously wrong with either
                        the application or the system.

    06H                 Ignore; error is informational.

    07H                 Prompt user to perform some action, such as
                        changing floppy disks in a drive and then retry.


Function 59H and older system calls

    The Interrupt 21H functions--primarily the FCB-related file and record
    calls--that return 0FFH in the AL register to indicate that an error
    has occurred but provide no further information about the type of
    error include

╓┌─────────────────┌─────────────────────────────────────────────────────────╖
    Function     Name
    ──────────────────────────────────────────────────────────────────
    0FH          Open File with FCB
    10H          Close File with FCB
    11H          Find First File
    12H          Find Next File
    13H          Delete File
    16H          Create File with FCB
    17H          Rename File
    23H          Get File Size

    These function calls now exist only to maintain compatibility with
    MS-DOS versions 1.x. The preferred choices are the handle-style calls
    available in MS-DOS versions 2.0 and later, which offer full path
    support and much better error reporting. See also SYSTEM CALLS.

    If the older calls must be used, the program can use Function 59H to
    obtain more detailed information under MS-DOS version 3.0 or later.
    For example:

    myfcb   db      0               ; drive = default
            db      'MYFILE  '      ; filename, 8 chars
            db      'DAT'           ; extension, 3 chars
            db      25 dup (0)      ; remainder of FCB
            .
            .
            .
            mov     dx,seg myfcb    ; DS:DX = FCB
            mov     ds,dx
            mov     dx,offset myfcb
            mov     ah,0fh          ; function 0FH = Open FCB

            int     21h             ; transfer to MS-DOS
            or      al,al           ; test status
            jz      success         ; jump, open succeeded
                                    ; open failed, get
                                    ; extended error info
            mov     bx,0            ; BX = 00H for ver. 2.x-3.x
            mov     ah,59h          ; function 59H = Get Info
            int     21h             ; transfer to MS-DOS
            or      ax,ax           ; really an error?
            jz      success         ; no error, jump
                                    ; test recommended actions
            cmp     bl,01h
            jz      retry           ; if BL = 01H retry operation
            cmp     bl,04h
            jz      cleanup         ; if BL = 04H clean up and exit
            cmp     bl,05h
            jz      panic           ; if BL = 05H exit immediately
            .
            .
            .

Function 59H and newer system calls

    The function calls listed below were added in MS-DOS versions 2.0 and
    later. These calls return with the carry flag set if an error occurs;
    in addition, the AX register contains an error value corresponding to
    error codes 01H through 12H of the extended error return codes:

╓┌─────────────────┌─────────────────────────────────────────────────────────╖
    Function     Name
    ──────────────────────────────────────────────────────────────────
    MS-DOS versions 2.0 and later:
    38H          Get/Set Current Country
    39H          Create Directory
    3AH          Remove Directory
    3BH          Change Current Directory
    3CH          Create File with Handle
    3DH          Open File with Handle
    3EH          Close File
    3FH          Read File or Device
    40H          Write File or Device
    41H          Delete File
    42H          Move File Pointer
    43H          Get/Set File Attributes
    44H          IOCTL (I/O Control for Devices)
    45H          Duplicate File Handle
    46H          Force Duplicate File Handle
    47H          Get Current Directory
    48H          Allocate Memory Block
    49H          Free Memory Block
    4AH          Resize Memory Block
    4BH          Load and Execute Program (EXEC)
    4EH          Find First File
    4FH          Find Next File
    56H          Rename File
    57H          Get/Set Date/Time of File
    ──────────────────────────────────────────────────────────────────
    MS-DOS versions 3.0 and later:
    58H          Get/Set Allocation Strategy
    5AH          Create Temporary File
    5BH          Create New File
    5CH          Lock/Unlock File Region
    ──────────────────────────────────────────────────────────────────
    MS-DOS versions 3.1 and later:
    5EH          Network Machine Name/Printer Setup
    5FH          Get/Make Assign List Entry

    Although these newer functions have much better error reporting than
    the older FCB functions, Function 59H is still useful. Regardless of
    the version of MS-DOS that is running, the error code returned in the
    AX register from an Interrupt 21H function call is always in the range
    0-12H. If a program is running under MS-DOS versions 3.x and wants to
    obtain one or more of the more specific error codes in the range 20-
    58H, the program must follow the failed Interrupt 21H call with a
    subsequent call to Interrupt 21H Function 59H. The program can then
    use the code returned by Function 59H in the BL register as a guide to
    the action to take in response to the error. For example:

    myfile  db      'MYFILE.DAT',0  ; ASCIIZ filename
            .
            .
            .
            mov     dx,seg myfile   ; DS:DX = ASCIIZ filename
            mov     ds,dx
            mov     dx,offset myfile
            mov     ax,3d02h        ; open, read/write
            int     21h             ; transfer to MS-DOS
            jnc     success         ; jump, open succeeded
                                    ; open failed, get
                                    ; extended error info
            mov     bx,0            ; BX = 00H for ver. 2.x-3.x
            mov     ah,59h          ; function 59H = Get Info
            int     21h             ; transfer to MS-DOS
            or      ax,ax           ; really an error?
            jz      success         ; no error, jump
                                    ; test recommended actions
            cmp     bl,01h
            jz      retry           ; if BL = 01H retry operation
            .
            .
            .

    If the standard critical error handler is replaced with a customized
    critical handler, Function 59H can also be used to obtain more
    detailed information about an error inside the handler before either
    returning control to the application or aborting. The value in the BL
    register should be used to determine the appropriate action to take or
    the message to display to the user.

                                                Jim Kyle
                                                Chip Rabinowitz



Article 13: Hardware Interrupt Handlers


    Unlike software interrupts, which are service requests initiated by a
    program, hardware interrupts occur in response to electrical signals
    received from a peripheral device such as a serial port or a disk
    controller, or they are generated internally by the microprocessor
    itself. Hardware interrupts, whether external or internal to the
    microprocessor, are given prioritized servicing by the Intel CPU
    architecture.

    The 8086 family of microprocessors (which includes the 8088, 8086,
    80186, 80286, and 80386) reserves the first 1024 bytes of memory
    (addresses 0000:0000H through 0000:03FFH) for a table of 256 interrupt
    vectors, each a 4-byte far pointer to a specific interrupt service
    routine (ISR) that is carried out when the corresponding interrupt is
    processed. The design of the 8086 family requires certain of these
    interrupt vectors to be used for specific functions (Table 13-1).
    Although Intel actually reserves the first 32 interrupts, IBM, in the
    original PC, redefined usage of Interrupts 05H to 1FH. Most, but not
    all, of these reserved vectors are used by software, rather than
    hardware, interrupts; the redefined IBM uses are listed in Table 13-2.


    Table 13-1. Intel Reserved Exception Interrupts.

╓┌────────────────────────┌──────────────────────────────────────────────────╖
    Interrupt Number    Definition
    ──────────────────────────────────────────────────────────────────
    00H                 Divide by zero
    01H                 Single step
    02H                 Nonmaskable interrupt (NMI)
    03H                 Breakpoint trap
    04H                 Overflow trap
    05H                 BOUND range exceeded
    06H                 Invalid opcode
    07H                 Coprocessor not available
    08H                 Double-fault exception
    09H                 Coprocessor segment overrun
    0AH                 Invalid task state segment (TSS)
    0BH                 Segment not present
    0CH                 Stack exception
    0DH                 General protection exception
    0EH                 Page fault
    0FH                 (Reserved)
    10H                 Coprocessor error


    Table 13-2. IBM Interrupt Usage.

╓┌────────────────────────┌──────────────────────────────────────────────────╖
    Interrupt Number    Definition
    ──────────────────────────────────────────────────────────────────
    05H                 Print screen
    06H                 Unused
    07H                 Unused
    08H                 Hardware IRQ0 (timer-tick)
    09H                 Hardware IRQ1 (keyboard)
    0AH                 Hardware IRQ2 (reserved)
    0BH                 Hardware IRQ3 (COM2)
    0CH                 Hardware IRQ4 (COM1)
    0DH                 Hardware IRQ5 (fixed disk)
    0EH                 Hardware IRQ6 (floppy disk)
    0FH                 Hardware IRQ7 (printer)
    10H                 Video service
    11H                 Equipment information
    12H                 Memory size
    13H                 Disk I/O service
    14H                 Serial-port service
    15H                 Cassette/network service
    16H                 Keyboard service
    17H                 Printer service
    18H                 ROM BASIC
    19H                 Restart system
    1AH                 Get/Set time/date
    1BH                 Control-Break (user defined)
    1CH                 Timer tick (user defined)
    1DH                 Video parameter pointer
    1EH                 Disk parameter pointer
    1FH                 Graphics character table


    Nestled in the middle of Table 13-2 are the eight hardware interrupt
    vectors (08-0FH) IBM implemented in the original PC design. These
    eight vectors provide the maskable interrupts for the IBM PC-family
    and close compatibles. Additional IRQ lines built into the IBM PC/AT
    are discussed under The IRQ Levels below.

    The conflicting uses of the interrupts listed in Tables 13-1 and 13-2
    have created compatibility problems as the 8086 family of
    microprocessors has developed. For complete compatibility with IBM
    equipment, the IBM usage must be followed even when it conflicts with
    the chip design. For example, a BOUND error occurs if an array index
    exceeds the specified upper and lower limits (bounds) of the array,
    causing an Interrupt 05H to be generated. But the 80286 processor used
    in all AT-class computers will, if a BOUND error occurs, send the
    contents of the display to the printer, because IBM uses Interrupt 05H
    for the Print Screen function.


Hardware Interrupt Categories

    The 8086 family of microprocessors can handle three types of hardware
    interrupts. First are the internal, microprocessor-generated exception
    interrupts (Table 13-1). Second is the nonmaskable interrupt, or NMI
    (Interrupt 02H), which is generated when the NMI line (pin 17 on the
    8088 and 8086, pin 59 on the 80286, pin B8 on the 80386) goes high
    (active). In the IBM PC family (except the PCjr and the Convertible),
    the nonmaskable interrupt is designated for memory parity errors.
    Third are the maskable interrupts, which are usually generated by
    external devices.

    Maskable interrupts are routed to the main processor through a chip
    called the 8259A Programmable Interrupt Controller (PIC). When it
    receives an interrupt request, the PIC signals the microprocessor that
    an interrupt needs service by driving the interrupt request (INTR)
    line of the main processor to high voltage level. This article focuses
    on the maskable interrupts and the 8259A because it is through the PIC
    that external I/O devices (disk drives, serial communication ports,
    and so forth) gain access to the interrupt system.

Interrupt priorities in the 8086 family

    The Intel microprocessors have a built-in priority system for handling
    interrupts that occur simultaneously. Priority goes to the internal
    instruction exception interrupts, such as Divide by Zero and Invalid
    Opcode, because priority is determined by the interrupt number:
    Interrupt 00H takes priority over all others, whereas the last
    possible interrupt, 0FFH, would, if present, never be allowed to break
    in while another interrupt was being serviced. However, if interrupt
    service is enabled (the microprocessor's interrupt flag is set), any
    hardware interrupt takes priority over any software interrupt (INT
    instruction).

    The priority sequencing by interrupt number must not be confused with
    the priority resolution performed by hardware external to the
    microprocessor. The numeric priority discussed here applies only to
    interrupts generated within the 8086 family of microprocessor chips
    and is totally independent of system interrupt priorities established
    for components external to the microprocessor itself.

Interrupt service routines

    For the most part, programmers need not write hardware-specific
    program routines to service the hardware interrupts. The IBM PC BIOS
    routines, together with MS-DOS services, are usually sufficient. In
    some cases, however, MS-DOS and the ROM BIOS do not provide enough
    assistance to ensure adequate performance of a program. Most notable
    in this category is communications software, for which programmers
    usually must access the 8259A and the 8250 Universal Asynchronous
    Receiver and Transmitter (UART) directly. See PROGRAMMING IN THE
    MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: Interrupt-Driven
    Communications.


Characteristics of Maskable Interrupts

    Two major characteristics distinguish maskable interrupts from all
    other events that can occur in the system: They are totally
    unpredictable, and they are highly volatile. In general, a hardware
    interrupt occurs when a peripheral device requires the full attention
    of the system and data will be irretrievably lost unless the system
    responds rapidly.

    All things are relative, however, and this is especially true of the
    speed required to service an interrupt request. For example, assume
    that two interrupt requests occur at essentially the same time. One is
    from a serial communications port receiving data at 300 bps; the other
    is from a serial port receiving data at 9600 bps. Data from the first
    serial port will not change for at least 30 milliseconds, but the
    second serial port must be serviced within one millisecond to avoid
    data loss.

Unpredictability

    Because maskable interrupts generally originate in response to
    external physical events, such as the receipt of a byte of data over a
    communications line, the exact time at which such an interrupt will
    occur cannot be predicted. Even the timer interrupt request, which by
    default occurs approximately 18.2 times per second, cannot be
    predicted by any program that happens to be executing when the
    interrupt request occurs.

    Because of this unpredictability, the system must, if it allows any
    interrupts to be recognized, be prepared to service all maskable
    interrupt requests. Conversely, if interrupts cannot be serviced, they
    must all be disabled. The 8086 family of microprocessors provides the
    Set Interrupt Flag (STI) instruction to enable maskable interrupt
    response and the Clear Interrupt Flag (CLI) instruction to disable it.
    The interrupt flag is also cleared automatically when a hardware
    interrupt response begins; the interrupt handler should execute STI as
    quickly as possible to allow higher priority interrupts to be
    serviced.

Volatility

    As noted earlier, a maskable interrupt request must normally be
    serviced immediately to prevent loss of data, but the concept of
    immediacy is relative to the data transfer rate of the device
    requesting the interrupt. The rule is that the currently available
    unit of data must be processed (at least to the point of being stored
    in a buffer) before the next such item can arrive. Except for such
    devices as disk drives, which always require immediate response,
    interrupts for devices that receive data are normally much more
    critical than interrupts for devices that transmit data.

    The problems imposed by data volatility during hardware interrupt
    service are solved by establishing service priorities for interrupts
    generated outside the microprocessor chip itself. Devices with the
    slowest transfer rates are assigned lower interrupt service
    priorities, and the most time-critical devices are assigned the
    highest priority of interrupt service.


Handling Maskable Interrupts

    The microprocessor handles all interrupts (maskable, nonmaskable, and
    software) by pushing the contents of the flags register onto the
    stack, disabling the interrupt flag, and pushing the current contents
    of the CS:IP registers onto the stack.

    The microprocessor then takes the interrupt number from the data bus,
    multiplies it by 4 (the size of each vector in bytes), and uses the
    result as an offset into the interrupt vector table located in the
    bottom 1 KB (segment 0000H) of system RAM. The 4-byte address at that
    location is then used as the new CS:IP value (Figure 13-1).


    ┌────────────────────┐
    │     Push flags     │
    └─────────┬──────────┘
    ┌───────────────────┐
    │ Disable interrupts │
    └─────────┬──────────┘
    ┌───────────────────┐
    │     Push CS:IP     │
    └─────────┬──────────┘
    ┌───────────────────┐
    │ Get address of ISR │
    │    from table;     │
    │   place in CS:IP   │
    └─────────┬──────────┘
    ┌───────────────────┐
    │ Process interrupt  │
    └─────────┬──────────┘
    ┌───────────────────┐
    │        IRET        │
    └─────────┬──────────┘
    ┌───────────────────┐
    │Restore CS:IP, flags│
    └────────────────────┘

    Figure 13-1. General interrupt sequence.


    External devices are assigned dedicated interrupt request lines (IRQs)
    associated with the 8259A. See The IRQ Levels below. When a device
    requires attention, it sends a signal to the PIC via its IRQ line. The
    PIC, which functions as an "executive secretary" for the external
    devices, operates as shown in Figure 13-2. It evaluates the service
    request and, if appropriate, causes the microprocessor's INTR line to
    go high. The microprocessor then checks whether interrupts are enabled
    (whether the interrupt flag is set). If they are, the flags are pushed
    onto the stack, the interrupt flag is disabled, and CS:IP is pushed
    onto the stack.


        DEVICE                    8259A       MICROPROCESSOR
                                ┌────────┐
                                        │    ┌────────┐
                                        │    │Process │────┐
                                /   \      │    └────┬───┘     │
        ┌───────────────┐IRQ  /  Any  \ No │                  │
        │Signals request├───  IRQs   ───┘                  │
        └───────────────┘     \active?/           /   \       │
                                \   /      │     / INTR  \  No │
                                        │ ┌─  high?  ────┘
                                 Yes    │ │   \       /     
                                        │ │     \   /       │
                                /   \      │ │                │
                            /Is this\ Yes│ │        Yes     │
                               INT   ───┘ │                │
                            \masked off?  │     /   \       │
                                \   /      │ │   / INTs  \  No │
                                        │ │   enabled?────┘
                                 No     │ │   \       /
                                        │ │     \   /
                                /   \      │ │       
                            / INT   \ Yes│ │        Yes
                              being  ───┘ │ ┌────────────┐
                            \serviced?     │ │ Push flags │
                                \   /        │ └────────────┘
                                 No       │        
                                          │ ┌─────────────┐
                        ┌──────────────┐   │ │ Disable INTs│
                        │Signal request├───┘ └──────┬──────┘
                        └──────────────┘INTR        
                                            ┌─────────────┐
                                            │  Push CS:IP │
                                            └──────┬──────┘
                                                    
                                            ┌─────────────┐
                                    ────      │ Acknowledge │
                                    INTA      │     INT     │
            ┌────────────────┐─────────────┴─────────────┘
            │Place INT number│
            │   on data bus  ├─────────────┌─────────────┐
            └────────────────┘  Data bus    │  Get INT    │
                                            │   number    │
                                            └──────┬──────┘
                                                    
                                            ┌─────────────┐
                                            │  Calculate  │
                                            │  new CS:IP  │
                                            └─────────────┘

    Figure 13-2. Maskable interrupt service.


    The microprocessor acknowledges the interrupt request by signaling the
    8259A via the interrupt acknowledge (INTA) line. The 8259A then places
    the interrupt number on the data bus. The microprocessor gets the
    interrupt number from the data bus and services the interrupt. Before
    issuing the IRET instruction, the interrupt service routine must issue
    an end-of-interrupt (EOI) sequence to the 8259A so that other
    interrupts can be processed. This is done by sending 20H to port 20H.
    (The similarity of numbers is pure coincidence.) The EOI sequence is
    covered in greater detail elsewhere. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: Interrupt-Driven Communications.

The 8259A Programmable Interrupt Controller

    The 8259A (Figure 13-3) has a number of internal components, many of
    them under software control. Only the default settings for the IBM PC
    family are covered here.

    Three registers influence the servicing of maskable interrupts: the
    interrupt request register (IRR), the in-service register (ISR), and
    the interrupt mask register (IMR).

    The IRR is used to keep track of the devices requesting attention.
    When a device causes its IRQ line to go high to signal the 8259A that
    it needs service, a bit is set in the IRR that corresponds to the
    interrupt level of the device.

    The ISR specifies which interrupt levels are currently being serviced;
    an ISR bit is set when an interrupt has been acknowledged by the CPU
    (via INTA) and the interrupt number has been placed on the data bus.
    The ISR bit associated with a particular IRQ remains set until an EOI
    sequence is received.

    The IMR is a read/write register (at port 21H) that masks (disables)
    specific interrupts. When a bit is set in this register, the
    corresponding IRQ line is masked and no servicing for it is performed
    until the bit is cleared. Thus, a particular IRQ can be disabled while
    all others continue to be serviced.

    The fourth major block in Figure 13-3, labeled Priority resolver, is a
    complex logical circuit that forms the heart of the 8259A. This
    component combines the statuses of the IMR, the ISR, and the IRR to
    determine which, if any, pending interrupt request should be serviced
    and then causes the microprocessor's INTR line to go high. The
    priority resolver can be programmed in a number of modes, although
    only the mode used in the IBM PC and close compatibles is described
    here.


&lt;────────────────────────────────────────────────────────&gt;
&lt;                                                        &gt;
&lt;                        DATA BUS                        &gt;
&lt;                                                        &gt;
&lt;───────────────────────────────────────────────────────&gt;
        ║
        ║
&lt;──────╨─────────────────────────────────────────────────&gt;
&lt;                                                        &gt;
&lt;                      CONTROL BUS                       &gt;
&lt;                                                        &gt;
&lt;──────╥──────────┬─────────────────────────────────────&gt;
        ║          │ ────                        │
        ║          │ INTA                        │ INT
- - - -║- - - - - │  - - - - - - - - - - - - - -│- - - - - -
|       ║     ┌─────────────────────────────────┴───┐       |
|       ║     │            Control logic             │       |
|       ║     │                                      │       |
|            └┬───────────────────────────────────┘       |
| &lt;────────────┴──────────────────┴─────────────────┴──────&gt; |
| &lt;                          INTERNAL BUS                  &gt; |
| &lt;──────────┬──────────────────┬─────────────────┬─────&gt; |
|    ║  ┌───╨────────┐    ┌────────────┐   ┌──────┴──╨───┐ |
|    ║  │             │    │             │   │             │--IRQ0 ▒
|    ║  │             │    │             │   │             │--IRQ1 ▒
|    ║  │ In-service  │    │  Priority   │   │  Interrupt  │--IRQ2 ▒
|    ║  │  register   │══│  resolver   │══╡   request   │--IRQ3 ▒IRQ
|    ║  │    (ISR)    │    │             │   │  register   │--IRQ4 ▒ lines
|    ║  │             │    │             │   │    (IRR)    │--IRQ5 ▒
|    ║  │             │    │             │   │             │--IRQ6 ▒
|    ║  │             │    │             │   │             │--IRQ7 ▒
|    ║  └─────────────┘    └─────────────┘   └─────────────┘ |
|    ║                                                    |
|    ║         ┌───┴──────────────┴─────────────┴───┐        |
|    ║         │      Interrupt mask register       │        |
|    ╚════════│               (IMR)                │        |
|              └────────────────────────────────────┘        |
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    Figure 13-3. Block diagram of the 8259A Programmable Interrupt
    Controller.


The IRQ levels

    When two or more unserviced hardware interrupts are pending, the 8259A
    determines which should be serviced first. The standard mode of
    operation for the PIC is the fully nested mode, in which IRQ lines are
    prioritized in a fixed sequence. Only IRQ lines with higher priority
    than the one currently being serviced are permitted to generate new
    interrupts.

    The highest priority is IRQ0, and the lowest is IRQ7. Thus, if an
    Interrupt 09H (signaled by IRQ1) is being serviced, only an Interrupt
    08H (signaled by IRQ0) can break in. All other interrupt requests are
    delayed until the Interrupt 09H service routine is completed and has
    issued an EOI sequence.

Eight-level designs
    The IBM PC, PCjr, and PC/XT (and port-compatible computers) have eight
    IRQ lines to the PIC chip--IRQ0 through IRQ7. These lines are mapped
    into interrupt vectors for Interrupts 08H through 0FH (that is, 8 +
    IRQ level). These eight IRQ lines and their associated interrupts are
    listed in Table 13-3.


    Table 13-3. Eight-Level Interrupt Map.

╓┌─────────────────────┌─────────────────┌───────────────────────────────────╖
    IRQ Line         Interrupt         Description
    ──────────────────────────────────────────────────────────────────────
    IRQ0             08H               Timer tick, 18.2 times per second
    IRQ1             09H               Keyboard service required
    IRQ2             0AH               I/O channel (unused on IBM PC/XT)
    IRQ3             0BH               COM1 service required
    IRQ4             0CH               COM2 service required
    IRQ5             0DH               Fixed-disk service required
    IRQ6             0EH               Floppy-disk service required
    IRQ7             0FH               Data request from parallel printer


Sixteen-level designs
    In the IBM PC/AT, 8 more IRQ levels have been added by using a second
    8259A PIC (the "slave") and a cascade effect, which gives 16 priority
    levels.

    The cascade effect is accomplished by connecting the INT line of the
    slave to the IRQ2 line of the first, or "master," 8259A instead of to
    the microprocessor. When a device connected to one of the slave's IRQ
    lines makes an interrupt request, the INT line of the slave goes high
    and causes the IRQ2 line of the master 8259A to go high, which, in
    turn, causes the INT line of the master to go high and thus interrupts
    the microprocessor.

    The microprocessor, ignorant of the second 8259A's presence, simply
    generates an interrupt acknowledge signal on receipt of the interrupt
    from the master 8259A. This signal initializes both 8259As and also
    causes the master to turn control over to the slave. The slave then
    completes the interrupt request.

    On the IBM PC/AT, the eight additional IRQ lines are mapped to
    Interrupts 70H through 77H (Table 13-4). Because the eight additional
    lines are effectively connected to the master 8259A's IRQ2 line, they
    take priority over the master's IRQ3 through IRQ7 events. The cascade
    effect is graphically represented in Figure 13-4.


    Table 13-4. Sixteen-Level Interrupt Map.

╓┌─────────────────────┌─────────────────┌───────────────────────────────────╖
    IRQ Line         Interrupt         Description
    ──────────────────────────────────────────────────────────────────
    IRQ0             08H               Timer tick, 18.2 times per second
    IRQ1             09H               Keyboard service required
    IRQ2             0AH               INT from slave 8259A:
    IRQ8             70H                   Real-time clock service
    IRQ9             71H                   Software redirected to IRQ2
    IRQ10            72H                   Reserved
    IRQ11            73H                   Reserved
    IRQ12            74H                   Reserved
    IRQ13            75H                   Numeric coprocessor
    IRQ14            76H                   Fixed-disk controller
    IRQ15            77H                   Reserved
    IRQ3             0BH               COM2 service required
    IRQ4             0CH               COM1 service required
    IRQ5             0DH               Data request from LPT2
    IRQ6             0EH               Floppy-disk service required
    IRQ7             0FH               Data request from LPT1


&lt;───────────────────────────────────────────────────────────────&gt;
&lt;                                                               &gt;
&lt;                            DATA BUS                           &gt;
&lt;                                                               &gt;
&lt;─────────────────────────────────────────────────────────────&gt;
        ║                              ║
        ║                              ║
&lt;──────────╨──────────────────────────────╨─────────────────────&gt;
&lt;                                                               &gt;
&lt;                          CONTROL BUS                          &gt;
&lt;                                                               &gt;
&lt;──────────╥──────┬───────────────────────╥────────┬───────────&gt;
        ║      │                       ║        │        │
        ║      │     ┌───────┐         ║        │        │
┌────────────────────┴───┐   │   ┌─────────────────────┴──┐
│              ────        │   │   │             ────         │
│              INTA   INT  ═══╪═══╡             INTA   INT   │
│       Slave 8259A        │Control│       Master 8259A       │
└──────────────────────────┘ lines └──────────────────────────┘
                        │                    
    │  │  │  │  │  │  │  │      │      │  │  │  │  │  │  │  │
IRQ15│IRQ13│IRQ11│IRQ9 │      │    IRQ7 │IRQ5 │IRQ3 │IRQ1 │
    │     │     │     │      │         │     │     │     │
    IRQ14 IRQ12 IRQ10 IRQ8      │      IRQ6  IRQ4     │  IRQ0
                                └─────────────────────┘

    Figure 13-4. A graphic representation of the cascade effect for IRQ
    priorities.


    Note: During the INTA sequence, the corresponding bit in the ISR
    register of both 8259As is set, so two EOIs must be issued to complete
    the interrupt service--one for the slave and one for the master.


Programming for the Hardware Interrupts

    Any program that modifies an interrupt vector must restore the vector
    to its original condition before returning control to MS-DOS (or to
    its parent process). Any program that totally replaces an existing
    hardware interrupt handler with one of its own must perform all the
    handshaking and terminating actions of the original--reenable
    interrupt service, signal EOI to the interrupt controller, and so
    forth. Failure to follow these rules has led to many hours of
    programmer frustration. See also PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: CUSTOMIZING MS-DOS: Exception Handlers.

    When an existing interrupt handler is completely replaced with a new,
    customized routine, the existing vector must be saved so it can be
    restored later. Although it is possible to modify the 4-byte vector by
    directly addressing the vector table in low RAM (and many published
    programs have followed this practice), any program that does so runs
    the risk of causing system failure when the program is used with
    multitasking or multiuser enhancements or with future versions of MS-
    DOS. The only technique that can be recommended for either obtaining
    the existing vector values or changing them is to use the MS-DOS
    functions provided for this purpose: Interrupt 21H Functions 25H (Set
    Interrupt Vector) and 35H (Get Interrupt Vector).

    After the existing vector has been saved, it can be replaced with a
    far pointer to the replacement routine. The new routine must end with
    an IRET instruction. It should also take care to preserve all
    microprocessor registers and conditions at entry and restore them
    before returning.

A sample replacement handler

    Suppose a program performs many mathematical calculations of random
    values. To prevent abnormal termination of the program by the default
    MS-DOS Interrupt 00H handler when a DIV or IDIV instruction is
    attempted and the divisor is zero, a programmer might want to replace
    the Interrupt 00H (Divide by Zero) routine with one that informs the
    user of what has happened and then continues operation without
    abnormal termination. The .COM program DIVZERO.ASM (Figure 13-5) does
    just that. (Another example is included in the article on interrupt-
    driven communications. See PROGRAMMING IN THE MS-DOS ENVIRONMENT:
    PROGRAMMING FOR MS-DOS: Interrupt-Driven Communications.)

    ──────────────────────────────────────────────────────────────────────

    Figure 13-5. The Divide by Zero replacement handler, DIVZERO.ASM. This
    code is specific to 80286 and 80386 microprocessors. (See Appendix M:
    8086/8088 Software Compatibility Issues.)

    ──────────────────────────────────────────────────────────────────────

Supplementary handlers

    In many cases, a custom interrupt handler augments, rather than
    replaces, the existing routine. The added routine might process some
    data before passing the data to the existing routine, or it might do
    the processing afterward. These cases require slightly different
    coding for the handler.

    If the added routine is to process data before the existing handler
    does, the routine need only jump to the original handler after
    completing its processing. This jump can be done indirectly, with the
    same pointer used to save the original content of the vector for
    restoration at exit. For example, a replacement Interrupt 08H handler
    that merely increments an internal flag at each timer tick can look
    something like the following:

            .
            .
            .
    myflag  dw      ?                       ; variable to be incremented
                                            ; on each timer-tick interrupt

    oldint8 dd      ?                       ; contains address of previous
                                            ; timer-tick interrupt handler
            .
            .                               ; get the previous contents
            .                               ; of the Interrupt 08H
                                            ; vector...
            mov     ax,3508h                ; AH = 35H (Get Interrupt
                                            ; Vector)
            int     21h                     ; AL = Interrupt number (08H)
            mov     word ptr oldint8,bx     ; save the address of
            mov     word ptr oldint8+2,es   ; the previous Int 08H Handler
            mov     dx,seg myint8           ; put address of the new
            mov     ds,dx                   ; interrupt handler into DS:DX
            mov     dx,offset myint8        ; and call MS-DOS to set
                                            ; vector
            mov     ax,2508h                ; AH = 25H (Set Interrupt
                                            ; Vector)
            int     21h                     ; AL = Interrupt number (08H)
            .
            .
            .
    myint8:                                 ; this is the new handler
                                            ; for Interrupt 08H

            inc     cs:myflag               ; increment variable on each
                                            ; timer-tick interrupt

            jmp     dword ptr cs:[oldint8]  ; then chain to the
                                            ; previous interrupt handler

    The added handler must preserve all registers and machine conditions,
    except those machine conditions it will modify, such as the value of
    myflag in the example (and the flags register, which is saved by the
    interrupt action), and it must restore those registers and conditions
    before performing the jump to the original handler.

    A more complex situation arises when a replacement handler does some
    processing after the original routine executes, especially if the
    replacement handler is not reentrant. To allow for this processing,
    the replacement handler must prevent nested interrupts, so that even
    if the old handler (which is chained to the replacement handler by a
    CALL instruction) issues an EOI, the replacement handler will not be
    interrupted during postprocessing. For example, instead of using the
    preceding Interrupt 08H example routine, the programmer could use the
    following code to implement myflag as a semaphore and use the XCHG
    instruction to test it:

    myint8:                                 ; this is the new handler
                                            ; for Interrupt 08H

            mov     ax,1                    ; test and set interrupt-
            xchg    cs:myflag,ax            ; handling-in-progress
                                            ; semaphore

            push    ax                      ; save the semaphore

            pushf                           ; simulate interrupt, allowing
            call    dword ptr cs:oldint8    ; the previous handler for the
                                            ; Interrupt 08H vector to run

            pop     ax                      ; get the semaphore back
            or      ax,ax                   ; is our interrupt handler
                                            ; already running?

            jnz     myint8x                 ; yes, skip this one

            .                               ; now perform our interrupt
            .                               ; processing here...
            .

            mov     cs:myflag,0             ; clear the interrupt-
                                            ; handling-
                                            ; in-progress flag

    myint8x:
            iret                            ; return from interrupt

    Note that an interrupt handler of this type must simulate the original
    call to the interrupt routine by first doing a PUSHF, followed by a
    far CALL via the saved pointer to execute the original handler
    routine. The flags register pushed onto the stack is restored by the
    IRET of the original handler. Upon return from the original code, the
    new routine can preserve the machine state and do its own processing,
    finally returning to the caller by means of its own IRET.

    The flags inside the new routine need not be preserved, as they are
    automatically restored by the IRET instruction. Because of the nature
    of interrupt servicing, the service routine should not depend on any
    information in the flags register, nor can it return any information
    in the flags register. Note also that the previous handler (invoked by
    the indirect CALL) will almost certainly have dismissed the interrupt
    by sending an EOI to the 8259A PIC. Thus, the machine state is not the
    same as in the first myint8 example.

    To remove the new vector and restore the original, the program simply
    replaces the new vector (in the vector table) with the saved copy. If
    the substituted routine is part of an application program, the
    original vector must be restored for every possible method of exiting
    from the program (including Control-Break, Control-C, and critical-
    error Abort exits). Failure to observe this requirement invariably
    results in system failure. Even though the system failure might be
    delayed for some time after the exit from the offending program, when
    some subsequent program overlays the interrupt handler code the crash
    will be imminent.


Summary

    Hardware interrupt handler routines, although not strictly a part of
    MS-DOS, form an integral part of many MS-DOS programs and are tightly
    constrained by MS-DOS requirements. Routines of this type play
    important roles in the functioning of the IBM personal computers, and,
    with proper design and programming, significantly enhance product
    reliability and performance. In some instances, no other practical
    method exists for meeting performance requirements.

                                                Jim Kyle
                                                Chip Rabinowitz



Article 14: Writing MS-DOS Filters


    A filter is, essentially, a program that operates on a stream of
    characters. The source and destination of the character stream can be
    files, another program, or almost any character device. The
    transformation applied by the filter to the character stream can range
    from an operation as simple as substituting a character set to an
    operation as elaborate as generating splines from sets of coordinates.

    The standard MS-DOS package includes three simple filters: SORT, which
    alphabetically sorts text on a line-by-line basis; FIND, which
    searches a text stream to match a specified string; and MORE, which
    displays text one screenful at a time. This article describes how
    filters work and how new ones can be constructed. See also USER
    COMMANDS: FIND; MORE; SORT.


System Support for Filters

    The operation of a filter program relies on two features that appeared
    in MS-DOS version 2.0:  standard devices and redirectable I/O.

    The standard devices are represented by five handles that are
    originally established when the system is initialized. Each process
    inherits these handles from its immediate parent. Thus, the standard
    device handles are already opened when a process acquires control of
    the system, and the process can use the handles with Interrupt 21H
    Functions 3FH and 40H for read and write operations without further
    preliminaries. The default assignments of the standard device handles
    are

╓┌────────────────┌──────────────────────────────────┌───────────────────────╖
    Handle      Name                               Default Device
    ──────────────────────────────────────────────────────────────────
    0           stdin  (standard input)            CON
    1           stdout (standard output)           CON
    2           stderr (standard error)            CON
    3           stdaux (standard auxiliary)        AUX
    4           stdlst (standard list)             PRN

    The CON device is assigned by default to the system's keyboard and
    video display. AUX is assigned by default to COM1 (the first physical
    serial port), and PRN is assigned by default to LPT1 (the first
    physical parallel printer port); in some systems these assignments can
    be altered with the MODE command. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: Character Device Input and
    Output; USER COMMANDS: MODE; CTTY.

    When a program is executed by entering its name at the system
    (COMMAND.COM) prompt, the user can redirect either or both of the
    standard input and standard output handles from their default device
    (CON) to another file, a character device, or a process. This
    redirection is accomplished by including one of the special characters
    &lt;, &gt;, &gt;&gt;, or  in the command line, in the following form:

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Redirection      Result
    ──────────────────────────────────────────────────────────────────
    &lt; file           Contents of the specified file are used instead of
                    the keyboard as the program's standard input.

    &lt; device         Program takes its standard input from the named
                    device instead of from the keyboard.

    &gt; device         Program sends its standard output to the named device
                    instead of to the video display.

    &gt; file           Program sends its standard output to the specified
                    file instead of to the video display.

    &gt;&gt; file          Program appends its standard output to the current
                    contents of the specified file instead of to the
                    video display.

    p1 | p2          Standard output of program p1 is routed to become the
                    standard input of program p2 (output of p1 is said
                    to be piped to p2).

    For example, the command

    C&gt;SORT &lt; MYFILE.TXT &gt; PRN  &lt;Enter&gt;

    causes the SORT filter to read its input from the file MYFILE.TXT,
    sort the lines alphabetically, and write resulting text to the
    character device PRN (the logical name for the system's list device).

    The redirection requested by the &lt;, &gt;, &gt;&gt;, or  characters takes place
    at the level of COMMAND.COM and is invisible to the program it
    affects. Such redirection can also be put into effect by another
    process. See Using a Filter as a Child Process, below.

    Note that if a program "goes around" MS-DOS to perform its input and
    output, either by calling ROM BIOS functions or by manipulating the
    keyboard or video controller directly, redirection commands placed in
    the program's command line do not have the expected effect.


How Filters Work

    By convention, a filter program reads its text from standard input and
    writes the results of its operations to standard output. When the end
    of the input stream is reached, the filter simply terminates,
    optionally writing an end-of-file mark (1AH) to the output stream. As
    a result, filters are both flexible and simple.

    Filter programs are flexible because they do not know, and do not
    care, about the source of the data they process or the destination of
    their output. Any redirection that the user specifies in the command
    line is invisible to the filter. Thus, any character device that has a
    logical name within the system (CON, AUX, COM1, COM2, PRN, LPT1, LPT2,
    LPT3, and so on), any file on any block device (local or network)
    known to the system, or any other program can supply a filter's input
    or accept its output. If necessary, several functionally simple
    filters can be concatenated with pipes to perform very complex
    operations.

    Although flexible, filters are also simple because they rely on their
    parent process to supply standard input and standard output handles
    that have already been appropriately redirected. The parent is
    responsible for opening or creating any necessary files, checking the
    validity of logical character device names, and loading and executing
    the preceding or following process in a pipe. The filter need only
    concern itself with the transformation it will apply to the data; it
    can leave the I/O details to the operating system and to its parent.


Building a Filter

    Creating a new filter for MS-DOS is a straightforward process. In its
    simplest form, a filter need only use the handle-oriented read
    (Interrupt 21H Function 3FH) and write (Interrupt 21H Function 40H)
    functions to get characters or lines from standard input and send them
    to standard output, performing any desired alterations on the text
    stream on a character-by-character or line-by-line basis.

    Figures 14-1 through 14-4 contain template character-oriented and
    line-oriented filters in both assembly language and C. The C version
    of the character filter runs much faster than the assembly-language
    version, because the C run-time library provides hidden blocking and
    deblocking (buffering) of character reads and writes; the assembly-
    language program actually makes two calls to MS-DOS for each character
    processed. (Of course, if buffering is added to the assembly-language
    version it will be both faster and smaller than the C filter.) The C
    and assembly-language versions of the line-oriented filter run at
    roughly the same speed.

    ──────────────────────────────────────────────────────────────────────

    Figure 14-1. Assembly-language template for a character-oriented
    filter (file PROTOC.ASM).

    ──────────────────────────────────────────────────────────────────────

    Figure 14-2. C template for a character-oriented filter (file
    PROTOC.C).

    ──────────────────────────────────────────────────────────────────────

    Figure 14-3. Assembly-language template for a line-oriented filter
    (file PROTOL.ASM).

    ──────────────────────────────────────────────────────────────────────

    Figure 14-4. C template for a line-oriented filter (file PROTOL.C).

    ──────────────────────────────────────────────────────────────────────

    Each of the four template filters can be assembled or compiled,
    linked, and run exactly as they are shown in Figures 14-1 through
    14-4. Of course, in this form they function like an incredibly slow
    COPY command.

    To obtain a filter that does something useful, a routine that performs
    some modification of the text stream that is flowing by must be
    inserted between the reads and writes. For example, Figures 14-5 and
    14-6 contain the assembly-language and C source code for a character-
    oriented filter named LC. This program converts all uppercase input
    characters (A-Z) to lowercase (a-z) output, leaving other characters
    unchanged. The only difference between LC and the template character
    filter is the translation subroutine that operates on the text stream.

    ──────────────────────────────────────────────────────────────────────

    Figure 14-5. Assembly-language source code for the LC filter (file
    LC.ASM).

    ──────────────────────────────────────────────────────────────────────

    Figure 14-6. C source code for the LC filter (file LC.C).

    ──────────────────────────────────────────────────────────────────────

    As another example, Figure 14-7 contains the C source code for a line-
    oriented filter called FIND. This simple filter is invoked with a
    command line in the form

    FIND "pattern" &lt; source &gt; destination

    FIND searches the input stream for lines containing the pattern
    specified in the command line. The line number and text of any line
    containing a match is sent to standard output, with any tabs expanded
    to eight-column tab stops.

    ──────────────────────────────────────────────────────────────────────

    Figure 14-7. C source code for a new FIND filter (file FIND.C).

    ──────────────────────────────────────────────────────────────────────

    This sample FIND filter differs from the FIND filter supplied by
    Microsoft with MS-DOS in several respects. It is not case sensitive,
    so the pattern "foobar" will match "FOOBAR", "FooBar", and so forth.
    Second, this filter supports no switches; these are left as an
    exercise for the reader. Third, unlike the Microsoft version of FIND,
    this program always reads from standard input; it is not able to open
    its own files.


Using a Filter as a Child Process

    Instead of incorporating all the code necessary to do the job itself,
    an application program can load and execute a filter as a child
    process to carry out a specific task. Before the child filter is
    loaded, the parent must arrange for the standard input and standard
    output handles that will be inherited by the child to be attached to
    the files or character devices that will supply the filter's input and
    receive its output. This redirection is accomplished with the
    following steps using Interrupt 21H functions:

    1. The parent process uses Function 45H (Duplicate File Handle) to
        create duplicates of its standard input and standard output handles
        and then saves the duplicates.

    2. The parent opens (with Function 3DH) or creates (with Function 3CH)
        the files or devices that the child process will use for input and
        output.

    3. The parent uses Function 46H (Force Duplicate File Handle) to force
        its own standard device handles to track the new file or device
        handles acquired in step 2.

    4. The parent uses Function 4B00H (Load and Execute Program [EXEC]) to
        load and execute the child process. The child inherits the
        redirected standard input and standard output handles and uses them
        to do its work. The parent regains control after the child filter
        terminates.

    5. The parent uses the duplicate handles created in step 1, together
        with Function 46H (Force Duplicate File Handle), to restore its own
        standard input and standard output handles to their original
        meanings.

    6. The parent closes (with Function 3EH) the duplicate handles created
        in step 1, because they are no longer needed.

    It might seem as though the parent process could just as easily close
    its own standard input and standard output (handles 0 and 1), open the
    input and output files needed by the child, load and execute the
    child, close the files upon regaining control, and then reopen the CON
    device twice. Because the open operation always assigns the first free
    handle, this approach would have the desired effect as far as the
    child process is concerned. However, it would throw away any
    redirection that had been established for the parent process by its
    parent. Thus, the need to preserve any preexisting redirection of the
    parent's standard input and standard output, along with the desire to
    preserve the parent's usual output channel for informational messages
    right up to the actual point of the EXEC call, is the reason for the
    elaborate procedure outlined above in steps 1 through 6.

    The program EXECSORT.ASM in Figure 14-8 demonstrates this redirection
    of input and output for a filter run as a child process. The parent,
    which is called EXECSORT, saves duplicates of its current standard
    input and standard output handles and then redirects those handles
    respectively to the files MYFILE.DAT (which it opens) and MYFILE.SRT
    (which it creates). EXECSORT then uses Interrupt 21H Function 4BH
    (EXEC) to run the SORT.EXE filter that is supplied with MS-DOS (this
    file must be in the current drive and directory for the demonstration
    to work correctly).

    ──────────────────────────────────────────────────────────────────────

    Figure 14-8. Assembly-language source code demonstrating use of a
    filter as a child process. This code redirects the standard input and
    standard output handles to files, invokes the EXEC function (Interrupt
    21H Function 4BH) to run the SORT.EXE program, and then restores the
    original meaning of the standard input and standard output handles
    (file EXECSORT.ASM).

    ──────────────────────────────────────────────────────────────────────

    The MS-DOS SORT program reads the file MYFILE.DAT via its standard
    input handle, sorts the file alphabetically, and writes the sorted
    data to MYFILE.SRT via its standard output handle. When SORT
    terminates, MS-DOS closes SORT's inherited handles for standard input
    and standard output, which forces an update of the directory entries
    for the associated files. The program EXECSORT then resumes execution,
    restores its own standard input and standard output handles (which are
    still open) to their original meanings, displays a success message on
    standard output, and exits to MS-DOS.

                                                    Ray Duncan



Article 15: Installable Device Drivers


    The software that runs on modern computer systems is, by convention,
    organized into layers with varied degrees of independence from the
    underlying computer hardware. The purpose of this layering is
    threefold:

    ■  To minimize the impact on programs of differences between hardware
        devices or changes in the hardware.

    ■  To allow the code for common operations to be centralized and
        optimized.

    ■  To ease the task of moving programs and their data from one machine
        to another.

    The top and most hardware-independent layer is usually the transient,
    or application, program, which performs a specific job and deals with
    data in terms of files and records within those files. Such programs
    are called transient because they are brought into RAM for execution
    when needed and are discarded from memory when their job is finished.
    Examples of such programs are Microsoft Word, various programming
    tools such as the Microsoft Macro Assembler (MASM) and the Microsoft
    Object Linker (LINK), and even some of the standard MS-DOS utility
    programs such as CHKDSK and FORMAT.

    The middle layer is the operating-system kernel, which manages the
    allocation of system resources such as memory and disk storage,
    provides a battery of services to application programs, and implements
    disk directories and the other housekeeping details of disk storage.
    The MS-DOS kernel is brought into memory from the file MSDOS.SYS (or
    IBMDOS.COM with PC-DOS) when the system is turned on or restarted and
    remains fixed in memory until the system is turned off. The system's
    default command processor, COMMAND.COM, and system manager programs
    such as Microsoft Windows bridge the categories of application program
    and operating system: Parts of them remain resident in memory at all
    times, but they rely on the MS-DOS kernel for services such as file
    I/O. See PROGRAMMING IN THE MS-DOS ENVIRONMENT: STRUCTURE OF MS-DOS:
    Components of MS-DOS.

    The modules in the lowest layer are called device drivers. These
    drivers are the components of the operating system that manage the
    controller, or adapter, of a peripheral device--a piece of hardware
    that the computer uses for such purposes as storage or communicating
    with the outside world. Thus, device drivers are responsible for
    transferring data between a peripheral device and the computer's RAM
    memory, where other programs can work on it. Drivers shield the
    operating-system kernel from the need to deal with hardware I/O port
    addresses, operating characteristics, and the peculiarities of a
    particular peripheral device, just as the kernel, in turn, shields
    application programs from the details of file management.

    In MS-DOS versions 1.x, device drivers were integrated into the
    operating system and could be extended or replaced only by patching
    the files that contained the operating system itself. Because every
    third-party peripheral manufacturer evolved a different method of
    modifying these files to get its product to work, conflicts between
    products from different manufacturers were frequent and expansion of a
    PC with new disk drives and other devices (especially fixed disks) was
    often a chancy proposition.

    In MS-DOS versions 2.0 and later, there is a clean separation between
    device drivers and the MS-DOS kernel. Device drivers have a
    straightforward structure and are interfaced to the kernel through a
    simple and clearly defined scheme that consists of far calls, function
    codes, and data packets. Given adequate information about the
    hardware, a programmer can write a new device driver that follows this
    structure and interface for almost any conceivable peripheral device;
    such a driver can subsequently be installed and used without any
    changes to the underlying operating system.

    This article explains the anatomy, operation, and creation of drivers
    for MS-DOS versions 2.0 and later. Device drivers for versions 1.x are
    not discussed further here.


Resident and Installable Drivers

    Every MS-DOS system contains built-in device drivers for the console
    (keyboard and video display), the serial port, the parallel printer
    port, the real-time clock, and at least one disk storage device (the
    system boot device). These drivers, known as the resident drivers, are
    loaded as a set from the file IO.SYS (or IBMBIO.COM with PC-DOS) when
    the system is turned on or restarted.

    Drivers for additional peripheral devices occupy individual files on
    the disk. These drivers, called installable drivers, are loaded and
    linked into the system during its initialization as a result of DEVICE
    directives in the CONFIG.SYS file. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: STRUCTURE OF MS-DOS: Components of MS-DOS. Examples of
    such drivers are the ANSI.SYS and RAMDISK.SYS files included with MS-
    DOS version 3.2. In all other respects, installable drivers have the
    same structure and relationship to the MS-DOS kernel as the resident
    drivers. All drivers in the system are chained together so that MS-DOS
    can rapidly search the entire set to find a specific block or
    character device when an I/O operation is requested.

    Device drivers as a whole are categorized into two groups: block-
    device drivers and character-device drivers. A driver's membership in
    one of these two groups determines how the associated device is viewed
    by MS-DOS and what functions the driver itself must support.

Character-device drivers

    Character-device drivers control peripheral devices, such as a
    terminal or a printer, that perform input and output one character (or
    byte) at a time. Each character-device driver ordinarily supports a
    single hardware unit. The device has a one-character to eight-
    character logical name that can be used by an application program to
    "open" the device for input or output as though it were a file. The
    logical name is strictly a means of identifying the driver to MS-DOS
    and has no physical equivalent on the device (unlike a volume label
    for block devices).

    The three resident character-device drivers for the console, serial
    port, and printer carry the logical device names CON, AUX, and PRN,
    respectively. These three drivers receive special treatment by MS-DOS
    that allows application programs to address the associated devices in
    three different ways:

    ■  They can be opened by name for input and output (like any other
        character device).

    ■  They are supported by special-purpose MS-DOS function calls
        (Interrupt 21H Functions 01-0CH).

    ■  They are assigned to default handles (standard input, standard
        output, standard error, standard auxiliary, and standard list) that
        need not be opened to be used.

    See PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS:
    Character Device Input and Output.

    Other character devices can be supported by simply installing
    additional character-device drivers. The only significant restriction
    on the total number of devices that can be supported, other than the
    memory required to hold the drivers, is that each driver must have a
    unique logical name. When MS-DOS receives an open request for a
    character device, it searches the chain of device drivers in order
    from the last driver loaded to the first. Thus, if more than one
    driver uses the same logical name, the last driver to be loaded
    supersedes any others and receives all I/O requests addressed to that
    logical name. This behavior can be used to advantage in some
    situations. For example, it allows the more powerful ANSI.SYS display
    driver to supersede the system's default console driver, which does
    not support cursor positioning and character attributes.

    The MS-DOS kernel's buffering and filtering of the characters that
    pass between it and a character-device driver are affected by whether
    MS-DOS regards the device to be in cooked mode or raw mode. During
    cooked mode input, MS-DOS requests characters one at a time from the
    driver and places them in its own internal buffer, echoing each
    character to the screen (if the input device is the keyboard) and
    checking each character for a Control-C (03H) or a Return (0DH). When
    either the number of characters requested by the application program
    has been received or a Return is detected, the input is terminated and
    the data is copied from MS-DOS's internal buffer into the requesting
    program's buffer. When a Control-C is detected, MS-DOS aborts the
    input operation and transfers to the routine whose address is stored
    in the Interrupt 23H (Control-C Handler Address) vector. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Exception
    Handlers. Similarly, during output in cooked mode, MS-DOS checks
    between each character for a Control-C pending at the keyboard and
    aborts the output operation if one is detected.

    In raw mode, the exact number of bytes requested by the application
    program is read or written, without regard to any control characters
    such as Return or Control-C. MS-DOS passes the entire I/O request to
    the driver in a single operation, instead of breaking the request into
    single-character reads or writes, and the characters are transferred
    directly to or from the requesting program's buffer.

    The mode for a specific device can be queried by an application
    program with the IOCTL Get Device Data function (Interrupt 21H
    Function 44H Subfunction 00H); the mode can be selected with the Set
    Device Data function (Interrupt 21H Function 44H Subfunction 01H). See
    SYSTEM CALLS: INTERRUPT 21H: Function 44H. The driver itself is not
    usually aware of its mode and the mode does not affect its operation.

Block-Device Drivers

    Block-device drivers control peripheral devices that transfer data in
    chunks rather than 1 byte at a time. Block devices are usually
    randomly addressable devices such as floppy- or fixed-disk drives, but
    they can also be sequential devices such as magnetic-tape drives. A
    block driver can support more than one physical unit and can also map
    two or more logical units onto a single physical unit, as with a
    partitioned fixed disk.

    MS-DOS assigns single-letter drive identifiers (A, B, and so forth) to
    block devices, instead of logical names. The first letter assigned to
    a block-device driver is determined solely by the driver's position in
    the chain of all drivers--that is, by the number of units supported by
    the block drivers loaded before it; the total number of letters
    assigned to the driver is determined by the number of logical drive
    units the driver supports.

    MS-DOS does not associate a mode (cooked or raw) with block-device
    drivers. A block-device driver always reads or writes exactly the
    number of sectors requested (barring hardware or addressing errors)
    and never filters or otherwise manipulates the contents of the blocks
    being transferred.


Structure of an MS-DOS Device Driver

    A device driver has three major components (Figure 15-1):

    ■  The device header
    ■  The Strategy routine (Strat)
    ■  The Interrupt routine (Intr)


    ┌─────────────────────────┬─────────────────────────────┐
    │                         │       Initialization        │
    │                         ├─────────────────────────────┤
    │                         │         Media Check         │
    │                         ├─────────────────────────────┤
    │                         │          Build BPB          │
    │                         ├─────────────────────────────┤
    │                         │    IOCTL Read and Write     │
    │                         ├─────────────────────────────┤
    │                         │           Status            │
    │                         ├─────────────────────────────┤
    │      Interrupt routine  │            Read             │
    │                         ├─────────────────────────────┤
    │                         │     Write, Write/Verify     │
    │                         ├─────────────────────────────┤
    │                         │      Output Until Busy      │
    │                         ├─────────────────────────────┤
    │                         │        Flush Buffers        │
    │                         ├─────────────────────────────┤
    │                         │         Device Open         │
    │                         ├─────────────────────────────┤
    │                         │        Device Close         │
    │                         ├─────────────────────────────┤
    │                         │     Check if Removable      │
    │                         ├─────────────────────────────┤
    │                         │        Generic IOCTL        │
    │                         ├─────────────────────────────┤
    │                         │   Get/Set Logical Device    │
    │                         └─────────────────────────────┤
    │                                                       │
    ├───────────────────────────────────────────────────────┤
    │                                                       │
    │                   Strategy routine                    │
    │                                                       │
    ├───────────────────────────────────────────────────────┤
    │                 Device-driver header                  │
    └───────────────────────────────────────────────────────┘

    Figure 15-1. General structure of an MS-DOS installable device driver.


The device header

    The device header (Figure 15-2) always lies at the beginning of the
    driver. It contains a link to the next driver in the chain, a word (16
    bits) of device attribute flags, offsets to the executable Strategy
    and Interrupt routines for the device, and the logical device name if
    it is a character device such as PRN or COM1 or the number of logical
    units if it is a block device.


    Offset
        00H  ┌────────────────────────────────────────────┐
            │        Link to next driver, offset         │
        02H  ├────────────────────────────────────────────┤
            │        Link to next driver, segment        │
        04H  ├────────────────────────────────────────────┤
            │           Device attribute word            │
        06H  ├────────────────────────────────────────────┤
            │        Offset, Strategy entry point        │
        08H  ├────────────────────────────────────────────┤
            │       Offset, Interrupt entry point        │
        0AH  ├────────────────────────────────────────────┤
            │ Logical name (8 bytes) if character device │
            │                     or                     │
            │    Number of units (1 byte) followed by    │
            │ 7 bytes of reserved space if block device  │
        12H  └────────────────────────────────────────────┘

    Figure 15-2. Device header. The offsets to the Strat and Intr routines
    are offsets from the same segment used to point to the device header.


    The device attribute flags word (Table 15-1) defines whether a driver
    controls a character or a block device, which of the optional
    subfunctions added in MS-DOS versions 3.0 and 3.2 are supported by the
    driver, and, in the case of block drivers, whether the driver supports
    IBM-compatible disk media. The least significant 4 bits of the device
    attribute flags word control whether MS-DOS should use the driver as
    the standard input, standard output, clock, or NUL device; each of
    these 4 bits should be set on only one driver in the system at a time.


    Table 15-1. Device Attribute Word in Device Header.

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Bit         Setting
    ──────────────────────────────────────────────────────────────────
    15          1 if character device, 0 if block device
    14          1 if IOCTL Read and Write supported
    13          1 if non-IBM format (block device)
                1 if Output Until Busy supported (character device)
    12          0 (reserved)
    11          1 if Open/Close/Removable Media supported (versions 3.0
                and later)
    10          0 (reserved)
    9          0 (reserved)
    8          0 (reserved)
    7          0 (reserved)
    6          1 if Generic IOCTL and Get/Set Logical Drive supported
                (version 3.2)
    5          0 (reserved)
    4          1 if special fast output function for CON device supported
    3          1 if current CLOCK device
    2          1 if current NUL device
    1          1 if current standard output (stdout)
    0          1 if current standard input (stdin)


    The information in the device header is ordinarily used only by the
    MS-DOS kernel and is not available to application programs. However,
    the IOCTL subfunctions Get and Set Device Data (Interrupt 21H Function
    44H Subfunctions 00H and 01H) can be used to inspect or modify some of
    the bits in the device attribute flags word. Note that there is not a
    one-to-one correspondence between the bits defined for those functions
    and the bits in the device header. For example, in the device
    information word used by the IOCTL subfunctions, bit 7 indicates a
    block or character device; in the device attribute word of the device
    header, bit 15 indicates a block or character device.

The Strategy routine (Strat)

    MS-DOS calls the driver's Strategy routine as the first step of any
    operation, passing it the segment and offset of a data structure
    called a request header in registers ES:BX. The Strategy routine saves
    this pointer for subsequent processing by the Interrupt routine and
    returns to MS-DOS.

    A request header is essentially a small buffer used for private
    communication between MS-DOS and the device driver. Both MS-DOS and
    the device driver read and write information in the request header.

    The first 13 bytes of a request header are the same for all device-
    driver functions and are therefore referred to as the static portion
    of the header. The number and contents of the subsequent bytes vary
    according to the type of operation being requested by the MS-DOS
    kernel (Figure 15-3). The request header's most important component is
    the command code passed in its third byte; this code selects a driver
    function such as Read or Write. Other information passed to the driver
    in the request header includes unit numbers, transfer addresses, and
    sector or byte counts.


    00H  ┌──────────────────────────────────────┐
        │        Request header length         │▒
    01H  ├──────────────────────────────────────┤▒
        │       Block-device unit number       │▒
    02H  ├──────────────────────────────────────┤▒
        │  Command code (driver subfunction)   │▒
    03H  ├──────────────────────────────────────┤▒
        │                                      │▒
        │           Returned status            │▒ Static portion
        │                                      │▒  of request header
    05H  ├──────────────────────────────────────┤▒
        │                                      │▒
        │                                      │▒
        │                                      │▒
        │               Reserved               │▒
        │                                      │▒
        │                                      │▒
        │                                      │▒
    0DH  ├──────────────────────────────────────┤
        │            Media ID byte             │▒
    0EH  ├──────────────────────────────────────┤▒
        │                                      │▒
        │                Offset                │▒
        │                                      │▒
    10H  ├──────────────────────────────────────┤▒
        │                                      │▒
        │  Segment of data to be transferred   │▒ Variable portion
        │                                      │▒  of request header
    12H  ├──────────────────────────────────────┤▒
        │                                      │▒
        │          Byte/sector count           │▒
        │                                      │▒
    14H  ├──────────────────────────────────────┤▒
        │                                      │▒
        │        Starting sector number        │▒
        │                                      │▒
        └──────────────────────────────────────┘

    Figure 15-3. A typical driver request header. The bytes following the
    static portion are the format used for driver Read, Write, Write with
    Verify, IOCTL Read, and IOCTL Write operations.


The Interrupt routine (Intr)

    The last and most complex part of a device driver is the Interrupt
    routine, which is called by MS-DOS immediately after the call to the
    Strategy routine. The bulk of the Interrupt routine is a collection of
    functions or subroutines, sometimes called command-code routines, that
    carry out each of the various operations the MS-DOS kernel requires a
    driver to support.

    When the Interrupt routine receives control from MS-DOS, it saves any
    affected registers, examines the request header whose address was
    previously passed in the call to the Strategy routine, determines
    which command-code routine is needed, and branches to the appropriate
    function. When the operation is completed, the Interrupt routine
    stores the status (Table 15-2), error (Table 15-3), and any other
    applicable information into the request header, restores the previous
    contents of the affected registers, and returns to the MS-DOS kernel.


    Table 15-2. The Request Header Status Word.

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Bits        Meaning
    ──────────────────────────────────────────────────────────────────
    15          Error
    12-14       Reserved
    9           Busy
    8           Done
    0-7         Error code if bit 15 = 1


    Table 15-3. Device-Driver Error Codes.

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Code        Meaning
    ──────────────────────────────────────────────────────────────────
    00H         Write-protect violation
    01H         Unknown unit
    02H         Drive not ready
    03H         Unknown command
    04H         CRC error
    05H         Bad drive request structure length
    06H         Seek error
    07H         Unknown media
    08H         Sector not found
    09H         Printer out of paper
    0AH         Write fault
    0BH         Read fault
    0CH         General failure
    0DH         Reserved
    0EH         Reserved
    0FH         Invalid disk change (versions 3.x)


    The Interrupt routine's name is misleading in that it is never entered
    asynchronously as a hardware interrupt. The division of function
    between the Strategy and Interrupt routines is present for symmetry
    with UNIX/XENIX and MS OS/2 drivers but is essentially meaningless in
    single-tasking MS-DOS because there is never more than one I/O request
    in progress at a time.

The command-code functions
    A total of twenty command codes are defined for MS-DOS device drivers.
    The command codes and the names of their associated Interrupt routines
    are shown in the following list:

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Code        Routine
    ──────────────────────────────────────────────────────────────────
    0          Init (initialization)
    1          Media Check (block devices only)
    2          Build BIOS Parameter Block (block devices only)
    3          IOCTL Read
    4          Read (Input)
    5          Nondestructive Read (character devices only)
    6          Input Status (character devices only)
    7          Flush Input Buffers (character devices only)
    8          Write (Output)
    9          Write with Verify
    10          Output Status (character devices only)
    11          Flush Output Buffers (character devices only)
    12          IOCTL Write
    13          Device Open
    14          Device Close
    15          Removable Media (block devices only)
    16          Output Until Busy (character devices only)
    19          Generic IOCTL Request
    23          Get Logical Device (block devices only)
    24          Set Logical Device (block devices only)

    Functions 0 through 12 must be supported by a driver's Interrupt
    section under all versions of MS-DOS. Drivers tailored for versions
    3.0 and 3.1 can optionally support an additional 4 functions defined
    under those versions of the operating system and drivers designed for
    version 3.2 can support 3 more, for a total of 20. MS-DOS inspects the
    bits in the device attribute word of the device header to determine
    which of the optional version 3.x functions a driver supports, if any.

    As noted in the list above, some of the functions are relevant only
    for character drivers, some only for block drivers, and some for both.
    In any case, there must be an executable routine present for each
    function, even if the routine does nothing but set the done flag in
    the status word of the request header. The general requirements for
    each function routine are described below.

    The Init function
    The Init (initialization) function (command code 0) for a driver is
    called only once, when the driver is loaded (Figure 15-4). Init is
    responsible for checking that the hardware device controlled by the
    driver is present and functional, performing any necessary hardware
    initialization (such as a reset on a printer or a seek to the home
    track on a disk device), and capturing any interrupt vectors that the
    driver will need later.

    The Init function is passed a pointer in the request header to the
    text of the DEVICE line in CONFIG.SYS that caused the driver to be
    loaded--specifically, the address of the next byte after the equal
    sign (=). The line is read-only and is terminated by a linefeed or
    carriage-return character; it can be scanned by the driver for
    switches or other parameters that might influence the driver's
    operation. (Alphabetic characters in the line are folded to
    uppercase.) With versions 3.0 and later, block drivers are also passed
    the drive number that will be assigned to their first unit (0 = A, 1 =
    B, and so on).


            Driver called with                   Driver returns
    00H ┌─────────────────────────┐    00H ┌─────────────────────────┐
        │ Request header length   │        │                         │
    01H ├─────────────────────────┤    01H ├─────────────────────────┤
        │                         │        │                         │
    02H ├─────────────────────────┤    02H ├─────────────────────────┤
        │      Command code       │        │                         │
    03H ├─────────────────────────┤    03H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │         Status          │
        │                         │        │                         │
    05H ├─────────────────────────┤    05H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │                         │
        │        Reserved         │        │        Reserved         │
        │                         │        │                         │
        │                         │        │                         │
    0DH ├─────────────────────────┤    0DH ├─────────────────────────┤
        │                         │        │    Units supported      │
    0EH ├─────────────────────────┤    0EH ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │ Offset of free memory   │
        │                         │        │      above driver       │
    10H ├─────────────────────────┤    10H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │ Segment of free menory  │
        │                         │        │      above driver       │
    12H ├─────────────────────────┤    12H ├─────────────────────────┤
        │                         │        │                         │
        │Offset of CONFIG.SYS     │        │        Offset of        │
        │line loading driver      │        │   BPB pointer array     │
    14H ├─────────────────────────┤    14H ├─────────────────────────┤
        │                         │        │                         │
        │Segment of CONFIG.SYS    │        │       Segment of        │
        │line loading driver      │        │   BPB pointer array     │
    16H ├─────────────────────────┤    16H ├─────────────────────────┤
        │First unit number        │        │                         │
        └─────────────────────────┘        └─────────────────────────┘

    Figure 15-4. Initialization request header (command code 0).


    When it returns to the kernel, the Init function must set the done
    flag in the status word of the request header and return the address
    of the start of free memory after the driver (sometimes called the
    break address). This address tells the kernel where it can build
    certain control structures of its own associated with the driver and
    then load the next driver. The Init routine of a block-device driver
    must also return the number of logical units supported by the driver
    and the address of a BPB pointer array.

    The number of units returned by a block driver is used to assign
    device identifiers. For example, if at the time the driver is loaded
    there are already drivers present for four block devices (drive codes
    0-3, corresponding to drive identifiers A through D) and the driver
    being initialized supports four units, it will be assigned the drive
    numbers 4 through 7 (corresponding to the drive names E through H).
    (Although there is also a field in the device header for the number of
    units, it is not inspected by MS-DOS; rather, it is set by MS-DOS from
    the information returned by the Init function.)

    The BPB pointer array is an array of word offsets to BIOS parameter
    blocks. See The Build BIOS Parameter Block Function, below;
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: STRUCTURE OF MS-DOS: MS-DOS
    Storage Devices. The array must contain one entry for each unit
    defined by the driver, although all entries can point to the same BPB
    to conserve memory. During the operating-system boot sequence, MS-DOS
    scans all the BPBs defined by all the units in all the resident block-
    device drivers to determine the largest sector size that exists on any
    device in the system; this information is used to set MS-DOS's cache
    buffer size. Thus, the sector size in the BPB of any installable block
    driver must be no larger than the largest sector size used by the
    resident block drivers.

    If the Init routine finds that its hardware device is missing or
    defective, it can bypass the installation of the driver completely by
    returning the following values in the request header:

╓┌────────────────────────────────┌──────────────────────────────────────────╖
    Item                        Value
    ──────────────────────────────────────────────────────────────────
    Number of units             0
    Address of free memory      Segment and offset of the driver's own
                                device header

    A character-device driver must also clear bit 15 of the device
    attribute word in the device header so that MS-DOS will load the next
    driver in the same location as the one that just terminated itself.

    The operating-system services that can be invoked by the Init routine
    are very limited. Only MS-DOS Interrupt 21H Functions 01-0CH (various
    character input and output services), 25H (Set Interrupt Vector), 30H
    (Get MS-DOS Version Number), and 35H (Get Interrupt Vector) can be
    called by the Init code. These functions assist the driver in
    configuring itself for the version of the host operating system it is
    to run under, capturing vectors for hardware interrupts, and
    displaying informational or error messages.

    The amount of RAM required by a device driver can be reduced by
    positioning the Init routine at the end of the driver and returning
    that routine's starting address as the location of the first free
    memory.

    The Media Check function
    The Media Check function (command code 1) is used only in block-device
    drivers. It is called by the MS-DOS kernel when there is a pending
    drive access call other than a simple file read or write (for example,
    a file open, close, rename, or delete), passing the media ID byte
    (Figure 15-5) for the disk that MS-DOS assumes is in the drive:

╓┌────────────────────────────┌──────────────────────────────────────────────╖
    Description             Medium
    ──────────────────────────────────────────────────────────────────
    0F9H                    5.25-inch double-sided, 15 sectors
    0FCH                    5.25-inch single-sided, 9 sectors
    0FDH                    5.25-inch double-sided, 9 sectors
    0FEH                    5.25-inch single-sided, 8 sectors
    0FFH                    5.25-inch double-sided, 8 sectors
    0F9H                    3.5-inch double-sided, 9 sectors
    0F0H                    3.5-inch double-sided, 18 sectors
    0F8H                    Fixed disk

    The function returns a code indicating whether the medium has been
    changed since the last transfer:

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Code        Meaning
    ──────────────────────────────────────────────────────────────────
    -1          Medium changed
    -0          Don't know if medium changed
    -1          Medium not changed


            Driver called with                   Driver returns
    00H ┌─────────────────────────┐    00H ┌─────────────────────────┐
        │  Request header length  │        │                         │
    01H ├─────────────────────────┤    01H ├─────────────────────────┤
        │       Unit number       │        │                         │
    02H ├─────────────────────────┤    02H ├─────────────────────────┤
        │      Command code       │        │                         │
    03H ├─────────────────────────┤    03H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │         Status          │
        │                         │        │                         │
    05H ├─────────────────────────┤    05H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │                         │
        │        Reserved         │        │        Reserved         │
        │                         │        │                         │
        │                         │        │                         │
    0DH ├─────────────────────────┤    0DH ├─────────────────────────┤
        │      Media ID byte      │        │                         │
    0EH ├─────────────────────────┤    0EH ├─────────────────────────┤
        │                         │        │    Media change code    │
    0FH ├─────────────────────────┤    10H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │    Offset of volume     │
        │                         │        │    (if error 0FH)       │
    11H ├─────────────────────────┤    11H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │ Segment of volume label │
        │                         │        │    (if error 0FH)       │
        └─────────────────────────┘        └─────────────────────────┘

    Figure 15-5. Media Check request header (command code 1).


    If the Media Check routine asserts that the disk has not been changed,
    MS-DOS bypasses rereading the FAT and proceeds with the disk access.
    If the returned code indicates that the disk has been changed, MS-DOS
    invalidates all buffers associated with the drive, including buffers
    containing data waiting to be written (this data is simply lost),
    performs a Build BPB call, and then reads the disk's FAT and
    directory.

    The action taken by MS-DOS when Don't know is returned depends on the
    state of its internal buffers. If data that needs to be written out is
    present in the buffers associated with the drive, MS-DOS assumes that
    no disk change has occurred. If the buffers are empty or have all been
    previously flushed to the disk, MS-DOS assumes that the disk was
    changed and proceeds as described above for the Medium changed return
    code.

    If bit 11 of the device attribute word is set (that is, the driver
    supports the optional Open/Close/Removable Media functions), the host
    system is MS-DOS version 3.0 or later, and the function returns the
    Medium changed code (-1), the function must also return the segment
    and offset of the ASCIIZ volume label for the previous disk in the
    drive. (If the driver does not have the volume label, it can return a
    pointer to the ASCIIZ string NO NAME.) If MS-DOS determines that the
    disk was changed with unwritten data still present in the buffers, it
    issues a critical error 0FH (Invalid Disk Change). Application
    programs can trap this critical error and prompt the user to replace
    the original disk.

    In character-device drivers, the Media Change function should simply
    set the done flag in the status word of the request header and return.

    The Build BIOS Parameter Block function
    The Build BPB function (command code 2) is supported only on block
    devices. MS-DOS calls this function when the Medium changed code has
    been returned by the Media Check routine or when the Don't know code
    has been returned and there are no dirty buffers (buffers that have
    not yet been written to disk). Thus, a call to this function indicates
    that the disk has been legally changed.

    The Build BPB call receives a pointer to a one-sector buffer in the
    request header (Figure 15-6). If the non-IBM-format bit (bit 13) in
    the device attribute word in the device header is zero, the buffer
    contains the first sector of the disk's FAT, with the media ID byte in
    the first byte of the buffer. In this case, the contents of the buffer
    should not be modified by the driver. However, if the non-IBM-format
    bit is set, the buffer can be used by the driver as scratch space.

    The Build BPB function must return the segment and offset of a BIOS
    parameter block (Table 15-4) for the disk format indicated by the
    media ID byte and set the done flag in the status word of the request
    header. The information in the BPB is used by the kernel to interpret
    the disk structure and is also used by the driver itself to translate
    logical sector addresses into physical track, sector, and head
    addresses. If bit 11 of the device attribute word is set (that is, the
    driver supports the optional Open/Close/Removable Media functions) and
    the host system is MS-DOS version 3.0 or later, this routine should
    also read the volume label from the disk and save it.


            Driver called with                   Driver returns
    00H ┌─────────────────────────┐    00H ┌─────────────────────────┐
        │  Request header length  │        │                         │
    01H ├─────────────────────────┤    01H ├─────────────────────────┤
        │       Unit number       │        │                         │
    02H ├─────────────────────────┤    02H ├─────────────────────────┤
        │      Command code       │        │                         │
    03H ├─────────────────────────┤    03H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │         Status          │
        │                         │        │                         │
    05H ├─────────────────────────┤    05H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │                         │
        │        Reserved         │        │        Reserved         │
        │                         │        │                         │
        │                         │        │                         │
    0DH ├─────────────────────────┤    0DH ├─────────────────────────┤
        │      Media ID byte      │        │                         │
    0EH ├─────────────────────────┤    0EH ├─────────────────────────┤
        │                         │        │                         │
        │  Offset of FAT buffer   │        │                         │
        │     or scratch area     │        │                         │
    10H ├─────────────────────────┤    10H ├─────────────────────────┤
        │                         │        │                         │
        │  Segment of FAT buffer  │        │                         │
        │     or scratch area     │        │                         │
    12H ├─────────────────────────┤    12H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │     Offset of BIOS      │
        │                         │        │     parameter block     │
    14H ├─────────────────────────┤    14H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │     Segment of BIOs     │
        │                         │        │     parameter block     │
        └─────────────────────────┘        └─────────────────────────┘

    Figure 15-6. Build BPB request header (command code 2).


    Table 15-4. Format of a BIOS Parameter Block (BPB).

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Bytes       Contents
    ──────────────────────────────────────────────────────────────────
    00-01H      Bytes per sector
    02H         Sectors per allocation unit (must be power of 2)
    03-04H      Number of reserved sectors (starting at sector 0)
    05H         Number of file allocation tables (FATs)
    06-07H      Maximum number of root-directory entries
    08-09H      Total number of sectors in medium
    0AH         Media ID byte
    0B-0CH      Number of sectors occupied by a single FAT
    0D-0EH      Sectors per track (versions 3.0 and later)
    0F-10H      Number of heads (versions 3.0 and later)
    11-12H      Number of hidden sectors (versions 3.0 and later)
    13-14H      High-order word of number of hidden sectors (version 3.2)
    15-18H      If bytes 8-9 are zero, total number of sectors in medium
                (version 3.2)


    In character-device drivers, the Build BPB function should simply set
    the done flag in the status word of the request header and return.

    The Read, Write, and Write with Verify functions
    The Read (Input) function (command code 4) transfers data from the
    device into a specified memory buffer. The Write (Output) function
    (command code 8) transfers data from a specified memory buffer to the
    device. The Write with Verify function (command code 9) works like the
    Write function but, if feasible, also performs a read-after-write
    verification that the data was transferred correctly. The MS-DOS
    kernel calls the Write with Verify function, instead of the Write
    function, whenever the system's global verify flag has been turned on
    with the VERIFY command or with Interrupt 21H Function 2EH (Set Verify
    Flag).

    All three of these driver functions are called by the MS-DOS kernel
    with the address and length of the buffer for the data to be
    transferred. In the case of block-device drivers, the kernel also
    passes the drive unit code, the starting logical sector number, and
    the media ID byte for the disk (Figure 15-7).


            Driver called with                   Driver returns
    00H ┌─────────────────────────┐    00H ┌─────────────────────────┐
        │  Request header length  │        │                         │
    01H ├─────────────────────────┤    01H ├─────────────────────────┤
        │       Unit number       │        │                         │
    02H ├─────────────────────────┤    02H ├─────────────────────────┤
        │      Command code       │        │                         │
    03H ├─────────────────────────┤    03H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │         Status          │
        │                         │        │                         │
    05H ├─────────────────────────┤    05H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │                         │
        │        Reserved         │        │        Reserved         │
        │                         │        │                         │
        │                         │        │                         │
    0DH ├─────────────────────────┤    0DH ├─────────────────────────┤
        │      Media ID byte      │        │                         │
    0EH ├─────────────────────────┤    0EH ├─────────────────────────┤
        │                         │        │                         │
        │     Offset of data      │        │                         │
        │                         │        │                         │
    10H ├─────────────────────────┤    10H ├─────────────────────────┤
        │                         │        │                         │
        │     Segment of data     │        │                         │
        │                         │        │                         │
    12H ├─────────────────────────┤    12H ├─────────────────────────┤
        │                         │        │                         │
        │ Bytes/sectors requested │        │Bytes/sectors transferred│
        │                         │        │                         │
    14H ├─────────────────────────┤    14H ├─────────────────────────┤
        │                         │        │                         │
        │Starting sector number   │        │                         │
        │                         │        │                         │
    16H ├─────────────────────────┤    16H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │ Offset of volume label  │
        │                         │        │   (if error 0FH)        │
    18H ├─────────────────────────┤    18H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │ Segment of volume label │
        │                         │        │   (if error 0FH)        │
        └─────────────────────────┘        └─────────────────────────┘

    Figure 15-7. The request header for IOCTL Read (command code 3), Read
    (command code 4), Write (command code 8), Write with Verify (command
    code 9), IOCTL Write (command code 12), and Output Until Busy (command
    code 16).


    The Read and Write functions must perform the requested I/O, first
    translating each logical sector number for a block device into a
    physical track, head, and sector with the aid of the BIOS parameter
    block. Then the functions must return the number of bytes or sectors
    actually transferred in the appropriate field of the request header
    and also set the done flag in the request header status word. If an
    error is encountered during an operation, the functions must set the
    done flag, the error flag, and the error type in the status word and
    also report the number of bytes or sectors successfully transferred
    before the error; it is not sufficient to simply report the error.

    Under MS-DOS versions 3.0 and later, the Read and Write functions can
    optionally use the reference count of open files maintained by the
    driver's Device Open and Device Close functions, together with the
    media ID byte, to determine whether the medium has been illegally
    changed. If the medium was changed with files open, the driver can
    return the error code 0FH and the segment and offset of the volume
    label for the correct disk so that the user can be prompted to replace
    the disk.

    The Nondestructive Read function
    The Nondestructive Read function (command code 5) is supported only on
    character devices. It allows MS-DOS to look ahead in the character
    stream by one character and is used to check for Control-C characters
    pending at the keyboard.

    The function is called by the kernel with no parameters other than the
    command code itself (Figure 15-8). It must set the done bit in the
    status word of the request header and also set the busy bit in the
    status word to reflect whether the device's input buffer is empty
    (busy bit = 1) or contains at least one character (busy bit = 0). If
    the latter, the function must also return the next character that
    would be obtained by a kernel call to the Read function, without
    removing that character from the buffer (hence the term
    nondestructive).

    In block-device drivers, the Nondestructive Read function should
    simply set the done flag in the status word of the request header and
    return.


            Driver called with                   Driver returns
    00H ┌─────────────────────────┐    00H ┌─────────────────────────┐
        │  Request header length  │        │                         │
    01H ├─────────────────────────┤    01H ├─────────────────────────┤
        │                         │        │                         │
    02H ├─────────────────────────┤    02H ├─────────────────────────┤
        │      Command code       │        │                         │
    03H ├─────────────────────────┤    03H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │         Status          │
        │                         │        │                         │
    05H ├─────────────────────────┤    05H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │                         │
        │        Reserved         │        │        Reserved         │
        │                         │        │                         │
        │                         │        │                         │
    0DH ├─────────────────────────┤    0DH ├─────────────────────────┤
        │                         │        │        Character        │
        └─────────────────────────┘        └─────────────────────────┘

    Figure 15-8. The Nondestructive Read request header.


    The Input Status and Output Status functions
    The Input Status and Output Status functions (command codes 6 and 10)
    are defined only for character devices. They are called with no
    parameters in the request header other than the command code itself
    and return their results in the busy bit of the request header status
    word (Figure 15-9). These functions constitute the driver-level
    support for the services the MS-DOS kernel provides to application
    programs by means of Interrupt 21H Function 44H Subfunctions 06H and
    07H (Check Input Status and Check Output Status).

    MS-DOS calls the Input Status function to determine whether there are
    characters waiting in a type-ahead buffer. The function sets the done
    bit in the status word of the request header and sets the busy bit to
    0 if at least one character is already in the input buffer or to 1 if
    no characters are in the buffer and a read request would wait on a
    character from the physical device. If the character device does not
    have a type-ahead buffer, the Input Status routine should always
    return the busy bit set to 0 so that MS-DOS will not wait for
    something to arrive in the buffer before calling the Read function.


            Driver called with                   Driver returns
    00H ┌─────────────────────────┐    00H ┌─────────────────────────┐
        │  Request header length  │        │                         │
    01H ├─────────────────────────┤    01H ├─────────────────────────┤
        │                         │        │                         │
    02H ├─────────────────────────┤    02H ├─────────────────────────┤
        │      Command code       │        │                         │
    03H ├─────────────────────────┤    03H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │         Status          │
        │                         │        │                         │
    05H ├─────────────────────────┤    05H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │                         │
        │        Reserved         │        │        Reserved         │
        │                         │        │                         │
        │                         │        │                         │
    0DH └─────────────────────────┘    0DH └─────────────────────────┘

    Figure 15-9. The request header for Input Status (command code 6),
    Flush Input Buffers (command code 7), Output Status (command code 10),
    and Flush Output Buffers (command code 11).


    MS-DOS uses the Output Status function to determine whether a write
    operation is already in progress for the device. The function must set
    the done bit and the busy bit (0 if the device is idle and a write
    request would start immediately; 1 if a write is already in progress
    and a new write request would be delayed) in the status word of the
    request header.

    In block-device drivers, the Input Status and Output Status functions
    should simply set the done flag in the status word of the request
    header and return.

    The Flush Input Buffer and Flush Output Buffer functions
    The Flush Input Buffer and Flush Output Buffer functions (command
    codes 7 and 11) are defined only for character devices. They simply
    terminate any read (for Flush Input) or write (for Flush Output)
    operations that are in progress and empty the associated buffer. The
    Flush Input Buffer function is used by MS-DOS to discard characters
    waiting in the type-ahead queue. This driver action corresponds to the
    MS-DOS service provided to application programs by means of Interrupt
    21H Function 0CH (Flush Buffer, Read Keyboard).

    These functions are called with no parameters in the request header
    other than the command code itself (see Figure 15-9) and return only
    the status word.

    In block-device drivers, the Flush Buffer functions have no meaning.
    They should simply set the done flag in the status word of the request
    header and return.

    The IOCTL Read and IOCTL Write functions
    The IOCTL (I/O Control) Read and IOCTL Write functions (command codes
    3 and 12) allow control information to be passed directly between a
    device driver and an application program. The IOCTL Read and Write
    driver functions are called by the MS-DOS kernel only if the IOCTL
    flag (bit 14) is set in the device attribute word of the device
    header.

    The MS-DOS kernel passes the address and length of the buffer that
    contains or will receive the IOCTL information (see Figure 15-7). The
    driver must return the actual count of bytes transferred and set the
    done flag in the request header status word. Any error code returned
    by the driver is ignored by the kernel.

    IOCTL Read and IOCTL Write operations are typically used to configure
    a driver or device or to report driver or device status and do not
    usually result in the transfer of data to or from the physical device.
    These functions constitute the driver support for the services
    provided to application programs by the MS-DOS kernel through
    Interrupt 21H Function 44H Subfunctions 02H, 03H, 04H, and 05H
    (Receive Control Data from Character Device, Send Control Data to
    Character Device, Receive Control Data from Block Device, and Send
    Control Data to Block Device).

    The Device Open and Device Close functions
    The Device Open and Device Close functions (command codes 13 and 14)
    are supported only in MS-DOS versions 3.0 and later and are called
    only if the open/close/removable media flag (bit 11) is set in the
    device attribute word of the device header. The Device Open and Device
    Close functions have no parameters in the request header other than
    the unit code for block devices and return nothing except the done
    flag and, if applicable, the error flag and number in the request
    header status word (Figure 15-10).


            Driver called with                   Driver returns
    00H ┌─────────────────────────┐    00H ┌─────────────────────────┐
        │  Request header length  │        │                         │
    01H ├─────────────────────────┤    01H ├─────────────────────────┤
        │      Unit number        │        │                         │
    02H ├─────────────────────────┤    02H ├─────────────────────────┤
        │      Command code       │        │                         │
    03H ├─────────────────────────┤    03H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │         Status          │
        │                         │        │                         │
    05H ├─────────────────────────┤    05H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │                         │
        │        Reserved         │        │        Reserved         │
        │                         │        │                         │
        │                         │        │                         │
    0DH └─────────────────────────┘    0DH └─────────────────────────┘

    Figure 15-10. The request header for Device Open (command code 13),
    Device Close (command code 14), and Removable Media (command code 15).


    Each Interrupt 21H request by an application to open or create a file
    or to open a character device for input or output results in a Device
    Open call by the kernel to the corresponding device driver. Similarly,
    each Interrupt 21H call by an application to close a file or device
    results in a Device Close call by the kernel to the appropriate device
    driver. These Device Open and Device Close calls are in addition to
    any directory read or write calls that may be necessary.

    On block devices, the Device Open and Device Close functions can be
    used to manage local buffering and to maintain a reference count of
    the number of open files on a device. Whenever this reference count is
    decremented to zero, all files on the disk have been closed and the
    driver should flush any internal buffers so that data is not lost, as
    the user may be about to change disks. The reference count can also be
    used together with the media ID byte by the Read and Write functions
    to determine whether the disk has been changed while files are still
    open.

    The reference count should be forced to zero when a Media Check call
    that returns the Medium changed code is followed by a Build BPB call,
    to provide for those programs that use FCBs to open files and then
    never close them. This problem does not arise with programs that use
    the handle functions for file management, because all handles are
    always closed automatically by MS-DOS on behalf of the program when it
    terminates. See PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR
    MS-DOS: File and Record Management.

    On character devices, the Device Open and Device Close functions can
    be used to send hardware-dependent initialization and post-I/O strings
    to the associated device (for example, a reset sequence or formfeed
    character to precede new output and a formfeed to follow it). Although
    these strings can be written directly by an application using ordinary
    write function calls, they can also be previously passed to the driver
    by application programs with IOCTL Write calls (Interrupt 21H Function
    44H Subfunction 05H), which in turn are translated by the MS-DOS
    kernel into driver command code 12 (IOCTL Write) requests. The latter
    method makes the driver responsible for sending the proper control
    strings to the device each time a Device Open or Device Close is
    executed, but this method can be used only with drivers specifically
    written to support it.

    The Removable Media function
    The Removable Media function (command code 15) is defined only for
    block devices. It is supported in MS-DOS versions 3.0 and later and is
    called by MS-DOS only if the open/ close/removable media flag (bit 11)
    is set in the device attribute word of the device header. This
    function constitutes the driver-level support for the service provided
    to application programs by MS-DOS by means of Interrupt 21H Function
    44H Subfunction 08H (Check If Block Device Is Removable).

    The only parameter for the Removable Media function is the unit code
    (see Figure 15-10). The function sets the done bit in the request
    header status word and sets the busy bit to 1 if the disk is not
    removable or to 0 if the disk is removable. This information can be
    used by MS-DOS to optimize its accesses to the disk and to eliminate
    unnecessary FAT and directory reads.

    In character-device drivers, the Removable Media function should
    simply set the done flag in the status word of the request header and
    return.

    The Output Until Busy function
    The Output Until Busy function (command code 16) is defined only for
    character devices under MS-DOS versions 3.0 and later and is called by
    the MS-DOS kernel only if the corresponding flag (bit 13) is set in
    the device attribute word of the device header. This function is an
    optional driver-optimization function included specifically for the
    benefit of background print spoolers driving printers that have
    internal memory buffers. Such printers can accept data at a rapid rate
    until the buffer is full.

    The Output Until Busy function is called with the address and length
    of the data to be written to the device (see Figure 15-7). It
    transfers data continuously to the device until the device indicates
    that it is busy or until the data is exhausted. The function then must
    set the done flag in the request header status word and return the
    actual number of bytes transferred in the appropriate field of the
    request header.

    For this function to return a count of bytes transferred that is less
    than the number of bytes requested is not an error. MS-DOS will adjust
    the address and length of the data passed in the next Output Until
    Busy function request so that all characters are sent.

    In block-device drivers, the Output Until Busy function should simply
    set the done flag in the status word of the request header and return.

    The Generic IOCTL function
    The Generic IOCTL function (command code 19) is defined under MS-DOS
    version 3.2 and is called only if the 3.2-functions-supported flag
    (bit 6) is set in the device attribute word of the device header. This
    driver function corresponds to the MS-DOS generic IOCTL service
    supplied to application programs by means of Interrupt 21H Function
    44H Subfunctions 0CH (Generic I/O Control for Handles) and 0DH
    (Generic I/O Control for Block Devices).

    In addition to the usual information in the static portion of the
    request header, the Generic IOCTL function is passed a category
    (major) code, a function (minor) code, the contents of the SI and DI
    registers at the point of the IOCTL call, and the segment and offset
    of a data buffer (Figure 15-11). This buffer in turn contains other
    information whose format depends on the major and minor IOCTL codes
    passed in the request header. The driver must interpret the major and
    minor codes in the request header and the contents of the additional
    buffer to determine which operation it will carry out and then set the
    done flag in the request header status word and return any other
    applicable information in the request header or the data buffer.

    Services that can be invoked by the Generic IOCTL function, if the
    driver supports them, include configuring the driver for nonstandard
    disk formats, reading and writing entire disk tracks of data, and
    formatting and verifying tracks. The Generic IOCTL function has been
    designed to be open-ended so that it can be used to easily extend the
    device driver definition in future versions of MS-DOS.


            Driver called with                   Driver returns
    00H ┌─────────────────────────┐    00H ┌─────────────────────────┐
        │  Request header length  │        │                         │
    01H ├─────────────────────────┤    01H ├─────────────────────────┤
        │       Unit number       │        │                         │
    02H ├─────────────────────────┤    02H ├─────────────────────────┤
        │      Command code       │        │                         │
    03H ├─────────────────────────┤    03H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │         Status          │
        │                         │        │                         │
    05H ├─────────────────────────┤    05H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │                         │
        │        Reserved         │        │        Reserved         │
        │                         │        │                         │
        │                         │        │                         │
    0DH ├─────────────────────────┤    0DH ├─────────────────────────┤
        │ Category (major) code   │        │                         │
    0EH ├─────────────────────────┤    0EH ├─────────────────────────┤
        │ Function (minor) code   │        │                         │
    0FH ├─────────────────────────┤    0FH ├─────────────────────────┤
        │                         │        │                         │
        │  SI register contents   │        │                         │
        │                         │        │                         │
    11H ├─────────────────────────┤    11H ├─────────────────────────┤
        │                         │        │                         │
        │  DI register contents   │        │                         │
        │                         │        │                         │
    13H ├─────────────────────────┤    13H ├─────────────────────────┤
        │                         │        │                         │
        │    Offset of generic    │        │                         │
        │    IOCTL data packet    │        │                         │
    15H ├─────────────────────────┤    15H ├─────────────────────────┤
        │                         │        │                         │
        │   Segment of generic    │        │                         │
        │    IOCTL data packet    │        │                         │
        └─────────────────────────┘        └─────────────────────────┘

    Figure 15-11. Generic IOCTL request header.


    The Get Logical Device and Set Logical Device functions
    The Get and Set Logical Device functions (command codes 23 and 24) are
    defined only for block devices under MS-DOS version 3.2 and are called
    only if the 3.2-functions-supported flag (bit 6) is set in the device
    attribute word of the device header. They correspond to the Get and
    Set Logical Drive Map services supplied by MS-DOS to application
    programs by means of Interrupt 21H Function 44H Subfunctions 0EH and
    0FH.

    The Get and Set Logical Device functions are called with a drive unit
    number in the request header (Figure 15-12). Both functions return a
    status word for the operation in the request header; the Get Logical
    Device function also returns a unit number.

    The Get Logical Device function is called to determine whether more
    than one drive letter is assigned to the same physical device. It
    returns a code for the last drive letter used to reference the device
    (1 = A, 2 = B, and so on); if only one drive letter is assigned to the
    device, the returned unit code should be 0.

    The Set Logical Device function is called to inform the driver of the
    next logical drive identifier that will be used to reference the
    device. The unit code passed by the MS-DOS kernel in this case is zero
    based relative to the logical drives supported by this particular
    driver. For example, if the driver supports two logical floppy-disk-
    drive units (A and B), only one physical disk drive exists in the
    system, and Set Logical Device is called with a unit number of 1, the
    driver is being informed that the next read or write request from the
    MS-DOS kernel will be directed to drive B.


            Driver called with                   Driver returns
    00H ┌─────────────────────────┐    00H ┌─────────────────────────┐
        │  Request header length  │        │                         │
    01H ├─────────────────────────┤    01H ├─────────────────────────┤
        │       Unit number       │        │  Last device driver     │
    02H ├─────────────────────────┤    02H ├─────────────────────────┤
        │      Command code       │        │                         │
    03H ├─────────────────────────┤    03H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │         Status          │
        │                         │        │                         │
    05H ├─────────────────────────┤    05H ├─────────────────────────┤
        │                         │        │                         │
        │                         │        │                         │
        │        Reserved         │        │        Reserved         │
        │                         │        │                         │
        │                         │        │                         │
    0DH └─────────────────────────┘    0DH └─────────────────────────┘

    Figure 15-12. Get Logical Device and Set Logical Device request
    header.


    In character-device drivers, the Get Logical Device and Set Logical
    Device functions should simply set the done flag in the status word of
    the request header and return.


The Processing of a Typical I/O Request

    An application program requests an I/O operation from MS-DOS by
    loading registers with the appropriate values and addresses and
    executing a software Interrupt 21H. MS-DOS inspects its internal
    tables, searches the chain of device headers if necessary, and
    determines which device driver should receive the I/O request.

    MS-DOS then creates a request header data packet in a reserved area of
    memory. Disk I/O requests are transformed from file and record
    information into logical sector requests by MS-DOS's interpretation of
    the disk directory and file allocation table. (MS-DOS locates these
    disk structures using the information returned by the driver from a
    previous Build BPB call and issues additional driver read requests, if
    necessary, to bring their sectors into memory.)

    After the request header is prepared, MS-DOS calls the device driver's
    Strategy entry point, passing the address of the request header in
    registers ES:BX. The Strategy routine saves the address of the request
    header and performs a far return to MS-DOS.

    MS-DOS then immediately calls the device driver's Interrupt entry
    point. The Interrupt routine saves all registers, retrieves the
    address of the request header that was saved by the Strategy routine,
    extracts the command code, and branches to the appropriate function to
    perform the operation requested by MS-DOS. When the requested function
    is complete, the Interrupt routine sets the done flag in the status
    word and places any other required information into the request
    header, restores all registers to their state at entry, and performs a
    far return.

    MS-DOS translates the driver's returned status into the appropriate
    carry flag status, register values, and (possibly) error code for the
    MS-DOS Interrupt 21H function that was requested and returns control
    to the application program. Figure 15-13 sketches this entire flow of
    control and data.


                ┌─────────────────────────────────────────┐
                │           Application program           │
                └─────────────────┬──────────────────────┘
                                    │       │
        Interrupt 21H Function 3FH, │       │ Read status returned
                Read File or Device │       │ in carry flag and AX register
                                    │       │
                ┌────────────────────────┴───────────────┐
                │              MS-DOS kernel              │
                └─────────────────┬──────────────────────┘
    Calls to driver Strategy, then │       │ Status returned to MS-DOS
        Interrupt routine, passing │       │ kernel in request header,
        request header with command │       │ data placed in buffer
            code 4, Read (Input) │       │ indicated by kernel
                ┌────────────────────────┴───────────────┐
                │              Device driver              │
                └─────────────────┬──────────────────────┘
        Device commands issued to │       │ Data transferred from
    adapter I/O ports, requesting │       │ device to memory
    read sector at physical track, │       │
            head, and sector number │       │
                ┌────────────────────────┴───────────────┐
                │             Physical device             │
                └─────────────────────────────────────────┘

    Figure 15-13. The processing of a typical I/O request from an
    application program.


    Note that a single Interrupt 21H function request by an application
    program can result in many operation requests by MS-DOS to the device
    driver. For example, if the application invokes Interrupt 21H Function
    3DH (Open File with Handle) to open a file, MS-DOS may have to issue
    multiple sector read requests to the driver while searching the
    directory for the filename. Similarly, an application program's
    request to write a string to the screen in cooked mode with Interrupt
    21H Function 40H (Write File or Device) will result in a write request
    to the driver for each character in the string, because MS-DOS filters
    the characters and polls the keyboard for a pending Control-C between
    each character output.


Writing Device Drivers

    Device drivers are traditionally coded in assembly language, both
    because of the rigid structural requirements and because of the need
    to keep driver execution speed high and memory overhead low. Although
    MS-DOS versions 3.0 and later are capable of loading drivers in .EXE
    format, versions 2.x can load only pure memory-image device drivers
    that do not require relocation. Therefore, drivers are typically
    written as though they were .COM programs with an "origin" of zero and
    converted with EXE2BIN to .BIN or .SYS files so that they will be
    compatible with any version of MS-DOS (2.0 or later). See PROGRAMMING
    IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: Structure of an
    Application Program.

    The device header must be located at the beginning of the file (offset
    0). Both words in the header's link field should be set to -1, thus
    allowing MS-DOS to fix up the link field when the driver is loaded
    during system initialization so that it points to the next driver in
    the chain. When a single file contains more than one driver, the
    offset portion of each header link field should point to the next
    header in that file, all using the same segment base of zero, and only
    the link field of the last header in the file should be set to -1, -1.

    The device attribute word must reflect the device-driver type
    (character or block) and the bits that indicate support for the
    various optional command codes must have appropriate values. The
    device header's offsets to the Strategy and Interrupt routines must be
    relative to the same segment base as the device header itself. If the
    driver is for a character device, the name field should be filled in
    properly with the device's logical name, which can be any legal eight-
    character uppercase filename padded with spaces and without a colon.
    Duplication of existing character-device names or existing disk-file
    names should be avoided (unless a resident character-device driver is
    being intentionally superseded).

    The Strategy and Interrupt routines for the device are called by MS-
    DOS by means of an intersegment call (CALL FAR) and must return to MS-
    DOS with a far return. Both routines must preserve all CPU registers
    and flags. The MS-DOS kernel's stack has room for 40 to 50 bytes when
    the driver is called; if the driver makes heavy use of the stack, it
    should switch to an internal stack of adequate depth.

    The Strategy routine is, of course, very simple. It need only save the
    address of the request header that is passed to it in registers ES:BX
    and exit back to the kernel.

    The logic of the Interrupt routine is necessarily more complex. It
    must save the CPU registers and flags, extract the command code from
    the request header whose address was previously saved by the Strategy
    routine, and dispatch the appropriate command-code function. When that
    function is finished, the Interrupt routine must ensure that the
    appropriate status and other information is placed in the request
    header, restore the CPU registers and flags, and return control to the
    kernel.

    Although the interface between the MS-DOS kernel and the command-code
    routines is fairly simple, it is also strict. The command-code
    functions must behave exactly as they are defined or the system will
    behave erratically. Even a very subtle discrepancy in the action of a
    driver function can have unexpectedly large global effects. For
    example, if a block driver Read function returns an error but does not
    return a correct value for the number of sectors successfully
    transferred, the MS-DOS kernel will be misled in its attempts to retry
    the read for only the failing sectors and disk data might be
    corrupted.

Example character driver: TEMPLATE

    Figure 15-14 contains the source code for a skeleton character-device
    driver called TEMPLATE.ASM. This driver does nothing except display a
    sign-on message when it is loaded, but it demonstrates all the
    essential driver components, including the device header, Strategy
    routine, and Interrupt routine. The command-code functions take no
    action other than to set the done flag in the request header status
    word.

    ──────────────────────────────────────────────────────────────────────

    Figure 15-14. TEMPLATE.ASM, the source file for the TEMPLATE.SYS
    driver.

    ──────────────────────────────────────────────────────────────────────

    TEMPLATE.ASM can be assembled, linked, and converted into a loadable
    driver with the following commands:

    C&gt;MASM TEMPLATE;  &lt;Enter&gt;
    C&gt;LINK TEMPLATE;  &lt;Enter&gt;
    C&gt;EXE2BIN TEMPLATE.EXE TEMPLATE.SYS  &lt;Enter&gt;

    The Microsoft Object Linker (LINK) will display the warning message No
    Stack Segment; this message can be ignored. The driver can then be
    installed by adding the line

    DEVICE=TEMPLATE.SYS

    to the CONFIG.SYS file and restarting the system. The fact that the
    TEMPLATE.SYS driver also has the logical character-device name
    TEMPLATE allows the demonstration of an interesting MS-DOS effect:
    After the driver is installed, the file that contains it can no longer
    be copied, renamed, or deleted. The reason for this limitation is that
    MS-DOS always searches its list of character-device names first when
    an open request is issued, before it inspects the disk directory. The
    only way to erase the TEMPLATE.SYS file is to modify the CONFIG.SYS
    file to remove the associated DEVICE statement and then restart the
    system.

    For a complete example of a character-device driver for interrupt-
    driven serial communications, See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: STRUCTURE OF MS-DOS: Interrupt-Driven Communications.

Example block driver: TINYDISK

    Figure 15-15 contains the source code for a simple 64 KB virtual disk
    (RAMdisk) called TINYDISK.ASM. This code provides a working example of
    a simple block-device driver. When its Initialization routine is
    called by the kernel, TINYDISK allocates itself 64 KB of RAM and maps
    a disk structure onto the RAM in the form of a boot sector containing
    a valid BPB, a FAT, a root directory, and a files area. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: STRUCTURE OF MS-DOS: MS-DOS
    Storage Devices.

    ──────────────────────────────────────────────────────────────────────

    Figure 15-15. TINYDISK.ASM, the source file for the TINYDISK.SYS
    driver.

    ──────────────────────────────────────────────────────────────────────

    Subsequent driver Read and Write calls by the kernel to TINYDISK
    function as though they were transferring sectors to and from a
    physical storage device but actually only copy data from one area in
    memory to another. A programmer can learn a great deal about the
    operation of block-device drivers and MS-DOS's relationship to those
    drivers (such as the order and frequency of Media Change, Build BPB,
    Read, Write, and Write With Verify calls) by inserting software probes
    into TINYDISK at appropriate locations and monitoring its behavior.

    TINYDISK.ASM can be assembled, linked, and converted into a loadable
    driver with the following commands:

    MASM TINYDISK;
    LINK TINYDISK;
    EXE2BIN TINYDISK.EXE TINYDISK.SYS

    The linker will display the warning message No Stack Segment; this
    message can be ignored. The driver can then be installed by adding the
    line

    DEVICE=TINYDISK.SYS

    to the CONFIG.SYS file and restarting the system. When it is loaded,
    TINYDISK displays a sign-on message and the drive letter that it was
    assigned if it is running under MS-DOS version 3.0 or later. (If the
    host system is MS-DOS version 2.x, this information is not provided to
    the driver.) Files can then be copied to the RAMdisk as though it were
    a small but extremely fast disk drive.

                                                Ray Duncan



───────────────────────────────────────────────────────────────────────────

Part D  Directions of MS-DOS



Article 16: Writing Applications for Upward Compatibility


    One of the major concerns of the designers of Microsoft OS/2 was that
    it be backwardly compatible--that is, that programs written to run
    under MS-DOS versions 2 and 3 be able to run on MS OS/2. A major
    concern for present application programmers is that their programs run
    not only on current versions of MS-DOS (and MS OS/2) but also on
    future versions of MS-DOS. Ensuring such upward compatibility involves
    both hardware issues and operating-system issues.


Hardware Issues

    A basic requirement for ensuring upward compatibility is hardware-
    independent code. If you bypass system services and directly program
    the hardware--such as the system interrupt controller, the system
    clock, and the enhanced graphics adapter (EGA) registers--your
    application will not run on future versions of MS-DOS.

Protected mode compatibility

    The 80286 and the 80386 microprocessors can operate in two
    incompatible modes: real mode and protected mode. When either chip is
    operating in real mode, it is perceived by the operating system and
    programs as a fast 8088 chip. Applications written for the 8086 and
    8088 run the same on the 80286 and the 80386--only faster. They
    cannot, however, take advantage of 80286 and 80386 features unless
    they can run in protected mode.

    Following the guidelines below will minimize the work necessary to
    convert a real mode program to protected mode and will also allow a
    program to use a special subset of the MS OS/2 Applications Program
    Interface (API)--Family API. A binary program (.EXE) that uses the
    family API can run in either protected mode or real mode under MS OS/2
    and subsequent systems, but it can run only in real mode under MS-DOS
    version 3.

Family API

    The Family API requires that the application use a subset of the MS
    OS/2 Dynamic Link System API. Special tools link the application with
    a special library that implements the subset MS OS/2 system services
    in the MS-DOS version 3 environment. Many of these services are
    implemented by calling the appropriate Interrupt 21H subfunction; some
    are implemented in the special library itself.

    When a Family API application is loaded under MS OS/2 protected mode,
    MS OS/2 ignores the special library code and loads only the
    application itself. MS OS/2 then provides the requested services in
    the normal fashion. However, MS-DOS version 3 loads the entire
    package--the application and the special library--because the Family
    API.EXE file is constructed to look like an MS-DOS 3.EXE file.

Linear vs segmented memory

    The protected mode and the real mode of the 80286 and the 80386 are
    compatible except in the area of segmentation. The 8086 has been
    described as a segmented machine, but it is actually a linear memory
    machine with offset registers. When a memory address is generated, the
    value in one of the "segment" registers is multiplied by 16 and added
    as a displacement to the offset value supplied by the instruction's
    addressing mode. No length information is associated with each
    "segment"; the "segment" register supplies only a 20-bit addressing
    offset. Programs routinely use this by computing a 20-bit address and
    then decomposing it into a 16-bit "segment" value and a 16-bit
    displacement value so that the address can be referenced.

    The protected mode of the 80286 and the 80386, however, is truly
    segmented. A value placed in a segment register selects an entry from
    a descriptor table; that entry contains the addressing offset, a
    segment length, and permission bits. On the 8086, the so-called
    segment component of an address is multiplied by 16 and added to the
    offset component, producing a 20-bit physical address. Thus, if you
    take an address in the segment:offset form, add 4 to the segment
    value, and subtract 64 (that is, 4 * 16) from the offset value, the
    new address references exactly the same location as the old address.
    On the 80286 and the 80386 in protected mode, however, segment values,
    called segment selectors, have no direct correspondence to physical
    addresses. In other words, in 8086 mode, the two address forms

    1000(sub 16):0345(sub 16)

    and

    1004(sub 16):0305(sub 16)

    reference the same memory location, but in protected mode these two
    forms reference totally different locations.

Creating segment values
    This architectural difference gives rise to the most common cause of
    incompatibility--the program performs addressing arithmetic to compute
    "segment" values. Any program that uses the 20-bit addressing scheme
    to create or to compute a value to be loaded in a segment register
    cannot be converted to run in protected mode. To be protected mode
    compatible, a program must treat the 8086's so-called segments as true
    segments.

    To create a program that does this, write according to the following
    guidelines:

    1. Do not generate any segment values. Use only the segment values
        supplied by MS-DOS calls and those placed in the segment registers
        when MS-DOS loaded your program. The exception is "huge objects"--
        memory objects larger than 64 KB. In this case, MS OS/2 provides a
        base segment number and a "segment offset value." The returned
        segment number selects the first 64 KB of the object and the
        segment number, plus the segment offset value address the second
        64 KB of the object. Likewise, the returned segment value plus
        N*(segment offset value) selects the N+1 64 KB piece of the huge
        object. Write real mode code in this same fashion, using 4096 as
        the segment offset value. When you convert your program, you can
        substitute the value provided by MS OS/2.

    2. Do not address beyond the allocated length of a segment.

    3. Do not use segment registers as scratch registers by placing
        general data in them. Place only valid segment values, supplied by
        MS-DOS, in a segment register. The one exception is that you can
        place a zero value in a segment register, perhaps to indicate "no
        address." You can place the zero in the segment register, but you
        cannot reference memory using that register; you can only
        load/store or push/pop it.

    4. Do not use CS: overrides on instructions that store into memory. It
        is impossible to store into a code segment in protected mode.

CPU speed

    Because various microprocessors and machine configurations execute at
    different speeds, a program should not contain timing loops that
    depend on CPU speed. Specifically, a program should not establish CPU
    speed during initialization and then use that value for timing loops
    because the preemptive scheduling of MS OS/2 and future operating
    systems can "take away" the CPU at any time for arbitrary and
    unpredictable lengths of time. (In any case, time should not be wasted
    in a timing loop when other processes could be using system
    resources.)

Program timing

    Programs must measure the passage of time carefully. They can use the
    system clock-tick interrupt while directly interfacing with the user,
    but no clock ticks will be seen by real mode programs when the user
    switches the screen interface to another program.

    It is recommended that applications use the time-of-day system
    interface to determine elapsed time. To facilitate conversion to MS
    OS/2 protected mode, programs should encapsulate time-of-day or
    elapsed-time functions into subroutines.

BIOS

    Avoid BIOS interrupt interfaces except for Interrupt 10H (the screen
    display functions) and Interrupt 16H (the keyboard functions).
    Interrupt 10H functions are contained in the MS OS/2 VIO package, and
    Interrupt 16H functions are in the MS OS/2 KBD package. Other BIOS
    interrupts provide functions that are available under MS OS/2 only in
    considerably modified forms.

Special operations

    Uncommon, or special, operations and instructions can produce varied
    results, depending on the microprocessor. For example, when a "divide
    by 0" trap is taken on an 8086, the stack frame points to the
    instruction after the fault; when such action is taken on the 80286
    and 80386, the return address points to the instruction that caused
    the fault. The effect of pushing the SP register is different between
    the 80286 and the 80386 as well. See Appendix M: 8086/8088 Software
    Compatibility Issues. Write your program to avoid these problem areas.


Operating-System Issues

    Basic to writing programs that will run on future operating systems is
    writing code that is not version specific. Incorporating special
    version-specific features in a program will virtually ensure that the
    program will be incompatible with future versions of MS-DOS and MS
    OS/2.

    Following the guidelines below will not necessarily ensure your
    program's compatibility, but it will facilitate converting the program
    or using the Family API to produce a dual-mode binary program.

Filenames

    MS-DOS versions 2 and 3 silently truncate a filename that is longer
    than eight characters or an extension that is longer than three
    characters. MS-DOS generates no error message when performing this
    task. In real mode, MS OS/2 also silently truncates a filename or
    extension that exceeds the maximum length; in protected mode, however,
    it does not. Therefore, a real mode application program needs to
    perform this truncating function. The program should check the length
    of the filenames that it generates or that it obtains from a user and
    refuse names that are longer than the eight-character maximum. This
    prevents improperly formatted names from becoming embedded in data and
    control files--a situation that could cause a protected mode version
    of the application to fail when it presents that invalid name to the
    operating system.

    When you convert your program to protected mode API, remove the
    length-checking code; MS OS/2 will check the length and return an
    error code as appropriate. Future file systems will support longer
    filenames, so it's important that protected mode programs simply
    present filenames to the operating system, which is then responsible
    for judging their validity.

    Other MS-DOS version 2 and 3 elements have fixed lengths, including
    the current directory path. To be upwardly compatible, your program
    should accept whatever length is provided by the user or returned from
    a system call and rely on MS OS/2 to return an error message if a
    length is inappropriate. The exception is filename length in real mode
    non-Family API programs: These programs should enforce the eight-
    character maximum because MS-DOS versions 2 and 3 fail to do so.

File truncation
    Files are truncated by means of a zero-length write under MS-DOS
    versions 2 and 3; under MS OS/2 in protected mode, files are truncated
    with a special API. File truncation operations should be encapsulated
    in a special routine to facilitate conversion to MS OS/2 protected
    mode or the Family API.

File searches
    MS-DOS versions 2 and 3 never close file-system searches (Find First
    File/Find Next File). The returned search contains the information
    necessary for MS-DOS to continue the search later, and if the search
    is never continued, no harm is done.

    MS OS/2, however, retains the necessary search continuation
    information in an internal structure of limited size. For this reason,
    your program should not depend on more than about 10 simultaneous
    searches and it should be able to close searches when it is done. If
    your program needs to perform more than about 10 searches
    simultaneously, it should be able to close a search, restart it later,
    and advance to the place where the program left off, rather than
    depending on MS OS/2 to continue the search.

    MS OS/2 further provides a Find Close function that releases the
    internal search information. Protected mode programs should use this
    call at the end of every search sequence. Because MS-DOS versions 2
    and 3 have no such call, your program should call a dummy procedure by
    this name at the appropriate locations. Then you can convert your
    program to the protected mode API or to the Family API without
    reexamining your algorithms.

    Note: Receiving a "No more files" return code from a search does not
    implicitly close the search; all search closes must be explicit.

    The Family API allows only a single search at a time. To circumvent
    this restriction, code two different Find Next File routines in your
    program--one for MS OS/2 protected mode and one for MS-DOS real mode--
    and use the Family API function that determines the program's current
    environment to select the routine to execute.

MS-DOS calls

    A program that uses only the Interrupt 21H functions listed below is
    guaranteed to work in the Compatibility Box of MS OS/2 and will be
    relatively easy to modify for MS OS/2 protected mode.

╓┌─────────────────────┌─────────────────────────────────────────────────────╖
    Function         Name
    ──────────────────────────────────────────────────────────────────
    0DH              Disk Reset
    0EH              Select Disk
    19H              Get Current Disk
    1AH              Set DTA Address
    25H              Set Interrupt Vector
    2AH              Get Date
    2BH              Set Date
    2CH              Get Time
    2EH              Set/Reset Verify Flag
    2FH              Get DTA Address
    30H              Get MS-DOS Version Number
    33H              Get/Set Control-C Check Flag
    35H              Get Interrupt Vector
    36H              Get Disk Free Space
    38H              Get/Set Current Country
    39H              Create Directory
    3AH              Remove Directory
    3BH              Change Current Directory
    3CH              Create File with Handle
    3DH              Open File with Handle
    3EH              Close File
    3FH              Read File or Device
    40H              Write File or Device
    41H              Delete File
    42H              Move File Pointer
    43H              Get/Set File Attributes
    44H              IOCTL (all subfunctions)
    45H              Duplicate File Handle
    46H              Force Duplicate File Handle
    47H              Get Current Directory
    48H              Allocate Memory Block
    49H              Free Memory Block
    4AH              Resize Memory Block
    4BH              Load and Execute Program (EXEC)
    4CH              Terminate Process with Return Code
    4DH              Get Return Code of Child Process
    4EH              Find First File
    4FH              Find Next File
    54H              Get Verify Flag
    56H              Rename File
    57H              Get/Set Date/Time of File
    59H              Get Extended Error Information
    5AH              Create Temporary File
    5BH              Create New File
    5CH              Lock/Unlock File Region

FCBs
    FCBs are not supported in MS OS/2 protected mode. Use handle-based
    calls instead.

Interrupt calls
    MS-DOS versions 2 and 3 use an interrupt-based interface; MS OS/2
    protected mode uses a procedure-call interface. Write your code to
    accommodate this difference by encapsulating the interrupt-based
    interfaces into individual subroutines that can then easily be
    modified to use the MS OS/2 procedure-call interface.

System call register usage
    The MS OS/2 procedure-call interface preserves all registers except AX
    and FLAGS. Write your program to assume that the contents of AX and
    the contents of any register modified by MS-DOS version 2 and 3
    interrupt interfaces are destroyed at each system call, regardless of
    the success or failure of that call.

Flush/Commit calls
    Your program should issue Flush/Commit calls where necessary--for
    example, after writing out the user's work file--but no more than
    necessary. Because MS OS/2 is multitasking, the floppy disk that
    contains the files to be flushed may not be in the drive. In such a
    case, MS OS/2 prompts the user to insert the proper floppy disk. As a
    result, too frequent flushes could generate a great many Insert disk
    messages and degrade the system's usability.

Seeks

    Seeks to negative offsets and to devices also create compatibility
    issues.

To negative offsets
    Your program should not attempt to seek to a negative file location. A
    negative seek offset is permissible as long as the sum of the seek
    offset and the current file position is positive. MS-DOS versions 2
    and 3 allow seeking to a negative offset as long as you do not attempt
    to read or write the file at that offset. MS OS/2 and subsequent
    systems return an error code for negative net offsets.

On devices
    Your program should not issue seeks to devices (such as AUX, COM, and
    so on). Doing so produces an error under MS OS/2.

Error codes

    Because future releases of the operating system may return new error
    codes to system calls, you should write code that is open-ended about
    error codes--that is, write your program to deal with error codes
    beyond those currently defined. You can generally do this by including
    special handling for any codes that require special treatment, such as
    "File not found," and by taking a generic course of action for all
    other errors. The MS OS/2 protected mode API and the Family API have
    an interface that contains a message describing the error; this
    message can be displayed to the user. The interface also returns error
    classification information and a recommended action.

Multitasking concerns

    Multitasking is a feature of MS OS/2 and will be a feature of all
    future versions of MS-DOS. The following guidelines apply to all
    programs, even to those written for MS-DOS version 3, because they may
    run in compatibility mode under MS OS/2.

Disabling interrupts
    Do not disable interrupts, typically with the CLI instruction. The
    consequences of doing so depend on the environment.

    In real mode programs under MS OS/2, disabling interrupts works
    normally but has a negative impact on the system's ability to maintain
    proper system throughput. Communications programs or networking
    applications might lose data. In a future version of real mode MS
    OS/2-80386, the operating system will disregard attempts to disable
    interrupts.

    Protected mode programs under MS OS/2 can disable interrupts only in
    special Ring 2 segments. Disabling interrupts for longer than 100
    microseconds might cause communications programs or networking
    applications to lose data or break connection. A future 80386-specific
    version of MS OS/2 will ignore attempts to disable interrupts in
    protected mode programs.

Measuring system resources
    Do not attempt to measure system resources by exhausting them, and do
    not assume that because a resource is available at one time it will be
    available later. Remember: System resources are being shared with
    other programs.

    For example, it is common for an MS-DOS version 3 application to
    request 1 MB of memory. The system cannot fulfill this request, so it
    returns the largest amount of memory available. The application then
    requests that amount of memory. Typically, applications do not even
    check for an error code from the second request. They routinely
    request all available memory because their creators knew that no other
    application could be in the system at the same time. This practice
    will work in real mode MS OS/2, although it is inefficient because MS
    OS/2 must allocate memory to a program that has no effective use for
    it. However, this practice will not work under MS OS/2 protected mode
    or under the Family API.

    Another typical resource-exhaustion technique is opening files until
    an open is refused and then closing unneeded file handles. All
    applications, even those that run only in an MS OS/2 real mode
    environment, must use only the resources they need and not waste
    system resources; in a multitasking environment, other programs in the
    system usually need those resources.

Sharing rules
    Because multiple programs can run under MS OS/2 simultaneously and
    because the system can be networked, conflicts can occur when two
    programs try to access the same file. MS OS/2 handles this situation
    with special file-sharing support. Although programs ignorant of file-
    sharing rules can run in real mode, you should explicitly specify
    file-sharing rules in your program. This will reduce the number of
    file-access conflicts the user will encounter.

Miscellaneous guidelines

    Do not use undocumented features of MS-DOS or undocumented fields such
    as those in the Find First File buffer. Also, do not modify or store
    your own values in such areas.

    Maintain at least 2048 free bytes on the stack at all times. Future
    releases of MS-DOS may require extra stack space at system call and at
    interrupt time.

    Print using conventional handle writes to the LPT device(s). For
    example:

    fd = open("LPT1");
    write(fd, data, datalen);

    Do not use Interrupt 17H (the IBM ROM BIOS printer services), writes
    to the stdprn handle (handle 3), or special-purpose Interrupt 21H
    functions such as 05H (Printer Output). These methods are not
    supported under MS OS/2 protected mode or in the Family API.

    Do not use the MS-DOS standard handles stdaux and stdprn (handles 3
    and 4); these handles are not supported in MS OS/2 protected mode. Use
    only stdin (handle 0), stdout (handle 1), and stderr (handle 2). Do
    use these latter handles where appropriate and avoid opening the CON
    device directly. Avoid Interrupt 21H Functions 03H (Auxiliary Input)
    and 04H (Auxiliary Output), which are polling operations on stdaux.


Summary

    A tenet of MS OS/2 design was flexibility: Each component was
    constructed in anticipation of massive changes in a future release and
    with an eye toward existing versions of MS-DOS. Writing applications
    that are upwardly and backwardly compatible in such an environment is
    essential--and challenging. Following the guidelines in this article
    will ensure that your programs function appropriately in the
    MS-DOS/OS/2 operating system family.

                                                    Gordon Letwin



Article 17: Windows


    Microsoft Windows is an operating environment that runs under MS-DOS
    versions 2.0 and later. The current version of Windows, version 2.0,
    requires either a fixed disk or two double-sided floppy-disk drives,
    at least 320 KB of memory, and a video display board and monitor
    capable of graphics and a screen resolution of at least 640
    (horizontal) by 200 (vertical) pixels. A fixed disk and 640 KB of
    memory provide the best environment for running Windows; a mouse or
    other pointing device is optional but recommended.

    For the user, Windows provides a multitasking, graphics-based
    windowing environment for running programs. In this environment, users
    can easily switch among several programs and transfer data between
    them. Because programs specially designed to run under Windows usually
    have a consistent user interface, the time spent learning a new
    program is greatly diminished. Furthermore, the user can carry out
    command functions using only the keyboard, only the mouse, or some
    combination of the two. In some cases, Windows (and Windows
    applications) provides several different ways to execute the same
    command.

    For the program developer, Windows provides a wealth of high-level
    routines that make it easy to incorporate menus, scroll bars, and
    dialog boxes (which contain controls, such as push buttons and list
    boxes) into programs. Windows' graphics interface is device
    independent, so programs developed for Windows work with every video
    display adapter and printer that has a Windows driver (usually
    supplied by the hardware manufacturer). Windows also includes features
    that facilitate the translation of programs into foreign languages for
    international markets.

    When Windows is running, it shares responsibility for managing system
    resources with MS-DOS. Thus, programs that run under Windows continue
    to use MS-DOS function calls for all file input and output and for
    executing other programs, but they do not use MS-DOS for display or
    printer output, keyboard or mouse input, or memory management.
    Instead, they use functions provided by Windows.


Program Categories

    Programs that run under Windows can be divided into three categories:

    1. Programs specially designed for the Windows environment. Examples
        of such programs include Clock and Calculator, which come with
        Windows. Microsoft Excel is also specially designed for Windows.
        Other programs of this type (such as Aldus's Pagemaker) are
        available from software vendors other than Microsoft. Programs in
        this category cannot run under MS-DOS without Windows.

    2. Programs designed to run under MS-DOS but that can usually be run
        in a window along with programs designed specially for Windows.
        These programs do not require large amounts of memory, do
        not write directly to the display, do not use graphics, and do not
        alter the operation of the keyboard interrupt. They cannot use the
        mouse, the Windows application-program interface (such as menus and
        dialog boxes), or the graphics services that Windows provides.
        MS-DOS utilities, such as EDLIN and CHKDSK, are examples of
        programs in this category.

    3. Programs designed to run under MS-DOS but that require large
        amounts of memory, write directly to the display, use graphics, or
        alter the operation of the keyboard interrupt. When Windows runs
        such a program, it must suspend operation of all other programs
        running in Windows and allow the program to use the full screen. In
        some cases, Windows cannot switch back to its normal display until
        the program terminates. Microsoft Word and Lotus 1-2-3 are examples
        of programs in this category.

    The programs in categories 2 and 3 are sometimes called standard
    applications. To run one of these programs in Windows, the user must
    create a PIF file (Program Information File) that describes how much
    memory the program requires and how it uses the computer's hardware.

    Although the ability to run existing MS-DOS programs under Windows
    benefits the user, the primary purpose of Windows is to provide an
    environment for specially designed programs that take full advantage
    of the Windows interface. This discussion therefore concentrates
    almost exclusively on programs written for the Windows 2.0
    environment.


The Windows Display

    Figure 17-1 shows a typical Windows display running several programs
    that are included with the retail version of Windows 2.0.

    The display is organized as a desktop, with each program occupying one
    or more rectangular windows that, unlike the tiled (juxtaposed)
    windows typical of earlier versions, can be overlapped. Only one
    program is active at any time--usually the program that is currently
    receiving keyboard input. Windows displays the currently active
    program on top of (overlying) the others. Programs such as CLOCK and
    TERMINAL that are not active continue to run normally, but do not
    receive keyboard input.

    The user can make another program active by pressing and releasing
    (clicking) the mouse button when the mouse cursor is positioned in the
    new program's window or by pressing either the Alt-Tab or Alt-Esc key
    combination. Windows then brings the new active program to the top.

    Most Windows programs allow their windows to be moved to another part
    of the display or to be resized to occupy smaller or larger areas.
    Most of these programs can also be maximized to fill the entire screen
    or minimized--generally as a small icon displayed at the bottom of the
    screen--to occupy a small amount of display space.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 17-1 is found on page 501      ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 17-1. A typical Windows display.


Parts of the window

    Figure 17-2 shows the Windows NOTEPAD program, with the different
    parts of the window identified. NOTEPAD is a small ASCII text editor
    limited to files of 16 KB. The various parts of the NOTEPAD window
    (similar to all Windows programs) are described in this section.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 17-2 is found on page 502      ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 17-2. The Windows NOTEPAD program, with different parts of the
    display labeled.


    Title bar (or caption bar). The title bar identifies the program and,
    if applicable, the data file currently loaded into the program. For
    example, the NOTEPAD window shown in Figure 17-2 has the file WIN.INI
    loaded into memory. Windows uses different title-bar colors to distin-
    guish the active window from inactive windows. The user can move a
    window to another part of the display by pressing the mouse button
    when the mouse pointer is positioned anywhere on the title bar and
    dragging (moving) the mouse while the button is pressed.

    System-menu icon. When the user clicks a system-menu icon with the
    mouse (or presses Alt-Spacebar), Windows displays a system menu like
    that shown in Figure 17-3. (Most Windows programs have identical
    system menus.) The user selects a menu item in one of several ways:
    clicking on the item; moving the highlight bar to the item with the
    cursor-movement keys and then pressing Enter; or pressing the letter
    that is underlined in the menu item (for example, n for
    Minimimize).

    The keyboard combinations (Alt plus function key) at the right of the
    system menu are keyboard accelerators. Using a keyboard accelerator,
    the user can select system-menu options without first displaying the
    system menu.

    The six options on the standard system menu are

    ■  Restore: Return the window to its previous position and size after
        it has been minimized or maximized.

    ■  Move: Allow the window to be moved with the cursor-movement keys.

    ■  Size: Allow the window to be resized with the cursor-movement keys.

    ■  Minimize: Display the window in its iconic form.

    ■  Maximize: Allow the window to occupy the full screen.

    ■  Close: End the program.

    Windows displays an option on the system menu in grayed text to
    indicate that the option is not currently valid. In the system menu
    shown in Figure 17-3, for example, the Restore option is grayed
    because the window is not in a minimized or maximized form.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 17-3 is found on page 502      ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 17-3. A system menu, displayed either when the user clicks the
    system-menu icon (top left corner) or presses Alt-Spacebar.


    Minimize icon. When the user clicks on the minimize icon with the
    mouse, Windows displays the program in its iconic form.

    Maximize icon. Clicking on the maximize icon expands the window to
    fill the full screen. Windows then replaces the maximize icon with a
    restore icon (shown in Figure 17-4). Clicking on the restore icon
    restores the window to its previous size and position.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 17-4 is found on page 503      ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 17-4. The restore icon, which replaces the maximize icon when a
    window is expanded to fill the entire screen.


    Programs that use a window of a fixed size (such as the CALC.EXE
    calculator program included with Windows) do not have a maximize icon.

    Menu bar. The menu bar, sometimes called the program's main or top-
    level menu, displays keywords for several sets of commands that differ
    from program to program.

    When the user clicks on a main-menu item with the mouse or presses the
    Alt key and the underlined letter in the menu text, Windows displays a
    pop-up menu for that item. The pop-up menu for NOTEPAD's keyword File
    is shown in Figure 17-5. Items are selected from a pop-up menu in the
    same way they are selected from the system menu.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 17-5 is found on page 503      ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 17-5. The NOTEPAD program's pop-up file menu.


    A Windows program can display options on the menu in grayed text to
    indicate that they are not currently valid. The program can also
    display checkmarks to the left of pop-up menu items to indicate which
    of several options have been selected by the user.

    In addition, items on a pop-up menu can be followed by an ellipsis
    (...) to indicate that selecting the item invokes a dialog box that
    prompts the user for additional information-more than can be provided
    by the menu.

    Client area. The client area of the window is where the program
    displays data. In the case of the NOTEPAD program shown in Figure
    17-2, the client area displays the file currently being edited. A
    program's handling of keyboard and mouse input within the client area
    depends on the type of work it does.

    Scroll bars. Programs that cannot display all the data in a file
    within the client area of the window often have a horizontal scroll
    bar across the bottom and a vertical scroll bar down the right edge.
    Both types of scroll bars have a small, boxed arrow at each end to
    indicate the direction in which to scroll. In the NOTEPAD window in
    Figure 17-2, for example, clicking on the up arrow of the vertical
    scroll bar moves the data within the window down one line. Clicking
    on the shaded part of the vertical scroll bar above the thumb (the
    box near the middle moves the data within the client area of the
    window down one screen; clicking below the thumb moves the data up one
    screen. The user can also drag the thumb with the mouse to move to
    a relative position within the file.

    Windows programs often include a keyboard interface (generally relying
    on the cursor-movement keys) to duplicate the mouse-based scroll-bar
    commands.

    Window border. The window border is a thick frame surrounding the
    entire window. It is segmented into eight sections that represent the
    four sides and four corners of the window. The user can change the
    size of a window by dragging the window border with the mouse.
    Dragging a corner section moves two adjacent sides of the border.

    When a program is maximized to fill the full screen, Windows does not
    draw the window border. Programs that use a window of a fixed size do
    not have a window border either.

Dialog boxes

    When a pop-up menu is not adequate for all the command options a
    program requires, the program can display a dialog box. A dialog box
    is a pop-up window that contains various controls in the form of push
    buttons, check boxes, radio buttons, list boxes, and text and edit
    fields. Programmers can also design their own controls for use in
    dialog boxes. A user fills in a dialog box and then clicks on a
    button, such as OK, or presses Enter to indicate that the information
    can be processed by the program.

    Most Windows programs use a dialog box to open an existing data file
    and load it into the program. The program displays the dialog box when
    the user selects the Open option on the File pop-up menu. The sample
    dialog box shown in Figure 17-6 is from the NOTEPAD program.

    The list box displays a list of all valid disk drives, the
    subdirectories of the current directory, and all the filenames in the
    current directory, including the filename extension used by the
    program. (NOTEPAD uses the extension .TXT for its data files.) The
    user can scroll through this list box and change the current drive or
    subdirectory or select a filename with the keyboard or the mouse. The
    user can also perform these actions by typing the name directly into
    the edit field.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 17-6 is found on page 504      ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 17-6. A dialog box from the NOTEPAD program, with parts
    labeled.


    Clicking the Open button (or pressing Enter) indicates to NOTEPAD that
    a file has been selected or that a new drive or subdirectory has been
    chosen (in this case, the program displays the files on the new drive
    or subdirectory). Clicking the Cancel button (or pressing Esc) tells
    NOTEPAD to close the dialog box without loading a new file.

    Figure 17-7 shows a different dialog box--this one from the Windows
    TERMINAL communications program. The check boxes turn options on
    (indicated by an X) and off. The circular radio buttons allow the user
    to select from a set of mutually exclusive options.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 17-7 is found on page 505      ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 17-7. A dialog box from the TERMINAL program, with parts
    labeled.


    Another, simple form of a dialog box is called a message box. This box
    displays one or more lines of text, an optional icon such as an
    exclamation point or an asterisk, and one or more buttons containing
    the words OK, Yes, No, or Cancel. Programs sometimes use message boxes
    for warnings or error messages.


The MS-DOS Executive

    Within Windows, the MS-DOS Executive program (shown in Figure 17-8)
    serves much the same function as the COMMAND.COM program in the MS-DOS
    environment.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 17-8 is found on page 506      ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 17-8. The MS-DOS Executive.


    The top of the MS-DOS Executive client area displays all valid disk
    drives. The current disk drive is highlighted. Below or to the right
    of the disk drives is a display of the full path of the current
    directory. Below this is an alphabetic listing of all subdirectories
    in the current directory, followed by an alphabetic listing of all
    files in the current directory. Subdirectory names are displayed in
    boldface to distinguish them from filenames.

    The user can change the current drive by clicking on the disk drive
    with the mouse or by pressing Ctrl and the key corresponding to the
    disk drive letter.

    To change to one of the parent directories, the user double-clicks
    (clicks the mouse button twice in succession) on the part of the text
    string corresponding to the directory name. Pressing the Backspace key
    moves up one directory level toward the root directory. The user can
    also change the current directory to a child subdirectory by double-
    clicking on the subdirectory name in the list or by pressing the Enter
    key when the cursor highlight is on the subdirectory name. In
    addition, the menu also contains an option for changing the current
    directory.

    The user can run a program by double-clicking on the program filename,
    by pressing the Enter key when the highlight is on the program name,
    or by selecting it from a menu.

    Other menu options allow the user to display the file and subdirectory
    lists in a variety of ways. A long format includes the same
    information displayed by the MS-DOS DIR command, or the user can
    choose to display a select group of files. Menu options also enable
    the user to specify whether the files should be listed in alphabetic
    order by filename, by filename extension, or by date or size.

    The remaining options on the MS-DOS Executive menu allow the user to
    run programs; copy, rename, and delete files; format a floppy disk;
    change a volume name; make a system disk; create a subdirectory; and
    print a text file.


Other Windows Programs

    Windows 2.0 also includes a number of application and utility
    programs. The application programs are CALC (a calculator), CALENDAR,
    CARDFILE (a database arranged as a series of index cards), CLOCK,
    NOTEPAD, PAINT (a drawing and painting program), REVERSI (a game),
    TERMINAL, and WRITE (a word processor).

    The utility programs include:

    CLIPBRD. This program displays the current contents of the Clipboard,
    which is a storage facility that allows users to transfer data from
    one program to another.

    CONTROL. The Control Panel utility allows the user to add or delete
    font files and printer drivers and to change the following: current
    printer, printer output port, communications parameters, date and
    time, cursor blink rate, screen colors, border width, mouse double-
    click time and options, and country-specific information, such
    as time and date formats. The Control Panel stores much of this
    information in the file named WIN.INI (Windows Initialization), so
    the information is available to other Windows programs.

    PIFEDIT. The PIF editor allows the user to create or modify the PIFs
    that contain information about standard applications that have not
    been specially designed to run under Windows. This information allows
    Windows to adjust the environment in which the program runs.

    SPOOLER. Windows uses the print-spooler utility to print files without
    suspending the operation of other programs. Most printer-directed
    output from Windows programs goes to the print spooler, which then
    prints the files while other programs run. SPOOLER enables the user to
    change the priority of print jobs or to cancel them.


The Structure of Windows

    When programs run under MS-DOS, they make requests of the operating
    system through MS-DOS software interrupts (such as Interrupt 21H),
    through BIOS software interrupts, or by directly accessing the machine
    hardware.

    When programs run under Windows, they use MS-DOS function calls only
    for file input and output and (more rarely) for executing other
    programs. Windows programs do not use MS-DOS function calls for memory
    management, keyboard input, display or printer output, or RS232
    communications. Nor do Windows programs use BIOS routines or direct
    access to the hardware.

    Instead, Windows provides application programs with access to more
    than 450 functions that allow programs to create and manipulate
    windows on the display; use menus, dialog boxes, and scroll bars;
    display text and graphics within the client area of a window; use the
    printer and RS232 communications port; and allocate memory.

The Windows modules

    The functions provided by Windows are largely handled by three main
    modules named KERNEL, GDI, and USER. The KERNEL module is responsible
    for scheduling and multitasking, and it provides functions for memory
    management and some file I/O. The GDI module provides Windows'
    Graphics Device Interface functions, and the USER module does
    everything else.

    The USER and GDI modules, in turn, call functions in various driver
    modules that are also included with Windows. Drivers control the
    display, printer, keyboard, mouse, sound, RS232 port, and timer. In
    most cases, these driver modules access the hardware of the computer
    directly. Windows includes different driver files for various hardware
    configurations. Hardware manufacturers can also develop Windows
    drivers specifically for their products.

    A block diagram showing the relationships of an application program,
    the KERNEL, USER, and GDI modules, and the driver modules is shown in
    Figure 17-9. The figure shows each of these modules as a separate
    file--KERNEL, USER, and GDI have the extension .EXE; the driver files
    have the extension .DRV. Some program developers install Windows with
    these modules in separate files, as in Figure 17-9, but most users
    install Windows by running the SETUP program included with Windows.

    SETUP combines most of these modules into two larger files called
    WIN200.BIN and WIN200.OVL. Printer drivers are a little different from
    the other driver files, however, because the Windows SETUP program
    does not include them in WIN200.BIN and WIN200.OVL. The name of the
    driver file identifies the printer. For example, IBMGRX.DRV is a
    printer driver file for the IBM Personal Computer Graphics Printer.


                        ┌────────────┐   ┌──────────────┐
                    ┌──│            ├──│ DISPLAY.DRV  ├──Display
                    │   │            │   └──────────────┘
                    │   │  GDI.EXE   │   ┌──────────────┐
                    │ ┌│            ├──│Printer driver├──Printer
                    │ │ └────────────┘   └──────────────┘
                    │ └────────────────┐
                    │   ┌────────────┐ │
                    │   │            ├─┘
                    │   │            │   ┌──────────────┐
                    │   │            ├──│ KEYBOARD.DRV ├──Keyboard
                    │   │            │   └──────────────┘
                    │   │            │   ┌──────────────┐
                    │   │            ├──│  MOUSE.DRV   ├──Mouse
                    │   │            │   └──────────────┘
                    │   │            │   ┌──────────────┐
                    │   │            ├──│  SOUND.DRV   ├──Sound hardware
    ┌────────────┐ │   │            │   └──────────────┘
    │  Windows   ├─┘   │            │   ┌──────────────┐
    │application ├────│  USER.EXE  ├──│   COMM.DRV   ├──RS-232 hardware
    │  program   ├─┐   │            │   └──────────────┘
    └────────────┘ │   │            │   ┌──────────────┐
                    │   │            ├──│  SYSTEM.DRV  ├──Timer hardware
                    │   │            │   └──────────────┘
                    │   │            │
                    │   │            │
                    │   │            │
                    │   │            ├─┐
                    │   └────────────┘ │
                    │┌─────────────────┘
                    ││  ┌────────────┐
                    │└─│            ├──MS-DOS file I/O
                    │   │ KERNEL.EXE │
                    └──│            ├──Memory management
                        └────────────┘

    Figure 17-9. A simplified block diagram showing the relationships of
    an application program, Windows modules (GDI, USER, and KERNEL),
    driver modules, and system hardware.


    The diagram in Figure 17-9 is somewhat simplified. In reality, a
    Windows application program can also make direct calls to the
    KEYBOARD.DRV and SOUND.DRV modules, and USER.EXE calls the DISPLAY.DRV
    and printer driver modules directly. The GDI.EXE module and driver
    modules can also call routines in KERNEL.EXE, and drivers sometimes
    call routines in SYSTEM.DRV.

    Also, Figure 17-9 omits the various font files provided with Windows,
    the WIN.INI file that contains Windows initialization information and
    user preferences, and the files WINOLDAP.MOD and WINOLDAP.GRB, which
    Windows uses to run standard MS-DOS applications.

Libraries and programs

    The USER.EXE, GDI.EXE, and KERNEL.EXE files, all driver files with the
    extension .DRV, and all font files with the extension .FON are called
    Windows libraries or, sometimes, dynamic link libraries to distinguish
    them from Windows programs. Programs and libraries both use a file
    format called the New Executable format.

    From the user's perspective, a Windows program and a Windows library
    are very different. The user cannot run a Windows library directly:
    Windows loads a part of a library into memory only when a program
    needs to use a function that the library provides.

    The user can also run multiple instances of the same Windows program.
    Windows uses the same code segments for the different instances but
    creates a unique data segment for each. Windows never runs multiple
    instances of a Windows library.

    From the programmer's perspective, a Windows program is a task that
    creates and manages windows on the display. Libraries are modules that
    assist the task. A programmer can write additional library modules,
    which one or more programs can use. For the developer, one important
    distinction between programs and libraries is that a Windows library
    does not have its own stack; instead, the library uses the stack of
    the program that calls the routine in the library.

    The New Executable format used for both programs and libraries gives
    Windows much more information about the module than is provided by the
    current MS-DOS .EXE format. In particular, the module contains
    information that allows Windows to make links between program modules
    and library modules when a program is run.

    When a module (such as a library) contains functions that can be
    called from another module (such as a program), the functions are said
    to be exported from the module that contains them. Each exported
    function in a module is identified either by a name (generally the
    name of the function) or by an ordinal (positive) number. A list of
    all exported functions in a module is included in the New Executable
    format header section of the module.

    Conversely, when a module (such as a program) contains code that calls
    a function in another module (such as a library), the function is said
    to be imported to the module that makes the call. This call appears in
    the .EXE file as an unresolved reference to an external function. The
    New Executable format identifies the module and the function name or
    ordinal number that the call references.

    When Windows loads a program or a library into memory, it must resolve
    all calls the module makes to functions in other modules. Windows does
    this by inserting the addresses of the functions into the code--a
    process called dynamic linking.

    For example, many Windows programs use the function TextOut to display
    text in the client area. In the code segment of the program's .EXE
    file, a call to TextOut appears as an unresolved far (intersegment)
    call. The code segment's relocation table shows that this call is to
    an imported function in the GDI module identified by the ordinal
    number 33. The header section of the GDI module lists TextOut as an
    exported function with the ordinal number 33. When Windows loads the
    program, it resolves all references to TextOut by inserting the
    address of the function into the program's code segment in each place
    where TextOut is called.

    Although Windows programs reference many functions that are exported
    from the standard Windows libraries, Windows programs also often
    include at least one exported function, called a window function.
    While the program is running, Windows calls this function to pass
    messages to the program's window. See The Structure of a Windows
    Program, below.


Memory Management

    Windows' memory management is based on the segmented-memory
    architecture of the Intel 8086 family of microprocessors. The memory
    space controlled by Windows is divided into segments of various
    lengths. Windows uses separate segments for nearly everything kept in
    memory--such as the code and data segments of programs and libraries--
    and for resources, such as fonts and bitmaps.

    Windows programs and libraries contain one or more code segments,
    which are usually both movable and discardable. Windows can move a
    code segment in memory in order to consolidate free memory space. It
    can also discard a code segment from memory and later reload the code
    segment from the program's or library's .EXE file when it is needed
    again. This capability is called demand loading.

    Windows programs usually contain only one data segment; Windows
    libraries are limited to one data segment. In most cases, Windows can
    move data segments in memory. However, it cannot usually discard data
    segments, because they can contain data that changes after the program
    begins executing. When a user runs multiple copies of a program, the
    different instances share the same code segments but have separate
    data segments.

    The use of movable and discardable segments allows Windows to run
    several large programs in a memory space that might be inadequate for
    even one of the programs if the entire program were kept in memory, as
    is typical under MS-DOS without Windows. The ability of Windows to use
    memory in this way is called memory overcommitment.

    The moving and discarding of code segments requires Windows to make
    special provisions so that intersegment calls continue to reference
    the correct address when a code segment is moved. These provisions are
    another part of dynamic linking. When Windows resolves a far call from
    one code segment to a function in another code segment that is movable
    and discardable, the call actually references a fixed area of memory.
    This fixed area of memory contains a small section of code called a
    thunk. If the code segment containing the function is currently in
    memory, the thunk simply jumps to the function. If the code segment
    with the function is not currently in memory, the thunk calls a loader
    that loads the segment into memory. This process is called dynamic
    loading. When Windows moves or discards a code segment, it must alter
    the thunks appropriately.

    Windows and Windows programs generally reference data structures
    stored in Windows' memory space by using 16-bit unsigned integers
    known as handles. The data structure that a handle references can be
    movable and discardable, so when Windows or the Windows program needs
    to access the data directly, it must lock the handle to cause the data
    to become fixed in memory. The function that locks the segment returns
    a pointer to the program.

    During the time the handle is locked, Windows cannot move or discard
    the data. The data can then be referenced directly with the pointer.
    When Windows (or the Windows program) finishes using the data, it
    unlocks the segment so that it can be moved (or in some cases
    discarded) to free up memory space if necessary.

    Programmers can choose to allocate nonmovable data segments, but the
    practice is not recommended, because Windows cannot relocate the
    segments to make room for segments required by other programs.


The Structure of a Windows Program

    During development, a Windows program includes several components that
    are combined later into a single executable file with the extension
    .EXE for execution under Windows. Although the Windows executable file
    has the same .EXE filename extension as MS-DOS executable files, the
    format is different. Among other things, the New Executable format
    includes Windows-specific information required for dynamic linking and
    the discarding and reloading of the program's code segments.

    Programmers generally use C, Pascal, or assembly language to create
    applications specially designed to run under Windows. Also required
    are several header files and development tools, which are included in
    the Microsoft Windows Software Development Kit.

The Microsoft Windows Software Development Kit

    The Windows Software Development Kit contains reference material, a
    special linker (LINK4), the Windows Resource Compiler (RC), special
    versions of the SYMDEB and CodeView debuggers, header files, and
    several programs that aid development and testing. These programs
    include

    ■  DIALOG: Used for creating dialog boxes.

    ■  ICONEDIT: Used for creating a program's icon, customized cursors,
        and bitmap images.

    ■  FONTEDIT: Used for creating customized fonts derived from an
        existing font file with the extension .FNT.

    ■  HEAPWALK: Used for displaying the organization of code and data
        segments in Windows' memory space and for testing programs under
        low memory conditions.

    ■  SHAKER: Used for randomly allocating memory to force segment
        movement and discarding. SHAKER tests a program's response to
        movement in memory and is useful for exposing program bugs
        involving pointers to unlocked segments.

    The Windows Software Development Kit also provides several include and
    header files that contain declarations of all Windows functions,
    definitions of many macro identifiers that the programmer can use, and
    structure definitions. Import libraries included in the kit allow
    LINK4 to resolve calls to Windows functions and to prepare the
    program's .EXE file for dynamic linking.

    Work with the Windows Software Development Kit requires one of the
    following compilers or assemblers:

    ■  Microsoft C Compiler version 4.0 or later
    ■  Microsoft Pascal Compiler version 3.31 or later
    ■  Microsoft Macro Assembler version 4.0 or later

    Other software manufacturers also provide compilers that are suitable
    for compiling Windows programs.

Components of a Windows program

    The discussion in this section is illustrated by a program called
    SAMPLE, which displays the word Windows in its client area. In
    response to a menu selection, the program displays this text in any of
    the three vector fonts--Script, Modern, and Roman--that are included
    with Windows. Sometimes also called stroke or graphics fonts, these
    vector fonts are defined by a series of line segments, rather than by
    the pixel patterns that make up the more common raster fonts. The
    SAMPLE program picks a font size that fits the client area.

    Figure 17-10 shows several instances of this program running under
    Windows.


            ╔══════════════════════════════════════════╗
            ║                                          ║
            ║    Figure 17-10 is found on page 512     ║
            ║    in the printed version of the book.   ║
            ║                                          ║
            ╚══════════════════════════════════════════╝

    Figure 17-10. A display produced by the example program SAMPLE.


    Five separate files go into the making of this program:

    1. Source-code file: This is the main part of the program, generally
        written in C, Pascal, or assembly language. The SAMPLE program was
        written in C, which is the most popular language for Windows
        programs because of its flexibility in using pointers and
        structures. The SAMPLE.C source-code file is shown in Figure 17-11.

    ──────────────────────────────────────────────────────────────────────

        Figure 17-11. The SAMPLE.C source code.

    ──────────────────────────────────────────────────────────────────────

    2. Resource script: The resource script is an ASCII file that
        generally has the extension .RC. This file contains definitions of
        menus, dialog boxes, string tables, and keyboard accelerators used
        by the program. The resource script can also reference other files
        that contain icons, cursors, bitmaps, and fonts in binary form, as
        well as other read-only data defined by the programmer. When a
        program is running, Windows loads resources into memory only when
        they are needed and in most cases can discard them if additional
        memory space is required.

        SAMPLE.RC, the resource script for the SAMPLE program, is shown in
        Figure 17-12; it contains only the definition of the menu used in
        the program.


        #include "sample.h"

        Sample MENU
            BEGIN
                POPUP "&amp;Typeface"
                    BEGIN
                            MENUITEM "&amp;Script", IDM_SCRIPT, CHECKED
                            MENUITEM "&amp;Modern", IDM_MODERN
                            MENUITEM "&amp;Roman",  IDM_ROMAN
                    END
            END

        Figure 17-12. The resource script for the SAMPLE program.


    3. Header (or include) file: This file, with the extension .H, can
        contain definitions of constants or macros, as is customary in C
        programming. For Windows programs, the header file also reconciles
        constants used in both the resource script and the program source-
        code file. For example, in the SAMPLE.RC resource script, each item
        in the pop-up menu (Script, Modern, and Roman) also includes an
        identifier--IDM_SCRIPT, IDM_MODERN, and IDM_ROMAN, respectively.
        These identifiers are merely numbers that Windows uses to notify
        the program of the user's selection of a menu item. The same names
        are used to identify the menu selection in the C source-code file.
        And, because both the resource compiler and the source-code
        compiler must have access to these identifiers, the header file is
        included in both the resource script and the source-code file.

        The header file for the SAMPLE program, SAMPLE.H, is shown in
        Figure 17-13.


        #define IDM_SCRIPT 1
        #define IDM_MODERN 2
        #define IDM_ROMAN  3

        Figure 17-13. The SAMPLE.H header file.


    4. Module-definition file: The module-definition file generally has a
        .DEF extension. The Windows linker uses this file in creating the
        executable .EXE file. The module-definition file specifies various
        attributes of the program's code and data segments, and it lists
        all imported and exported functions in the source-code file. In
        large programs that are divided into multiple code segments, the
        module-definition file allows the programmer to specify different
        attributes for each code segment.

        The module-definition file for the SAMPLE program is named
        SAMPLE.DEF and is shown in Figure 17-14.


        NAME           SAMPLE
        DESCRIPTION    'Demonstration Windows Program'
        STUB           'WINSTUB.EXE'
        CODE           MOVABLE
        DATA           MOVABLE MULTIPLE
        HEAPSIZE       1024
        STACKSIZE      4096
        EXPORTS        WndProc

        Figure 17-14. The SAMPLE.DEF module-definition file.


    5. Make file: To facilitate construction of the executable file from
        these different components, Windows programmers often use the MAKE
        program to compile only those files that have changed since the
        last time the program was linked. To do this, the programmer first
        creates an ASCII text file called a make file. By convention, the
        make file has no extension.

        The make file for the SAMPLE program is named SAMPLE and is shown
        in Figure 17-15. The programmer can create the SAMPLE.EXE
        executable file by executing

        C&gt;MAKE SAMPLE  &lt;Enter&gt;

        A make file often contains several sections, each beginning with a
        target filename, followed by a colon and one or more dependent
        filenames, such as

        sample.obj : sample.c sample.h

        If either or both the SAMPLE.C and SAMPLE.H files have a later
        creation time than SAMPLE.OBJ, then MAKE runs the program or pro-
        grams listed immediately below. In the case of the SAMPLE make
        file, the program is the C compiler, and it compiles the SAMPLE.C
        source code:

        cl -c -Gsw -W2 -Zdp sample.c

        Thus, if the programmer changes only one of the several files used
        in the development of SAMPLE, then running MAKE ensures that the
        executable file is brought up to date, while carrying out only the
        required steps.


        sample.obj : sample.c sample.h
            cl -c -Gsw -W2 -Zdp sample.c

        sample.res : sample.rc sample.h
            rc -r sample.rc

        sample.exe : sample.obj sample.def sample.res
            link4 sample, /align:16, /map /line, slibw, sample
            rc sample.res
            mapsym sample

        Figure 17-15. The make file for the SAMPLE program.


Construction of a Windows program

    The make file shows the steps that create a program's .EXE file from
    the various components:

    1. Compiling the source-code file:

        cl -c -Gsw -W2 -Zdp sample.c

        This step uses the CL.EXE C compiler to create a .OBJ object-module
        file. The command line switches are

        - -c: Compiles the program but does not link it. Windows programs
        must be linked with Windows' LINK4 linker, rather than with the
        LINK program the C compiler would normally invoke.

        - -Gsw: Includes two switches, -Gs and -Gw. The -Gs switch removes
        stack checks from the program. The -Gw switch inserts special
        prologue and epilogue code in all far functions defined in the
        program. This special code is required for Windows' memory
        management.

        - -W2: Compiles with warning level 2. This is the highest warning
        level, and it causes the compiler to display messages for
        conditions that may be acceptable in normal C programs but that
        can cause serious errors in a Windows program.

        - -Zdp: Includes two switches, -Zd and -Zp. The -Zd switch includes
        line numbers in the .OBJ file--helpful for debugging at the
        source-code level. The -Zp switch packs structures on byte
        boundaries. The -Zp switch is required, because data structures
        used within Windows are in a packed format.

    2. Compiling the resource script:

        rc -r sample.rc

        This step runs the resource compiler and converts the ASCII .RC
        resource script into a binary .RES form. The -r switch indicates
        that the resource script should be compiled but the resources
        should not yet be added to the program's .EXE file.

    3. Linking the program:

        link4 sample, /align:16, /map /line, slibw, sample

        This step uses the special Windows linker, LINK4. The first
        parameter listed is the name of the .OBJ file. The /align:16 switch
        instructs LINK4 to align segments in the .EXE file on 16-byte
        boundaries. The /map and /line switches cause LINK4 to create a
        .MAP file that contains program line numbers--again, useful for
        debugging source code. Next, slibw is a reference to the SLIBW.LIB
        file, which is an import library that contains module names and
        ordinal numbers for all Windows functions. The last parameter,
        sample, is the program's module-definition file, SAMPLE.DEF.

    4. Adding the resources to the .EXE file:

        rc sample.res

        This step runs the resource compiler a second time, using the
        compiled resource file, SAMPLE.RES. This time, the resource
        compiler adds the resources to the .EXE file.

    5. Creating a symbol (.SYM) file from the linker's map (.MAP) file:

        mapsym sample

        This step is required for symbolic debugging with SYMDEB.

    Figure 17-16 shows how the various components of a Windows program fit
    into the creation of a .EXE file.


    ┌───────────────┐ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐
    │    Module     │ │    Program    │ │   Header or   │ │               │
    │definition file│ │  source code  │ │ include files │ │Resource script│
    │    (.DEF)     │ │(.C,.PAS,.ASM) │ │ (.H or .INC)  │ │     (.RC)     │
    └───────┬───────┘ └───────┬───────┘ └───────┬───────┘ └───────┬───────┘
            │                 │   ┌─────────────┴────────────┐    │
            │         ┌─────────────┐                   ┌─────────────┐
            │         │  C or Pascal  │                   │    RC.EXE     │
            │         │  Compiler or  │                   │   Resource    │
            │         │Macro Assembler│                   │   compiler    │
            │         └───────┬───────┘                   └───────┬───────┘
            │                 │                                   │
            │         ┌──────────────┐ ┌───────────────┐ ┌──────────────┐
            │         │               │ │               │ │   Compiled    │
            │         │ Object module │ │   Libraries   │ │   resources   │
            │         │    (.OBJ)     │ │    (.LIB)     │ │    (.RES)     │
            │         └───────┬───────┘ └───────┬───────┘ └───────┬───────┘
            └─────────────┐   │   ┌─────────────┘                 │
                    ┌────────────┐                           │
                    │               │                           │
                    │   LINK4.EXE   │                           │
                    │ Window linker │                           │
                    └───┬───┬───────┘                           │
            ┌─────────────┘   │                                   │
    ┌──────────────┐  ┌──────────────┐                          │
    │               │  │  Executable   │                          │
    │   Map file    │  │  without re-  │                          │
    │    (.MAP)     │  │sources (.EXE) │                          │
    └───────┬───────┘  └───────┬───────┘                          │
            │                  │   ┌──────────────────────────────┘
    ┌──────────────┐  ┌─────────────┐
    │  MAPSYM.EXE   │  │    RC.EXE     │
    │Makes map file │  │   Resource    │
    │ a symbol file │  │   compiler    │
    └───────┬───────┘  └───────┬───────┘
            │                  │
    ┌──────────────┐  ┌──────────────┐
    │               │  │               │
    │  Symbol file  │  │  Executable   │
    │    (.SYM)     │  │    (.EXE)     │
    └───────────────┘  └───────────────┘

    Figure 17-16. A block diagram showing the creation of a Windows
    .EXE file.


Program initialization

    The SAMPLE.C program shown in Figure 17-11 contains some code that
    appears in almost every Windows program. The statement

    #include &lt;windows.h&gt;

    appears at the top of every Windows source-code file written in C. The
    WINDOWS.H file, provided with the Microsoft Windows Software
    Development Kit, contains templates for all Windows functions,
    structure definitions, and #define statements for many mnemonic
    identifiers.

    Some of the variable names in SAMPLE.C may look unusual to C
    programmers because they begin with a prefix notation that denotes the
    data type of the variable. Windows programmers are encouraged to use
    this type of notation. Some of the more common prefixes are

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Prefix      Data Type
    ──────────────────────────────────────────────────────────────────
    i or n      Integer (16-bit signed integer)
    w           Word (16-bit unsigned integer)
    l           Long (32-bit signed integer)
    dw          Doubleword (32-bit unsigned integer)
    h           Handle (16-bit unsigned integer)
    sz          Null-terminated string
    lpsz        Long pointer to null-terminated string
    lpfn        Long pointer to a function

    The program's entry point (following some startup code) is the WinMain
    function, which is passed the following parameters: a handle to the
    current instance of the program (hInstance), a handle to the most
    recent previous instance of the program (hPrevInstance), a long
    pointer to the program's command line (lpszCmdLine), and a number
    (nCmdShow) that indicates whether the program should initially be
    displayed as a normally sized window or as an icon.

    The first job SAMPLE performs in the WinMain function is to register
    a window class--a structure that describes characteristics of the
    windows that will be created in the class. These characteristics
    include background color, the type of cursor to be displayed in the
    window, the window's initial menu and icon, and the window function
    (the structure member called lpfnWndProc).

    Multiple instances of a program can share the same window class, so
    SAMPLE registers the window class only for the first instance of the
    program:

    if (!hPrevInstance)
            {
            wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
            wndclass.lpfnWndProc   = WndProc ;
            wndclass.cbClsExtra    = 0 ;
            wndclass.cbWndExtra    = 0 ;
            wndclass.hInstance     = hInstance ;
            wndclass.hIcon         = NULL ;
            wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
            wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
            wndclass.lpszMenuName  = szAppName ;
            wndclass.lpszClassName = szAppName ;

            RegisterClass (&amp;wndclass) ;
            }

    The SAMPLE program then creates a window using the CreateWindow call,
    displays it to the screen by calling ShowWindow, and updates the
    client area by calling UpdateWindow:

    hWnd = CreateWindow (szAppName, "Demonstration Windows Program",
                        WS_OVERLAPPEDWINDOW,
                        (int) CW_USEDEFAULT,0,
                        (int) CW_USEDEFAULT,0,
                        NULL, NULL, hInstance, NULL) ;
    ShowWindow (hWnd, nCmdShow) ;
    UpdateWindow (hWnd) ;

    The first parameter to CreateWindow is the name of the window class.
    The second parameter is the actual text that appears in the window's
    title bar. The third parameter is the style of the window--in this
    case, the WINDOWS.H identifier WS_OVERLAPPEDWINDOW. The
    WS_OVERLAPPEDWINDOW is the most common window style. The fourth
    through seventh parameters specify the initial position and size of
    the window. The identifier CW_USEDEFAULT tells Windows to position and
    size the window according to the default rules.

    After creating and displaying a Window, the SAMPLE program enters a
    piece of code called the message loop:

    while (GetMessage (&amp;msg, NULL, 0, 0))
            {
            TranslateMessage (&amp;msg) ;
            DispatchMessage (&amp;msg) ;
            }
    return msg.wParam ;

    This loop continues to execute until the GetMessage call returns zero.
    When that happens, the program instance terminates and the memory
    required for the instance is freed.

The Windows messaging system

    Interactive programs written for the normal MS-DOS environment
    generally obtain user input only from the keyboard, using either an
    MS-DOS or a ROM BIOS software interrupt to check for keystrokes. When
    the user types something, such programs act on the keystroke and then
    return to wait for the next keystroke.

    Programs written for Windows, however, can receive user input from a
    variety of sources, including the keyboard, the mouse, the Windows
    timer, menus, scroll bars, and controls, such as buttons and edit
    boxes.

    Moreover, a Windows program must be informed of other events occurring
    within the system. For instance, the user of a Windows program might
    choose to make its window smaller or larger. Windows must make the
    program aware of this change so that the program can adjust its screen
    output to fit the new window size. Thus, for example, if a Windows
    program is minimized as an icon and the user maximizes its window to
    fill the full screen, Windows must inform the program that the size of
    the client area has changed and needs to be re-created.

    Windows carries out this job of keeping a program informed of other
    events through the use of formatted messages. In effect, Windows sends
    these messages to the program. The Windows program receives and acts
    upon the messages.

    This messaging makes the relationship between Windows and a Windows
    program much different from the relationship between MS-DOS and an
    MS-DOS program. Whereas MS-DOS does not provide information until a
    program requests it through an MS-DOS function call, Windows must
    continually notify a program of all the events that affect its window.

    Window messages can be separated into two major categories: queued and
    nonqueued.

    Queued messages are similar to the keyboard information an MS-DOS
    program obtains from MS-DOS. When the Windows user presses a key on
    the keyboard, moves the mouse, or presses one of the mouse buttons,
    Windows saves information about the event (in the form of a data
    structure) in the system message queue. Each message is destined for a
    particular window in a particular instance of a Windows program.
    Windows therefore determines which window should get the information
    and then places the message in the instance's own message queue.

    A Windows program retrieves information from its queue in the message
    loop:

        while (GetMessage (&amp;msg, NULL, 0, 0))
                    {
                    TranslateMessage (&amp;msg) ;
                    DispatchMessage (&amp;msg) ;
                    }

    The msg variable is a structure. During the GetMessage call, Windows
    fills in the fields of this structure with information about the
    message. The fields are as follows:

    ■  hwnd: The handle for the window that is to receive the message.

    ■  iMessage: A numeric code identifying the type of message (for
        example, keyboard or mouse).

    ■  wParam: A 16-bit value containing information specific to the
        message. See The Windows Messages, below.

    ■  lParam: A 32-bit value containing information specific to the
        message.

    ■  time: The time, in milliseconds, that the message was placed in the
        queue. The time is a 32-bit value relative to the time at which the
        current Windows session began.

    ■  pt.x: The horizontal coordinate of the mouse cursor at the time the
        event occurred.

    ■  pt.y: The vertical coordinate of the mouse cursor at the time the
        event occurred.

    GetMessage always returns a nonzero value except when it receives a
    quit message. The quit message causes the message loop to end. The
    program should then terminate and return control to Windows.

    Within the message loop, the TranslateMessage function translates
    physical keystrokes into character-code messages. Windows places these
    translated messages into the program's message queue.

    The DispatchMessage function essentially makes a call to the window
    function of the window specified by the hwnd field. This window
    function (WndProc in SAMPLE) is indicated in the lpfnWndProc field of
    the window class structure.

    When DispatchMessage passes the message to the window function,
    Windows uses the first four fields of the message structure as
    parameters to the function. The window function can then process the
    message. In SAMPLE, for instance, the four fields passed to WndProc
    are hwnd (the handle to the window), iMessage (the numeric message
    identifier), wParam, and lParam. Although Windows does not pass the
    time and mouse-position information fields as parameters to the window
    function, this information is available through the Windows functions
    GetMessageTime and GetMessagePos.

    A Windows program obtains only a few specific types of messages
    through its message queue. These are keyboard messages, mouse
    messages, timer messages, the paint message that tells the program it
    must re-create the client area of its window, and the quit message
    that tells the program it is being terminated.

    In addition to the queued messages, however, a program's window
    function also receives many nonqueued messages. Windows sends these
    nonqueued messages by bypassing the message loop and calling the
    program's window function directly.

    Many of these nonqueued messages are derived from queued messages. For
    example, when the user clicks the mouse on the menu bar, a mouse-click
    message is placed in the program's message queue. The GetMessage
    function retrieves the message and the DispatchMessage function sends
    it to the program's window function. However, because this mouse
    message affects a nonclient area of the window (an area outside the
    window's client area), the window function normally does not process
    it. Instead, the function passes the message back to Windows. In this
    example, the message tells Windows to invoke a pop-up menu. Windows
    calls up the menu and then sends the window function several nonqueued
    messages to inform the program of this action.

    A Windows program is thus message driven. Once a program reaches the
    message loop, it acts only when the window function receives a
    message. And, although a program receives many messages that affect
    the window, the program usually processes only some of them, sending
    the rest to Windows for normal default processing.

The Windows messages

    Windows can send a window function more than 100 different messages.
    The WINDOWS.H header file includes identifiers for all these messages
    so that C programmers do not have to remember the message numbers.
    Some of the more common messages and the meanings of the wParam and
    lParam parameters are discussed here:

    WM_CREATE. Windows sends a window function this nonqueued message
    while processing the CreateWindow call. The lParam parameter is a
    pointer to a creation structure. A window function can perform some
    program initialization during the WM_CREATE message.

    WM_MOVE. Windows sends a window function the nonqueued WM_MOVE message
    when the window has been moved to another part of the display. The
    lParamparameter gives the new coordinates of the window relative to
    the upper left corner of the screen.

    WM_SIZE. This nonqueued message indicates that the size of the window
    has been changed. The new size is encoded in the lParam parameter.
    Programs often save this window size for later use.

    WM_PAINT. This queued message indicates that a region in the window's
    client area needs repainting. (The message queue can contain only one
    WM_PAINT message.)

    WM_COMMAND. This nonqueued message signals a program that a user has
    selected a menu item or has triggered a keyboard accelerator. Child-
    window controls also use WM_COMMAND to send messages to the parent
    window.

    WM_KEYDOWN. The wParam parameter of this queued message is a virtual
    key code that identifies the key being pressed. The lParam parameter
    includes flags that indicate the previous key state and the number of
    keypresses the message represents.

    WM_KEYUP. This queued message tells a window function that a key has
    been released. The wParam parameter is a virtual key code.

    WM_CHAR. This queued message is generated from WM_KEYDOWN messages
    during the TranslateMessage call. The wParam parameter is the ASCII
    code of a keyboard key.

    WM_MOUSEMOVE. Windows uses this queued message to tell a program about
    mouse movement. The lParam parameter contains the coordinates of the
    mouse relative to the upper left corner of the client area of the
    window. The wParam parameter contains flags that indicate whether any
    mouse buttons or the Shift or Ctrl keys are currently pressed.

    WM_xBUTTONDOWN. This queued message tells a program that a button on
    the mouse was depressed while the mouse was in the window's client
    area. The x can be either L, R, or M for the left, right, or middle
    mouse button. The wParam and lParam parameters are the same as for
    WM_MOUSEMOVE.

    WM_xBUTTONUP. This queued message tells a program that the user has
    released a mouse button.

    WM_xBUTTONDBLCLK. When the user double-clicks a mouse button, Windows
    generates a WM_xBUTTONDOWN message for the first click and a queued
    WM_xBUTTONDBLCLK message for the second click.

    WM_TIMER. When a Windows program sets a timer with the SetTimer
    function, Windows places a WM_TIMER message in the message queue at
    periodic intervals. The wParam parameter is a timer ID. (If the
    message queue already contains a WM_TIMER message, Windows does not
    add another one to the queue.)

    WM_VSCROLL. A Windows program that includes a vertical scroll bar in
    its window receives nonqueued WM_VSCROLL messages indicating various
    types of scroll-bar manipulation.

    WM_HSCROLL. This nonqueued message indicates a user is manipulating a
    horizontal scroll bar.

    WM_CLOSE. Windows sends a window function this nonqueued message when
    the user has selected Close from the window's system menu. A program
    can query the user to determine whether any action, such as saving a
    file to disk, is needed before the program is terminated.

    WM_QUERYENDSESSION. This nonqueued message indicates that the user is
    shutting down Windows by selecting Close from the MS-DOS Executive
    system menu. A program can request the user to verify that the program
    should be ended. If the window function returns a zero value from the
    message, Windows does not end the session.

    WM_DESTROY. This nonqueued message is the last message a window
    function receives before the program ends. A window function can
    perform some last-minute cleanup while processing WM_DESTROY.

    WM_QUIT. This is a queued message that never reaches the window
    function because it causes GetMessage to return a zero value that
    causes the program to exit the message loop.

Message processing
    Programmers can choose to process some messages and ignore others in
    the window function. Messages that are ignored are generally passed on
    to the function DefWindowProc for default processing within Windows.

    Because Windows eventually has access to messages that a window
    function does not process, it can send a program messages that might
    otherwise be regarded as pertaining to system functions--for example,
    mouse messages that occur in a nonclient area of the window, or system
    keyboard messages that affect the menu. Unless these messages are
    passed on to DefWindowProc, the menu and other system functions do not
    work properly.

    A program can, however, trap some of these messages to override
    Windows' default processing. For example, when Windows needs to
    repaint the nonclient area of a window (the title bar, system-menu
    box, and scroll bars), it sends the window function a WM_NCPAINT
    (nonclient paint) message. The window function normally passes
    this message to DefWindowProc, which then calls routines to update the
    nonclient areas of the window. The program can, however, choose to
    process the WM_NCPAINT message and paint the nonclient area itself. A
    program that does this can, for example, draw its own scroll bars.

    The Windows messaging system also notifies a program of important
    events occurring outside its window. For example, if the MS-DOS
    Executive were simply to end the Windows session when the user selects
    the Close option from its system menu, then applications that were
    still running would not have a chance to save changed files to disk.
    Instead, when the user selects Close from the last instance of the
    MS-DOS Executive's system menu, the MS-DOS Executive sends a
    WM_QUERYENDSESSION message to each currently running application
    If any application responds by returning a zero value, the MS-DOS
    Executive does not end the Windows session.

    Before responding, an application can process the WM_QUERYENDSESSION
    message and display a message box asking the user if a file should be
    saved. The message box should include three buttons labeled Yes, No,
    and Cancel. If the user answers Yes, the program can save the file and
    then return a nonzero value to the WM_QUERYENDSESSION message. If the
    user answers No, the program can return a nonzero value without saving
    the file. But if the user answers Cancel, the program should return a
    zero value so that the Windows session will not be ended. If a program
    does not process the WM_QUERYENDSESSION message, DefWindowProc returns
    a nonzero value.

    When a user selects Close from the system menu of a particular
    instance of an application, rather than from the MS-DOS Executive's
    menu, Windows sends the window function a WM_CLOSE message. If the
    program has an unsaved file loaded, it can query the user with a
    message box--possibly the same one displayed when WM_QUERYENDSESSION
    is processed. If the user responds Yes to the query, the program can
    save the file and then call DestroyWindow. If the user responds No,
    the program can call DestroyWindow without saving the file. If the
    user responds Cancel, the window function does not call DestroyWindow
    and the program will not be terminated. If a program does not process
    WM_CLOSE messages, DefWindowProc calls DestroyWindow.

    Finally, a window function can send messages to other window
    functions, either within the same program or in other programs, with
    the Windows SendMessage function. This function returns control to the
    calling program after the message has been processed. A program can
    also place messages in a program's message queue with the PostMessage
    function. This function returns control immediately after posting the
    message.

    For example, when a program makes changes to the WIN.INI file (a file
    containing Windows initialization information), it can notify all
    currently running instances of these changes by sending them a
    WM_WININICHANGE message:

    SendMessage (-1, WM_WININICHANGE, 0, 0L) ;

    The -1 parameter indicates that the message is to be sent to all
    window functions of all currently running instances. Windows calls the
    window functions with the WM_WININICHANGE message and then returns
    control to the program that sent the message.

SAMPLE's message processing
    The SAMPLE program shown in Figure 17-11 processes only four messages:
    WM_COMMAND, WM_SIZE, WM_PAINT, and WM_DESTROY. All other messages are
    passed to DefWindowProc. As is typical with most Windows programs
    written in C, SAMPLE uses a switch and case construction for
    processing messages.

    The WM_COMMAND message signals the program that the user has selected
    a new font from the menu. SAMPLE first obtains a handle to the menu
    and removes the checkmark from the previously selected font:

    hMenu = GetMenu (hWnd) ;
    CheckMenuItem (hMenu, nCurrentFont, MF_UNCHECKED) ;

    The value of wParam in the WM_COMMAND message is the menu ID of the
    newly selected font. SAMPLE saves that value in a static variable
    (nCurrentFont) and then places a checkmark on the new menu choice:

    nCurrentFont = wParam ;
    CheckMenuItem (hMenu, nCurrentFont, MF_CHECKED) ;

    Because the typeface has changed, SAMPLE must repaint its display. The
    program does not repaint it immediately, however. Instead, it calls
    the InvalidateRect function:

    InvalidateRect (hWnd, NULL, TRUE) ;

    This causes a WM_PAINT message to be placed in the program's message
    queue. The NULL parameter indicates that the entire client area should
    be repainted. The TRUE parameter indicates that the background should
    be erased.

    The WM_SIZE message indicates that the size of SAMPLE's client area
    has changed. SAMPLE simply saves the new dimensions of the client area
    in two static variables:

    xClient = LOWORD (lParam) ;
    yClient = HIWORD (lParam) ;

    The LOWORD and HIWORD macros are defined in WINDOWS.H.

    Windows also places a WM_PAINT message in SAMPLE's message queue when
    the size of the client area has changed. As is the case with
    WM_COMMAND, the program does not have to repaint the client area
    immediately, because the WM_PAINT message is in the message queue.

    SAMPLE can receive a WM_PAINT message for many reasons. The first
    WM_PAINT message it receives results from calling UpdateWindow in the
    WinMain function. Later, if the current font is changed from the menu,
    the program itself causes a WM_PAINT message to be placed in the
    message queue by calling InvalidateRect. Windows also sends a window
    function a WM_PAINT message whenever the user changes the size of the
    window or when part of the window previously covered by another window
    is uncovered.

    Programs begin processing WM_PAINT messages by calling BeginPaint:

    BeginPaint (hWnd, &amp;ps) ;

    The SAMPLE program then creates a font based on the current size of
    the client area and the current typeface selected from the menu:

    hFont = CreateFont (yClient, xClient / 8,
                        0, 0, 400, 0, 0, 0, OEM_CHARSET,
                        OUT_STROKE_PRECIS, OUT_STROKE_PRECIS,
                        DRAFT_QUALITY, (BYTE) VARIABLE_PITCH  |
                        cFamily [nCurrentFont - IDM_SCRIPT],
                        szFace  [nCurrentFont - IDM_SCRIPT]) ;

    The font is selected into the device context (a data structure
    internal to Windows that describes the characteristics of the output
    device); the program also saves the original device-context font:

    hFont = SelectObject (ps.hdc, hFont) ;

    And the word Windows is displayed:

    TextOut (ps.hdc, 0, 0, "Windows", 7) ;

    The original font in the device context is then selected, and the font
    that was created is now deleted:

    DeleteObject (SelectObject (ps.hdc, hFont)) ;

    Finally, SAMPLE calls EndPaint to signal Windows that the client area
    is now updated and valid:

    EndPaint (hWnd, &amp;ps) ;

    Although the processing of the WM_PAINT message in this program is
    simple, the method used is common to all Windows programs. The
    BeginPaint and EndPaint functions always occur in pairs, first to get
    information about the area that needs repainting and then to mark that
    area as valid.

    SAMPLE will display this text even when the program is minimized to be
    displayed as an icon at the bottom of the screen. Although most
    Windows programs use a customized icon for this purpose, the window-
    class structure in SAMPLE indicates that the program's icon is NULL,
    meaning that the program is responsible for drawing its own icon.
    SAMPLE does not, however, make any special provisions for drawing the
    icon. To it, the icon is simply a small client area. As a result,
    SAMPLE displays the word Windows in its "icon," using a small font
    size.

    Windows sends the window function the WM_DESTROY message as a result
    of the DestroyWindow function that DefWindowProc calls when processing
    a WM_CLOSE message. The standard processing involves placing a WM_QUIT
    message in the message queue:

    PostQuitMessage (0) ;

    When the GetMessage function retrieves WM_QUIT from the message queue,
    GetMessage returns 0. This terminates the message loop and the
    program.

    For all other messages, SAMPLE calls DefWindowProc and exits the
    window function by returning the value from the call:

    return DefWindowProc (hWnd, iMessage, wParam, lParam) ;

    This allows Windows to perform default processing on the messages
    SAMPLE ignores.

Windows' multitasking

    Most operating systems or operating environments that allow
    multitasking use what is called a preemptive scheduler. Generally, the
    procedure involves use of the computer's clock to switch rapidly
    between programs and allow each a small time slice. When switching
    between programs, the operating system must preserve the machine
    state.

    Windows is different. It is a nonpreemptive multitasking environment.
    Although Windows allows several programs to run simultaneously, it
    never switches from one program to allow another to run. It switches
    between programs only when the currently running program calls the
    GetMessage function or the related PeekMessage and WaitMessage
    functions.

    When a Windows program calls GetMessage and the program's message
    queue contains a message other than WM_PAINT or WM_TIMER, Windows
    returns control to the program with the next message. However, if the
    program's message queue contains only a WM_PAINT or WM_TIMER message
    and another program's queue contains a message other than WM_PAINT or
    WM_TIMER, Windows returns control to the other program, which is also
    waiting for its GetMessage call to return.

    (Windows also switches between programs temporarily when a program
    uses SendMessage to send a message to a window function in another
    program, but control returns to the calling program after the window
    function has processed the message sent to it.)

    To cooperate with Windows' nonpreemptive multitasking, programmers
    should try to perform message processing as quickly as possible.
    Programs can, for example, split a large amount of processing into
    several smaller pieces to allow other programs to run in the interval.
    During long processing a program can also periodically call
    PeekMessage to allow other programs to run.


Graphics Device Interface

    Programs receive input through the Windows message system. For program
    output, Windows provides a device-independent interface to graphics
    output devices, such as the video display, printers, and plotters.
    This interface is called the Graphics Device Interface, or GDI.

The device context (DC)

    When a Windows program needs to send output to the video screen, the
    printer, or another graphics output device, it must first obtain a
    handle to the device's device context, or DC. Windows provides a
    number of functions for obtaining this device-context handle:

    BeginPaint. Used for obtaining a video device-context handle during
    processing of a WM_PAINT message. This device context applies only to
    the rectangular section of the client area that is invalid (needs
    repainting). This region is also a clipping region, meaning that a
    program cannot paint outside this rectangle. BeginPaint fills in the
    fields of a PAINTSTRUCT structure. This structure contains the
    coordinates of the invalid rectangle and a byte that indicates if the
    background of the invalid rectangle has been erased.

    GetDC. Generally used for obtaining a video device-context handle
    during processing of messages other than WM_PAINT. The handle obtained
    with this function references only the client area of the window.

    GetWindowDC. Used for obtaining a video device-context handle that
    encompasses the entire window, including the title bar, menu bar, and
    scroll bars. A Windows program can use this function if it is
    necessary to paint over areas of the window outside the client area.

    CreateDC. Used for obtaining a device-context handle for the entire
    display or for a printer, a plotter, or other graphics output device.

    CreateIC. Used for obtaining an information-context handle, which is
    similar to a device-context handle but can be used only for obtaining
    information about the output device, not for drawing.

    CreateCompatibleDC. Used for obtaining a device-context handle to a
    memory device context compatible with a particular graphics output
    device. This function is generally used for transferring bitmaps to a
    graphics output device.

    CreateMetaFile. Used for obtaining a metafile device-context handle. A
    metafile is a collection of GDI calls encoded in binary form.

    The Windows program uses the device-context handle when calling GDI
    functions. In addition to drawing, the various GDI functions can
    change the attributes of the device context, select different drawing
    objects (such as pens and fonts) into the device context, and
    determine the characteristics of the device context.

Device-independent programming

    Windows supports such a wide variety of video displays, printers, and
    plotters that programs cannot make assumptions about the size and
    resolution of the device. Furthermore, because the user can generally
    alter the size of a program's window, the program must be able to
    adjust its output appropriately. The SAMPLE program, for example,
    showed how the window function can use the WM_SIZE message to obtain
    the current size of a window to create a font that fits text within
    the window's client area.

    Programs can also use other Windows functions to determine the
    physical characteristics of a device. For instance, a program can use
    the GetDeviceCaps function to obtain information about the device
    context, including the resolution of the device, its physical
    dimensions, and its relative pixel height and width.

    Then, too, the GetTextMetrics function returns information about the
    current font selected in the device context. In the default device
    context, this is the system font. Many Windows programs base the size
    of their display output on the size of a system-font character.

Device-context attributes

    The device context includes attributes that define how the graphics
    output functions work on the device. When a program first obtains a
    handle to a device context, Windows sets these attributes to default
    values, but the program can change them. Some of these device-context
    attributes are as follows:

    Pen. Windows uses the current pen for drawing lines. The default pen
    produces a solid black line 1 pixel wide. A program can change the pen
    color, change to a dotted or dashed line, or make the pen draw a solid
    line wider than 1 pixel.

    Brush. Windows uses the current brush (sometimes called a pattern) for
    filling areas. A brush is an 8-pixel-by-8-pixel bitmap. The default
    brush is solid white. Programs can create colored brushes, hatched
    brushes, and customized brushes based on bitmaps.

    Background color. Windows uses the background color to fill the spaces
    in and between characters when drawing text and to color the open
    areas in hatched brushstrokes and dotted or dashed pen lines. Windows
    uses the background color only if the background mode (another
    attribute of the display context) is opaque. If the background mode is
    transparent, Windows leaves the background unaltered. The default
    background color is white.

    Text color. Windows uses this color for drawing text. The default is
    black.

    Font. Windows uses the font to determine the shape of text characters.
    The default is called the system font, a fixed-pitch font that also
    appears in menus, caption bars, and dialog boxes.

    Additional device-context attributes (such as mapping modes) are
    described in the following sections.

Mapping modes

    Most GDI drawing functions in Windows have parameters that specify the
    coordinates or size of an object. For instance, the Rectangle function
    has five parameters:

    Rectangle (hDC, x1, y1, x2, y2) ;

    The first parameter is the handle to the device context. The others
    are

    ■  x1: horizontal coordinate of the upper left corner of the
        rectangle.

    ■  y1: vertical coordinate of the upper left corner of the rectangle.

    ■  x2: horizontal coordinate of the lower right corner of the
        rectangle.

    ■  y2: vertical coordinate of the lower right corner of the rectangle.

    In the Rectangle and most other GDI functions, coordinates are logical
    coordinates, which are not necessarily the same as the physical
    coordinates (pixels) of the device. To translate logical coordinates
    into physical coordinates, Windows uses the current mapping mode.

    In actuality, the mapping mode defines a transformation of coordinates
    between a window, which is defined in terms of logical coordinates,
    and a viewport, which is defined in terms of physical coordinates. For
    any mapping mode, a program can define separate window and viewport
    origins. The logical point defined as the window origin is then mapped
    to the physical point defined as the viewport origin. For some mapping
    modes, a program can also define window and viewport extents, which
    determine how the logical coordinates are scaled to the physical
    coordinates.

    Windows programs can select one of eight mapping modes. The first six
    are sometimes called fully constrained, because the ratio between the
    window and viewport extents is fixed and cannot be changed.

    In MM_TEXT, the default mapping mode, coordinates on the x axis
    increase from left to right, and coordinates on the y axis increase
    from the top downward. In the other five fully constrained mapping
    modes, coordinates on the x axis also increase from left to right, but
    coordinates on the y axis increase from the bottom upward. The six
    fully constrained mapping modes are

    ■  MM_TEXT: Logical coordinates are the same as physical coordinates.

    ■  MM_LOMETRIC: Logical coordinates are in units of 0.1 millimeter.

    ■  MM_HIMETRIC: Logical coordinates are in units of 0.01 millimeter.

    ■  MM_LOENGLISH: Logical coordinates are in units of 0.01 inch.

    ■  MM_HIENGLISH: Logical coordinates are in units of 0.001 inch.

    ■  MM_TWIPS: Logical coordinates are in units of 1/1440 inch. (These
        units are 1/20 of a typographic point, which is approximately
        1/72 inch.)

    The seventh mapping mode is called partially constrained, because a
    program can change the window and viewport extents but Windows adjusts
    the values to ensure that equal horizontal and vertical logical
    coordinates translate to equal horizontal and vertical physical
    dimensions:

    ■  MM_ISOTROPIC: Logical coordinates represent the same physical
        distance on both the x and y axes.

    The MM_ISOTROPIC mapping mode is useful for drawing circles and
    squares. The MM_LOMETRIC, MM_HIMETRIC, MM_LOENGLISH, MM_HIENGLISH, and
    MM_TWIPS mapping modes are also isotropic, because equal logical
    coordinates map to the same physical dimensions on both axes.

    The final mapping mode is sometimes called unconstrained because a
    program is free to set different window and viewport extents on the x
    and y axes.

    ■  MM_ANISOTROPIC: Logical coordinates are mapped to arbitrarily
        scaled physical coordinates.

Functions for drawing

    Windows includes several functions that programs can use to draw in
    the client area of a window. The most common of these functions are

    SetPixel. Sets a point to a particular color.

    LineTo. Draws a line from the current position to a point specified in
    the LineTo function. The current position is defined in the device
    context and can be altered before the call to LineTo with the MoveTo
    function, which changes the current position but does not draw
    anything. Windows uses the current pen and the current drawing mode
    (see below) for drawing the line.

    Polyline. Draws multiple lines much like a series of LineTo calls but
    does not alter the current position on completion.

    Rectangle. Draws a filled rectangle with a border. Parameters to the
    Rectangle function specify the coordinates of the upper left and lower
    right corners of the rectangle. Windows draws the border of the
    rectangle with the current pen and current drawing mode defined in the
    device context, just as if it were using the Polyline function then
    Windows fills the rectangle with the current brush defined in the
    device context.

    Ellipse. Uses the same parameters as Rectangle but draws an ellipse
    within the rectangular area.

    RoundRect. Draws a rectangle with rounded corners. Two parameters to
    this function define the height and width of an ellipse that Windows
    uses for drawing the rounded corners.

    Polygon. Draws a polygon connecting a series of points and fills the
    enclosed areas in either an alternate or winding mode. The winding
    mode causes Windows to fill every area within the polygon. The
    alternate mode fills every other area. For a polygon that defines a
    five-pointed star, for instance, the center is filled if the mode is
    winding but is not filled if the mode is alternate.

    Arc. Draws a curved line that is part of the circumference of an
    ellipse.

    Chord. Similar to the Arc function, but Windows connects the beginning
    and ending points of the arc with a straight line. The area is filled
    with the current brush defined in the device context.

    Pie. Similar to the Arc function, but Windows draws lines from the
    beginning and ending points of the arc to the center of the ellipse.
    The area is filled with the current brush defined in the device
    context.

    TextOut. Writes text with the current font, text color, background
    color, and background mode (transparent or opaque).

    Windows also includes other drawing functions for filling areas,
    formatting text, and transferring bitmaps.

Raster operations for pens

    When Windows uses a pen to write to a device context, it must first
    determine which pixels of the destination are to be altered by the pen
    (the foreground) and which pixels will not be affected (the
    background). With dotted and dashed pens, the background--the space
    between the dots or dashes--is left unaltered if the drawing mode is
    transparent and is filled with the background color if the drawing
    mode is opaque.

    When Windows alters the pixels of the destination that correspond to
    the foreground of the pen, the most obvious result is that the color
    of the current pen defined in the display context is used to color the
    destination. But this is not the only possible result. Windows also
    generalizes the process by using a logical operation to combine the
    pixels of the pen and the pixels of the destination.

    This logical operation is defined by the drawing mode attribute of the
    device context. This drawing mode can be set to one of 16 binary
    raster operations (abbreviated ROP2).

    The following table shows the 16 binary raster operation codes defined
    in WINDOWS.H. The column headed "Resultant Destination" shows how the
    destination changes, depending on the bit pattern of the pen and the
    bit pattern of the destination before the line is drawn. The words OR,
    AND, XOR, and NOT are the logical operations.

╓┌────────────────────────────────┌──────────────────────────────────────────╖
    Binary Raster               Resultant
    Operation                   Destination
    ──────────────────────────────────────────────────────────────────
    R2_BLACK                    0
    R2_COPYPEN                  pen
    R2_MERGEPEN                 pen OR destination
    R2_MASKPEN                  pen AND destination
    R2_XORPEN                   pen XOR destination
    R2_NOTCOPYPEN               NOT pen
    R2_NOTMERGEPEN              NOT (pen OR destination)
    R2_NOTMASKPEN               NOT (pen AND destination)
    R2_NOTXORPEN                NOT (pen XOR destination)
    R2_MERGEPENNOT              pen OR (NOT destination)
    R2_MASKPENNOT               pen AND (NOT destination)
    R2_MERGENOTPEN              (NOT pen) OR destination
    R2_MASKNOTPEN               (NOT pen) AND destination
    R2_NOP                      destination
    R2_NOT                      NOT destination
    R2_WHITE                    1

    The default drawing mode defined in a device context is R2_COPYPEN,
    which simply copies the pen to the destination. However, if the pen
    color is blue, the destination is red, and the drawing mode is
    R2_MERGEPEN, then the drawn line appears as magenta, which results
    from combining the pen and destination colors. If the pen color is
    blue, the destination is red, and the drawing mode is R2_NOTMERGEPEN,
    then the drawn line is green, because the blue pen and the red
    destination are combined into magenta, which Windows then inverts to
    make green.

Bit-block transfers

    Windows also uses logical operations when transferring a rectangular
    pixel pattern (a bit block) from one device context to another or from
    one area of a device context to another area of the same device
    context.

    While line drawing involves a logical combination of two sets of
    pixels (the pen and the destination), the bit-block transfer functions
    perform a logical combination of three sets of pixels: a source
    bitmap, a destination bitmap, and the brush currently selected in the
    destination device context. As shown in the preceding section, there
    are 16 different ROP2 drawing modes for all the possible combinations
    of two sets of pixels. The tertiary raster operations (abbreviated
    ROP3) for bit-block transfers require 256 different operations for all
    possible combinations.

    Windows defines three functions for transferring rectangular pixel
    patterns: BitBlt (bit-block transfer), StretchBlt (stretch-block
    transfer), and PatBlt (pattern-block transfer). Of these three
    functions, StretchBlt is the most generalized. StretchBlt transfers a
    bitmap from a source device context to a destination device context.
    Function parameters specify the origin, width, and height of the
    bitmap. If the source and destination widths and heights are
    different, Windows stretches or compresses the bitmap appropriately.
    Negative values of widths and heights cause Windows to draw a mirror
    image of the bitmap.

    The BitBlt function transfers a bitmap from a source device context to
    a destination device context, but the width and height of the source
    and destination must be the same. If the source and destination device
    contexts have different mapping modes, Windows uses StretchBlt
    instead.

    In both BitBlt and StretchBlt, Windows performs a bit-by-bit logical
    operation with the bit block in the source device context, the bit
    block in the destination area of the destination device context, and
    the brush currently selected in the destination device context.
    Although Windows supports all 256 possible raster operations with
    these three bitmaps, only a few have been given WINDOWS.H identifiers:

╓┌────────────────────────────┌──────────────────────────────────────────────╖
    Raster                  Resultant
    Operation               Destination
    ──────────────────────────────────────────────────────────────────
    BLACKNESS               0
    SRCCOPY                 source
    SRCAND                  source AND destination
    SRCPAINT                source OR destination
    SRCINVERT               source XOR destination
    SRCERASE                source AND (NOT destination)
    MERGEPAINT              source OR (NOT destination)
    NOTSRCCOPY              NOT source
    NOTSRCERASE             NOT (source OR destination)
    DSTINVERT               NOT destination
    PATCOPY                 pattern
    MERGECOPY               source AND pattern
    PATINVERT               destination XOR pattern
    PATPAINT                source OR (NOT destination) OR pattern
    WHITENESS               1

    The PatBlt function is similar to BitBlt and StretchBlt but performs a
    logical operation only between the currently selected brush and a
    destination area of the device context. Thus, only 16 raster
    operations can be used with PatBlt; these are equivalent to the binary
    raster operations used with line drawing.

Text and fonts

    Windows supports file-based text fonts in two different formats:
    raster and vector. The raster fonts, such as Courier, Helvetica, and
    Times Roman, are defined by digital representations of the bit
    patterns of the characters. Font files usually contain several
    different sizes for each typeface. The vector fonts, such as Modern,
    Script, and Roman, are defined by points that are connected to form
    the letters and can be scaled to different sizes.

    When using a device such as a printer, which has built-in fonts,
    Windows can also use these device-based fonts.

    To specify a font, a Windows program uses the CreateFont function to
    create a logical font--a detailed description of the desired font.
    When this logical font is selected into a device context, Windows
    finds the actual font that best fits this description. In many cases,
    this match is not exact. The program can then call GetTextMetrics to
    determine the characteristics of the actual font that the device will
    use to display text.

    Windows supports both fixed-width and variable-width fonts, as well as
    such attributes as italics, underlining, and boldfacing. Programs can
    also justify text with the GetTextExtent call, which obtains the width
    of a particular text string. The program can then insert extra spaces
    between words with SetTextJustification or it can insert extra spaces
    between letters with SetTextCharacterExtra.

Metafiles

    As explained earlier, a metafile is a collection of GDI function calls
    stored in a binary coded form. A program can create a metafile by
    calling CreateMetaFile and giving it either an MS-DOS filename or NULL
    as a parameter. If CreateMetaFile is given an MS-DOS filename, Windows
    creates a disk-based metafile; if the parameter is NULL, Windows
    creates a metafile in memory. The CreateMetaFile call returns a handle
    to a metafile device context. Any GDI calls that reference this
    device-context handle become part of the metafile.

    When the program calls CloseMetaFile, Windows closes the metafile
    device context and returns a handle to the metafile. The program can
    then "play" this metafile on another device context (such as the video
    display) without calling the GDI functions directly.

    Metafiles provide a useful way to transfer device-independent pictures
    between programs.


Data Sharing and Data Exchange

    Windows includes a variety of methods by which programs can share and
    exchange data. These methods are discussed in the following sections.

Sharing local data among instances

    Multiple instances of the same program can share data in the static
    data area of the program's data segment. Later instances of a program
    can thus call GetInstanceData and copy configuration options
    established by the user in the first instance. Multiple instances of
    programs can also share resources, such as dialog-box templates.

The Windows Clipboard

    The Windows Clipboard is a general-purpose mechanism that allows a
    user to transfer data from one program to another. Programs that
    support the Clipboard generally include a top-level menu item called
    Edit, which invokes a pop-up menu that offers at least these three
    options:

    ■  Cut: Copies the current selection to the Clipboard and deletes the
        selection from the current program file.

    ■  Copy: Copies the current selection to the Clipboard without
        deleting the selection from the current program file.

    ■  Paste: Copies the contents of the Clipboard to the current program
        file.

    The Clipboard can hold only one item at a time. A program can transfer
    data to the Clipboard through the function call SetClipboardData. With
    this function, the program passes the Clipboard a handle to a global
    memory block, which then becomes the property of the Clipboard. A
    program can access Clipboard data through the complementary function
    GetClipboardData.

    The Clipboard supports several formats:

    ■  Text: ASCII text; each line ends with a carriage return and
        linefeed, and the text is terminated with a NULL character.

    ■  Bitmap: A collection of bits in the GDI bitmap format.

    ■  Metafile Picture: A structure that contains a handle to a metafile
        along with other information suggesting the mapping mode and aspect
        ratio of the picture.

    ■  SYLK: Microsoft's Symbolic Link format.

    ■  DIF: Software Arts' Data Interchange Format.

    Programs can also use the Clipboard for storing data in private
    formats.

    Some programs, such as the CLIPBRD program included with Windows, can
    also become Clipboard viewers. Such programs receive a message
    whenever the contents of the Clipboard change.

Dynamic Data Exchange (DDE)

    Dynamic Data Exchange (DDE) is a protocol that cooperating programs
    can use to exchange data without user intervention. DDE makes use of
    the facilities in Windows that enable programs to send messages among
    themselves.

    In DDE, the program that needs data from another program is called the
    client. The client sends a WM_DDE_INITIATE message either to a
    dedicated server program or to all currently running programs.
    Parameters to the WM_DDE_INITIATE message are atoms, which are numbers
    referring to text strings. A server application that has the data the
    client needs sends a WM_DDE_ACK message back to the client. The client
    can then be more specific about the data it needs by sending the
    server a WM_DDE_ADVISE message. The server can then pass global memory
    handles to the client with the WM_DDE_DATA message.


Internationalization

    Windows includes several features that ease the conversion and
    translation of programs for international markets. Among these
    features are keyboard drivers appropriate for many European languages
    and use of the ANSI character set, which provides a richer set of
    accented letters than does the character set resident in the IBM PC
    and compatibles.

    Windows also includes several functions that assist in language-
    independent coding. The AnsiUpper and AnsiLower functions translate
    characters or strings to uppercase or lowercase in the full ANSI
    character set, rather than the more limited ASCII character set. In
    addition, the AnsiNext and AnsiPrev functions allow scanning of text
    strings that may contain 2 or more bytes per character.

    Windows programmers can also help in program translation by defining
    all text strings used within the program as resources contained in the
    resource script file. Because the resource script file also contains
    menu templates and dialog-box templates, it thus becomes the only file
    that needs alteration when a foreign-language version of the program
    is created.

                                                Charles Petzold



───────────────────────────────────────────────────────────────────────────

Part E  Programming Tools



Article 18: Debugging in the MS-DOS Environment


    It is axiomatic that any program will need debugging at some time in
    its development cycle, and programs written to run under MS-DOS are no
    exception. This article provides an introduction to the debugging
    tools and techniques available to the serious programmer developing
    code in the MS-DOS environment. Space does not permit a thorough
    investigation of the philosophy, psychology, and science of debugging
    computer programs; instead, a brief and practical discussion of the
    basic debugging approaches is presented, along with some rules-of-
    thumb for choosing the best approach. Nor are the details of every
    single utility and command included in this article; these are
    described in detail in the reference sections of this volume. The
    commands and utility programs that are most useful for debugging are
    discussed and illustrated with examples and case histories that also
    serve as models for the various debugging methods.

    The reader of this article is assumed to be a programmer with
    sufficient experience to understand an assembly-language program. The
    reader is also assumed to be familiar with MS-DOS--terms like FCB and
    PSP are not explained. A reader without this background in MS-DOS need
    not be deterred, however; these terms are thoroughly explained
    elsewhere in this book. Besides assembly language, examples in this
    article are written in Microsoft QuickBASIC and Microsoft C. A
    detailed knowledge of these languages is not required; the examples
    are short and straightforward.

    The reader should also keep in mind that the examples given here are
    real but not necessarily realistic. To avoid the tedium that
    accompanies debugging, the examples have been designed to reveal their
    bugs fairly quickly. All the methods and techniques shown are accurate
    in detail but not always in scale. Most of the debugging examples
    presented here would require one-half to one hour of work. It is
    possible for real debugging sessions to last for hours or days,
    especially if the wrong approach or tool is chosen. One of the
    purposes of this article is to help the programmer choose the correct
    tool and, thus, to reduce the tedium.


The Programs

    There are more than a dozen listings in this article. Some of them are
    correct and others contain errors for use in illustrating debugging
    techniques. Many of the programs serve as examples in multiple
    sections of the article. The following summary of the programs (Table
    18-1) is given to avoid confusion and to provide a common location to
    consult for explanations of the programs.


    Table 18-1. Summary of Example Programs.


    Name:          EXP.BAS
    Figure:        18-1
    Status:        Incorrect--do not use.

    Purpose:       Computes EXP(x) (the exponential of x) to a specified
                    precision using an infinite series.
    Compiling:     QB EXP;
                    LINK EXP;
    Parameters:    Prompts for value for x and a convergence criterion.
                    Enter zero to quit.
    ──────────────────────────────────────────────────────────────────
    Name:          EXP.BAS
    Figure:        18-3
    Status:        Correct version of Figure 18-1.

    Purpose:       Computes EXP(x) (the exponential of x) to a specified
                    precision using an infinite series.
    Compiling:     QB EXP;
                    LINK EXP;
    Parameters:    Prompts for value for x and a convergence criterion.
                    Enter zero to quit.
    ──────────────────────────────────────────────────────────────────
    Name:          COMMSCOP.ASM
    Figure:        18-4
    Status:        Correct.

    Purpose:       Monitors the activity on a specified COM port and
                    places a copy of all transmitted and received data in
                    a RAM buffer. Each entry in the buffer is tagged to
                    indicate whether the byte was sent by or received by
                    the application program under test. Control is
                    provided to start, stop, and resume tracing by means
                    of a control interrupt. When tracing is stopped and
                    resumed, a marker is left in the buffer. COMMSCOP is a
                    terminate-and-stay-resident (TSR) program.

    Compiling:     MASM COMMSCOP;
                    LINK COMMSCOP;
                    EXE2BIN COMMSCOP.EXE COMMSCOP.COM
                    DEL COMMSCOP.EXE

    Parameters:    Installed by entering COMMSCOP; no parameters for
                    installation. The TSR is controlled by passing
                    parameter data in registers with an Interrupt 60H
                    call. The registers can have the following values:

                    AH:         Command:
                    00H         STOP
                    01H         FLUSH AND START
                    02H         RESUME TRACE
                    03H         RETURN TRACE BUFFER ADDRESS
                    DX:         COM port:
                    00H         COM1
                    01H         COM2

                    Interrupt 60H returns the following in response to
                    function 3:

                    CX          Buffer count in bytes
                    DX          Segment address of buffer
                    BX          Offset address of buffer
    ──────────────────────────────────────────────────────────────────
    Name:          COMMSCMD.C
    Figure:        18-5
    Status:        Correct.

    Purpose:       Controls the COMMSCOP program by issuing Interrupt 60H
                    calls.C version.

    Compiling:     MSC COMMSCMD;
                    LINK COMMSCMD;

    Parameters:    Commands are issued byCOMMSCMD [[cmd][ port]]
                    where:  cmd   is the command to be executed:
                                STOP     Stop trace
                                START    Flush buffer and start trace
                                RESUME   Resume a stopped trace
                            port  is the COM port (1 = COM1, 2 = COM2)
                    If cmd is omitted, STOP is assumed; if port is omitted,
                    1 is assumed.
    ──────────────────────────────────────────────────────────────────
    Name:          COMMSCMD.BAS
    Figure:        18-6
    Status:        Correct.

    Purpose:       Controls the COMMSCOP program by issuing Interrupt 60H
                    calls. QuickBASIC version.

    Compiling:     QB COMMSCMD;
                    LINK COMMSCMD USERLIB;

    Parameters:    Commands are issued by COMMSCMD [[cmd][,port]]
                    where:  cmd   is the command to be executed:
                                STOP     Stop trace
                                START    Flush buffer and start trace
                                RESUME   Resume a stopped trace
                            port  is the COM port (1 = COM1, 2 = COM2)
                    If cmd is omitted, STOP is assumed; if port is omitted,
                    1 is assumed.
    ──────────────────────────────────────────────────────────────────
    Name:          COMMDUMP.BAS
    Figure:        18-7
    Status:        Correct.

    Purpose:       Produces a formatted dump of the communications trace
                    buffer.

    Compiling:     QB COMMDUMP;
                    LINK COMMDUMP USERLIB;

    Parameters:    No parameters. When COMMDUMP is invoked, it formats and
                    dumps the entire buffer.
    ──────────────────────────────────────────────────────────────────
    Name:          TESTCOMM.ASM
    Figure:        18-9
    Status:        Incorrect--do not use.

    Purpose:       Provides test data for the COMMSCOP routine.

    Compiling:     MASM TESTCOMM;
                    LINK TESTCOMM;

    Parameters:    No parameters. TESTCOMM reads data from the keyboard
                    and writes to COM1 and reads COM1 data and displays it
                    on the screen. Ctrl-C cancels.
    ──────────────────────────────────────────────────────────────────
    Name:          TESTCOMM.ASM
    Figure:        18-10
    Status:        Correct version of Figure 18-9.

    Purpose:       Provides test data for the COMMSCOP routine.

    Compiling:     MASM TESTCOMM;
                    LINK TESTCOMM;

    Parameters:    No parameters. TESTCOMM reads data from the keyboard
                    and writes to COM1 and reads COM1 data and displays it
                    on the screen. Ctrl-C cancels.
    ──────────────────────────────────────────────────────────────────
    Name:          BADSCOP.ASM
    Figure:        18-11
    Status:        Incorrect version of Figure 18-4--do not use.

    Purpose:       Monitors the activity on a specified COM port and
                    places a copy of all transmitted and received data in
                    a RAM buffer. Each entry in the buffer is tagged to
                    indicate whether the byte was sent by or received by
                    the application program under test. Control is
                    provided to start, stop, and resume tracing by means
                    of a control interrupt. When tracing is stopped and
                    resumed, a marker is left in the buffer. BADSCOP is a
                    terminate-and-stay-resident (TSR) program.

    Compiling:     MASM BADSCOP;
                    LINK BADSCOP;
                    EXE2BIN BADSCOP.EXE BADSCOP.COM
                    DEL BADSCOP.EXE

    Parameters:    Installed by entering BADSCOP; no parameters for
                    installation. The TSR is controlled by passing
                    parameter data in registers with an Interrupt 60H
                    call. The registers can have the following values:

                    AH:         Command:
                    00H         STOP
                    01H         FLUSH AND START
                    02H         RESUME TRACE
                    03H         RETURN TRACE BUFFER ADDRESS
                    DX:         COM port:
                    00H         COM1
                    01H         COM2
                    Interrupt 60H returns the following in response to
                    function 3:
                    CX          Buffer count in bytes
                    DX          Segment address of buffer
                    BX          Offset address of buffer
    ──────────────────────────────────────────────────────────────────
    Name:          UPPERCAS.C
    Figure:        18-13
    Status:        Incorrect--do not use.

    Purpose:       Converts a fixed string to uppercase and prints it.

    Compiling:     MSC /Zi UPPERCAS;
                    LINK UPPERCAS /CO;

    Parameters:    No parameters.
    ──────────────────────────────────────────────────────────────────
    Name:          UPPERCAS.C
    Figure:        18-14
    Status:        Correct version of Figure 18-13.

    Purpose:       Converts a fixed string to uppercase and prints it.

    Compiling:     MSC /Zi UPPERCAS;
                    LINK UPPERCAS /CO;

    Parameters:    No parameters.
    ──────────────────────────────────────────────────────────────────
    Name:          ASCTBL.C
    Figure:        18-16
    Status:        Incorrect--do not use.

    Purpose:       Displays a table of all displayable characters.

    Compiling:     MSC /Zi ASCTBL;
                    LINK ASCTBL /CO;

    Parameters:    No parameters.
    ──────────────────────────────────────────────────────────────────
    Name:          ASCTBL.C
    Figure:        18-17
    Status:        Correct version of Figure 18-16.

    Purpose:       Displays a table of all displayable characters.

    Compiling:     MSC /Zi ASCTBL;
                    LINK ASCTBL /CO;

    Parameters:    No parameters.


Debugging Tools and Techniques

    MS-DOS provides a wide variety of tools to aid in the debugging
    process. Some are intended specifically for debugging. For example,
    the DEBUG program is delivered with MS-DOS and provides basic
    debugging aid; the more sophisticated SYMDEB is supplied with MASM,
    Microsoft's macro assembler; CodeView, a debugger for high-order
    languages, is supplied with Microsoft C, Microsoft Pascal, and
    Microsoft FORTRAN. Others are general MS-DOS services and features
    that are also useful in the debugging process.

    Debugging, like programming, has aspects of both an art and a craft.
    The craft--the mechanical details of using the tools--is discussed
    both here and elsewhere in this volume, but the main subject of this
    article is the art of debugging--the choice of the correct tool, the
    best techniques to use in various situations, the methods of
    extracting the clues to the problem from a recalcitrant program.

    Debugging a program is a form of puzzle solving. As with most
    intellectual detective work, the following rule applies:

    Gather enough information and the solution will be obvious.

    The craft of debugging involves gathering the data; the art lies in
    deciding which data to gather and in noticing when the solution has
    become obvious.

    The methods of gathering data for debugging, listed in order of
    increasing difficulty and tediousness, fall into four major
    categories:

    ■  Inspection and observation
    ■  Instrumentation
    ■  Use of software debugging monitors (DEBUG, SYMDEB, and CodeView)
    ■  Use of hardware debugging aids

    As mentioned above, part of the art of debugging is knowing which
    method to use. This is one of the most difficult aspects of debugging-
    so difficult, in fact, that even programmers with years of experience
    make mistakes. Many programmers have spent hours single-stepping
    through a program with DEBUG only to discover that the cause of the
    problem would have been obvious if they had given the program's output
    even a cursory check. The only universal rule for choosing the correct
    debugging method is

    Try them all, starting with the simplest.

Inspection and observation

    Inspection and observation is the oldest and, usually, the best method
    of program debugging. It is also the basis for all the other methods.
    The first step with this method, as with the others, is to gather all
    the pertinent materials. Program listings, file layouts, report
    layouts, and program design materials (such as algorithm descriptions
    and flowcharts) are all extremely valuable in the debugging process.

Desk-checking
    Before a programmer can determine what a program is doing wrong, he or
    she must know the correct operation of the program. There was a time,
    when computers were rare and expensive resources, that programmers
    were encouraged not to run their programs until the programs had been
    thoroughly desk-checked. The desk-checking process involves sitting
    down with a listing, a hand calculator, and some sample data. The
    programmer then "plays computer," executing each line of the program
    manually and writing down on paper the results of each program step.
    This process is extremely slow and tedious. When the desk-checking is
    completed, however, the programmer not only has found most of the bugs
    in the program but also has become intimately familiar with the
    execution of the program and the values of the program variables at
    each step.

    The advent of inexpensive yet powerful personal computers, combined
    with the rising cost of programmer time, has made complete desk-
    checking nearly obsolete. It is now cheaper to run the program and let
    the computer find the errors. However, the usefulness of the desk-
    checking technique remains. Many programmers find it helpful to
    manually execute those sections of a program that they suspect are
    causing trouble. Even if they don't find errors in the code, the
    insight they gain into the workings of the code and the values of the
    variables at each step can be invaluable when applying other debugging
    techniques.

The inspection-and-observation methodology
    The basic technique of the inspection-and-observation method is
    simple: After gathering all the required materials, run the program
    and observe. Observe very carefully; events that seem insignificant
    may be the very clues needed to discover where the program is going
    astray. As the program executes, note whether each section performs
    correctly. Does the program clear the screen when it should? Does it
    ask for input when it should? Does it produce the correct results?
    Observable events are the debugger's milestones in the execution of
    the program. If the program clears the screen but writes purple
    asterisks instead of requesting input, then the problem lies somewhere
    after the program issues the Clear Screen command but before it writes
    the input prompt on the screen. At this point, the program listing and
    design data become important. Inspect the listing and examine the area
    after the last successful milestone and before the missing milestone.
    Look for a logic error in the code that could explain the observed
    data.

    If the program produces printed reports, they may also be useful.
    Watch the screen and listen to the printer. Clues can sometimes be
    found in the order in which things happen. The light on the disk drive
    can be another indication of activity. See how disk activity
    coordinates with screen and printer events. Try to identify each
    section of the program from these clues. Then use this information to
    localize the inspection of the listing to isolate the erroneous code.

    The values of data given in reports and on the screen can also give
    clues to what's going wrong. Examining the data and reconstructing the
    values used to compute it sometimes leads to inferences about data
    problems. Perhaps a variable was misspelled in the code or perhaps a
    data file is in the wrong format or has been corrupted. With this
    information, the bug can often be isolated. However, a very thorough
    knowledge of the program and its algorithms is required. See
    Desk-checking, above.

    MS-DOS provides four commands and filters that are useful in the
    collection and examination of data for debugging: TYPE, PRINT, FIND,
    and DEBUG. All these commands display the data in a file in some way.
    If the data is ASCII (displayable) characters, TYPE and PRINT can be
    used, with some help from FIND. Binary files can be examined and
    modified with the DEBUG utility. See USER COMMANDS: FIND; PRINT;
    TYPE; PROGRAMMING UTILITIES: DEBUG.

    The TYPE command provides the simplest way to display ASCII data
    files. This method can be used to examine both input and output files.
    Checking the input files may uncover some bad (or unexpected) data
    that causes the program to malfunction; examining the output files
    will show whether calculations are being performed correctly and may
    help pinpoint the erroneous calculations if they are not.

    The FIND utility is useful in locating specific data in a file. Using
    FIND is more accurate and definitely less tedious than examining the
    file manually using the TYPE command. The /N switch causes FIND to
    also display the relative line number of the matching line-information
    that is most useful in debugging.

    Sometimes the data is too complex to be examined on the screen and
    printed copy is needed. The PRINT command will produce hard copy of an
    ASCII file as will the TYPE command if its output is redirected to the
    printer with the &gt;PRN command-line parameter after the filename.

    Not all data files contain pure ASCII data, and displaying such non-
    ASCII files requires a different approach. The TYPE command can be
    used, but nonprintable characters will produce garbage on the screen.
    This technique can still prove useful if the file has a large amount
    of ASCII data or if the records are regular and the ASCII information
    always appears at the same location, but no information can be gained
    about non-ASCII numeric data in such files. Note also that the entire
    file might not be displayed using TYPE because if TYPE encounters a
    byte containing 1AH (Control-Z), it assumes it has reached the end of
    the file and stops.

    Clearly, a more useful tool for examining non-ASCII files would be a
    program that dumps the file in hexadecimal, with an appropriate
    translation of all displayable characters. Such programs exist in the
    public domain (through bulletin-board services, for instance) and, in
    any event, are not difficult to write. MS-DOS does not include a
    stand-alone file-dumping program among its standard commands and
    utilities, but the DEBUG program can be used, with minor
    inconvenience, to display files. This program is discussed in detail
    later in this article; for now, simply follow these instructions to
    use DEBUG as a file dumper. To load DEBUG and the program to be
    debugged, use the form

    DEBUG [drive:][path]filename.ext

    DEBUG will display a hyphen as a prompt. To see the contents of the
    file, enter D (the DEBUG Display Memory command) and press Enter.
    DEBUG will display the first 128 (80H) bytes of the file in
    hexadecimal and will also show any displayable characters. To see the
    rest of the file, simply continue entering D until the desired area is
    found. Hard copy of the contents of the display can be made by using
    the PrtSc key (or Ctrl-PrtSc to print continuously). Note that the
    offset addresses for the bytes in the file begin at the value in the
    program's CS:IP registers, which can be viewed by using the Debug R
    (Display or Modify Registers) command. To obtain the true offsets,
    subtract CS:IP from the address shown.

    The essence of the inspection-and-observation method is careful and
    thoughtful observation. The computer and the operating system can
    provide tools to aid in the collection of data, but the most important
    tool is the programmer's mind. By applying the logical skills they
    already possess to the observed data, programmers can usually avoid
    the more complex forms of debugging.

Instrumentation

    Debugging by instrumentation is a traditional method that has been
    popular since programs were holes punched in cards. In general, this
    method consists of adding something to the program, either internally
    or externally, to report on the progress of program execution.
    Programmers call this added mechanism instrumentation because of
    its resemblance to the measuring instruments used in science and
    engineering. Instrumentation can be software, hardware, or a combina-
    tion of both; it can be internal to the program or external to it.
    Internal instrumentation is always software, but external
    instrumentation may be either hardware or software.

Internal instrumentation
    Internal instrumentation usually consists of display or print
    statements placed at strategic locations. Other signals to the user
    can be used if they are available. For instance, the system beeper can
    be sounded at key locations, perhaps in a coded sequence of beeps; if
    the device being debugged has lights that can be accessed by the
    program, these lights can be flashed at important locations in the
    program. Beeping and flashing do not, however, possess the information
    content usually required for debugging, so display or print statements
    are preferred.

    The use of display or print statements to display key data and
    milestones on the screen or printer requires careful planning. First,
    apply the techniques of inspection and observation described in the
    previous section to determine the most probable points of failure.
    Then, if there is some doubt about what path execution is taking
    through the code, embed messages of the following types after key
    decision points:

    BEGINNING SORT PHASE
    ENDING PRINCIPAL OF CALCULATION
    PROCESSING RECORD XX

    A second way to use display or print statement instrumentation is to
    embed statements that display the data and interim values used for
    calculations. This technique can be extremely useful in finding
    problems related to the data being processed. Consider the QuickBASIC
    program in Figure 18-1 as an example. The program has no syntax errors
    and compiles cleanly, but it sometimes produces an incorrect answer.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-1. A routine to compute exponentials.

    ──────────────────────────────────────────────────────────────────────

    The purpose of the EXP.BAS program is to compute the exponential of a
    given number to a specified precision using an infinite series. The
    program computes the value of each term in the infinite series and
    adds it to a running total. To keep from executing forever, the
    program checks the difference between the last two elements computed
    and stops when this difference is less than the convergence criterion
    entered by the user.

    When the program is run for several values, the following results are
    observed:

    Enter number:  ? 1
    Enter convergence criterion (.0001 for 4 places):  ? .0001
    2.718282
    10 elements required to converge

    Enter number:  ? 1.5
    Enter convergence criterion (.0001 for 4 places):  ? .0001
    4.481686
    11 elements required to converge

    Enter number:  ? 2
    Enter convergence criterion (.0001 for 4 places):  ? .0001
    5
    3 elements required to converge

    Enter number:  ? 2.5
    Enter convergence criterion (.0001 for 4 places):  ? .0001
    12.18249
    15 elements required to converge

    Enter number:  ? 3
    Enter convergence criterion (.0001 for 4 places):  ? .0001
    13
    4 elements required to converge

    Enter number:  ? 0

    Some of these numbers are incorrect. Table 18-2 shows the computed
    values and the correct values.


    Table 18-2. The Computed Values Generated By EXP.BAS
                and the Expected Values.

    ──────────────────────────────────────────────────────────────────
    x         Computed       Correct
    ──────────────────────────────────────────────────────────────────
    1.0        2.718282       2.718282
    1.5        4.481686       4.481689
    2.0        5              7.389056
    2.5       12.18249       12.18249
    3.0       13             20.08554


    Applying the methods from the first section of this article and
    observing the data quickly reveals a pattern. With the exception of 1,
    all whole numbers give incorrect results, but all numbers with
    fractions give results that are correct to the specified convergence
    criterion. Examination of the listing shows no obvious reason for
    this. The answer is there, but only an exceptionally intuitive numeric
    analyst would see it. Because no answer is obvious, the next step is
    to validate the only information available--that whole numbers produce
    errors and fractional ones do not. Repeating the first experiment with
    2 and a number very close to 2 yields the following results:

    Enter number:  ? 1.999
    Enter convergence criterion (.0001 for 4 places):  ? .0001
    7.38167
    13 elements required to converge

    Enter number:  ? 2
    Enter convergence criterion (.0001 for 4 places):  ? .0001
    5
    3 elements required to converge

    Enter number:  ? 0

    The outcome is the same--repeating the experiment with a number as
    near to 2 as the convergence criterion permits (1.9999) produces the
    same result. The error is indeed caused by the fact that the number is
    an integer.

    Because no intuitive way can be found to solve the mystery by
    inspection, the programmer must turn to the next method in the
    hierarchy, instrumentation. The problem has something to do with the
    calculation of the terms of the series. Therefore, the section of the
    program that performs this calculation should be instrumented by
    placing PRINT statements inside the WHILE loop (Figure 18-2) to
    display all the intermediate values of the calculation.


    WHILE ABS(LAST - DELTA) &gt;= C
        LAST = DELTA
        FACT = FACT * TERMS
        DELTA = X ^ TERMS / FACT
        EX = EX + DELTA
        PRINT "TERMS="; TERMS; "EX="; EX; "FACT="; FACT; "DELTA="; DELTA;
        PRINT "LAST="; LAST
        TERMS = TERMS + 1
    WEND

    Figure 18-2. Instrumenting the WHILE loop.


    The print statements used in this WHILE loop are typical of the type
    used for instrumentation. The program makes no attempt at fancy
    formatting. The print statements simply identify each value with its
    variable name, allowing easy correlation of the data and the code in
    the listing. Repeating the experiment with 1.999 and 2 yields

Enter number:  ? 1.999
Enter convergence criterion (.0001 for 4 places):  ? .0001
TERMS= 1 EX= 2.999 FACT= 1 DELTA= 1.999 LAST= 1E+34
TERMS= 2 EX= 4.997001 FACT= 2 DELTA= 1.998 LAST= 1.999
TERMS= 3 EX= 6.328335 FACT= 6 DELTA= 1.331334 LAST= 1.998
TERMS= 4 EX= 6.993669 FACT= 24 DELTA= .6653343 LAST= 1.331334
TERMS= 5 EX= 7.25967 FACT= 120 DELTA= .2660006 LAST= .6653343
TERMS= 6 EX= 7.348292 FACT= 720 DELTA= 8.862254E-02 LAST= .2660006
TERMS= 7 EX= 7.373601 FACT= 5040 DELTA= 2.530806E-02 LAST= 8.862254E-02
TERMS= 8 EX= 7.379924 FACT= 40320 DELTA= 6.323853E-03 LAST= 2.530806E-02
TERMS= 9 EX= 7.381329 FACT= 362880 DELTA= 1.404598E-03 LAST= 6.323853E-03
TERMS= 10 EX= 7.38161 FACT= 3628800 DELTA= 2.807791E-04 LAST= 1.404598E-03
TERMS= 11 EX= 7.381661 FACT= 3.99168E+07 DELTA= 5.102522E-05 LAST= 2.807791E-04
TERMS= 12 EX= 7.38167 FACT= 4.790016E+08 DELTA= 8.499951E-06 LAST= 5.102522E-05
7.38167
13 elements required to converge

Enter number:  ? 2
Enter convergence criterion (.0001 for 4 places):  ? .0001
TERMS= 1 EX= 3 FACT= 1 DELTA= 2 LAST= 1E+34
TERMS= 2 EX= 5 FACT= 2 DELTA= 2 LAST= 2
5
3 elements required to converge

    Examination of the instrumentation printout for the two cases shows a
    drastically different pattern. The fractional number went through 13
    iterations following the expected pattern; the whole number, however,
    quit on the third step. The loop is terminating prematurely. Why? Look
    at the values calculated for DELTA and LAST on the last complete step.
    They are the same, giving a difference of zero. Because this
    difference will always be less than the convergence criterion, the
    loop will always terminate early. A moment's reflection shows why. The
    numerator of the fraction for each term but the first in the infinite
    series is a power of the number entered; the denominator is a
    factorial, a product formed by multiplying successive integers.
    Because n! = n * (n-1)!, when an integer is raised to a power equal to
    itself and divided by the factorial of that integer the result will
    always be the same as the preceding term. That is what has happened
    here.

    Now that the cause of the problem is found, it must be fixed. How can
    this problem be prevented? In this case, the problem is caused by a
    logic error. The programmer misread (or miswrote!) the algorithm and
    assumed that the criterion for termination was that the difference
    between the last two terms be less than the specified value. This is
    incorrect. Actually, the termination criterion should be that the
    difference between the forming EXP(x) and the last term be less than
    the criterion. To simplify, the last term itself must be less than the
    value specified. The correct program listing, including the new WHILE
    loop, is shown in Figure 18-3.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-3. Corrected exponential calculation routine.

    ──────────────────────────────────────────────────────────────────────

    The program now produces the correct results within the limits of the
    specified accuracy:

    Enter number:  ? 1.999
    Enter convergence criterion (.0001 for 4 places):  ? .0001
    7.381661
    12 elements required to converge

    Enter number:  ? 2
    Enter convergence criterion (.0001 for 4 places):  ? .0001
    7.389047
    12 elements required to converge

    Enter number:  ? 0

    This example illustrates how easy it is to use internal
    instrumentation in high-order languages. Because these languages
    usually have simple formatted output commands, they require very
    little work to instrument. When these output commands are not
    available, however, more work may be required. For instance, if the
    program being debugged is in assembly language, it is possible that
    the code required to format and print internal data will be longer
    than the program being debugged. For this reason, internal
    instrumentation is rarely used on small and moderate assembly
    programs. However, large assembly programs and systems often already
    have print formatting routines built into them; in these cases,
    internal instrumentation may be as easy as with high-order languages.

External instrumentation
    Sometimes it is difficult to use internal instrumentation with a
    program. If, for instance, the problem is timing related, adding print
    statements could cloud the problem or, worse yet, make it go away
    completely. This leaves the programmer in the frustrating position of
    having the problem only when the cause can't be seen and not having
    the problem when it can. A solution to this type of problem can
    sometimes be found by moving the instrumentation outside the program
    itself. There are two types of external instrumentation: hardware and
    software.

    Hardware instrumentation consists of whatever logic analyzers,
    oscilloscopes, meters, lights, bells, or gongs are appropriate to the
    hardware and software under test. Hardware instrumentation is
    difficult to set up and tedious to use. It is, therefore, usually
    reserved for those problems directly associated with hardware. Such
    problems often arise when new software is being run on new hardware
    and no one is quite sure where the bugs are. Because most programmers
    reading this book are developing software on tried-and-true personal
    computer hardware and because most of those programmers are unlikely
    to have a logic analyzer costing several thousand dollars, we will
    skip over the use of hardware instrumentation for software debugging.
    If a logic analyzer must be used, the programmer should remember that
    the debugging philosophy and techniques discussed in this article can
    still be applied effectively.

    MS-DOS provides a feature that is very useful in building external
    instrumentation software: the TSR, or terminate-and-stay-resident
    routine. See PROGRAMMING IN THE MS-DOS ENVIRONMENT: CUSTOMIZING
    MS-DOS: Terminate-and-Stay-Resident Utilities. This feature of the
    operating system allows the programmer to build a monitoring routine
    that is, in essence, a part of the operating system and outside the
    application program. The TSR is loaded as a normal program, but
    instead of leaving the system when it is done, it remains intact in
    memory. The operating system provides no way to reexecute the program
    after it terminates, so most TSRs are interrupt driven.

    Because TSRs exist outside the application program, they can be used
    to build external instrumentation devices. This independence allows
    them to perform monitoring functions without disturbing the logic flow
    of the application program. The only areas where interference is
    likely are those where the TSR and the program must use common
    resources. These conflicts typically involve timing but can also
    involve other resources, such as I/O devices, disk files, and MS-DOS
    resources, including environment space. Some of these problems are
    addressed in the next example.

    The TSR type of external instrumentation software can prove useful in
    analyzing serial communications. Such an instrumentation program
    monitors the serial communication line and records all data. To detect
    protocol or timing problems, the program tags the recorded data so
    that transmitted data can be differentiated from received data.
    Hardware devices exist that plug into the serial port and perform both
    the monitoring and tagging function, but they are expensive and not
    always handy. Fortunately, this inexpensive piece of software
    instrumentation will serve in many cases.

    Software interrupt calls are made with the INT instruction. Although
    their service routines must obey similar rules, these interrupts
    should not be confused with hardware interrupts caused by external
    hardware events. Software interrupts in MS-DOS are used by an
    application program to communicate with the operating system and, by
    extension in IBM systems, with the ROM BIOS. For example, on IBM PCs
    and compatibles, application programs can use software Interrupt 14H
    to communicate with the ROM BIOS serial port driver. The ROM BIOS
    routine, in turn, manages the hardware interrupts from the actual
    serial device. Thus, Interrupt 14H does not communicate directly with
    the hardware. All the programs in this article deal with software
    interrupts to the ROM BIOS and MS-DOS.

    A program to trace the serial data flow must have access to the serial
    data, so such a program must replace the vector for Interrupt 14H with
    one that points to itself. The routine can then record all the serial
    data and pass it along through the serial port. Because the goal is to
    minimize the effect of this monitoring on the timing of the data, the
    method used for recording the data should be fast. This requirement
    rules out writing to a disk file, because unexpected delays can be
    introduced (and because doing disk I/O from an interrupt service
    routine under MS-DOS is difficult, if not impossible). Printing the
    data on paper is clearly too slow, and data displayed on the screen is
    too ephemeral. Thus, about the only thing that can be done with the
    data is to write it to RAM. Luckily, memory has become cheap and most
    personal computers have plenty.

    Writing a routine that monitors and records serial data is not enough,
    however. The data must still flow through the serial port to and from
    the external serial device. Thus, the monitor program can have only
    temporary custody of the data and must pass it on to the serial
    interrupt service routine in the ROM BIOS. This is accomplished by
    using MS-DOS function calls to extract the address of the serial
    interrupt handler before the new vector is installed in its place. The
    process of intercepting interrupts and then passing the data on is
    known as "daisy-chaining" interrupt handlers. So long as such
    intercepting programs are careful to maintain the data and conditions
    upon entrance for subsequent routines (that is, so long as routines
    are well behaved; see PROGRAMMING IN THE MS-DOS ENVIRONMENT:
    PROGRAMMING FOR MS-DOS), several interrupt handlers can be daisy-
    chained together with no detriment to processing. (Woe be unto the
    person who breaks the daisy chain--the results are annoying at best
    and unpredictable at worst.)

    The serial monitoring program, as described so far, correctly collects
    and stores serial data and then passes it on to the serial port. This
    may be intellectually satisfying, but it is not of much use in the
    real world. Some way must be provided to control the program--to start
    collection, to stop collection, to pause and resume collection. Also,
    once data is collected, a control function must be provided that
    returns the number of bytes collected and their starting location, so
    that the data can be examined.

    From all this, it is clear that a serial communications monitoring
    instrument must

    1. Replace the Interrupt 14H vector with one pointing to itself.

    2. Save the address of the old interrupt handler.

    3. Collect the serial data, tag it as transmitted or received, and
        store it in RAM.

    4. Pass the data on, in a completely transparent manner, to the old
        interrupt handler.

    5. Provide some way to control data collection.

    A program that meets all these criteria is shown in Figure 18-4. The
    COMMSCOP program has three major parts:

╓┌───────────────────────┌───────────────────────────────────────────────────╖
    Procedure          Purpose
    ──────────────────────────────────────────────────────────────────
    COMMSCOPE          Monitoring and tagging
    CONTROL            External control
    VECTOR_INIT        Interrupt vector initialization

    The COMMSCOPE procedure provides the new Interrupt 14H handler that
    intercepts the serial I/O interrupts. The CONTROL procedure provides
    the external control needed to make the system work. The VECTOR_INIT
    procedure gets the old interrupt handler address, installs COMMSCOPE
    as the new interrupt handler, and installs the interrupt handler for
    the control interrupt.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-4. Communications trace utility.

    ──────────────────────────────────────────────────────────────────────

    The first executable statement of the program is a jump to the
    VECTOR_INIT procedure. The vector initialization code is needed only
    during installation; after initialization of the vectors, the code can
    be discarded. In this case, the area where this code resides will
    become the start of the trace buffer; therefore, it makes sense to put
    the initialization code at the end of the program where it can be
    overlaid by the trace buffer. The jump at the start of the program is
    required because the rules for making .COM files require that the
    entry point be the first instruction of the program.

    The vector initialization routine uses Interrupt 21H Function 35H (Get
    Interrupt Vector) to get the address of the current Interrupt 14H
    service routine. The segment and offset address (returned in the ES:BX
    registers) is stored in the doubleword at OLD_COMM_INT. Interrupt 21H
    Function 25H (Set Interrupt Vector) is then used to vector all
    Interrupt 14H calls to COMMSCOPE. Another Function 25H call sets
    Interrupt 60H to vector to the CONTROL routine. This interrupt, which
    provides the means to control and interrogate the COMMSCOPE routine,
    was chosen because it is unused by MS-DOS and because some IBM
    technical materials list 60H through 66H as being available for user
    interrupts. (If, for some reason, Interrupt 60H is not available,
    simply change the equated symbol COMMSCOPE_INT to an available
    interrupt.)

    When the vector initialization process is complete, the routine exits
    and stays resident by using Interrupt 21H Function 31H (Terminate and
    Stay Resident). As part of the termination process, the routine
    requests 1000H paragraphs, or 64 KB, of storage. A little over 500
    bytes of this storage area is used for the code; the rest is available
    for trace data. If the serial port is running at 2400 baud, a solid
    stream of data will fill this buffer in about two minutes. However, a
    solid 32 KB block of data is unusual in asynchronous communications
    and, in reality, the buffer will usually contain many minutes worth of
    data. Note that the buffer-handling routines in COMMSCOPE require that
    the buffer be aligned on an even byte boundary, so VECTOR_INIT is
    preceded by the EVEN directive.

    The interrupt service routine, COMMSCOPE, receives all Interrupt 14H
    calls. First COMMSCOPE checks its own status. If it has not been
    activated, it immediately passes control to the real service routine.
    If the tracer is active, COMMSCOPE examines the Interrupt 14H function
    in AH. Setup and status requests (AH = 0 and AH = 3) do not affect
    tracing, so they are passed on directly to the the real service
    routine. If the Interrupt 14H call is a write-data request (AH = 1),
    COMMSCOPE moves the byte marking the data as transmitted and the data
    byte itself to the current buffer location and increments both the
    byte count and the buffer pointer by 2. If the buffer pointer goes to
    zero, the buffer has wrapped; data collection is turned off and cannot
    be turned on again without clearing the trace buffer. Because the
    buffer, which starts at VECTOR_INIT, is always on an even byte
    boundary, there is no danger of the first byte of the data pair
    forcing a wrap. After the transmitted data is added to the buffer,
    COMMSCOPE passes control to the real service routine.

    A read-data request (AH = 2) must be handled a little differently. In
    this case, the data to be collected is not yet available. In order to
    get it, COMMSCOPE must pass control to the real service routine and
    then intercept the results on the way back. The code at GET_READ fakes
    an interrupt to the service routine by pushing the flags onto the
    stack so that the service routine's IRET will pop them off again.
    COMMSCOPE then calls the service routine and, when it returns,
    retrieves the incoming serial data character from AL. If the incoming
    data byte is valid (bit 7 of AH is zero), the byte marking the data as
    received and the data byte itself are placed in the trace buffer, and
    both the byte count and the buffer pointer are incremented by 2. The
    buffer-wrap condition is detected and handled in the same manner as
    with transmitted data. Because the real service routine has already
    been called, COMMSCOPE exits as if it were the service routine by
    issuing an IRET.

    The CONTROL procedure provides the mechanism for external control of
    the trace procedure. The routine is entered whenever an Interrupt 60H
    is executed. Commands are sent through the AH register and can cause
    the routine to STOP (AH = 0), START/FLUSH (AH = 1), RESUME (AH = 2),
    or RETURN STATUS (AH = 3). This routine also sets the communications
    port to be traced. The required information is provided in DX using
    the same format as the Interrupt 14H routine. The port information is
    used only with START and RESUME requests. The RETURN STATUS command
    returns data in registers: the byte count (CX), the segment address of
    the buffer (DX), and the offset of the first byte in the buffer (BX).

    The COMMSCOP program is assembled using the Microsoft Macro Assembler
    (MASM), linked using the Microsoft Object Linker (LINK), and then
    converted to a .COM file using EXE2BIN (see PROGRAMMING UTILITIES):

    C&gt;MASM COMMSCOP;  &lt;Enter&gt;
    C&gt;LINK COMMSCOP;  &lt;Enter&gt;
    C&gt;EXE2BIN COMMSCOP.EXE COMMSCOP.COM  &lt;Enter&gt;
    C&gt;DEL COMMSCOP.EXE  &lt;Enter&gt;

    The linker will display the message Warning: no stack segment; this
    message can be ignored because the rules for making a .COM file forbid
    a separate stack segment.

    The program is installed by simply typing COMMSCOP. Tracing can then
    be started and stopped using Interrupt 60H. MS-DOS does not allow
    resident routines to be removed, so COMMSCOP will be in the system
    until the system is restarted. Also note that, because COMMSCOP is
    well behaved, nothing disastrous will happen if multiple copies of it
    are accidentally installed. As each new copy is installed, it chains
    to the previous copy. When Interrupt 14H is intercepted, the new
    routine dutifully passes the data on to the previous routine, which
    repeats the process until the real service routine is reached. The
    data is added to the trace buffer of each copy, giving multiple,
    redundant copies of the same data. Because Interrupt 60H is not
    chained, only the last copy's buffer can be accessed. Thus, the other
    copies simply waste 64 KB each.

    Two techniques can be used to start or stop a trace. The first is to
    issue Interrupt 60H calls at strategic locations within the program
    being debugged. With assembly-language programs, this is easy. The
    appropriate registers are loaded and an INT 60H instruction is
    executed. Issuing this INT instruction is not much more difficult with
    higher-order Microsoft languages--both QuickBASIC and C provide a
    library routine called INT86 that allows registers to be loaded and
    INT instructions to be executed. (In QuickBASIC, the INT86 library
    routine is included in the File USERLIB.OBJ; in Microsoft C, it is
    included in the file DOS.H.) Embedded Interrupt 60H calls can be
    convenient because they limit tracing to those areas where processing
    is suspect. Because COMMSCOP marks the buffer each time the trace is
    stopped and resumed, the separate pieces of a trace are easy to
    differentiate.

    The second technique is to write a simple routine to start or stop the
    trace outside the program being debugged. The example in Figure 18-5,
    COMMSCMD, is a Microsoft C program that can perform these functions
    using the INT86 library function to issue Interrupt 60H calls.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-5. A serial-trace control routine written in C.

    ──────────────────────────────────────────────────────────────────────

    COMMSCMD is passed arguments in the command line. The first argument
    is the command to be performed: STOP, START, or RESUME. If no command
    is specified, STOP is assumed. The second argument is the port number:
    1 (for COM1) or 2 (for COM2). If no port number is specified, 1 is
    assumed.

    The COMMSCMD program uses a simple IF filter to determine the function
    to be performed. The program tests the number of arguments in the
    command line to see if a port has been specified. If the argument
    count (argc) is 3 (one for the command name, one for the command, and
    one for the port number), the port number argument is retrieved and
    converted to an integer. The Interrupt 60H routine expects port
    numbers to be specified in the same manner as for Interrupt 14H, so
    the port number is decremented if it is not already zero. The AH
    register is loaded with the command (cmd), the DX register is loaded
    with the port number (port), and the INT86 library function is then
    used to execute an Interrupt 60H call. When the interrupt returns,
    COMMSCMD displays a message showing the function and port.

    The same function can be performed by the QuickBASIC program in
    Figure 18-6.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-6. A QuickBASIC version of COMMSCMD.

    ──────────────────────────────────────────────────────────────────────

    Both versions of COMMSCMD accept their commands from the command tail;
    both are invoked with a STOP, START, or RESUME command and a serial
    port number (1 or 2). If the operands are omitted, STOP and COM1 are
    assumed.

    After data has been collected and safely placed in the trace buffer,
    it must be read before it can be useful. Interrupt 60H provides a
    function (AH = 3) that returns the buffer address and the number of
    bytes in the buffer. The QuickBASIC routine in Figure 18-7 uses this
    function to get the address of the data and then formats the data on
    the screen.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-7. Formatted dump routine for serial-trace buffer.

    ──────────────────────────────────────────────────────────────────────

    COMMDUMP is a simple routine. Like most debugging aids, it lacks
    needless frills. When it is executed, COMMDUMP displays the data in
    the trace buffer on the screen in the format shown in Figure 18-8.


.012832.132056780001006713205678000100671320567800010067132056780001006713205678
03333330333333333333333333333333333333333333333333333333333333333333333333333333
10128323132056780001006713205678000100671320567800010067132056780001006713205678
--------------------------------------------------------------------------------
00010067132056780001006713205678000100671320567800010067.#...012832.567813200001
33333333333333333333333333333333333333333333333333333333021003333330333333333333
00010067132056780001006713205678000100671320567800010067338610128323567813200001
--------------------------------------------------------------------------------
00675678132000010067567813200001006756781320000100675678132000010067567813200001
33333333333333333333333333333333333333333333333333333333333333333333333333333333
00675678132000010067567813200001006756781320000100675678132000010067567813200001
--------------------------------------------------------------------------------
006756781320000100675678132000010067.#...012832.00671320567800010067132056780001
33333333333333333333333333333333333302100333333033333333333333333333333333333333
00675678132000010067567813200001006733861012832300671320567800010067132056780001
--------------------------------------------------------------------------------
00671320567800010067132056780001006713205678000100671320567800010067132056780001
33333333333333333333333333333333333333333333333333333333333333333333333333333333
00671320567800010067132056780001006713205678000100671320567800010067132056780001
--------------------------------------------------------------------------------
0067132056780001.#...012832.1320567800010067132056780001006713205678000100671320
33333333333333330210033333303333333333333333333333333333333333333333333333333333
00671320567800013386101283231320567800010067132056780001006713205678000100671320
--------------------------------------------------------------------------------
NUM = 1122 BUFSEG = 1313 BUFOFF = 208            ENTER ANY KEY TO CONTINUE:

    Figure 18-8. Formatted trace dump routine output.


    Note that the data for each byte is presented in two forms. If the
    byte is greater than 1FH, the ASCII character represented by that
    number is shown; otherwise, a dot is shown. Directly below each
    character is the hexadecimal representation of the data. The display
    shows received data in reverse video and transmitted data in normal
    video. The mark placed in the buffer when collection is stopped and
    resumed is represented on the screen as a vertical bar one character
    wide. The display pauses when the screen is full and waits for a key
    to be pressed.

    Data collected and displayed in this way can be invaluable to the
    programmer trying to debug a program involving a communications
    protocol. The example shown above is part of an ordered exchange of
    sales data for a system using blocked transmissions and ACK/NAK
    protocol. Like all debugging, finding bugs in such a system requires
    the collection of large amounts of data. With no data, the causes of
    problems can be almost impossible to find; with sufficiently large
    amounts of data, the solutions are obvious.

    Several things could be done to the COMMSCOP program to increase its
    usefulness. For instance, there are six unused bits in the tag
    accompanying each data byte in the trace buffer. These could be used
    to record the status of the modem control bits, to place timer ticks
    in the buffer, or to coordinate the data with some outside event.
    (Such changes to COMMSCOP would require a more complicated COMMDUMP
    routine to display them.)

Software debugging monitors

    Debugging monitors provide the next level of sophistication in the
    hierarchy of debugging methods. These monitors are coresident in
    memory with the application being debugged and provide a controlled
    testing environment--that is, they allow the programmer to control the
    execution of the program and to monitor the results. They even allow
    some problems to be fixed directly and the result reexecuted
    immediately, without the need to reassemble or recompile.

    These monitors are analogous to the TSR serial monitor from the
    previous section. The debugging monitors, however, do not reside
    permanently in memory and are controlled interactively from the
    keyboard during the execution of the program under test. Although this
    level of control is more flexible than instrumentation, it is also
    more intrusive into program execution. While the debugging monitor
    sits and waits for input from the keyboard, the application program is
    also idle. For programs that must run in real time or must respond to
    external stimuli, long delays can be fatal. Careful planning and a
    thorough knowledge of the internal workings of the program are
    required to debug in such an environment.

    Other problems with debugging monitors arise from the nature of the
    monitors themselves. They are programs, no different from the
    application program being debugged and are therefore limited to those
    things that can be done with software. For instance, they can break
    (stop execution to allow investigation of program status) when a
    specific instruction address is executed (because this can be done
    with software), but they cannot break when a data address is
    referenced (because this would require special hardware). Because
    these monitors reside in RAM, as do the application program and
    MS-DOS, they are susceptible to damage from a program running wild.
    Some trial and error is usually involved in locating the problem
    causing this kind of damage; breakpoints won't work here because the
    problem kills the monitor (and usually MS-DOS also).

    Microsoft provides three debugging monitors, each with greater
    capabilities than its predecessor. In order of increasing
    sophistication, these three monitors are

╓┌─────────────────┌─────────────────────────────────────────────────────────╖
    Monitor      Description
    ──────────────────────────────────────────────────────────────────────
    DEBUG        A basic debugging monitor with the ability to load files,
                modify memory and registers, execute programs, set
                simple breakpoints, trace execution, modify disk files,
                and enter assembly-language statements into memory.

    SYMDEB       A more advanced debugging monitor incorporating all the
                features of DEBUG plus more sophisticated data display,
                support for graphics programs, support for the Intel
                80186/80286 microprocessors and the Intel 80287 math
                coprocessor, improved breakpoints, improved tracing,
                recognition of symbols from the program being debugged,
                and limitedsource-line display.

    CodeView     The most sophisticated debugging monitor, incorporating
                the functionality of SYMDEB (with some differences in
                the details) plus windows, full source-line support,
                mouse support, and generally more sophistication on all
                functions.

    Although all these debugging monitors will be discussed here, this
    section is not intended to be a tutorial on all the commands and
    options of the monitors--those are presented elsewhere in this volume
    and in the manuals accompanying the monitors. See PROGRAMMING
    UTILITIES: DEBUG; SYMDEB; CODEVIEW. Rather, this section uses case
    histories and sample programs to illustrate the techniques for solving
    various types of common debugging problems. The case histories have
    been chosen to show a wide range of problems, from simple to extremely
    complex.

DEBUG
    Although DEBUG is the least sophisticated of the software debugging
    monitors, it is quite useful with moderately complex programs and is
    an effective tool for learning basic techniques.

    Basic techniques
    The first sample program is written in assembly language. It is a test
    program that performs serial input and output and was used to debug
    COMMSCOP, the serial-trace TSR presented earlier. The routine reads
    from the keyboard and writes to COM1 by means of Interrupt 14H. It
    also accepts incoming serial data and displays it on the screen. This
    process continues until Ctrl-C is pressed on the keyboard. A serial
    terminal is attached to COM1 to serve as a data source. Figure 18-9
    shows the erroneous program.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-9. Incorrect serial test routine.

    ──────────────────────────────────────────────────────────────────────

    When executed, this program produces a constant stream of zeros from
    the serial port. Incoming serial data is not echoed on the screen, but
    the cursor moves as if it were. Further, the Ctrl-C keystroke is not
    recognized, so the only way to stop the program is to restart the
    system.

    An examination of the listing should reveal the errors that cause
    these problems, but things do not always happen that way. For the
    purposes of this case study, assume that the listing was no help.
    Instrumentation is more difficult for assembly-language programs than
    for programs written in higher-order languages, so in this case it is
    advantageous to go directly to a debugging monitor. The monitor for
    this example is DEBUG.

    The first step in using DEBUG is not to invoke the monitor; rather, it
    is to gather all pertinent listings, link maps, and program design
    documentation. In this case, the program is so short that a link map
    will not be needed; all the design documentation that exists is in the
    program comments.

    Now begin DEBUG by typing

    C&gt;DEBUG TESTCOMM.EXE  &lt;Enter&gt;

    The filename must be fully qualified; DEBUG makes no assumptions about
    the extension. Any type of file can be examined with DEBUG, but only
    files with an extension of .COM, .EXE, or .HEX are actually loaded and
    made ready for execution. Since TESTCOMM is a .EXE file, DEBUG loads
    it and prepares it for execution in a manner compatible with the MS-
    DOS loader. Type the Display or Modify Registers command, R.

    -R  &lt;Enter&gt;
    AX=0000  BX=0000  CX=0131  DX=0000  SP=0100  BP=0000  SI=0000  DI=0000
    DS=1AAD  ES=1AAD  SS=1ABD  CS=1ACD  IP=0000   NV UP EI PL NZ NA PO NC
    1ACD:0000 1E            PUSH  DS

    Notice that the SS and CS registers have been loaded to their correct
    values and that SP points to the bottom of the stack. DS and ES point
    to an address 100H bytes (10H paragraphs) before the stack segment.
    (This is because the system sets these registers to point to the
    program segment prefix [PSP] when a .EXE program is loaded.) Normally,
    the program code would be responsible for loading the correct value of
    DS, but this example does not use the data segment, so the program
    doesn't bother. The register display also shows the instruction at the
    current value of CS:IP, 1ACD:0000H. The instruction pointer was set to
    this address because the END statement in the source program specified
    the procedure BEGIN as the entry point and that procedure begins at
    CS:IP. Note that the instruction displayed below the register
    information has not yet been executed. This condition is true for all
    register displays in DEBUG--IP always points to the next instruction
    to be executed, so the instruction at IP has not been executed.

    From the symptoms observed during program execution, it is clear that
    the keyboard data is not reaching the serial port. The failure could
    be in the keyboard read routine or in the serial port write routine.
    This code is compact and fairly linear, so the easiest way to find out
    what is going on is to trace through the first few instructions of the
    program. Executing five instructions with the Trace Program Execution
    command, T, will do this.

    -T5  &lt;Enter&gt;

    AX=0000  BX=0000  CX=0131  DX=0000  SP=00FE  BP=0000  SI=0000  DI=0000
    DS=1AAD  ES=1AAD  SS=1ABD  CS=1ACD  IP=0001   NV UP EI PL NZ NA PO NC
    1ACD:0001 33C0          XOR   AX,AX

    AX=0000  BX=0000  CX=0131  DX=0000  SP=00FE  BP=0000  SI=0000  DI=0000
    DS=1AAD  ES=1AAD  SS=1ABD  CS=1ACD  IP=0003   NV UP EI PL ZR NA PE NC
    1ACD:0003 50            PUSH  AX

    AX=0000  BX=0000  CX=0131  DX=0000  SP=00FC  BP=0000  SI=0000  DI=0000
    DS=1AAD  ES=1AAD  SS=1ABD  CS=1ACD  IP=0004   NV UP EI PL ZR NA PE NC
    1ACD:0004 B406          MOV   AH,06

    AX=0600  BX=0000  CX=0131  DX=0000  SP=00FC  BP=0000  SI=0000  DI=0000
    DS=1AAD  ES=1AAD  SS=1ABD  CS=1ACD  IP=0006   NV UP EI PL ZR NA PE NC
    1ACD:0006 B2FF          MOV   DL,FF

    AX=0600  BX=0000  CX=0131  DX=00FF  SP=00FC  BP=0000  SI=0000  DI=0000
    DS=1AAD  ES=1AAD  SS=1ABD  CS=1ACD  IP=0008   NV UP EI PL ZR NA PE NC
    1ACD:0008 CD15          INT   15

    The Trace command shows the contents of the registers as each
    instruction is executed. The register contents are after
    the execution of the instruction listed above the registers and the
    instruction shown with the registers is the next instruction to be
    executed. The first register display in this example represents the
    state of affairs after the execution of the PUSH DS instruction, as
    indicated by SP. The first three instructions set up the stack so that
    the far return issued at the end of the program will pass control to
    the PSP for termination. The next two instructions set the registers
    for a Direct Console I/O MS-DOS call (AH = 060, DL = HFFH for input).
    After these registers are set up, the program should execute the MS-
    DOS call INT 21H. However, the next instruction to be executed is INT
    15H. This is the reason the keyboard data is not being read. The code
    requests INT 21, not 21H. This mistake is a common one. The
    assembler's default radix is decimal, so it converted 21 into 15H.
    This error can be corrected in memory from within DEBUG and, because
    the instruction hasn't executed yet, the fix can be tested
    immediately. To make the correction, use the Assemble Machine
    Instructions command, A.

    -A 8  &lt;Enter&gt;
    1ACD:0008 int 21  &lt;Enter&gt;
    1ACD:000A

    The A 8 code instructs DEBUG to begin assembling at CS:0008H. DEBUG
    prompts with the address and waits for an instruction to be entered.
    The letter H is not needed after the 21 this time because DEBUG
    assumes all numbers entered with the Assemble command are in
    hexadecimal form. In general, any valid 8086/8087/8088 assembly-
    language statement can be entered this way and translated into
    executable machine code. See PROGRAMMING UTILITIES: DEBUG: A. Within
    its restrictions, the Assemble command is a handy way of making
    changes. The Enter Data command, E, could also have been used to
    change the 15H to a 21H, but the Assemble command is safer, especially
    for complex instructions. After the new instruction has been entered,
    press Enter again to stop the assembly process.

    There is a danger associated with making changes in memory during
    debugging: The memory copy of the program is temporary; the changes
    exist only in memory and when DEBUG exits, they are lost. Changes made
    to .EXE and .HEX files cannot be written back to disk. To avoid
    forgetting the changes, write them down. When DEBUG exits, edit the
    source file immediately. Changes made to other files can be written
    back to disk with DEBUG's Write File or Sectors command, W.

    To be sure that the change was made correctly, use the Disassemble
    (Unassemble) Program command, U, to show the instructions starting at
    CS:0004H.

    -U 4  &lt;Enter&gt;
    1ACD:0004 B406          MOV   AH,06
    1ACD:0006 B2FF          MOV   DL,FF
    1ACD:0008 CD21          INT   21
    1ACD:000A 740C          JZ    0018
    1ACD:000C 3C03          CMP   AL,03
    1ACD:000E 7501          JNZ   0011
    1ACD:0010 CB            RETF
    1ACD:0011 B401          MOV   AH,01
    1ACD:0013 BA0000        MOV   DX,0000
    1ACD:0016 CD14          INT   14
    1ACD:0018 B403          MOV   AH,03
    1ACD:001A BA0000        MOV   DX0000
    1ACD:001D CD14          INT   14
    1ACD:001F 80E401        AND   AH,01
    1ACD:0022 74E0          JZ    0004

    The change has been correctly made. Now, to test the change, start the
    program to see if characters make it out the serial port. The problem
    of data from the serial port not making it to the screen remains,
    however, so instead of simply starting the program, set a breakpoint
    at the location in the program that handles incoming serial data
    (CS:0024H). This technique allows the output section of the code to be
    tested separately. The breakpoint is set using the Go command, G.

    -G 24  &lt;Enter&gt;

    AX=0130  BX=0000  CX=0131  DX=0000  SP=00FC  BP=0000  SI=0000  DI=0000
    DS=1AAD  ES=1AAD  SS=1ABD  CS=1ACD  IP=0024   NV UP EI PL NZ NA PO NC
    1ACD:0024 B402          MOV   AH,02
    -U  &lt;Enter&gt;
    1ACD:0024 B402          MOV   AH,02
    1ACD:0026 BA0000        MOV   DX,0000
    1ACD:0029 CD14          INT   14
    1ACD:002B B406          MOV   AH,06
    1ACD:002D CD21          INT   21
    1ACD:002F EBD3          JMP   0004
    1ACD:0031 0000          ADD   [BX+SI],AL
    1ACD:0033 0000          ADD   [BX+SI],AL
    1ACD:0035 0000          ADD   [BX+SI],AL
    1ACD:0037 0000          ADD   [BX+SI],AL
    1ACD:0039 0000          ADD   [BX+SI],AL
    1ACD:003B 0000          ADD   [BX+SI],AL
    1ACD:003D 0000          ADD   [BX+SI],AL
    1ACD:003F 0000          ADD   [BX+SI],AL
    1ACD:0041 0000          ADD   [BX+SI],AL
    1ACD:0043 0000          ADD   [BX+SI],AL

    As stated earlier, the serial port is attached to a serial terminal.
    After execution of the program is started with the Go command, all
    keys typed on the keyboard are displayed correctly on the terminal,
    thus confirming the fix made to the INT 21H instruction. To test
    serial input, a key must be pressed on the terminal, causing the
    breakpoint at CS:0024H to be executed.

    The fact that location CS:0024H was reached indicates that Interrupt
    14H is detecting the presence of an input character. To test if the
    character is now making it to the screen, a breakpoint is needed after
    the write to the screen. The Disassemble command shows the
    instructions starting at the current IP value. The program ends at
    CS:002FH; the instructions shown after that are whatever happened to
    be in memory when the program was loaded. A good place to set the next
    breakpoint is CS:002FH, just after the Interrupt 21H call.

    -G 2f  &lt;Enter&gt;

    AX=0600  BX=0000  CX=0131  DX=0000  SP=00FC  BP=0000  SI=0000  DI=0000
    DS=1AAD  ES=1AAD  SS=1ABD  CS=1ACD  IP=002F   NV UP EI PL NZ NA PO NC
    1ACD:002F EBD3          JMP   0004

    DEBUG shows that the breakpoint was reached and the character did not
    print (it should have been on the line after -G 2f), so something must
    be wrong with the Interrupt 21H call. A breakpoint just before the
    MS-DOS call at CS:002DH should reveal the cause of the problem.

    -G 2d  &lt;Enter&gt;

    AX=0662  BX=0000  CX=0131  DX=0000  SP=00FC  BP=0000  SI=0000  DI=0000
    DS=1AAD  ES=1AAD  SS=1ABD  CS=1ACD  IP=002D   NV UP EI PL NZ NA PO NC
    1ACD:002D CD21          INT   21

    The key that was entered on the serial terminal (b) is in AL, where it
    was returned by Interrupt 14H. Unfortunately, it is not in DL, where
    it is expected by the Direct Console I/O function (06H) of the MS-DOS
    command. The MS-DOS function was simply printing a null (00H) and then
    moving the cursor. An instruction (MOV DL,AL) is missing.

    Fixing this problem requires the insertion of a line of code, which is
    usually difficult to do inside DEBUG. The Move (Copy) Data command, M,
    can be used to move the code located below the point where the
    insertion is to be made down 2 bytes, but this will probably throw any
    subsequent addressing off. It is usually easier to exit DEBUG, edit
    the source file, and then reassemble. In this case, however, because
    the instruction to be added is near the last instruction, a patch can
    easily be made by entering only three instructions: the new one and
    the two it destroys.

    -A 2d  &lt;Enter&gt;
    1ACD:002D mov dl,al  &lt;Enter&gt;
    1ACD:002F int 21  &lt;Enter&gt;
    1ACD:0031 jmp 4  &lt;Enter&gt;
    1ACD:0033
    -U 2b  &lt;Enter&gt;
    1ACD:002B B406          MOV   AH,06
    1ACD:002D 88C2          MOV   DL,AL
    1ACD:002F CD21          INT   21
    1ACD:0031 EBD1          JMP   0004
    1ACD:0033 0000          ADD   [BX+SI],AL
    1ACD:0035 0000          ADD   [BX+SI],AL
    1ACD:0037 0000          ADD   [BX+SI],AL
    1ACD:0039 0000          ADD   [BX+SI],AL
    1ACD:003B 0000          ADD   [BX+SI],AL
    1ACD:003D 0000          ADD   [BX+SI],AL
    1ACD:003F 0000          ADD   [BX+SI],AL
    1ACD:0041 0000          ADD   [BX+SI],AL
    1ACD:0043 0000          ADD   [BX+SI],AL
    1ACD:0045 0000          ADD   [BX+SI],AL
    1ACD:0047 0000          ADD   [BX+SI],AL
    1ACD:0049 0000          ADD   [BX+SI],AL

    The new line of code has been inserted and verified with the  Dis-
    assemble command. The fix is ready to test. The Trace command could
    be used to single-step through the program to verify execution. A word
    of warning is in order, however: The DEBUG Trace command should never
    be used to trace an Interrupt 21H call. Once the trace enters the MS-
    DOS call, it will wander around for a while and then lock the machine,
    requiring a restart. Avoid this problem either by setting a breakpoint
    just beyond the Interrupt 21H call or by using the Proceed Through
    Loop or Subroutine command, P. The Proceed command operates in a
    similar manner to the Trace command but does not trace loops, calls,
    and interrupts.

    Because the fix is fairly certain, use the Go command in its simple
    form with no breakpoints. The program will execute without further
    intervention from DEBUG.

    -G  &lt;Enter&gt;
    lasdfgh
    Program terminated normally
    -Q  &lt;Enter&gt;

    The lasdfgh text entered on the serial terminal is displayed
    correctly. When a Ctrl-C is entered from the keyboard, the program
    terminates properly and DEBUG displays the message Program terminated
    normally. Now exit DEBUG with the Quit command, Q.

    The source code of TESTCOMM should be edited immediately so that it
    reflects the two changes made temporarily under DEBUG. Figure 18-10
    shows the corrected listing.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-10. Correct serial test routine.

    ──────────────────────────────────────────────────────────────────────

    DEBUG has a rich set of commands and features. The preceding case
    study shows the more common ones in their most straightforward aspect.
    Some of the other commands and some useful techniques are described
    below. See PROGRAMMING UTILITIES: DEBUG.

    Establishing initial conditions
    When a program is loaded for testing, four areas may require
    initialization:

    ■  Registers
    ■  Data areas
    ■  Default file-control blocks (FCBs)
    ■  Command tail

    These areas may also require changes during testing, especially when
    the programmer is working around bugs or establishing different test
    conditions.

    Registers. Registers are ordinarily set when the program is loaded.
    The values in them depend on whether a .EXE, .COM, or .HEX file was
    loaded. Generally, the segment registers, the IP register, and the SP
    register are set to appropriate values; with the exception of AX, BX,
    and CX, the rest of the registers are set to zero. BX and CX contain
    the length of the loaded file. By MS-DOS convention, when a program is
    loaded, the contents of AL and AH indicate the validity of the drive
    specifiers in the first and second DEBUG command-line parameters,
    respectively. Each register contains zero if the corresponding drive
    was valid, 01H if the drive was valid and wildcards were used, or 0FFH
    if the drive was invalid.

    To change the value of any register, use an alternate form of the
    Register command. Enter R followed by the two-letter register name.
    Only 16-bit registers can be changed, so use the X form of the
    general-purpose registers:

    -R AX  &lt;Enter&gt;

    DEBUG will respond with the current contents of the register and
    prompt for a new value. Either enter a new hexadecimal value or press
    Enter to keep the current value:

    AX 0000
    :FFFF  &lt;Enter&gt;

    In this example, the new value of AX is FFFFH.

    When changing registers, exercise caution modifying the segment
    registers. These registers control the execution of the program and
    should be changed only after careful and thoughtful consideration.

    The Register command can also be used to modify the CPU flags.

    Data areas. Initializing or changing data areas is easy, and several
    methods are provided. The Fill Memory command, F, can be used to
    initialize areas of RAM. For instance,

    -F 0 L400 0  &lt;Enter&gt;

    fills DS:0000H through DS:03FFH with zero. (The absence of a segment
    override causes the Fill command to use its default segment, DS.)
    Entering

    -F CS:100 200 1B "[Hello" 0D  &lt;Enter&gt;

    fills CS:0100H through CS:0200H with many repetitions of the string 1B
    5B 48 65 6C 6C 6F 0D. (Note that an address range was specified, not a
    length.)

    When the wholesale changing of memory is not appropriate, the Enter
    command can be used to edit a small number of locations. The Enter
    command has two forms: One enters a list of bytes into the specified
    memory location; the other prompts with the contents of each location
    and waits for input. Either form can be used as appropriate.

    Default file-control blocks and the command tail. The setting of the
    default FCBs and of the command tail are related functions. When DEBUG
    is entered, the first parameter following the command DEBUG is the
    name of the file to be loaded into memory for debugging. If the next
    two parameters are filenames, FCBs for these files are formatted at
    DS:005CH and DS:006CH in the PSP. See PROGRAMMING IN THE MS-DOS
    ENVIRONMENT: PROGRAMMING FOR MS-DOS: File and Record Management. If
    either parameter contains a pathname, the corresponding FCB will
    contain only a valid drive number; the filename field will not be
    valid. All filenames and switches following the name of the file to be
    debugged are considered the command tail and are saved in memory
    starting at DS:0081H. The length of the command tail is in DS:0080H.
    For example, entering

    C&gt;DEBUG COMMDUMP.EXE FILE1.DAT FILE2.DAT  &lt;Enter&gt;

    results in the first FCB (5CH), the second FCB (6CH), and the command
    tail (81H) being loaded as follows:

-D 50
42C9:0050  CD 21 CB 00 00 00 00 00-00 00 00 00 00 46 49 4C .!...........FIL
42C9:0060  45 31 20 20 20 44 41 54-00 00 00 00 00 46 49 4C E1   DAT.....FIL
42C9:0070  45 32 20 20 20 44 41 54-00 00 00 00 00 00 00 00 E2   DAT........
42C9:0080  15 20 66 69 6C 65 31 2E-64 61 74 20 66 69 6C 65 . file1.dat file
42C9:0090  32 2E 64 61 74 20 0D 74-20 66 69 6C 65 32 2E 64 2.dat .t file2.d
42C9:00A0  61 74 20 0D 00 00 00 00-00 00 00 00 00 00 00 00 at .............
42C9:00B0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................
42C9:00C0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................

    In this example, location DS:005CH contains an unopened FCB for file
    FILE1.DAT on the current drive. Location DS:006CH contains an unopened
    FCB for FILE2.DAT on the current drive. (The second FCB cannot be used
    where it is and must be moved to another location before the first FCB
    is opened.) Location DS:0080H contains the length of the command tail,
    15H (21) bytes. The next 21 bytes are the command tail prepared by
    DEBUG; they correspond exactly to what the command tail would be if
    the program had been loaded by COMMAND.COM instead of by DEBUG.

    The default FCBs and the command tail can also be set after the
    program has been loaded, by using the Name File or Command-Tail
    Parameters command, N. DEBUG treats the string of characters that
    follow the Name command as the command tail: If the first two
    parameters are filenames, they become the first and second FCBs,
    respectively. The Name command also places the string at DS:0081H,
    with the length of the string at DS:0080H. Entering the DEBUG command

    -N FILE1.DAT FILE2.DAT  &lt;Enter&gt;

    produces the same results as specifying the filenames in the command
    line. When employed in this manner, the Name command is useful for
    initializing command-tail data that was not in the command line or for
    changing the command-tail data to test different aspects of a program.
    (If files are named in this manner, they are not validated until the
    Load File or Sectors command, L, is used.) Note that the data
    following the Name command need not be filenames; it can be any
    parameters, data, or switches that the application program expects to
    see.

    More on breakpoints
    The case study at the beginning of this section used breakpoints in
    their simplest form: Only a single breakpoint was specified at a time
    and the execution address was considered to be the current IP. The Go
    command is also capable of setting multiple breakpoints and of
    beginning execution at any address in memory. The more general form of
    the Go command is

    G[=address] [address [address...]]

    If Go is used with no operands, execution begins at the current value
    of CS:IP and no breakpoints are set. If the =address operand is used,
    DEBUG sets IP to the address specified and execution then begins at
    the new CS:IP. The other optional addresses are breakpoints. When
    execution reaches one of these breakpoints, DEBUG stops and displays
    the system's registers. As many as 10 breakpoints can be set on one Go
    command, and they can be in any order.

    The breakpoint addresses must be on instruction boundaries because
    DEBUG replaces the instruction at each breakpoint address with an
    INT 03H instruction (0CCH). DEBUG saves the replaced instructions
    internally. When any breakpoint is reached, DEBUG stops execution and
    restores the instructions at all the breakpoints; if no breakpoint is
    reached, the instructions are not restored and the Load command must
    be used to reload the original program.

    The multiple-breakpoint feature of the Go command allows the tracing
    of program execution when branches exist in the code. When a program
    contains, for instance, a conditional jump on the zero flag, a
    breakpoint can be placed in each of the two possible branches. When
    the branch is reached, one of the two breakpoints will be encountered
    shortly thereafter. When DEBUG displays the breakpoint, the programmer
    knows which branch was taken. Moving through a program with
    breakpoints at key locations is faster than using the Trace command to
    execute each and every instruction.

    Multiple breakpoints can also be used to home in on a bad piece of
    code. This technique is particularly useful in those nasty situations
    when there are no symptoms except that the system locks up and must be
    restarted. When debugging a problem such as this, set breakpoints at
    each of the major sections of the program and then note those
    breakpoints that are executed successfully, continuing until the
    system locks up. The problem lies somewhere between the last
    successful breakpoint and the next breakpoint set. Now repeat the
    processes, setting breakpoints between the last breakpoint and the one
    that was never reached. By progressively narrowing the gap between
    breakpoints, the exact offending instruction can be isolated.

    Some general comments about the Go command and breakpoints:

    ■  After a program has reached completion and returned to MS-DOS, it
        must be reloaded with the Load command before it can be executed
        again. (DEBUG intercepts this return and displays Program
        terminated normally.)

    ■  Because DEBUG replaces program instructions with an INT 03H
        instruction to form breakpoints, the break address must be on an
        instruction boundary. If it is not, the INT 03H will be stuck in
        the middle of an instruction, causing strange and sometimes
        entertaining results.

    ■  Breakpoints cannot be set in data, because data is not executed.

    ■  The target program's SS:SP registers must point to a valid stack
        that has at least 6 bytes of stack space available. When the Go
        command is executed, it pushes the target program's flags and CS
        and IP registers onto the stack and then transfers control to the
        program with an IRET instruction. Thus, if the target program's
        stack is not valid or is too small, the system may crash.

    ■  Finally, and obviously, breakpoints cannot be set in read-only
        memory (the ROM BIOS, for instance).

    Using the Write commands
    After a program has been debugged, fixed, and tested with DEBUG, the
    temptation exists to write the patched program directly back to the
    disk as a .COM file. This action is sometimes legitimate, but only
    rarely. The technique will be explained in a moment, but first a
    sermon:

    DON'T DO IT.

    One of the greatest sadnesses in a programmer's life comes when, after
    a program has been running wonderfully, enhancements are made to the
    source code and the recompiled program suddenly has bugs in it that
    haven't been seen for months. Always make any debugging patches
    permanent in the source file immediately.

    Unless, of course, the source code is not available. This is the only
    time saving a patched program is permissible. For example, sometimes
    commercial programs require patching because the program does not
    quite fit the hardware it must run on or because bugs have been found
    in the program. The source of these patches is sometimes word-of-
    mouth, sometimes a bulletin-board service, and sometimes the program's
    manufacturer.

    Even when legitimate reasons exist to save patched code, precautions
    should be taken. Be very careful, meticulous, and alert as the patches
    are applied. Understand each step before undertaking it. Most
    important of all, always have a backup of the original unpatched
    program safely on a floppy disk.

    Use the Write command to write the program image to disk. A starting
    address can optionally be specified; otherwise the write starts at
    CS:0100H. The name of the file will be either the name specified in
    the last Name command or the name of the program from the DEBUG
    command line if the Name command has not been used. The number of
    bytes to be written is in BX and CX, with the most significant half in
    BX. These registers will have been loaded correctly when the program
    was loaded, but they should be checked if the program has executed
    since it was loaded.

    The .EXE and .HEX file types cannot be written to disk with the Write
    command. The command performs no formatting and only writes the binary
    image of memory to the disk file. Thus, all programs written with
    Write must be .COM files. The image of a .EXE or .HEX file can still
    be written as a .COM file provided no segment fixups are required and
    provided the other rules for a .COM file are followed. See PROGRAMMING
    IN THE MS-DOS ENVIRONMENT: PROGRAMMING FOR MS-DOS: Structure of an
    Application Program. (A segment fixup is a segment address that must
    be provided by the loader when the program is originally loaded.
    See PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING TOOLS:
    Object Modules.) If a .EXE file containing a segment fixup is written
    as a .COM file, the new file will execute correctly only when loaded
    at exactly the same address as the original file, and this is
    difficult to ensure for programs running under MS-DOS.

    If it is necessary to patch a .EXE or .HEX file and the exact
    addresses relative to the start of the file are known, use the
    following procedure:

    1. Rename (or better yet, copy) the file to an extension other than
        .EXE or .HEX.

    2. Load the program image into memory by placing the new name on
        DEBUG's command line. Note that the loaded file is an image of the
        disk file and is not executable.

    3. Modify the program image in memory, but never try to execute the
        program. Results would be unpredictable and the program image could
        be damaged.

    4. Write the modified image back to disk using a simple w. No other
        action is needed, because the original load will have set the
        filename and the correct length in BX and CX.

    5. Rename the file to a name with the correct .EXE or .HEX extension.
        The new name need not be the same as the original, but it should
        have the same extension.

    The same technique can be used to load, modify, and save data files.
    Simply make sure that the file does not have an extension of .COM,
    .EXE, or .HEX. The data file will be loaded at address CS:0100H.
    (DEBUG treats the file much the same as a .COM file.) After patching
    the data (the Enter command works best), use the Write command to
    write it back to the disk.

SYMDEB
    SYMDEB is an extension of DEBUG; virtually all the DEBUG commands and
    techniques still work as expected. The major new feature, and the
    source of the name SYMDEB, is symbolic debugging: SYMDEB can use all
    public labels in a program for reference, instead of using hexadecimal
    offset addresses. In addition, SYMDEB allows the use of line numbers
    for reference in compatible high-order languages; source-line display
    within SYMDEB is also possible for these languages. Currently, the
    languages supporting these options are Microsoft FORTRAN versions 3.0
    and later, Microsoft Pascal versions 3.0 and later, and Microsoft C
    versions 2.0 and later. Versions 4.0 and earlier of the Microsoft
    Macro Assembler (MASM) do not generate the data needed for line-number
    display and source-line debugging.

    In addition to symbolic debugging, SYMDEB has added several other new
    features and has expanded existing DEBUG features:

    ■  Breakpoints have been made more sophisticated with the addition of
        "sticky" breakpoints. Unlike the breakpoints set with the Go
        command, sticky breakpoints remain attached to the program
        throughout a SYMDEB session until they are explicitly removed.
        Specific commands are supplied for listing, removing, enabling, and
        disabling sticky breakpoints.

    ■  DEBUG's Display Memory command, D, has been extended so that data
        can be displayed in different formats.

    ■  Full redirection is supported.

    ■  A stack trace feature has been added.

    ■  Terminate-and-stay-resident programs are supported.

    ■  A shell escape command has been added to allow the execution of
        MS-DOS commands and programs without leaving SYMDEB and the
        debugging session.

    These additions allow more sophisticated debugging techniques to be
    used and, in some cases, also simplify locating problems. To see the
    advantages of using symbols and sticky breakpoints in debugging,
    consider a type of program that is one of the most difficult to de-
    bug--the TSR.

    Debugging TSRs with SYMDEB
    Terminate-and-stay-resident routines can be difficult to debug. They
    exist in two worlds and can have bugs associated with each. At the
    outset, they are usually simple programs that perform some
    initialization task and then exit. At this point, they are transformed
    into another type of beast entirely--resident routines that are more a
    part of the operating system than of any application program. Each
    form of the program must be debugged separately, using different
    techniques.

    The TSR routine used for this case study is the same one created
    previously to serve as external instrumentation to trace serial
    communications. The program was called COMMSCOP, but to avoid
    confusion of that working program with the broken one presented here,
    the name has been changed to BADSCOP. BADSCOP was assembled and linked
    in the usual manner and then converted to a .COM file using EXE2BIN.
    When it was installed, it returned normally, but at the first attempt
    to issue an Interrupt 14H, the system locked up completely. Warm
    booting was not sufficient to restore it, and a power-on cold boot was
    required to get the system working again.

    Figure 18-11 is a listing of BADSCOP. The only difference from
    COMMSCOP, aside from the errors, is the addition of two PUBLIC
    statements to make all the procedure names and the important data
    names available to SYMDEB.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-11. An incorrect version of the serial trace utility.

    ──────────────────────────────────────────────────────────────────────

    In order to use the symbolic debugging features of SYMDEB, a symbol
    file must be built in a specific format. The SYMDEB utility MAPSYM
    performs this function, using the contents of the .MAP file built by
    LINK. MAPSYM is easy to use because it has only two parameters: the
    .MAP file and the /L switch (which triggers verbose mode). The symbol
    table for BADSCOP is built as follows:

    C&gt;MAPSYM BADSCOP  &lt;Enter&gt;

    This operation produces a symbol file called BADSCOP.SYM.

    Armed with the .SYM file and the usual collection of listing and
    design notes, the programmer can begin the debugging process using
    SYMDEB.

    The first task is to discover if the BADSCOP TSR is installing
    correctly. To test this, run the .COM file under SYMDEB by typing

    C&gt;SYMDEB BADSCOP.SYM BADSCOP.COM  &lt;Enter&gt;

    Note the order in which operands are passed to SYMDEB--it is not the
    order that would be expected. All switches (none were used here) must
    immediately follow the word SYMDEB. These switches must be followed in
    turn by the fully qualified names of any symbol files (in this case,
    BADSCOP.SYM). Only then is the name of the file to be debugged given.
    If BADSCOP expected any parameters in the command tail, they would be
    last. This potential need for command-tail data is the reason the name
    of the file to be debugged follows the name of the symbol file. SYMDEB
    knows that the first non-.SYM file it encounters is the file to be
    loaded; the parameters that follow the filename may be of any form and
    number.

    When SYMDEB begins, it displays

    Microsoft (R) Symbolic Debug Utility  Version 4.00
    Copyright (C) Microsoft Corp 1984, 1985. All rights reserved.

    Processor is [80286]

    The debugger identifies itself and then notes the type of CPU it is
    running on--in this case, an Intel 80286. The Display or Modify
    Registers command, R, gives the same display that DEBUG gives, with
    one exception.

    -R  &lt;Enter&gt;
    AX=0000  BX=0000  CX=0133  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
    DS=1FD0  ES=1FD0  SS=1FD0  CS=1FD0  IP=0100   NV UP EI PL NZ NA PO NC
    CSEG:INITIALIZE:
    1FD0:0100 E90701         JMP  VECTOR_INIT

    The instruction at CS:IP, JMP, is now preceded by the information that
    the instruction is at label INITIALIZE within segment CSEG. An exam-
    ination of Figure 18-11 shows that this is indeed the case.

    To check that all the symbols requested with the PUBLIC statement are
    present, use the X?* form of the Examine Symbol Map command.

    -X?*  &lt;Enter&gt;

    CSEG: (1FD0)
    0100 INITIALIZE   0103 OLD_COMM_INT 0107 COUNT         0109 STATUS
    010A PORT         010B BUFPNTR      010D COMMSCOPE     018F CONTROL
    020A VECTOR_INIT

    The display shows that the value of CSEG (1FD0H) matches the current
    value of CS. The offset values shown for the procedure names and data
    names match the numbers from an assembled listing. Because this is a
    .COM file, there is only one segment. If there had been other
    segments--a data segment, for instance--they would have been shown
    with their values and associated labels and offsets.

    The purpose of this test is to determine whether the problems this
    program is having are caused by an incorrect installation. First, use
    the Trace Program Execution command, T, to trace through the first few
    steps.

-T7  &lt;Enter&gt;
AX=0000  BX=0000  CX=0133  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=1FD0  ES=1FD0  SS=1FD0  CS=1FD0  IP=020A   NV UP EI PL NZ NA PO NC
CSEG:VECTOR_INIT:
1FD0:020A B435           MOV  AH,35                         ;'5'
AX=3500  BX=0000  CX=0133  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=1FD0  ES=1FD0  SS=1FD0  CS=1FD0  IP=020C   NV UP EI PL NZ NA PO NC
1FD0:020C B014           MOV  AL,14
AX=3514  BX=0000  CX=0133  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=1FD0  ES=1FD0  SS=1FD0  CS=1FD0  IP=020E   NV UP EI PL NZ NA PO NC
1FD0:020E CD21           INT  21  ;Get Interrupt Vector
AX=3514  BX=1375  CX=0133  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=0210   NV UP EI PL NZ NA PO NC
1FD0:0210 891E0301       MOV  [OLD_COMM_INT],BX                DS:0103=0000
AX=3514  BX=1375  CX=0133  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=0214   NV UP EI PL NZ NA PO NC
1FD0:0214 8CC0           MOV  AX,ES
AX=1567  BX=1375  CX=0133  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=0216   NV UP EI PL NZ NA PO NC
1FD0:0216 A30501         MOV  [OLD_COMM_INT+02 (0105)],AX      DS:0105=0000
AX=1567  BX=1375  CX=0133  DX=0000  SP=FFFE  BP=0000  SI=0000  DI=0000
DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=0219   NV UP EI PL NZ NA PO NC
1FD0:0219 BA0D01         MOV  DX,010D

    This part of the program uses Interrupt 21H Function 35H to obtain the
    current vector for Interrupt 14H. Note that, unlike DEBUG, SYMDEB
    coasts right through an Interrupt 21H call with no problems. It not
    only knows enough not to make the call but also displays the type of
    function call being made, based on the value in AH.

    To make sure that the correct vector for the old Interrupt 14H handler
    has been stored, use the Display Doublewords command, DD, in
    conjunction with a symbol name.

    -DD OLD_COMM_INT L1  &lt;Enter&gt;
    1FD0:01030  1567:1375

    This is the correct vector address (1567:1375H). Now trace through
    the next part of the program, which establishes the new vectors for
    interrupts.

    -T8  &lt;Enter&gt;
    AX=1567  BX=1375  CX=0133  DX=010D  SP=FFFE  BP=0000  SI=0000  DI=0000
    DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=021C   NV UP EI PL NZ NA PO NC
    1FD0:021C B425           MOV  AH,25                         ;'%'
    AX=2567  BX=1375  CX=0133  DX=010D  SP=FFFE  BP=0000  SI=0000  DI=0000
    DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=021E   NV UP EI PL NZ NA PO NC
    1FD0:021E B014           MOV  AL,14
    AX=2514  BX=1375  CX=0133  DX=010D  SP=FFFE  BP=0000  SI=0000  DI=0000
    DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=0220   NV UP EI PL NZ NA PO NC
    1FD0:0220 CD21           INT  21  ;Set Vector
    AX=2514  BX=1375  CX=0133  DX=010D  SP=FFFE  BP=0000  SI=0000  DI=0000
    DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=0222   NV UP EI PL NZ NA PO NC
    1FD0:0222 BA8F01         MOV  DX,018F
    AX=2514  BX=1375  CX=0133  DX=018F  SP=FFFE  BP=0000  SI=0000  DI=0000
    DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=0225   NV UP EI PL NZ NA PO NC
    1FD0:0225 B425           MOV  AH,25                         ;'%'
    AX=2514  BX=1375  CX=0133  DX=018F  SP=FFFE  BP=0000  SI=0000  DI=0000
    DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=0227   NV UP EI PL NZ NA PO NC
    1FD0:0227 B060           MOV  AL,60                         ;'`'
    AX=2560  BX=1375  CX=0133  DX=018F  SP=FFFE  BP=0000  SI=0000  DI=0000
    DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=0229   NV UP EI PL NZ NA PO NC
    1FD0:0229 CD21           INT  21  ;Set Vector
    AX=2560  BX=1375  CX=0133  DX=018F  SP=FFFE  BP=0000  SI=0000  DI=0000
    DS=1FD0  ES=1567  SS=1FD0  CS=1FD0  IP=022B   NV UP EI PL NZ NA PO NC
    1FD0:022B B80031         MOV  AX,3100

    Examination of these trace steps shows that all went normally. The new
    Interrupt 14H vector has been established at COMMSCOPE; the vector for
    the new Interrupt 60H has also been correctly installed. Use the Go
    command, G, to allow the program to continue to termination and then
    use the Quit command, Q, to exit SYMDEB.

    -G  &lt;Enter&gt;

    Program terminated and stayed resident (0)
    -Q  &lt;Enter&gt;

    SYMDEB displays the information that the program terminated with a
    completion code of zero and stayed resident. This is as it should be,
    and the conclusion is that the installation portion of this TSR is
    running properly. The problem must be in the real-time execution of
    the program.

    Debugging the resident portion of a TSR is complicated but not
    especially difficult. A simple program is used to exercise the TSR,
    and it is this program that is debugged. As this driver program
    exercises the TSR, the tracing process continues into the resident
    routine.

    Because symbol tables exist for the TSR, symbolic debugging can be
    used to follow its execution.

    The driver program will be TESTCOMM, shown in Figure 18-10. To make
    the program more easily usable by SYMDEB, one line has been added
    before the first SEGMENT statement:

    PUBLIC     BEGIN,MAINLOOP,SENDCOMM,TESTCOMM

    Using the .MAP file produced by LINK, the MAPSYM routine creates
    TESTCOMM.SYM. TESTCOMM can now be invoked with two symbol files:

    C&gt;SYMDEB TESTCOMM.SYM BADSCOP.SYM TESTCOMM.EXE  &lt;Enter&gt;

    SYMDEB will load both symbol files and then load TESTCOMM.EXE. Be-
    cause the name of the TESTCOMM.SYM file matches the name of the pro-
    gram being loaded, SYMDEB makes TESTCOMM.SYM the active symbol file.

    Use the Register command to show that the test program was properly
    loaded.

    -R  &lt;Enter&gt;
    AX=0000  BX=0000  CX=0133  DX=0000  SP=0100  BP=0000  SI=0000  DI=0000
    DS=38EE  ES=38EE  SS=38FE  CS=390E  IP=0000   NV UP EI PL NZ NA PO NC
    CSEG:BEGIN:
    390E:0000 1E             PUSH     DS

    Then use the Examine Symbol Map command to determine whether the
    symbol files were loaded correctly. The form X* lists all the symbol
    maps and their segments; the form X?* lists all the symbols for the
    current symbol map and segment.

    -X*  &lt;Enter&gt;
    [38FE TESTCOMM]
        [390E CSEG]
    0000 BADSCOP
            0000 CSEG
    -X?*  &lt;Enter&gt;

    CSEG: (390E)
    0000 BEGIN    0004 MAINLOOP 0011 SENDCOMM 0018 TESTCOMM

    The current symbol map and segment are shown in square brackets. The
    symbol map for BADSCOP is also present but not selected. Note that
    there are no values associated with BADSCOP in the listing produced by
    the X?* command, because all the symbols currently available to SYMDEB
    are shown and only the symbols in TESTCOMM's CSEG are available (that
    is, TESTCOMM.SYM is the only active symbol file).

    Recall that the BADSCOP TSR loaded normally but locked the system up
    at the first attempt to issue an Interrupt 14H. This behavior
    indicates that the problem is associated with an Interrupt 14H call.
    TESTCOMM repeatedly makes the system fail, but which of the Interrupt
    14H calls within TESTCOMM is causing the trouble is not known. The
    most straightforward approach would be to put a breakpoint just before
    each Interrupt 14H instruction. Use the Disassemble (Unassemble)
    command, U, to find the location of all Interrupt 14H calls.

    -U MAINLOOP L19  &lt;Enter&gt;
    CSEG:MAINLOOP:
    390E:0004 B406           MOV  AH,06
    390E:0006 B2FF           MOV  DL,FF
    390E:0008 CD21           INT  21
    390E:000A 740C           JZ   TESTCOMM
    390E:000C 3C03           CMP  AL,03
    390E:000E 7501           JNZ  SENDCOMM
    390E:0010 CB             RETF
    CSEG:SENDCOMM:
    390E:0011 B401           MOV  AH,01
    390E:0013 BA0000         MOV  DX,BADSCOP!CSEG
    390E:0016 CD14           INT  14
    CSEG:TESTCOMM:
    390E:0018 B403           MOV  AH,03
    390E:001A BA0000         MOV  DX,BADSCOP!CSEG
    390E:001D CD14           INT  14
    390E:001F 80E401         AND  AH,01
    390E:0022 74E0           JZ   MAINLOOP
    390E:0024 B402           MOV  AH,02
    390E:0026 BA0000         MOV  DX,BADSCOP!CSEG
    390E:0029 CD14           INT  14
    390E:002B B406           MOV  AH,06
    390E:002D 8AD0           MOV  DL,AL
    390E:002F CD21           INT  21
    390E:0031 EBD1           JMP  MAINLOOP

    The Disassemble request starts at MAINLOOP and acts on the next 25
    (19H) instructions. SYMDEB displays symbol names instead of numbers
    whenever it can. However, it does get confused from time to time, so a
    grain of salt might be needed when reading the disassembly. Notice,
    for instance, the MOV DX,0 instructions at offsets 13H, 1AH, and 26H.
    SYMDEB has decided that what is being moved is not zero, but
    BADSCOP!CSEG. (The ! identifies a mapname in the same way a : defines
    a segment.) In this case, SYMDEB searched its map tables for an
    address of zero and found one at CSEG in BADSCOP. This segment has the
    address of zero because it has not been initialized.

    Ignoring the name confusions, the disassembly clearly shows the three
    INT 14H instructions at offsets 16H, 1DH, and 29H. Use the Set
    Breakpoints command, BP, to set a sticky, or permanent, breakpoint at
    each of these locations. In this way, any Interrupt 14H call issued by
    TESTCOMM will be intercepted before it executes. Use the List
    Breakpoints command, BL, to verify the breakpoints.

    -BP 16  &lt;Enter&gt;
    -BP 1D  &lt;Enter&gt;
    -BP 29  &lt;Enter&gt;
    -BL  &lt;Enter&gt;
    0 e 390E:0016 [CSEG:SENDCOMM+05 (0016)]
    1 e 390E:001D [CSEG:TESTCOMM+05 (001D)]
    2 e 390E:0029 [CSEG:TESTCOMM+11 (0029)]

    The List Breakpoints command shows that breakpoint 0 is enabled
    and set to SENDCOMM+05, or CS:0016H. Likewise, breakpoint 1 is at
    CS:001DH and breakpoint 2 is at CS:0029H. It is important to trap
    on an Interrupt 14H so that the subsequent actions of the Interrupt
    14H service routine can be traced. Now allow the program to execute
    until it encounters a breakpoint.

    -G  &lt;Enter&gt;
    AX=0300  BX=0000  CX=0133  DX=0000  SP=00FC  BP=0000  SI=0000  DI=0000
    DS=38EE  ES=38EE  SS=38FE  CS=390E  IP=001D   NV UP EI PL ZR NA PE NC
    390E:001D CD14           INT     14                            ;BR1

    The first Interrupt 14H encountered is the one at the second
    breakpoint, breakpoint 1, as can be seen from the address at which
    execution broke. Also, SYMDEB was kind enough to include the comment
    ;BR1 on the disassembled line, indicating that this is Break Request
    1. The instruction at this location is a request for serial port
    status (AH = 3) and the registers are loaded correctly. Execution can
    now be passed to the TSR by simply executing the current instruction.
    (Remember that the instruction displayed at a breakpoint has not yet
    been executed.)

-T  &lt;Enter&gt;
AX=0300  BX=0000  CX=0133  DX=0000  SP=00F6  BP=0000  SI=0000  DI=0000
DS=38EE  ES=38EE  SS=38FE  CS=1FD0  IP=010D   NV UP DI PL ZR NA PE NC
1FD0:010D 2EF606090101   TEST       Byte Ptr CS:[0109],01        CS:0109=00

    The single Trace command has moved execution into the TSR. Note that
    the Interrupt 14H has changed the value of CS and jumped to location
    10DH off the new CS. This location contains the first instruction of
    the COMMSCOPE procedure in the TSR. SYMDEB does not know that a
    different segment is being executed and must be instructed to use a
    different map table. Use the Open Symbol Map command, XO, to do this,
    instructing SYMDEB to set the active map table to BADSCOP!.

    -XO BADSCOP!  &lt;Enter&gt;
    -X?*  &lt;Enter&gt;

    CSEG: (0000)
    0100 INITIALIZE   0103 OLD_COMM_INT 0107 COUNT         0109 STATUS
    010A PORT         010B BUFPNTR      010D COMMSCOPE     018F CONTROL
    020A VECTOR_INIT

    The X?* command shows that the BADSCOP symbols are now the current
    map. They are not usable, however, because the value of CSEG--zero--
    needs to be changed to the current CS register. To correct this, use
    the SYMDEB Set Symbol Value command, Z. This command can set any
    symbol in the current map table to any value; the value can be a
    number, another symbol, or the contents of a register. In this case,
    set the value of CSEG in BADSCOP! to the current contents of the CS
    register.

    -Z CSEG CS  &lt;Enter&gt;
    -X*  &lt;Enter&gt;
    38FE TESTCOMM
            390E CSEG
    [0000 BADSCOP]
        [1FD0 CSEG]

    The X* command confirms that BADSCOP! is now the selected symbol map
    and that the CSEG within it has the value 1FD0H. The CSEG segment in
    TESTCOMM is an entirely different entity and still has its correct
    value, which will be valid when the TSR returns.

    With the symbols set, the debugging can begin by tracing the first few
    instructions. Because COMMSCOPE is not currently active, the routine
    should quickly pass the processing on to the old interrupt handler.

-T5  &lt;Enter&gt;
AX=0300  BX=0000  CX=0133  DX=0000  SP=00F6  BP=0000  SI=0000  DI=0000
DS=38EE  ES=38EE  SS=38FE  CS=1FD0  IP=0113   NV UP DI PL ZR NA PE NC
1FD0:0113 7476           JZ  COMMSCOPE+7E (018B)
AX=0300  BX=0000  CX=0133  DX=0000  SP=00F6  BP=0000  SI=0000  DI=0000
DS=38EE  ES=38EE  SS=38FE  CS=1FD0  IP=018B   NV UP DI PL ZR NA PE NC
1FD0:018B FF2E0301       JMP  FAR [0103]                       DS:0103=0000
AX=0300  BX=0000  CX=0133  DX=0000  SP=00F6  BP=0000  SI=0000  DI=0000
DS=38EE  ES=38EE  SS=38FE  CS=0000  IP=0000   NV UP DI PL ZR NA PE NC
0000:0000 381E6715       CMP  [1567],BL                         DS:1567=00
AX=0300  BX=0000  CX=0133  DX=0000  SP=00F6  BP=0000  SI=0000  DI=0000
DS=38EE  ES=38EE  SS=38FE  CS=0000  IP=0004   NV UP DI PL ZR NA PE NC
0000:0004 BC2CE1         MOV  SP,E12C
AX=0300  BX=0000  CX=0133  DX=0000  SP=E12C  BP=0000  SI=0000  DI=0000
DS=38EE  ES=38EE  SS=38FE  CS=0000  IP=0007   NV UP DI PL ZR NA PE NC
0000:0007 2F             DAS

    STATUS is tested with a mask of 01H at CS:010DH; the test sets the
    zero flag, indicating that tracing is disabled. The JZ to
    COMMSCOPE+7E (CS:018BH) is taken. At this address is a far jump to
    the old Interrupt 14H handler at 1567:1375H. The jump is taken and
    then disaster strikes. Instead of going to the correct address,
    processing is suddenly at 0000:0000H. Any wild jump is dangerous, but
    a far jump into low memory is exceptionally so. This explains the
    system's locking up and requiring a cold boot to recover.

    Now that the bug has been caught in the act, it should be a simple
    matter to determine what went wrong. When the BADSCOP TSR installed
    itself, it was seen to place the correct offset address at 0103H. Yet
    whenever the resident portion of the TSR tries to use the value at
    that address, it finds all zeros. The initialization routine placed
    the address at the symbol OLD_COMM_INT (1FD0:0103H). If that location
    is examined, the following is found:

    -DD OLD_COMM_INT L1  &lt;Enter&gt;
    1FD0:0103  1567:1375

    This is the correct address. Why, then, did the programs find zero
    there? Use the Display Doublewords command to look at the same memory
    location again, this time using the specific address 0103H rather than
    a program symbol.

    -DD 103 L1  &lt;Enter&gt;
    38EE:0103  0000:0000

    The dump of OLD_COMM_INT looked at 1FD0:0103H, but the simple dump
    looked at 38EE:0103H. The explanation is clear when the values of the
    registers just before the far jump are examined. The CS register
    contains 1FD0H and the DS register contains 38EEH.

    This is the problem--there is a missing CS override on the indirect
    jump command. When the TSR installed itself, CS and DS were the same
    because it was a .COM file. When the TSR is entered as the result of
    an interrupt call, only CS is set; DS remains what it was in the
    calling program. Without an override, the CPU assumed that the address
    of the destination of the far call was located at offset 103H from the
    DS register. This offset, unfortunately, contained zeros, and the
    program locked up the system.

    The problem is now easily corrected. Exit SYMDEB with the Quit command
    and edit the program source so that the offending line reads

    OLD_JUMP:
            JMP     CS:OLD_COMM_INT

    Debugging C programs with SYMDEB
    One of SYMDEB's finest features is the ability to debug with source-
    line data from programs written in Microsoft C, Pascal, and FORTRAN.
    The actual lines of C or FORTRAN can be included in the debugging
    display, and the addresses for breakpoints show which line of code the
    breakpoints are in. Combined with symbolic debugging, these features
    provide a powerful tool that can significantly reduce debugging time
    for programs written in a supported language.

    The following rather complicated case illustrates SYMDEB at its best.
    The program BADSCOP from the previous example was not completely
    debugged. Although the patch to the BADSCOP code at OLD_JUMP: did
    correct the disastrous problem that caused the system to lock up,
    running the program in a realistic test situation reveals that a
    subtle problem still remains that might be in either BADSCOP or one of
    the support programs.

    Before we investigate the problem, a quick review of the programs in
    the COMMSCOP system is in order. At the heart of the system is the
    Interrupt 14H intercept program COMMSCOP. When executed, this program
    installs itself as a TSR and intercepts all Interrupt 14H calls. (The
    incorrect version of the COMMSCOP program is called BADSCOP.) The
    installed COMMSCOP TSR passes all Interrupt 14H calls on to the real
    service routine in the ROM BIOS until it is commanded to start
    tracing. The COMMSCMD routine controls tracing. This control routine
    can request that COMMSCOP start, stop, or resume tracing for a
    specific serial port. These commands are facilitated through Interrupt
    60H, which is recognized by the COMMSCOP TSR as a command request.
    When tracing is started, the trace buffer is emptied by zeroing the
    trace count and setting the buffer pointer to the first buffer
    location. When tracing is stopped by COMMSCMD's STOP command, a marker
    is placed in the buffer to indicate the end of a trace segment.
    Tracing can be resumed with COMMSCMD's RESUME command. Resuming a
    trace preserves collected data and places new trace data after the
    marker in the trace buffer. The RESUME command differs from the START
    command in that the buffer is not emptied.

    Now the problem: When the serial data tracing is started with COMMSCMD
    (see Figure 18-5), data is collected normally. When COMMSCMD issues a
    STOP command and the data is displayed with COMMDUMP (see Figure
    18-7), the data appears normal. The traced data ends with a stop mark
    just as it should. However, the RESUME command of COMMSCMD causes the
    stop mark to be overwritten with collected data. After this, whenever
    COMMDUMP displays data an extra byte appears at the end of the data.
    The problem could be with either BADSCOP or COMMSCMD. SYMDEB has the
    facilities to debug both the routines at once.

    The first step in the debugging process is, as usual, to gather all
    the listings and design documentation. As a part of this process, the
    symbol tables needed for SYMDEB must be prepared. The process of
    preparing a symbol table for BADSCOP has already been explained;
    however, preparing the SYMDEB input and supporting listings for a C
    program is slightly more complicated.

    First, when the C program is compiled, three switches must be
    specified. (C switches are case sensitive and must be entered exactly
    as shown.)

    C&gt;MSC /Fc /Zd /Od COMMSCMD;  &lt;Enter&gt;

    The /Zd switch produces an object file containing line-number
    information that corresponds to the line numbers of the source file.
    The /Od switch disables optimization that involves complex code
    rearrangement; localized optimization, peephole optimization, and
    other simple forms of optimization are still performed. The /Od switch
    is not required, but code rearrangement can make the resulting object
    code more difficult to debug.

    The /Fc switch invokes a feature of C that is especially important for
    debugging with SYMDEB: a listing that contains the C source lines and
    the generated assembler code intermixed. The file is a .COD file; the
    command line shown above would produce the file COMMSCMD.COD. Figure
    18-12 shows the contents of COMMSCMD.COD.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-12. COMMSCMD.COD.

    ──────────────────────────────────────────────────────────────────────

    After the C program is compiled, it must be linked using the /LI
    switch to indicate that the line number information is to be
    maintained:

    C&gt;LINK COMMSCMD /MAP /LI;  &lt;Enter&gt;

    The /MAP switch is still required to generate a map file of public
    names for use in building the symbol file, which is created in the
    usual manner:

    C&gt;MAPSYM COMMSCMD  &lt;Enter&gt;

    Everything needed to debug COMMSCMD and BADSCOP is now available. The
    first test is an attempt to start tracing. To invoke SYMDEB, type

    C&gt;SYMDEB COMMSCMD.SYM BADSCOP.SYM COMMSCMD.EXE START 1  &lt;Enter&gt;

    SYMDEB first loads the symbol files for COMMSCMD and BADSCOP and then
    loads the .EXE file for COMMSCMD. BADSCOP is already in memory, having
    been loaded by simply running it. (It then stays resident.) The last
    two entries in the command line load the command tail for COMMSCMD
    with a start request for COM1. SYMDEB responds with

    Microsoft (R) Symbolic Debug Utility  Version 4.00
    Copyright (C) Microsoft Corp 1984, 1985. All rights reserved.

    Processor is [80286]

    Use the Register and Examine Symbol Map commands to display the
    initial register values and symbol table information.

-R  &lt;Enter&gt;
AX=0000  BX=0000  CX=1928  DX=0000  SP=0800  BP=0000  SI=0000  DI=0000
DS=2CA0  ES=2CA0  SS=2E85  CS=2CB0  IP=010F   NV UP EI PL NZ NA PO NC
_TEXT:__astart:
2CB0:010F B430           MOV  AH,30                         ;'0'
-X*  &lt;Enter&gt;
[2CB0 COMMSCMD]
    [2CB0 _TEXT]
    2E08 DGROUP
0000 BADSCOP
    0000 CSEG
-X?*  &lt;Enter&gt;
9876 __acrtused    9876 __acrtmsg
_TEXT: (2CB0)
0010 _main         00F6 _atoi
00F9 __chkstk      010F __astart      01AB __cintDIV     01AE __amsg_exit
01B9 _int86        023A _printf       0270 _strcmpi      0270 _stricmp
02C2 __stbuf       0361 __ftbuf       03E7 __catox       043C __nullcheck
0458 __cinit       0507 _exit         051E __exit        054A __ctermsub
0572 __dosret0     057A __dosretax    0586 __maperror    05BA __NMSG_TEXT
05EA __NMSG_WRITE  0613 __output      0E22 __setargv     0F07 __setenvp
0F6D __flsbuf      1098 __fassign     1098 __cropzeros   1098 __positive
1098 __forcdecpt   1098 __cfltcvt     109B _fflush       1103 _isatty
1125 __myalloc     1167 _strlen       1182 _ultoa        118C __fptrap
1192 _flushall     11C3 _free         11C3 __nfree       11D1 _malloc
11D1 __nmalloc     1217 _write        12F1 __cltoasub    12FD __cxtoa
1351 __amalloc     1432 __amexpand    146C __amlink      148E __amallocbrk
14AD _brkctl
DGROUP: (2E08)
0094 STKHQQ        0096 __asizds      0098 __atopsp
009A __abrktb      00EA __abrktbe     00EA __abrkp       00EC __iob
018C __iob2        0204 __lastiob     0212 __aintdiv     0216 __fac
021E _errno        0220 __umaskval    0222 __pspadr      0224 __psp
0226 __osmajor     0226 __dosvermajor 0227 __osminor     0227 __dosverminor
0228 __oserr       0228 __doserrno    022A __osfile      023E ___argc
0240 ___argv       0242 _environ      0244 __child       0246 __csigtab
0278 __cflush      027A __asegds      0286 __aseg1       0288 __asegn
028A __asegr       028C __amblksiz    0292 __fpinit      03A8 _edata
03D0 __bufout      05D0 __bufin       07D0 _end

    The Register command shows that the first instruction to be executed
    will be at symbol astart in the _TEXT segment. (Note that C puts a
    single underscore in front of all public library and routine names; a
    double underscore indicates routines for C's internal use.) The
    Examine Symbol Map command reveals that the symbol map COMMSCMD! has
    two segments, _TEXT and DGROUP, with _TEXT currently selected. The
    segment in BADSCOP!, CSEG, has no value assigned to it because SYMDEB
    doesn't know where it is; one of the debugging tasks is to determine
    the location of CSEG.

    C places initialization and preamble code at the front of its object
    modules. This code can be skipped during debugging, so this example
    begins at the label _main. Examination of the code at this label using
    the Disassemble command reveals the following:

    -U _main  &lt;Enter&gt;
    commscmd.C
    29:  int argc;
    _TEXT:_main:
    2CB0:0010 55             PUSH     BP
    2CB0:0011 8BEC           MOV      BP,SP
    2CB0:0013 B82200         MOV      AX,0022
    2CB0:0016 E8E000         CALL     __chkstk
    2CB0:0019 57             PUSH     DI

    This disassembly shows the way source-line information is displayed.
    These instructions are generated by line 29 of COMMSCMD.C. When the
    disassembly is compared with the listing in Figure 18-12, the same
    instructions are seen. However, their addresses are different. The
    addresses in the disassembly are relative to the start of the segment
    _TEXT, but the addresses in the listing are relative to the start of
    _main. SYMDEB allows address references to be made relative to a
    symbol, so breakpoints can be set as displacements from _main and the
    addresses shown in the listing can be used.

    Because the location of the problem being debugged is not known,
    breakpoints must be placed strategically throughout COMMSCMD to trace
    the execution of the program. Use the Set Breakpoints command to set
    the breakpoints.

    -BP _main+1e  &lt;Enter&gt;
    -BP _main+36  &lt;Enter&gt;
    -BP _main+56  &lt;Enter&gt;
    -BP _main+76  &lt;Enter&gt;
    -BP _main+7b  &lt;Enter&gt;
    -BP _main+9c  &lt;Enter&gt;
    -BP _main+b7  &lt;Enter&gt;
    -BP _main+e5  &lt;Enter&gt;
    -BL  &lt;Enter&gt;
    0 e 2CB0:002E [_TEXT:_main+1E (002E)] commscmd.C:41
    1 e 2CB0:0046 [_TEXT:_main+36 (0046)] commscmd.C:42
    2 e 2CB0:0066 [_TEXT:_main+56 (0066)] commscmd.C:44
    3 e 2CB0:0086 [_TEXT:_main+76 (0086)] commscmd.C:46
    4 e 2CB0:008B [_TEXT:_main+7B (008B)] commscmd.C:49
    5 e 2CB0:00AC [_TEXT:_main+9C (00AC)] commscmd.C:53
    6 e 2CB0:00C7 [_TEXT:_main+B7 (00C7)] commscmd.C:58
    7 e 2CB0:00F5 [_TEXT:_main+E5 (00F5)] commscmd.C:63

    The List Breakpoints command shows the breakpoint addresses in three
    ways: first the absolute segment:offset address, then the displacement
    from the label _main, and finally the line number in COMMSCMD.C.

    The first part of the COMMSCMD program decodes the arguments and sets
    the appropriate values for cmd and port. If there are no arguments,
    this decoding is skipped; if there are arguments, the decoding begins
    at line 41, so the first breakpoint is set there. If the criterion of
    line 41 is met (the first argument is STOP), then line 42 is executed.
    The second breakpoint is set there. Reaching the second breakpoint
    means that a STOP command was properly decoded. If the command was not
    STOP, execution continues at line 43. If this test is passed, line 44
    is executed. This is the location of the third breakpoint. If the test
    at line 44 fails but the one at line 45 is passed, then the breakpoint
    at line 46 is executed. Whether or not one of the tests passes,
    execution ends up at line 49. At this point, the program tests for the
    presence of a second operand. If there is a second operand, execution
    traps at line 53, where the program decrements the port number to put
    it in the proper form for the Interrupt 60H handler. Execution will
    then always stop in line 58, just before the call to _int86. (_int86
    is a library routine that loads registers and executes INT
    instructions.)

    When the program is run with START 1 in the command tail, it gives the
    following results:

G  &lt;Enter&gt;
AX=0022  BX=0F82  CX=0019  DX=0098  SP=0F7E  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=002E   NV UP EI PL NZ NA PO NC
41:               if (0 == stricmp(argv[1],"STOP"))
2CB0:002E B83600         MOV        AX,0036                        ;BR0
-G  &lt;Enter&gt;
AX=0000  BX=415A  CX=0000  DX=0098  SP=0F7E  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=0066   NV UP EI PL ZR NA PE NC
44:                      cmd = 1;
2CB0:0066 C746FC0100     MOV        Word Ptr [BP-04],0001         ;BR2
                                                            SS:0FA0=0000
-G  &lt;Enter&gt;
AX=0000  BX=415A  CX=0000  DX=0098  SP=0F7E  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=008B   NV UP EI PL ZR NA PE NC
49:           if (argc == 3)
2CB0:008B 837E0403       CMP       Word Ptr [BP+04],+03          ;BR4
                                                            SS:0FA8=0003
-G  &lt;Enter&gt;
AX=0001  BX=00D0  CX=0000  DX=0000  SP=0F7E  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=00AC   NV UP EI PL NZ NA PO NC
5             port = port-1;
2CB0:00AC FF4EFA         DEC        Word Ptr [BP-06]              ;BR5
                                                            SS:0F9E=0001
-G  &lt;Enter&gt;
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F78  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=00C7   NV UP EI PL ZR NA PE NC
2CB0:00C7 E8EF00         CALL      _int86                        ;BR6

    The first break occurs at line 41, indicating that one or more
    arguments were present in the command line. The next break is at line
    44, where the program sets the cmd code for Interrupt 60H to 1, the
    correct value for a start request. The next break occurs at line 49,
    where the program checks the number of arguments. If this number is 3,
    then there is a second argument in the command line. (Remember that,
    in C, the first argument is the name of the routine, so an argument
    count of 3 actually means that there are 2 arguments present.) The
    number of arguments is at BP+04, or SS:0FA8H, and it is indeed 3.
    Therefore, the next break is at line 53. The program decrements the
    current value of port, leaving a value of 0, which is what Interrupt
    60H expects to see for COM1.

    Continuing execution causes a break just before the call to _int86. To
    validate that the Interrupt 60H call is being made correctly, set a
    breakpoint just before the INT 60H instruction is issued.
    Unfortunately, no listing of _int86 is available, so no alternative
    exists but to trace the execution of the routine until the INT
    instruction is issued. The details of the processing are of no
    interest to this debugging session, so they can be ignored until an
    INT 60H is seen. (The trace offers a great deal of information about
    how C interfaces with subroutines. Studying the trace would be
    educational but is beyond the scope of this example.)

-T 5  &lt;Enter&gt;
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F76  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01B9   NV UP EI PL ZR NA PE NC
_TEXT:_int86:
2CB0:01B9 55             PUSH     BP
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F74  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01BA   NV UP EI PL ZR NA PE NC
2CB0:01BA 8BEC           MOV     BP,SP
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F74  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01BC   NV UP EI PL ZR NA PE NC
2CB0:01BC 56             PUSH     SI
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F72  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01BD   NV UP EI PL ZR NA PE NC
2CB0:01BD 57             PUSH     DI
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F70  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01BE   NV UP EI PL ZR NA PE NC
2CB0:01BE 83EC0A         SUB     SP,+0A
-T 5  &lt;Enter&gt;
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01C1   NV UP EI PL NZ AC PE NC
2CB0:01C1 C646F6CD       MOV     Byte Ptr [BP-0A],CD                SS:0F6A=BE
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01C5   NV UP EI PL NZ AC PE NC
2CB0:01C5 8B4604         MOV     AX,[BP+04]                         SS:0F78=0060
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01C8   NV UP EI PL NZ AC PE NC
2CB0:01C8 8846F7         MOV     [BP-09],AL                         SS:0F6B=01
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01CB   NV UP EI PL NZ AC PE NC
2CB0:01CB 3C25           CMP     AL,25                         ;'%'
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01CD   NV UP EI PL NZ AC PO NC
2CB0:01CD 740A           JZ     _int86+20 (01D9)
-T 5  &lt;Enter&gt;
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01CF   NV UP EI PL NZ AC PO NC
2CB0:01CF 3C26           CMP     AL,26                         ;'&amp;'
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01D1   NV UP EI PL NZ AC PE NC
2CB0:01D1 7406           JZ     _int86+20 (01D9)
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01D3   NV UP EI PL NZ AC PE NC
2CB0:01D3 C646F8CB       MOV     Byte Ptr [BP-08],CB                SS:0F6C=B0
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01D7   NV UP EI PL NZ AC PE NC
2CB0:01D7 EB0C           JMP     _int86+2C (01E5)
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01E5   NV UP EI PL NZ AC PE NC
2CB0:01E5 8C56F4         MOV     [BP-0C],SS                         SS:0F68=0F74
-T 5  &lt;Enter&gt;
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01E8   NV UP EI PL NZ AC PE NC
2CB0:01E8 8D46F6         LEA     AX,[BP-0A]                         SS:0F6A=60CD
AX=0F6A  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01EB   NV UP EI PL NZ AC PE NC
2CB0:01EB 8946F2         MOV     [BP-0E],AX                         SS:0F66=0060
AX=0F6A  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01EE   NV UP EI PL NZ AC PE NC
2CB0:01EE 8B7E06         MOV     DI,[BP+06]                         SS:0F7A=0F82
AX=0F6A  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=0F82
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01F1   NV UP EI PL NZ AC PE NC
2CB0:01F1 8B05           MOV     AX,[DI]                            DS:0F82=0100
AX=0100  BX=00D0  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=0F82
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01F3   NV UP EI PL NZ AC PE NC
2CB0:01F3 8B5D02         MOV     BX,[DI+02]                         DS:0F84=0000
-T 5  &lt;Enter&gt;
AX=0100  BX=0000  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=0F82
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01F6   NV UP EI PL NZ AC PE NC
2CB0:01F6 8B4D04         MOV     CX,[DI+04]                         DS:0F86=0000
AX=0100  BX=0000  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=0F82
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01F9   NV UP EI PL NZ AC PE NC
2CB0:01F9 8B5506         MOV     DX,[DI+06]                         DS:0F88=0000
AX=0100  BX=0000  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0089  DI=0F82
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01FC   NV UP EI PL NZ AC PE NC
2CB0:01FC 8B7508         MOV     SI,[DI+08]                         DS:0F8A=0000
AX=0100  BX=0000  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0000  DI=0F82
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=01FF   NV UP EI PL NZ AC PE NC
2CB0:01FF 8B7D0A         MOV     DI,[DI+0A]                         DS:0F8C=0000
AX=0100  BX=0000  CX=0000  DX=0000  SP=0F66  BP=0F74  SI=0000  DI=0000
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=0202   NV UP EI PL NZ AC PE NC
2CB0:0202 55             PUSH     BP
-T 5  &lt;Enter&gt;
AX=0100  BX=0000  CX=0000  DX=0000  SP=0F64  BP=0F74  SI=0000  DI=0000
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=0203   NV UP EI PL NZ AC PE NC
2CB0:0203 83ED0E         SUB     BP,+0E
AX=0100  BX=0000  CX=0000  DX=0000  SP=0F64  BP=0F66  SI=0000  DI=0000
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=0206   NV UP EI PL NZ AC PE NC
2CB0:0206 FF5E00         CALL     FAR [BP+00]                       SS:0F66=0F6A
AX=0100  BX=0000  CX=0000  DX=0000  SP=0F60  BP=0F66  SI=0000  DI=0000
DS=2E08  ES=2E08  SS=2E08  CS=2E08  IP=0F6A   NV UP EI PL NZ AC PE NC
2E08:0F6A CD60           INT     60
AX=0100  BX=0000  CX=0000  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=0000
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0190   NV UP DI PL NZ AC PE NC
1313:0190 80FC00         CMP     AH,00
AX=0100  BX=0000  CX=0000  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=0000
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0193   NV UP DI PL NZ NA PO NC
1313:0193 7521           JNZ     01B6

    When the Interrupt 60H call is encountered at offset 0F6AH, the values
    passed to it can be checked. AH contains 1 and DX contains 0--the
    correct values for START COM1.

    In order to use the symbols for BADSCOP, use the Open Symbol Map
    command, XO, to switch to the correct symbol map. Then, because the
    value of CSEG is not defined in the map, use the Set Symbol Value
    command to set CSEG to the current value of CS. (CS was changed to the
    correct value for BADSCOP when the program executed the INT 60H
    instruction.)

    -XO BADSCOP!  &lt;Enter&gt;
    -Z CSEG CS    &lt;Enter&gt;
    -X?*          &lt;Enter&gt;

    CSEG: (1313)
    0100 INITIALIZE   0103 OLD_COMM_INT 0107 COUNT        0109 STATUS
    010A PORT         010B BUFPNTR      010D COMSCOPE     0190 CONTROL
    020A VECTOR_INIT

    Because the BADSCOP symbols now have meaning, a great deal of trouble
    can be avoided by setting a breakpoint at CONTROL, the entry point for
    Interrupt 60H, so that it will no longer be necessary to trace the
    _int86 routine to find the INT 60H command. Execution will
    automatically stop when the Interrupt 60H handler is entered.

    -BP CONTROL  &lt;Enter&gt;
    -BL  &lt;Enter&gt;
    0 e 2CB0:002E [COMMSCMD!_TEXT:_main+1E (002E)] commscmd.C:41
    1 e 2CB0:0046 [COMMSCMD!_TEXT:_main+36 (0046)] commscmd.C:42
    2 e 2CB0:0066 [COMMSCMD!_TEXT:_main+56 (0066)] commscmd.C:44
    3 e 2CB0:0086 [COMMSCMD!_TEXT:_main+76 (0086)] commscmd.C:46
    4 e 2CB0:008B [COMMSCMD!_TEXT:_main+7B (008B)] commscmd.C:49
    5 e 2CB0:00AC [COMMSCMD!_TEXT:_main+9C (00AC)] commscmd.C:53
    6 e 2CB0:00C7 [COMMSCMD!_TEXT:_main+B7 (00C7)] commscmd.C:58
    7 e 2CB0:00F5 [COMMSCMD!_TEXT:_main+E5 (00F5)] commscmd.C:63
    8 e 1313:0190 [CSEGS:CONTROL]

    With the housekeeping tasks done, the business of debugging BADSCOP
    can begin. The first thing CONTROL does is check for a stop request.
    If no stop request is present, the routine jumps to the check for a
    start request. (The first test and jump were already complete when the
    trace ended above.)  The test for a start request is passed. CONTROL
    places the port number in a local variable, resets the buffer pointer
    and the buffer count, and turns tracing status on. With all this
    complete, CONTROL returns.

-T 5  &lt;Enter&gt;
AX=01BB  BX=E81E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=1CE7  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01B6   NV UP DI PL NZ NA PO NC
1313:01B6 80FC01         CMP     AH,01
AX=01BB  BX=E81E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=1CE7  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01B9   NV UP DI PL ZR NA PE NC
1313:01B9 751C           JNZ     CONTROL+47 (01D7)
AX=01BB  BX=E81E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=1CE7  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01BB   NV UP DI PL ZR NA PE NC
1313:01BB 2E88160A01     MOV     CS:[PORT],DL                      CS:010A=00
AX=01BB  BX=E81E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=1CE7  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01C0   NV UP DI PL ZR NA PE NC
1313:01C0 2EC7060B010202 MOV     Word Ptr CS:[BUFPNTR],VECTOR_INIT (0209)  CS:010B
AX=01BB  BX=E81E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=1CE7  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01C7   NV UP DI PL ZR NA PE NC
1313:01C7 2EC70607010000 MOV     Word Ptr CS:[COUNT],0000           CS:0107=0002
-T 5  &lt;Enter&gt;
AX=01BB  BX=E81E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=1CE7  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01CE   NV UP DI PL ZR NA PE NC
1313:01CE 2EC606090101   MOV     Byte Ptr CS:[STATUS],01            CS:0109=01
AX=01BB  BX=E81E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=1CE7  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01D4   NV UP DI PL ZR NA PE NC
1313:01D4 EB2B           JMP     CONTROL+71 (0201)
AX=01BB  BX=E81E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=1CE7  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0201   NV UP DI PL ZR NA PE NC
1313:0201 CF             IRET
AX=01BB  BX=E81E  CX=3F48  DX=0000  SP=0F60  BP=0F66  SI=1CE7  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=2E08  IP=0F6C   NV UP EI PL NZ AC PE NC
2E08:0F6C CB             RETF
AX=01BB  BX=E81E  CX=3F48  DX=0000  SP=0F64  BP=0F66  SI=1CE7  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=0209   NV UP EI PL NZ AC PE NC
2CB0:0209 5D             POP     BP


    As can be seen from the trace, CONTROL performed correctly, so
    execution of the routine can continue.


    -G  &lt;Enter&gt;
    Communications tracing STARTED for port COM1:
    AX=002F  BX=0001  CX=0C13  DX=0000  SP=0FA6  BP=0000  SI=0089  DI=1065
    DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=00F5   NV UP EI PL NZ NA PE NC
    2CB0:00F5 C3             RET                                   ;BR7


    COMMSCMD has written the message to the user and trapped at the
    breakpoint set at the end of _main. The Examine Symbol Map command now
    shows that SYMDEB has automatically switched to the symbol map for
    COMMSCMD.


    -X*  &lt;Enter&gt;
    [2CB0 COMMSCMD]
        [2CB0 _TEXT]
        2E08 DGROUP
    0000 BADSCOP
        1313 CSEG


    No problems have been encountered with the START command; now the same
    process of checking COMMSCMD and BADSCOP must be repeated for the STOP
    command. (Even if problems had been found with the START command, it
    would be imprudent not to test the other commands--they could have
    errors, too.) SYMDEB could be exited and restarted with new commands,
    but this would mean the loss of the painfully created set of break-
    points. Instead, a new copy of COMMSCMD is loaded without leaving
    SYMDEB. One problem with this, however, is that when SYMDEB loads an
    .EXE file, it adds the value of the initial CS register to the
    addresses of the segments in the symbol map whose name matches the
    .EXE file. This is fine the first time the program loads, but the
    second time, all the values are doubled and therefore incorrect. To
    avoid this error, the addresses must be adjusted before the load. Use
    the Set Symbol Value command to subtract CS from each segment name in
    COMMSCMD!. The Examine Symbol Map command shows the new values.


    -Z _TEXT _TEXT-CS  &lt;Enter&gt;
    -Z DGROUP DGROUP-CS  &lt;Enter&gt;
    -X*  &lt;Enter&gt;
    [2CB0 COMMSCMD]
        [0000 _TEXT]
            0158 DGROUP
    0000 BADSCOP
            1313 CSEG


    The Name File or Command-Tail Parameters command, N, and the Load File
    or Sectors command, L, can now be used to load a new copy of
    COMMSCMD.EXE.


    -N COMMSCMD.EXE  &lt;Enter&gt;
    -L  &lt;Enter&gt;
    -X*  &lt;Enter&gt;
    [2CB0 COMMSCMD]
        [2CB0 _TEXT]
            2E08 DGROUP
    0000 BADSCOP
            1313 CSEG


    Notice that the segment values inside COMMSCMD! are the same as they
    were when the program was first loaded. Use the Name command again,
    this time to set the command tail to contain a STOP command for COM1.
    The breakpoint table from the first execution is still set, so the
    program can now be traced in the same way.


-N STOP 1  &lt;Enter&gt;
-G  &lt;Enter&gt;
AX=0022  BX=0F84  CX=0019  DX=0098  SP=0F80  BP=0FA6  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=002E   NV UP EI PL NZ NA PO NC
41:             if (0 == stricmp(argv[1],"STOP"))
2CB0:002E B83600         MOV     AX,0036                       ;BR0
-G  &lt;Enter&gt;
AX=0000  BX=415A  CX=0000  DX=0098  SP=0F80  BP=0FA6  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=0046   NV UP EI PL ZR NA PE NC
42:                 cmd = 0;
2CB0:0046 C746FC0000     MOV     Word Ptr [BP-04],0000         ;BR1
                                                            SS:0FA2=0000
-G  &lt;Enter&gt;
AX=0000  BX=415A  CX=0000  DX=0098  SP=0F80  BP=0FA6  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=008B   NV UP EI PL ZR NA PE NC
49:         if (argc == 3)
2CB0:008B 837E0403       CMP     Word Ptr [BP+04],+03          ;BR4
                                                            SS:0FAA=0003
-G  &lt;Enter&gt;
AX=0001  BX=00D0  CX=0000  DX=0000  SP=0F80  BP=0FA6  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=00AC   NV UP EI PL NZ NA PO NC
53:                 port = port-1;
;ET
2CB0:00AC FF4EFA         DEC     Word Ptr [BP-06]              ;BR5
                                                            SS:0FA0=0001
-G  &lt;Enter&gt;
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F7A  BP=0FA6  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=00C7   NV UP EI PL ZR NA PE NC
2CB0:00C7 E8EF00         CALL     _int86                        ;BR6


    COMMSCMD detected that this is a stop request for COM1 and set the
    arguments for _int86 correctly. Because a breakpoint is now set at
    CONTROL, tracing until the Interrupt 60H call is found is not
    necessary. Simply executing the program will cause it to stop at
    CONTROL.


-G  &lt;Enter&gt;
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F5C  BP=0F68  SI=7400  DI=E903
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0190   NV UP DI PL NZ AC PO NC
CSEG:CONTROL:
1313:0190 80FC00         CMP     AH,00                         ;BR8


    The registers are set correctly for a stop request on COM1 (AH = 0, DX
    = 0). The routine can now be traced to check for correct operation.
    First, however, a quick look at the symbol maps shows that SYMDEB has
    automatically switched to BADSCOP's symbols.


-X*  &lt;Enter&gt;
2CB0 COMMSCMD
    2CB0 _TEXT
    2E08 DGROUP
[0000 BADSCOP]
    [1313 CSEG]
-T 5  &lt;Enter&gt;
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F5C  BP=0F68  SI=7400  DI=E903
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0193   NV UP DI PL ZR NA PE NC
1313:0193 7521           JNZ     CONTROL+26 (01B6)
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F5C  BP=0F68  SI=7400  DI=E903
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0195   NV UP DI PL ZR NA PE NC
1313:0195 1E             PUSH     DS
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F5A  BP=0F68  SI=7400  DI=E903
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0196   NV UP DI PL ZR NA PE NC
1313:0196 53             PUSH     BX
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F58  BP=0F68  SI=7400  DI=E903
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0197   NV UP DI PL ZR NA PE NC
1313:0197 0E             PUSH     CS
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F56  BP=0F68  SI=7400  DI=E903
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0198   NV UP DI PL ZR NA PE NC
1313:0198 1F             POP     DS
-T 5  &lt;Enter&gt;
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F58  BP=0F68  SI=7400  DI=E903
DS=1313  ES=2E08  SS=2E08  CS=1313  IP=0199   NV UP DI PL ZR NA PE NC
1313:0199 C606090100     MOV     Byte Ptr [STATUS],00            DS:0109=01
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F58  BP=0F68  SI=7400  DI=E903
DS=1313  ES=2E08  SS=2E08  CS=1313  IP=019E   NV UP DI PL ZR NA PE NC
1313:019E 8B1E0B01       MOV     BX,[BUFPNTR]                  DS:010B=0202
AX=001E  BX=0202  CX=0000  DX=0000  SP=0F58  BP=0F68  SI=7400  DI=E903
DS=1313  ES=2E08  SS=2E08  CS=1313  IP=01A2   NV UP DI PL ZR NA PE NC
1313:01A2 C60780         MOV     Byte Ptr [BX],80               DS:0202=80
AX=001E  BX=0202  CX=0000  DX=0000  SP=0F58  BP=0F68  SI=7400  DI=E903
DS=1313  ES=2E08  SS=2E08  CS=1313  IP=01A5   NV UP DI PL ZR NA PE NC
1313:01A5 C64701FF       MOV     Byte Ptr [BX+01],FF            DS:0203=FF
AX=001E  BX=0202  CX=0000  DX=0000  SP=0F58  BP=0F68  SI=7400  DI=E903
DS=1313  ES=2E08  SS=2E08  CS=1313  IP=01A9   NV UP DI PL ZR NA PE NC
1313:01A9 FF060701       INC     Word Ptr [COUNT]               DS:0107=0000
T 5  &lt;Enter&gt;
AX=001E  BX=0202  CX=0000  DX=0000  SP=0F58  BP=0F68  SI=7400  DI=E903
DS=1313  ES=2E08  SS=2E08  CS=1313  IP=01AD   NV UP DI PL NZ NA PO NC
1313:01AD FF060701       INC     Word Ptr [COUNT]              DS:0107=0001
AX=001E  BX=0202  CX=0000  DX=0000  SP=0F58  BP=0F68  SI=7400  DI=E903
DS=1313  ES=2E08  SS=2E08  CS=1313  IP=01B1   NV UP DI PL NZ NA PO NC
1313:01B1 5B             POP     BX
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F5A  BP=0F68  SI=7400  DI=E903
DS=1313  ES=2E08  SS=2E08  CS=1313  IP=01B2   NV UP DI PL NZ NA PO NC
1313:01B2 1F             POP     DS
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F5C  BP=0F68  SI=7400  DI=E903
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01B3   NV UP DI PL NZ NA PO NC
1313:01B3 EB4C           JMP     CONTROL+71 (0201)
AX=001E  BX=3F48  CX=0000  DX=0000  SP=0F5C  BP=0F68  SI=7400  DI=E903
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0201   NV UP DI PL NZ NA PO NC
1313:0201 CF             IRET


    CONTROL correctly detected that this was a stop request. It then saved
    the user's registers and established a DS equal to CS. (Remember that
    BADSCOP is a .COM file and CS = DS = SS.) Having done this, the
    routine moves a zero to STATUS, which turns the trace off. It then
    moves 80H FFH to the buffer to indicate the end of a trace session,
    increments COUNT to allow for the new entry, and restores the user's
    registers. What it does not do is increment the buffer pointer to
    allow for the stop marker. This behavior is entirely consistent with
    the observed phenomena: When a trace is stopped and resumed, the stop
    marker is missing and the count is one too high. The fix is to add


    INC     BX          ;INCREMENT BUFFER POINTER
    INC     BX          ; .
    MOV     BUFPNTR,BX  ; .


    to the CONTROL procedure before the registers are restored. (Insert
    these lines later with your favorite editor.)

    Even though the bug has been found, the rest of the routine should be
    checked for other possible bugs.


-G  &lt;Enter&gt;
Communications tracing STOPPED for port COM1:
AX=002F  BX=0001  CX=0C13  DX=0000  SP=0FA8  BP=0000  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=00F5   NV UP EI PL NZ AC PO NC
2CB0:00F5 C3             RET                                   ;BR7


    Loading a new copy of COMMSCMD, setting the command tail to RESUME 1,
    and monitoring program execution yields the following:


-N COMMSCMD.EXE  &lt;Enter&gt;
-Z _TEXT _TEXT-CS  &lt;Enter&gt;
-Z DGROUP DGROUP-CS  &lt;Enter&gt;
-X*  &lt;Enter&gt;
[2CB0 COMMSCMD]
    [0000 _TEXT]
    0158 DGROUP
0000 BADSCOP
    1313 CSEG
-L  &lt;Enter&gt;
-X*  &lt;Enter&gt;
[2CB0 COMMSCMD]
    [2CB0 _TEXT]
    2E08 DGROUP
0000 BADSCOP
    1313 CSEG
-N RESUME 1  &lt;Enter&gt;
-G  &lt;Enter&gt;
AX=0022  BX=0F82  CX=0019  DX=0098  SP=0F7E  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=002E   NV UP EI PL NZ NA PO NC
41:             if (0 == stricmp(argv[1],"STOP"))
2CB0:002E B83600         MOV     AX,0036                       ;BR0
-G  &lt;Enter&gt;
AX=0000  BX=415A  CX=0000  DX=0098  SP=0F7E  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=0086   NV UP EI PL ZR NA PE NC
46:                 cmd = 2;
2CB0:0086 C746FC0200     MOV     Word Ptr [BP-04],0002    ;BR3 SS:0FA0=0000
-G  &lt;Enter&gt;
AX=0000  BX=415A  CX=0000  DX=0098  SP=0F7E  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=008B   NV UP EI PL ZR NA PE NC
49:         if (argc == 3)
2CB0:008B 837E0403       CMP     Word Ptr [BP+04],+03      ;BR4 SS:0FA8=0003
-G  &lt;Enter&gt;
AX=0001  BX=00D0  CX=0000  DX=0000  SP=0F7E  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=00AC   NV UP EI PL NZ NA PO NC
53:                 port = port-1;
2CB0:00AC FF4EFA         DEC     Word Ptr [BP-06]         ;BR SS:0F9E=00015
-G  &lt;Enter&gt;
AX=0060  BX=00D0  CX=0000  DX=0000  SP=0F78  BP=0FA4  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=00C7   NV UP EI PL ZR NA PE NC
2CB0:00C7 E8EF00         CALL     _int86                        ;BR6
-G  &lt;Enter&gt;
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0190   NV UP DI PL NZ AC PE NC
CSEG:CONTROL:
1313:0190 80FC00         CMP     AH,00                         ;BR8
-T 5  &lt;Enter&gt;
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0193   NV UP DI PL NZ NA PO NC
1313:0193 7521           JNZ     CONTROL+26 (01B6)
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01B6   NV UP DI PL NZ NA PO NC
1313:01B6 80FC01         CMP     AH,01
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01B9   NV UP DI PL NZ NA PO NC
1313:01B9 751C           JNZ     CONTROL+47 (01D7)
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01D7   NV UP DI PL NZ NA PO NC
1313:01D7 80FC02         CMP     AH,02
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01DA   NV UP DI PL ZR NA PE NC
1313:01DA 7516           JNZ     CONTROL+62 (01F2)
-T 5  &lt;Enter&gt;
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01DC   NV UP DI PL ZR NA PE NC
1313:01DC 2E833E0B0100   CMP     Word Ptr CS:[BUFPNTR],+00     CS:010B=0202
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01E2   NV UP DI PL NZ NA PO NC
1313:01E2 741D           JZ     CONTROL+71 (0201)
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01E4   NV UP DI PL NZ NA PO NC
1313:01E4 2E88160A01     MOV     CS:[PORT],DL                     CS:010A=00
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01E9   NV UP DI PL NZ NA PO NC
1313:01E9 2EC606090101   MOV     Byte Ptr CS:[STATUS],01         CS:0109=00
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=01EF   NV UP DI PL NZ NA PO NC
1313:01EF EB10           JMP     CONTROL+71 (0201)
-T 5  &lt;Enter&gt;
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F5A  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=1313  IP=0201   NV UP DI PL NZ NA PO NC
1313:0201 CF             IRET
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F60  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=2E08  IP=0F6C   NV UP EI PL NZ AC PE NC
2E08:0F6C CB             RETF
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F64  BP=0F66  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=0209   NV UP EI PL NZ AC PE NC
2CB0:0209 5D             POP     BP
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F66  BP=0F74  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=020A   NV UP EI PL NZ AC PE NC
2CB0:020A 57             PUSH     DI
AX=0265  BX=001E  CX=3F48  DX=0000  SP=0F64  BP=0F74  SI=0000  DI=7400
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=020B   NV UP EI PL NZ AC PE NC
2CB0:020B 8B7E08         MOV     DI,[BP+08]                    SS:0F7C=0F90
-G  &lt;Enter&gt;
Communications tracing RESUMED for port COM1:
AX=002F  BX=0001  CX=0C13  DX=0000  SP=0FA6  BP=0000  SI=0089  DI=1065
DS=2E08  ES=2E08  SS=2E08  CS=2CB0  IP=00F5   NV UP EI PL NZ NA PE NC
2CB0:00F5 C3             RET                                   ;BR7
-Q  &lt;Enter&gt;


    The processing of a resume request is correct. Thus, the problem with
    stop processing in BADSCOP was the only problem. The corrected
    BADSCOP, which is actually COMMSCOP, is shown in Figure 18-4.

CodeView
    CodeView is the most sophisticated debugging monitor produced by
    Microsoft. It combines the philosophy and many of the commands of its
    predecessors, DEBUG and SYMDEB, with true source-code debugging. The
    availability of source lines and symbols allows CodeView to rival the
    convenience of program development and debugging previously available
    only in interpreters such as Microsoft GW-BASIC. However, this high
    level of interaction with the source program is also the root of its
    problems for advanced debugging.

    In order to provide the debugger with the tools to debug at the
    source-line level and to interrogate program variables, CodeView is
    required to have a detailed knowledge of how high-order languages work
    and of their internal conventions. This is not a problem for languages
    like C, Pascal, and FORTRAN, versions of which are produced by the
    same company that created CodeView. The object code generated by these
    compilers obeys a stringent set of rules and conventions. Assembly-
    language programs, however, tend to follow their own rules and
    traditions, making them quite different from C programs, with their
    own separate debugging needs.

    C, Pascal, and FORTRAN programmers will find CodeView a dream to use.
    Assembly-language programmers using versions of MASM earlier than 5.0
    will find CodeView cumbersome and will have to weigh its advantages
    over its disadvantages. All users will, however, appreciate the good
    design and programming that have gone into CodeView. It is pleasing to
    know that someone understands the programmer's debugging needs and is
    trying to ease the burden.

    CodeView has added several welcome functions to the debugger's
    repertoire, but one of these new features towers above the rest--
    watchpoints. The debugger can watch the values of program variables or
    expressions and set breakpoints on them, making it possible to stop
    execution if an expression evaluates to zero or if a location changes.
    Previous debugging monitors have been limited to tracing and breaking
    on instructions. This new facet of debugging changes, somewhat, the
    approach to resolving a bug.

    In the previous discussion of debugging techniques, an orderly
    application of techniques from inspection and observation through
    instrumentation to debugging monitors was recommended. This sequence
    is still recommended with CodeView, but now the instrumentation
    features have been integrated into the debugging monitor.

    A simple example
    The following example shows how CodeView uses the instrumentation
    approach to isolate a problem and then uses the debugging monitor
    functions to solve it. The example is also an introduction to CodeView
    commands and techniques. The commands are, for the most part, similar
    to those used by SYMDEB. Those commands that differ greatly are
    indicated. This example, like all the examples and demonstrations in
    this article, is not intended to be a complete tutorial--CodeView
    commands are summarized elsewhere in this book and explained in detail
    in the manual accompanying the product. See PROGRAMMING UTILITIES:
    CODEVIEW. The example simply shows some of the more common CodeView
    commands and demonstrates debugging techniques using them.

    UPPERCAS.C (Figure 18-13) is a simple program whose sole function is
    to convert a canned string to uppercase. When executed, the program
    prints a few of the characters from the string and some that aren't in
    the string. Inspecting the listing doesn't reveal the cause of the
    problem. (Some readers with experience writing C programs will see the
    cause of the problem, because it is quite common; pretend, for now,
    that the listing is of no help and enjoy the wonders of CodeView.)

    ──────────────────────────────────────────────────────────────────────

    Figure 18-13. An erroneous C program to convert a string to uppercase.

    ──────────────────────────────────────────────────────────────────────

    Like SYMDEB, CodeView requires some special preparation to produce a
    suitable executable file. CodeView, however, makes the job much
    simpler. Using the Microsoft C Compiler, compile the program with

    C&gt;MSC /Zi UPPERCAS;  &lt;Enter&gt;

    (Remember that C is case sensitive when interpreting switches, so the
    /Zi switch should be entered exactly as shown.) The /Zi switch
    instructs the compiler to generate the symbol tables and line-number
    information needed by CodeView. Other options appropriate to the
    program can also be included, but /Zi is required.

    To form an executable file, use the Microsoft Object Linker (LINK) as
    follows:

    C&gt;LINK /CO UPPERCAS;  &lt;Enter&gt;

    This command line instructs LINK to build an executable file with the
    information needed for CodeView. Other options can be used as needed
    or desired. The output of LINK, UPPERCAS.EXE, will be larger than a
    .EXE file built without /CO (about 2600 bytes larger in this case),
    but the program will run correctly when executed without CodeView.

    Starting CodeView is straightforward. Simply type

    C&gt;CV UPPERCAS  &lt;Enter&gt;

    CodeView loads UPPERCAS.EXE. It locates UPPERCAS.C, the source file,
    and loads that too. It then presents a full-screen display similar to
    this:


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ uppercas.C ╞═══════════════════════════════════╕
1:                                                                             
2:      /**********************************************************************▓
3:       *                                                                     ▒
4:       * UPPERCAS.C                                                          ▒
5:       *    This routine converts a fixed string to uppercase and prints it. ▒
6:       *                                                                     ▒
7:       **********************************************************************▒
8:                                                                             ▒
9:      #include &lt;ctype.h&gt;                                                     ▒
10:     #include &lt;string.h&gt;                                                    ▒
11:     #include &lt;stdio.h&gt;                                                     ▒
12:                                                                            ▒
13:     main(argc,argv)                                                        ▒
14:                                                                            ▒
15:     int argc;                                                              ▒
16:     char *argv[];                                                          ▒
17:                                                                            ▒
18:     {                                                                      
══════════════════════════════════════════════════════════════════════════════╡
                                                                            
Microsoft (R) CodeView (R)  Version 2.0                                        ▓
(C) Copyright Microsoft Corp. 1986, 1987.  All rights reserved.                ▒
&gt;                                                                              


    This display has two windows open: the display window, which shows the
    program being debugged, and the the dialog window, which currently
    contains only the copyright notice and a prompt (&gt;) for input. The F6
    function key moves the cursor back and forth between the two windows.

    CodeView can be instructed from either window to go to a specific line
    (that is, to execute until a specific line is reached). If the cursor
    is in the display window, use the arrow keys to select a line and
    press the F7 key. Execution will proceed until the selected line (or
    the end of the program) is reached. To start execution without
    specifying a stop line, press F5.

    The same functions can be performed from the dialog window using typed
    commands, which may seem more familiar. Enter the Go Execute Program
    command, G, optionally followed by an address. Execution will continue
    until the specified address is reached or until stopped by something
    else, such as the end of the program. In this sense, the CodeView Go
    command is the same as that of DEBUG and SYMDEB. Unlike those
    routines, however, CodeView's Go command does not allow an equals
    operator (=).

    The address for the Go command can be specified in several ways.
    Because the display window is currently showing only source lines, it
    is appropriate to set the stop location in terms of line numbers. The
    syntax of a line-number specification is the same as in SYMDEB--simply
    enter the line number preceded by a period:

    &gt;G .27  &lt;Enter&gt;

    Note that the line number is specified in decimal. This seemingly
    innocent statement uncovers one of the problem areas in CodeView,
    especially for assembly-language programmers. The default radix for
    CodeView is decimal. This convention works well for things associated
    with the C program, such as line numbers, but is very inconvenient for
    addresses and other similar items, which are usually in hexadecimal.
    Hexadecimal numbers must be specified using the cumbersome C notation.
    Thus, the number FF3EH would be entered as 0xff3e. The radix can be
    changed using the Change Current Radix command, N (different from the
    DEBUG and SYMDEB N command). (The problems associated with hexadecimal
    numbers in early versions of CodeView are no longer present in
    versions 2.0 and later.)

    The radix problem can be avoided, for the moment, by using labels.
    Issue

    &gt;G _main  &lt;Enter&gt;

    to cause CodeView to execute until the main routine is reached.
    CodeView then shows


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ uppercas.C ╞═══════════════════════════════════╕
9:      #include &lt;ctype.h&gt;                                                     
10:     #include &lt;string.h&gt;                                                    ▒
11:     #include &lt;stdio.h&gt;                                                     ▒
12:                                                                            ▒
13:     main(argc,argv)                                                        ▒
14:                                                                            ▓
15:     int argc;                                                              ▒
16:     char *argv[];                                                          ▒
17:                                                                            ▒
18:     {                                                                      ▒
19:     char    *cp,c;                                                         ▒
20:                                                                            ▒
21:             cp = "a string\n";                                             ▒
22:                                                                            ▒
23:             /*  Convert *cp to uppercase and write to standard output  */  ▒
24:                                                                            ▒
25:             while (*cp != '\0')                                            ▒
26:                     {                                                      
══════════════════════════════════════════════════════════════════════════════╡
Microsoft (R) CodeView (R)  Version 2.0                                        
(C) Copyright Microsoft Corp. 1986, 1987.  All rights reserved.                ▓
&gt;g _main                                                                       ▒
&gt;                                                                              


    The display shows line 15 in reverse video, indicating that CodeView
    has stopped there. This is the first line of the main() module, but it
    is not executable. Press the F10 key, which has the same effect as
    entering the Step Through Program command, P, in the dialog window, to
    cause line 19 to be executed. The reverse video line is then 21, which
    is the next line to be executed.

    To see the changes to cp, *cp, and c, establish a watch on these three
    variables. To use the Watch Word command, WW, for the word cp, type

    &gt;WW cp  &lt;Enter&gt;

    When entered from the dialog window, this command opens the watch
    window at the top of the screen and displays the current value of cp.
    To display the expression at *cp, use the Watch Expression command,
    W?, as follows:

    &gt;W? cp,s  &lt;Enter&gt;

    This expression will display the null-delimited string at *cp.
    Finally, to see the ASCII character value of c, use the Watch ASCII
    command, WA:

    &gt;WA c  &lt;Enter&gt;

    The results of these watch commands are shown in the following screen:


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ uppercas.C ╞═══════════════════════════════════╕
0)  cp  :  55C4:0FF0  5527                                                     │
1)  cp,s  :  ""                                                                │
2)  c  :  55C4:0FF2  .                                                         │
═══════════════════════════════════════════════════════════════════════════════╡
9:      #include &lt;ctype.h&gt;                                                     
10:     #include &lt;string.h&gt;                                                    ▒
11:     #include &lt;stdio.h&gt;                                                     ▒
12:                                                                            ▒
13:     main(argc,argv)                                                        ▓
14:                                                                            ▒
15:     int argc;                                                              ▒
16:     char *argv[];                                                          ▒
17:                                                                            ▒
18:     {                                                                      ▒
19:     char    *cp,c;                                                         ▒
20:                                                                            ▒
21:             cp = "a string\n";                                             ▒
22:                                                                            
══════════════════════════════════════════════════════════════════════════════╡
&gt;ww cp                                                                         
&gt;w? cp,s                                                                       ▓
&gt;wa c                                                                          ▒
&gt;                                                                              


    The values displayed in the watch window are not yet defined because
    line 21, which initialized cp, has not been executed. Press F8 to
    rectify this. Press it again to bring the execution of the program
    into the main loop.


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ uppercas.C ╞═══════════════════════════════════╕
0)  cp  :  55C4:0FF0  0036                                                     │
1)  cp,s  :  "a string                                                         │
2)  c  :  55C4:0FF2  .                                                         │
═══════════════════════════════════════════════════════════════════════════════╡
18:     {                                                                      
19:     char    *cp,c;                                                         ▒
20:                                                                            ▒
21:             cp = "a string\n";                                             ▒
22:                                                                            ▒
23:             /*  Convert *cp to uppercase and write to standard output  */  ▒
24:                                                                            ▒
25:             while (*cp != '\0')                                            ▓
26:                     {                                                      ▒
27:                     c = toupper(*cp++);                                    ▒
28:                     putchar(c);                                            ▒
29:                     }                                                      ▒
30:                                                                            ▒
31:     }                                                                      
══════════════════════════════════════════════════════════════════════════════╡
&gt;ww cp                                                                         
&gt;w? cp,s                                                                       ▓
&gt;wa c                                                                          ▒
&gt;                                                                              


    The pointer cp now contains the correct address. The Display Memory
    command, D,  could be used to display the contents of DS:0036H, just
    as in DEBUG and SYMDEB. (This step is not necessary, however, because
    there is a formatted display of memory in the watch window at 1). The
    variable c has not yet been initialized.

    Press the F8 key to execute line 27. A curious and unexpected thing
    happens, as shown in the next screen:


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ uppercas.C ╞═══════════════════════════════════╕
0)  cp  :  55C4:0FF0  0038                                                     │
1)  cp,s  :  "string                                                           │
2)  c  :  55C4:0FF2                                                            │
═══════════════════════════════════════════════════════════════════════════════╡
18:     {                                                                      
19:     char    *cp,c;                                                         ▒
20:                                                                            ▒
21:             cp = "a string\n";                                             ▒
22:                                                                            ▒
23:             /*  Convert *cp to uppercase and write to standard output  */  ▒
24:                                                                            ▒
25:             while (*cp != '\0')                                            ▓
26:                     {                                                      ▒
27:                     c = toupper(*cp++);                                    ▒
28:                     putchar(c);                                            ▒
29:                     }                                                      ▒
30:                                                                            ▒
31:     }                                                                      
══════════════════════════════════════════════════════════════════════════════╡
&gt;ww cp                                                                         
&gt;w? cp,s                                                                       ▓
&gt;wa c                                                                          ▒
&gt;                                                                              


    Notice that the value of cp has changed from 0036H to 0038H. The line
    of code, however, indicates that the pointer should have been
    incremented by only one (*cp++). The second character of the string, a
    blank, has been loaded into c. This could explain the apparent random
    selection of characters being displayed (actually every other
    character) and the garbage characters displayed (the zero at the end
    of the string might be skipped, causing the routine to continue
    converting until a zero is encountered somewhere in memory).

    Source-line debugging does not reveal enough about what is happening
    in this case. To look more closely at the mechanism of the program,
    the program must be restarted. Before doing this, set a breakpoint at
    line 27:

    &gt;BP .27  &lt;Enter&gt;

    Then restart (actually, reload) the program with the Reload
    Program command, L. Note that watch commands and breakpoints are
    preserved when a program is restarted. Executing the restarted program
    with G yields


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ uppercas.C ╞═══════════════════════════════════╕
0)  cp  :  55C4:0FF0  0036                                                     │
1)  cp,s  :  "a string                                                         │
2)  c  :  55C4:0FF2  .                                                         │
═══════════════════════════════════════════════════════════════════════════════╡
18:     {                                                                      
19:     char    *cp,c;                                                         ▒
20:                                                                            ▒
21:             cp = "a string\n";                                             ▒
22:                                                                            ▒
23:             /*  Convert *cp to uppercase and write to standard output  */  ▒
24:                                                                            ▒
25:             while (*cp != '\0')                                            ▓
26:                     {                                                      ▒
27:                     c = toupper(*cp++);                                    ▒
28:                     putchar(c);                                            ▒
29:                     }                                                      ▒
30:                                                                            ▒
31:     }                                                                      
══════════════════════════════════════════════════════════════════════════════╡
&gt;bp .27                                                                        
&gt;l                                                                             ▓
&gt;g                                                                             ▒
&gt;                                                                              


    The display shows line 27 in reverse video, indicating that it is the
    next line to be executed. The pointer cp has the correct value, as
    shown in the watch window. Now Press the F2 key to turn on the
    register display and press F3 to show the assembly code.


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ uppercas.C ╞═════════════════════════╤══════════
0)  cp  :  55C4:0FF0  0036                                           │ AX = 0004
1)  cp,s  :  "a string                                               │ BX = 0036
2)  c  :  55C4:0FF2  .                                               │ CX = 0019
═════════════════════════════════════════════════════════════════════╡ DX = 00B8
27:                     c = toupper(*cp++);                           SP = 0FF0
5527:0026 FF46FC         INC       Word Ptr [cp]             ;BR0    ▒ BP = 0FF4
5527:0029 8A07           MOV       AL,Byte Ptr [BX]                  ▒ SI = 00A9
5527:002B 98             CBW                                         ▒ DI = 10D5
5527:002C 8BD8           MOV       BX,AX                             ▒ DS = 55C4
5527:002E F687B30102     TEST      Byte Ptr [BX+01B3],02             ▓ ES = 55C4
5527:0033 740C           JZ        _main+31 (0041)                   ▒ SS = 55C4
5527:0035 8B5EFC         MOV       BX,Word Ptr [cp]                  ▒ CS = 5527
5527:0038 FF46FC         INC       Word Ptr [cp]                     ▒ IP = 0026
5527:003B 8A07           MOV       AL,Byte Ptr [BX]                  ▒
5527:003D 2C20           SUB       AL,20                             ▒   NV UP
5527:003F EB08           JMP       _main+39 (0049)                   ▒   EI PL
5527:0041 8B5EFC         MOV       BX,Word Ptr [cp]                  ▒   NZ NA
5527:0044 FF46FC         INC       Word Ptr [cp]                        PO NC
════════════════════════════════════════════════════════════════════╡
&gt;bp .27                                                                 SS:0FF0
&gt;l                                                                   ▓      0036
&gt;g                                                                   ▒
&gt;                                                                    


    The display highlights line 27, indicating that a breakpoint exists at
    this line. The line of code at CS:0026H is in reverse video,
    indicating that it is the next line to be executed.

    The previous instruction has loaded BX with [cp]. The first thing the
    code for line 27 does is increment the word at memory location [cp].
    The initial value of cp is in BX, so the *cp++ request can now be
    executed. Use the F8 key to single-step through the lines of code.
    Notice that when only source lines are on the screen, F8 steps one
    source line at a time, but when assembly code is shown, F8 steps one
    assembly line at a time. Single-stepping through the code, note how
    the registers and watch window change. Everything appears normal until
    CS:0038H is executed.


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ uppercas.C ╞═════════════════════════╤══════════
0)  cp  :  55C4:0FF0  0038                                           │ AX = 0061
1)  cp,s  :  "string                                                 │ BX = 0037
2)  c  :  55C4:0FF2  .                                               │ CX = 0019
═════════════════════════════════════════════════════════════════════╡ DX = 00B8
27:                     c = toupper(*cp++);                           SP = 0FF0
5527:0026 FF46FC         INC       Word Ptr [cp]             ;BR0    ▒ BP = 0FF4
5527:0029 8A07           MOV       AL,Byte Ptr [BX]                  ▒ SI = 00A9
5527:002B 98             CBW                                         ▒ DI = 10D5
5527:002C 8BD8           MOV       BX,AX                             ▒ DS = 55C4
5527:002E F687B30102     TEST      Byte Ptr [BX+01B3],02             ▓ ES = 55C4
5527:0033 740C           JZ        _main+31 (0041)                   ▒ SS = 55C4
5527:0035 8B5EFC         MOV       BX,Word Ptr [cp]                  ▒ CS = 5527
5527:0038 FF46FC         INC       Word Ptr [cp]                     ▒ IP = 003B
5527:003B 8A07           MOV       AL,Byte Ptr [BX]                  ▒
5527:003D 2C20           SUB       AL,20                             ▒   NV UP
5527:003F EB08           JMP       _main+39 (0049)                   ▒   EI PL
5527:0041 8B5EFC         MOV       BX,Word Ptr [cp]                  ▒   NZ NA
5527:0044 FF46FC         INC       Word Ptr [cp]                        PO NC
════════════════════════════════════════════════════════════════════╡
&gt;bp .27                                                                 DS:0037
&gt;l                                                                   ▓        20
&gt;g                                                                   ▒
&gt;                                                                    


    Notice that the value of cp in the watch window has incremented again.
    The line of C code has two increments hidden in it, not the expected
    single increment. Why is this?

    To find the answer, examine the toupper() macro. The following
    definition, extracted from CTYPE.H, explains what is happening:

    #define _UPPER        0x1       /* uppercase letter */
    #define _LOWER        0x2       /* lowercase letter */
    #define isupper(c)     ( (_ctype+1)[c] &amp; _UPPER )
    #define islower(c)     ( (_ctype+1)[c] &amp; _LOWER )

    #define _tolower(c)    ( (c)-'A'+'a' )
    #define _toupper(c)    ( (c)-'a'+'A' )

    #define toupper(c)     ( (islower(c)) ? _toupper(c) : (c) )
    #define tolower(c)     ( (isupper(c)) ? _tolower(c) : (c) )

    The argument to toupper(), c, is used twice, once in the macro that
    checks for lowercase, islower(), and once in _toupper(). The argument
    is replaced in this case with *cp$QP$QP, which has the famous C
    unexpected side effects. Because the unary post-increment is the
    handiest way to perform the function desired in the program, fixing
    the problem by changing the code in the main loop is undesirable.
    Another solution to the problem is to use the function version of
    toupper(). Because toupper() is defined as a function in STDIO.H,
    simply deleting #include &lt;ctype.h&gt; would solve the problem.
    Unfortunately, this would also deprive the program of the other useful
    definitions in CTYPE.H. (Admittedly, the features are not currently
    used by the program, but little programs sometimes grow into mighty
    systems.) So to keep CTYPE.H but still remove the macro definition of
    toupper(), use the #undef command. (Because tolower() has the same
    problem, it should also be undefined.) The corrected listing is shown
    in Figure 18-14.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-14. The corrected version of UPPERCAS.C.

    ──────────────────────────────────────────────────────────────────────

    An example using screen output
    A problem with DEBUG is that it writes to the same screen as the
    program does. Both SYMDEB and CodeView, however, allow the debugger to
    switch back and forth between the screen containing the program's
    output and the screen containing the debugger's output. This feature
    is a special option with SYMDEB and is sometimes clumsy to use, but
    with CodeView, keeping a separate program output screen is automatic
    and switching back and forth involves simply pressing a function key
    (F4).

    The following example program is intended to display an ASCII lookup
    table with all the displayable characters available on an IBM PC. The
    expected output is shown in Figure 18-15.


C&gt;asctbl


                ASCII LOOKUP TABLE

    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
0                                         
1                       
2      !  "  #  $  %  &amp;  '  (  )  *  +  ,  -  .  /
3   0  1  2  3  4  5  6  7  8  9  :  ;  &lt;  =  &gt;  ?
4   @  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O
5   P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _
6   `  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o
7   p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~  
8   Ç  ü  é  â  ä  à  å  ç  ê  ë  è  ï  î  ì  Ä  Å
9   É  æ  Æ  ô  ö  ò  û  ù  ÿ  Ö  Ü  ¢  £  ¥  ₧  ƒ
A   á  í  ó  ú  ñ  Ñ  ª  º  ¿  ⌐  ¬  ½  ¼  ¡  «  »
B   ░  ▒  ▓  │  ┤  ╡  ╢  ╖  ╕  ╣  ║  ╗  ╝  ╜  ╛  ┐
C   └  ┴  ┬  ├  ─  ┼  ╞  ╟  ╚  ╔  ╩  ╦  ╠  ═  ╬  ╧
D   ╨  ╤  ╥  ╙  ╘  ╒  ╓  ╫  ╪  ┘  ┌  █  ▄  ▌  ▐  ▀
E   α  ß  Γ  π  Σ  σ  µ  τ  Φ  Θ  Ω  δ  ∞  φ  ε  ∩
F   ≡  ±  ≥  ≤  ⌠  ⌡  ÷  ≈  °  ∙  ·  √  ⁿ  ²  ■   

    Figure 18-15. The output expected from ASCTBL.C.


    The program that should produce this display, ASCTBL.C, is shown in
    Figure 18-16.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-16. An erroneous program to display ASCII characters.

    ──────────────────────────────────────────────────────────────────────

    The problem to be debugged in this example is evident when the program
    in Figure 18-16 is compiled, linked, and executed. Here is the
    resulting display:


╓┌─────────┌──────────────────────────────────────────────────────────────────╖


C&gt;asctbl


                ASCII LOOKUP TABLE

    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  h0                
                    y1                                     y2
!  "  #  $  %  &amp;  '  (  )  *  +  ,  -  .  /  y3   0  1  2  3  4  5  6  7  8
9  :  ;  &lt;  =  &gt;  ?  y4   @  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  y5   P
Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _  y6   `  a  b  c  d  e  f  g  h  i
j  k  l  m  n  o  y7   p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~    y8   Ç
ü  é  â  ä  à  å  ç  ê  ë  è  ï  î  ì  Ä  Å  y9   É  æ  Æ  ô  ö  ò  û  ù  ÿ  Ö
Ü  ¢  £  ¥  ₧  ƒ  yA   á  í  ó  ú  ñ  Ñ  ª  º  ¿  ⌐  ¬  ½  ¼  ¡  «  »  yB   ░
▒  ▓  │  ┤  ╡  ╢  ╖  ╕  ╣  ║  ╗  ╝  ╜  ╛  ┐  yC   └  ┴  ┬  ├  ─  ┼  ╞  ╟  ╚  ╔
╩  ╦  ╠  ═  ╬  ╧  yD   ╨  ╤  ╥  ╙  ╘  ╒  ╓  ╫  ╪  ┘  ┌  █  ▄  ▌  ▐  ▀  yE   α  ß
Γ  π  Σ  σ  µ  τ  Φ  Θ  Ω  δ  ∞  φ  ε  ∩  yF   ≡  ±  ≥  ≤  ⌠  ⌡  ÷  ≈  °  ∙  ·
√  ⁿ  ²  ■     y
C&gt;


    Something is clearly wrong. The output is jumbled and no pattern is
    immediately obvious. To locate the problem, first prepare a .EXE file
    and start CodeView as follows:

    C&gt;MSC /Zi ASCTBL;  &lt;Enter&gt;
    C&gt;LINK /CO ASCTBL;  &lt;Enter&gt;
    C&gt;CV ASCTBL  &lt;Enter&gt;

    CodeView starts and displays the following screen:


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ asctbl.C ╞═════════════════════════════════════╕
1:                                                                             
2:      /**********************************************************************▓
3:       *                                                                     ▒
4:       *  ASCTBL.C                                                           ▒
5:       *   This program generates an ASCII lookup table for all displayable  ▒
6:       *   ASCII and extended IBMPC codes, leaving blanks for nondisplayable ▒
7:       *   codes.                                                            ▒
8:       *                                                                     ▒
9:       **********************************************************************▒
10:                                                                            ▒
11:     #include &lt;ctype.h&gt;                                                     ▒
12:     #include &lt;stdio.h&gt;                                                     ▒
13:                                                                            ▒
14:     main()                                                                 ▒
15:     {                                                                      ▒
16:     int i, j, k;                                                           ▒
17:             /* Print table title. */                                       ▒
18:             printf("\n\n\n                ASCII LOOKUP TABLE\n\n");        
══════════════════════════════════════════════════════════════════════════════╡
                                                                            
Microsoft (R) CodeView (R)  Version 2.0                                        ▓
(C) Copyright Microsoft Corp. 1986, 1987.  All rights reserved.                ▒
&gt;                                                                              


    The start of the source program is shown in the display window and the
    dialog window contains an input prompt. Press the F10 key three times
    to bring execution to line 21. (Remember that the line indicated in
    reverse video has not yet been executed.)


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ asctbl.C ╞═════════════════════════════════════╕
9:       **********************************************************************
10:                                                                            ▒
11:     #include &lt;ctype.h&gt;                                                     ▒
12:     #include &lt;stdio.h&gt;                                                     ▒
13:                                                                            ▓
14:     main()                                                                 ▒
15:     {                                                                      ▒
16:     int i, j, k;                                                           ▒
17:             /* Print table title. */                                       ▒
18:             printf("\n\n\n                ASCII LOOKUP TABLE\n\n");        ▒
19:                                                                            ▒
20:             /* Print column headers. */                                    ▒
21:             printf("    ");                                                ▒
22:             for (i = 0; i &lt; 16; i++)                                       ▒
23:                     printf("%X  ", i);                                     ▒
24:             fputchar("\n");                                                ▒
25:                                                                            ▒
26:             /* Print each line of the table. */                            
══════════════════════════════════════════════════════════════════════════════╡
                                                                            
Microsoft (R) CodeView (R)  Version 2.0                                        ▓
(C) Copyright Microsoft Corp. 1986, 1987.  All rights reserved.                ▒
&gt;                                                                              


    The display heading has been printed at line 18. Press the F4 key to
    display what the program has written on the screen.


C&gt;cv asctbl


                ASCII LOOKUP TABLE


    Note: Any information on the screen when you started CodeView will
    remain on the virtual output screen until program execution clears it
    or forces it to scroll off.

    The table heading has been properly written to the screen. Press the
    F4 key again to return to the CodeView display. Continue executing the
    program with the F10 key to bring the program to line 24.


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ asctbl.C ╞═════════════════════════════════════╕
9:       **********************************************************************
10:                                                                            ▒
11:     #include &lt;ctype.h&gt;                                                     ▒
12:     #include &lt;stdio.h&gt;                                                     ▒
13:                                                                            ▓
14:     main()                                                                 ▒
15:     {                                                                      ▒
16:     int i, j, k;                                                           ▒
17:             /* Print table title. */                                       ▒
18:             printf("\n\n\n                ASCII LOOKUP TABLE\n\n");        ▒
19:                                                                            ▒
20:             /* Print column headers. */                                    ▒
21:             printf("    ");                                                ▒
22:             for (i = 0; i &lt; 16; i++)                                       ▒
23:                     printf("%X  ", i);                                     ▒
24:             fputchar("\n");                                                ▒
25:                                                                            ▒
26:             /* Print each line of the table. */                            
══════════════════════════════════════════════════════════════════════════════╡
                                                                            
Microsoft (R) CodeView (R)  Version 2.0                                        ▓
(C) Copyright Microsoft Corp. 1986, 1987.  All rights reserved.                ▒
&gt;                                                                              


    At this point in program execution, the column headings have been
    written on the screen. Press the F4 key again to see the results.


C&gt;cv asctbl


                ASCII LOOKUP TABLE

    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F


    The output of the program is still correct, so allow execution to
    continue by pressing F4 to return to the CodeView screen and then
    pressing the F10 key. This will execute the call to the fputchar()
    function to write a newline character.


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ asctbl.C ╞═════════════════════════════════════╕
21:             printf("    ");                                                
22:             for (i = 0; i &lt; 16; i++)                                       ▒
23:                     printf("%X  ", i);                                     ▒
24:             fputchar("\n");                                                ▒
25:                                                                            ▒
26:             /* Print each line of the table. */                            ▒
27:             for ( i = 0, k = 0; i &lt; 16; i++)                               ▒
28:                     {                                                      ▒
29:                     /* Print first hex digit of symbols on this line. */   ▓
30:                     printf("%X   ", i);                                    ▒
31:                     /* Print each of the 16 symbols for this line. */      ▒
32:                     for (j = 0; j &lt; 16; j++)                               ▒
33:                             {                                              ▒
34:                             /* Filter non-printable characters. */         ▒
35:                             if ((k &gt;= 7 &amp;&amp; k &lt;= 13) || (k &gt;= 28 &amp;&amp; k &lt;= 31)▒
36:                                     printf("   ");                         ▒
37:                             else                                           ▒
38:                                     printf("%c  ", k);                     
══════════════════════════════════════════════════════════════════════════════╡
                                                                            
Microsoft (R) CodeView (R)  Version 2.0                                        ▓
(C) Copyright Microsoft Corp. 1986, 1987.  All rights reserved.                ▒
&gt;                                                                              


    Examination of the output screen shows that the display is now
    incorrect.


C&gt;cv asctbl


                ASCII LOOKUP TABLE

    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  h


    A lowercase h has been written to the screen instead of a newline
    character. Further execution demonstrates that newline characters
    written with fputchar() are not working. A closer inspection of the
    fputchar() function is needed.

    To see what is happening, use the Reload Program command to restart
    execution at the top of the program. Change the cursor window with the
    F6 key, use the arrow keys to place the cursor on line 24, and press
    F7. This brings execution back to line 24, where fputchar() is called.
    Press the F3 key to place the display in assembly mode and the F2 key
    to show the CPU registers and flags. The first assembly instruction of
    the fputchar() function call is about to be executed.


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ asctbl.C ╞═══════════════════════════╤══════════
24:             fputchar("\n");                                       AX = 0003
5527:004E B86800         MOV       AX,0068                           ▒ BX = 0001
5527:0051 50             PUSH      AX                                ▒ CX = 0001
5527:0052 E83F01         CALL      _fputchar (0194)                  ▒ DX = 03C0
5527:0055 83C402         ADD       SP,+02                            ▒ SP = 0F90
27:             for ( i = 0, k = 0; i &lt; 16; i++)                     ▒ BP = 0F96
5527:0058 C746FE0000     MOV       Word Ptr [i],0000                 ▒ SI = 00A9
5527:005D C746FA0000     MOV       Word Ptr [k],0000                 ▓ DI = 1075
5527:0062 837EFE10       CMP       Word Ptr [i],+10                  ▒ DS = 566D
5527:0066 7D68           JGE       _main+c0 (00D0)                   ▒ ES = 566D
5527:0068 EB05           JMP       _main+5f (006F)                   ▒ SS = 566D
5527:006A FF46FE         INC       Word Ptr [i]                      ▒ CS = 5527
5527:006D EBF3           JMP       _main+52 (0062)                   ▒ IP = 004E
30:                     printf("%X   ", i);                          ▒
5527:006F FF76FE         PUSH      Word Ptr [i]                      ▒   NV UP
5527:0072 B86A00         MOV       AX,006A                           ▒   EI PL
5527:0075 50             PUSH      AX                                ▒   ZR NA
5527:0076 E84801         CALL      _printf (01C1)                       PE NC
════════════════════════════════════════════════════════════════════╡
Microsoft (R) CodeView (R)  Version 2.0                              
(C) Copyright Microsoft Corp. 1986, 1987.  All rights reserved.      ▓
&gt;l                                                                   ▒
&gt;                                                                    


    Notice that the parameter being passed to the function by means of the
    stack is 0068H. Use the Display Memory command to display DS:0068H.
    (Note the hexadecimal notation.)


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ asctbl.C ╞═══════════════════════════╤══════════
24:             fputchar("\n");                                       AX = 0003
5527:004E B86800         MOV       AX,0068                           ▒ BX = 0001
5527:0051 50             PUSH      AX                                ▒ CX = 0001
5527:0052 E83F01         CALL      _fputchar (0194)                  ▒ DX = 03C0
5527:0055 83C402         ADD       SP,+02                            ▒ SP = 0F90
27:             for ( i = 0, k = 0; i &lt; 16; i++)                     ▒ BP = 0F96
5527:0058 C746FE0000     MOV       Word Ptr [i],0000                 ▒ SI = 00A9
5527:005D C746FA0000     MOV       Word Ptr [k],0000                 ▓ DI = 1075
5527:0062 837EFE10       CMP       Word Ptr [i],+10                  ▒ DS = 566D
5527:0066 7D68           JGE       _main+c0 (00D0)                   ▒ ES = 566D
5527:0068 EB05           JMP       _main+5f (006F)                   ▒ SS = 566D
5527:006A FF46FE         INC       Word Ptr [i]                      ▒ CS = 5527
5527:006D EBF3           JMP       _main+52 (0062)                   ▒ IP = 004E
30:                     printf("%X   ", i);                          ▒
5527:006F FF76FE         PUSH      Word Ptr [i]                      ▒   NV UP
5527:0072 B86A00         MOV       AX,006A                           ▒   EI PL
5527:0075 50             PUSH      AX                                ▒   ZR NA
5527:0076 E84801         CALL      _printf (01C1)                       PE NC
════════════════════════════════════════════════════════════════════╡
&gt;l                                                                   
&gt;d 0x68 L8                                                           ▓
566D:0060                         -0A 00 25 58 20 20 20 00          .▒
&gt;                                                                    


    The contents of memory at this address consist of a null-delimited
    string containing a newline character. The representation of \n is
    correct. To see how the string is handled, use the trace key, F8, to
    single-step through fputchar() and subordinate functions. These
    functions are complicated; nearly 100 steps are required to reach the
    MS-DOS Interrupt 21H call that actually writes the screen.


File  View  Search  Run  Watch  Options  Language  Calls  Help │ F8=Trace F5=Go
══════════════════════════════╡ asctbl.C ╞═══════════════════════════╤══════════
5527:10E9 51             PUSH      CX                                 AX = 400A
5527:10EA 8BCF           MOV       CX,DI                             ▒ BX = 0001
5527:10EC 2BCA           SUB       CX,DX                             ▒ CX = 0001
5527:10EE CD21           INT       21                                ▒ DX = 0F84
5527:10F0 9C             PUSHF                                       ▒ SP = 0F68
5527:10F1 03F0           ADD       SI,AX                             ▒ BP = 0F6E
5527:10F3 9D             POPF                                        ▒ SI = 0000
5527:10F4 7304           JNB       _write+82 (10FA)                  ▒ DI = 0F85
5527:10F6 B409           MOV       AH,09                             ▒ DS = 566D
5527:10F8 EB1A           JMP       _write+9c (1114)                  ▒ ES = 566D
5527:10FA 0BC0           OR        AX,AX                             ▒ SS = 566D
5527:10FC 7516           JNZ       _write+9c (1114)                  ▒ CS = 5527
5527:10FE F687120240     TEST      Byte Ptr [BX+__osfile],40         ▒ IP = 10EE
5527:1103 740B           JZ        _write+98 (1110)                  ▒
5527:1105 8B5E06         MOV       BX,Word Ptr [BP+06]               ▒   NV UP
5527:1108 803F1A         CMP       Byte Ptr [BX],1A                  ▒   EI PL
5527:110B 7503           JNZ       _write+98 (1110)                  ▓   NZ NA
5527:110D F8             CLC                                            PO NC
════════════════════════════════════════════════════════════════════╡
566D:0060                         -0A 00 25 58 20 20 20 00          .
&gt;d 0xf84 L8                                                          ▓
566D:0F80              68 00 DC 00-A9 00 96 0F                  h....▒
&gt;                                                                    


    The AH register's contents, 40H, indicate that the Interrupt 21H call
    is a request for a write to a device. The BX register has the handle
    of the device, 1, which is the special file handle for standard output
    (stdout). For this program as it was invoked, standard output is the
    screen. The CX register indicates that 1 byte is to be written; DS:DX
    points to the data to be written. The contents of memory at DS:0F84H
    finally reveal the cause of the problem: This memory location contains
    the address of the data to be written, not the data. The fputchar()
    function was called with the wrong level of indirection.

    Examination of the listing shows that all the newline requests were
    made with

    fputchar("\n");

    Strings specified with double quotes are replaced in C functions with
    the address of the string, but the function expected the actual
    character and not its address. The problem can be corrected by
    replacing the fputchar() calls with

    fputchar('\n');

    The newline character will now be passed directly to the function.

    This kind of problem can be avoided. C provides the ability to check
    the type of each parameter passed to a function against the expected
    type. If the following definition is included at the top of the C
    program, incorrect types will generate error messages:

    #define LINT_ARGS

    The corrected listing is shown in Figure 18-17. This new program
    produces the correct output.

    ──────────────────────────────────────────────────────────────────────

    Figure 18-17. The correct ASCII table generation program.

    ──────────────────────────────────────────────────────────────────────

    CodeView is a good choice for debugging C, Pascal, BASIC, and FORTRAN
    programs. The fact that versions of MASM earlier than 5.0 do not
    generate data for CodeView makes CodeView a poorer choice for these
    assembly-language programs. These disadvantages must be weighed
    against the ability to set watchpoints and to trap nonmaskable
    interrupts (NMIs). CodeView is also not as well suited as SYMDEB for
    debugging programs that interact with TSRs and device drivers, because
    CodeView does not provide any mechanism for including symbol tables
    for routines not linked together.

Hardware debugging aids

    Hardware debuggers are a combination of hardware and software designed
    to be installed in a PC system. The software provides features much
    like those available with SYMDEB and CodeView. The advantages of
    hardware debuggers over purely software debuggers can be summarized in
    three points:

    ■  Crash protection
    ■  Manual execution break
    ■  Hardware breakpoints

    A hardware debugger can provide program crash protection because of
    its independence from the PC software. If the program being debugged
    goes wild and destroys the operating system of the PC, the hardware
    debugger is protected by virtue of being a separate hardware system
    and is capable of recovering enough control to allow the user to find
    out what happened.

    All hardware debuggers offer a means of breaking into the program
    under test from some external source--usually a push button in the
    hands of the programmer. The mechanism used to get the attention of
    the PC's CPU is the nonmaskable interrupt (NMI). This interrupt
    provides a more reliable means of interrupting program execution than
    the Break key because its operation is independent of the state of
    interrupts and other conditions.

    Hardware debuggers usually have access to the address and data lines
    on the PC bus, allowing them to set hardware breakpoints. Thus, these
    debuggers can be set to break when specific addresses are referenced.
    They execute the breakpoint code from a debugging monitor, which
    generally runs from their own memory. This memory is usually protected
    from the regular operating system and the application program.

    Although hardware debuggers can be used to instrument a program, they
    should not be confused with the external hardware instrumentation
    discussed earlier in this article. The logic analyzers and in-circuit
    emulators mentioned there are general-purpose test instruments; the
    hardware debuggers are highly specific devices intended to do only one
    thing on one type of hardware--provide debugging monitor functions at
    a hardware level to IBM PC-type machines. It is this specialization
    that makes hardware debuggers so much easier to use for programmers
    trying to get a piece of code running.

    Because this volume deals only with MS-DOS and associated Microsoft
    software, a detailed discussion of hardware debuggers and debugging
    would not be appropriate. Instead, a few popular hardware products
    that work with MS-DOS utilities are mentioned and a general discussion
    of debugging with hardware is presented.

    Several manufacturers make hardware products that can be used for
    debugging. These products vary in the features offered and in their
    suitability for various kinds of debugging. Three of these products
    that can be used with SYMDEB are

    ■  IBM Professional Debug Utility
    ■  PC Probe and AT Probe from Atron Corporation
    ■  Periscope from The Periscope Company, Inc.

    These boards can be used with SYMDEB by specifying the /N switch when
    the program is started. When used in this way, however, the hardware
    provides little more than a source of NMIs to interrupt program
    execution; otherwise, SYMDEB runs as usual. This restriction may not
    be acceptable to a programmer who wants to use the sophisticated
    debugging software that accompanies these products and makes use of
    their hardware features. For this reason, these boards are rarely used
    with SYMDEB.

    The general techniques of debugging with hardware aids will already be
    familiar to the reader--they are the same techniques discussed at
    length earlier in this article. The techniques of inspection and
    observation should still be applied; instrumentation is facilitated by
    hardware; a debugging monitor accompanies all hardware debuggers and
    the same techniques discussed for DEBUG, SYMDEB, and CodeView apply.
    No new techniques are needed to use these devices. The changes in the
    details of the techniques come with the added features available with
    the hardware debuggers. (Remember that all these features are not
    universally available on all hardware debuggers.)

    The manual interrupt feature of hardware debuggers is useful in a
    system crash. Every programmer, especially assembly-language
    programmers, has had the situation where the program runs wild,
    destroys the operating system, and locks up the system. The techniques
    described in previous sections of this article show that about the
    only way to solve these problems without hardware help is to set
    breakpoints at strategic locations in the program and see how many are
    passed before the system locks up. The breakpoints are placed at finer
    and finer increments until the instruction causing the crash is
    located.

    This long and ugly procedure can sometimes be shortened with a
    hardware debugger. When the system crashes, the programmer can push
    the manual interrupt button, suspend program execution, and give
    control to the debugger card. At this point, the programmer can use
    the debugging monitor software supplied with the card to sniff around
    memory looking for something suspicious. Clues can sometimes be found
    by examining the program's stack and data areas--provided, of course,
    that they are still in memory and haven't been destroyed, along with
    the operating system, by the rampaging program. This approach is not
    always an immediate solution to the problem, however; often, the
    start-and-set-breakpoints process has to be repeated even with a
    hardware debugger. The hardware will, however, possibly shed some
    light on the causes of the problem and shorten the procedure.

    Another feature offered by many of the debugging boards is the ability
    to set breakpoints on events other than the execution of a line of
    code. Often, these boards will allow the programmer to break on a
    reference to a specific memory location, to a range of memory
    locations, or to an I/O port. This feature allows a watch to be set on
    data, analogous to the watchpoint feature of CodeView. This technique
    is almost always useful, as it is with CodeView, but there is one
    class of problems where it is essential to reaching a solution.

    Consider the case of a program that seems to be running well. Every so
    often, however, an ampersand appears in the middle of a payroll
    amount, or occasionally the program makes an erroneous branch and
    executes the wrong path. Suppose that, after painstaking investi-
    gation, the programmer discovers that these problems are being
    caused by a change in a specific location in memory sometime during
    the execution of the program. In debugging, the discovery of the cause
    of a problem usually leads almost instantly to a fix. Not so in this
    case. That byte of memory could be changed by an error in the program,
    by a glitch in the operating system or in a device driver, or by
    cosmic rays from outer space. Discovering the culprit in a case like
    this is almost impossible without the help of hardware breakpoints.
    Setting a breakpoint on the affected memory location and running the
    program will solve the problem. As soon as the memory location is
    changed, the breakpoint will be executed and the state of the system
    registers will point a clear finger at the instruction that caused the
    problem.

    Hardware debuggers can provide significant aid to the serious
    programmer. They are especially helpful in debugging operating systems
    and operating-system services such as device drivers. They are also
    helpful in complicated situations where many programs may be running
    at the same time. The consensus among programmers who have hardware
    debuggers is that they are well worth the money.


Summary

    Although Microsoft and others have provided an impressive array of
    technology to aid in program debugging, the most important tool a
    programmer has is his or her native wit and talent. As the examples in
    this article have illustrated, the technology makes the task easier,
    but never easy. In all cases, however, it is the programmer who debugs
    the program and solves the problems.

    Technology will never be able to replace the person for solving the
    problem of a bug-ridden program. (This is an area where artificial
    intelligence will undoubtedly fail.) Therefore, it is the skills
    discussed in the first part of this article--debugging by inspection
    and observation--that deserve the greatest attention and practice. All
    the other techniques and technologies, with their ever-increasing
    sophistication, are only extensions of these basic techniques. A
    programmer who can debug effectively at the lowest level of technology
    will always be ready to use whatever advanced technology is available.

    Therefore, as a final word, remember the rule that opened this
    article:

    Gather enough information and the solution will be obvious.

    All the rest of this article was merely a discussion of ways to gather
    the information.

                                                Steve Bostwick



Article 19: Object Modules


    Object modules are used primarily by programmers. The end user of an
    MS-DOS application need never be concerned with object code, object
    modules, and object libraries because application programs are almost
    always distributed as .EXE or .COM files that can be executed with a
    simple startup command.

    An application programmer writing in a high-level language can use
    object modules and object libraries without knowing either the format
    of object code or the details of what the utilities that process
    object modules, such as the Microsoft Library Manager (LIB) and the
    Microsoft Object Linker (LINK), are actually doing. Most application
    programmers simply regard the contents of an object module as a "black
    box" and trust their compilers and object module utility programs to
    do the right thing.

    A programmer using assembly language or an assembly-language debugger
    such as DEBUG or SYMDEB, however, might want to know more about the
    content and function of object modules. The use of assembly language
    gives the programmer more control over the actual contents of object
    modules, so knowing how the modules are constructed and examining
    their contents can sometimes help with program debugging.

    Finally, a programmer writing a compiler, an assembler, or a language
    translator must know the details of object module format and
    processing. To take advantage of LIB and LINK, a language translator
    must construct object modules that conform to the format and usage
    conventions specified by Microsoft.

    Note: This article assumes some background knowledge of the process by
    which source code is converted into an executable file in the MS-DOS
    environment. See PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING
    FOR MS-DOS: Structure of an Application Program; PROGRAMMING TOOLS:
    The Microsoft Object Linker; PROGRAMMING UTILITIES.


The Use of Object Modules

    Although some MS-DOS language translators generate executable 8086-
    family machine code directly from source code, most produce object
    code instead. Typically, a translator processes each file of source
    code individually and leaves the resulting object module in a separate
    file bearing a .OBJ extension. The source-code files themselves remain
    unchanged. After all of a program's source-code modules have been
    translated, the resulting object modules can be linked into a single
    executable program. Because object modules frequently represent only a
    portion of a complete program, each source-code module usually
    contains instructions that indicate how its corresponding object code
    is to be combined with the object code in other object modules when
    they are linked.

    The object code contained in each object module consists of a binary
    image of the program plus program structure information. This object
    code is not directly executable. The binary image corresponds to the
    executable code that will ultimately be loaded into memory for
    execution; it contains both machine code and program data. The program
    structure information includes descriptions of logical groupings
    defined in the source code (such as named subroutines or segments) and
    symbolic references to addresses in other object modules.

    The program structure information is used by a linkage editor, or
    linker, such as Microsoft LINK to edit the binary image of the program
    contained in the object module. The linker combines the binary images
    from one or more object modules into a complete executable program.

    The linker's output is a .EXE file--a file containing executable
    machine code that can be loaded into RAM and executed (Figure 19-1).
    The linker leaves intact all of the object modules it processes.


    ┌───────────────────┐
    │    Source code    │
    └─────────┬─────────┘
            │ Language translator or assembler
    ┌──────────────────┐                     ┌───────────────────┐
    │                   │                     │                   │
    │   Object module   │── Object module ──│  Object library   │
    │    (.OBJ file)    │   librarian (LIB)   │    (.LIB file)    │
    └─────────┬─────────┘                     └─────────┬─────────┘
            └─────────────────────┬───────────────────┘
                                    │ Linker (LINK)
                        ┌──────────────────┐
                        │                   │
                        │    Executable     │
                        │   binary image    │
                        │    (.EXE file)    │
                        │                   │
                        └─────────┬─────────┘
                                    │ MS-DOS loader
                                    
                            (Program runs)

    Figure 19-1. Generation of an executable (.EXE) file.


    Object code thus serves as an intermediate form for compiled programs.
    This form offers two major advantages:

    ■  Modular intermediate code. The use of object modules eliminates the
        overhead of repeated compilation of an entire program whenever
        changes are made to parts of its source code. Instead, only those
        object modules affected by source-code revisions need be
        recompiled.

    ■  Shareable format. Object module format is well defined, so object
        modules can be linked even if they were produced by different
        translators. Many high-level-language compilers take advantage of
        this commonality of object-code format to support "interlanguage"
        linkage.

Contents of an object module

    Object modules contain five basic types of information. Some of this
    information exists explicitly in the source code (and is subsequently
    passed on to the object module), but much is inferred by the program
    translator from the structure of the source code and the way memory is
    accessed by the 8086.

    Binary Image. As described earlier, the binary image comprises  ex-
    ecutable code (such as opcodes and addresses) and program data. When
    object modules are linked, the linker builds an executable program
    from the binary image in each object module it processes. The binary
    image in each object module is always associated with program
    structure information that tells the linker how to combine it with
    related binary images in other object modules.

    External References. Because an object module generally represents
    only a small portion of a larger program that will be constructed from
    several object modules, it usually contains symbols that allow it to
    be linked to the other modules. Such references to corresponding
    symbols in other object modules are resolved when the modules are
    linked.

    For example, consider the following short C program:

    main()
    {
            puts("Hello, world\n");
    }

    This program calls the C function puts() to display a character
    string, but puts() is not defined in the source code. Rather, the name
    puts is a reference to a function that is external to the program's
    main() routine. When the C compiler generates an object module for
    this program, it will identify puts as an external reference. Later,
    the linker will resolve the external reference by linking the object
    module containing the puts() routine with the module containing the
    main() routine.

    Address References. When a program is built from a group of object
    modules, the actual values of many addresses cannot be computed until
    the linker combines the binary image of executable code and the
    program data from each of the program's constituent object modules.
    Object modules contain information that tells the linker how to
    resolve the values of such addresses, either symbolically (as in the
    case of external references) or relatively, in terms of some other
    address (such as the beginning of a block of executable code or
    program data).

    Debugging Information. An object module can also contain information
    that relates addresses in the executable program to the corresponding
    source code. After the linker performs its address fixups, it can use
    the object module's debugging information to relate a line of source
    code in a program module to the executable code that corresponds to
    it.

    Miscellaneous Information. Finally, an object module can contain
    comments, lists of symbols defined in or referenced by the module,
    module identification information, and information for use by an
    object library manager or a linker (for example, the names of object
    libraries to be searched by default).

Object module terminology

    When the linker generates an executable program, it organizes the
    structural components of the program according to the information
    contained in the object modules. The layout of the executable program
    can be conceptually described as a run-time memory map after  it has
    been loaded into memory.

    The basic structure of every executable program for the 8086 family of
    microprocessors must conform to the segmented architecture of the
    microprocessor. Thus, the run-time memory map of an executable program
    is partitioned into segments, each of which can be addressed by using
    one of the microprocessor's segment registers. This segmented
    structure of 8086-based programs is the basis for most of the
    following terminology.

    Frames. The memory address space of the 8086 is conceptually divided
    into a sequence of paragraph-aligned, overlapping 64 KB regions called
    frames. Frame 0 in the 8086's address space is the 64 KB of memory
    starting at physical address 00000H (0000:0000 in segment:offset
    notation), frame 1 is the 64 KB of memory starting at 00010H
    (0001:0000), and so on. A frame number thus denotes the beginning of
    any paragraph-aligned 64 KB of memory. For example, the location of a
    64 KB buffer that starts at address B800:0000 can be specified as
    frame 0B800H.

    Logical Segments. The run-time memory map for every 8086 program is
    partitioned into one or more logical segments, which are groupings of
    logically related portions of the program. Typically, an MS-DOS
    program includes at least one code segment (that contains all of the
    program's executable code), one or more data segments (that contain
    program data), and one stack segment.

    When a program is loaded into RAM to be executed, each logical segment
    in the program can be addressed with a frame number--that is, a
    physical 8086 segment address. Before the MS-DOS loader transfers
    control to a program in memory, it initializes the CS and SS registers
    with the segment addresses of the program's executable code and stack
    segments. If an MS-DOS program has a separate logical segment for
    program data, the program itself usually stores this segment's address
    in the DS register.

    Relocatable Segments. In MS-DOS programs, most logical segments are
    relocatable. The loader determines the physical addresses of a
    program's relocatable segments when it places the program into memory
    to be executed. However, this address determination poses a problem
    for the MS-DOS loader, because a program may contain references to the
    address of a relocatable segment even though the address value is not
    determined until the program is loaded. The problem is solved by
    indicating where such references occur within the program's object
    modules. The linker then extracts this information from the object
    modules and uses it to build a list of such address references into a
    segment relocation table in the header of executable files. After the
    loader copies a program into memory for execution, it uses the segment
    relocation table to update, or fix up, the segment address references
    within the program.

    Consider the following example, in which a program loads the starting
    addresses of two data segments into the DS and ES segment registers:

    mov   ax,seg _DATA
    mov   ds,ax             ; make _DATA segment addressable through DS
    mov   ax,seg FAR_DATA
    mov   es,ax             ; make FAR_DATA segment addressable through ES

    The actual addresses of the _DATA and FAR_DATA segments are unknown
    when the source code is assembled and the corresponding object module
    is constructed. The assembler indicates this by including segment
    fixup information, instead of actual segment addresses, in the
    program's object module. When the object module is linked, the linker
    builds this segment fixup information into the segment relocation
    table in the header of the program's .EXE file. Then, when the .EXE
    file is loaded, the MS-DOS loader uses the information in the .EXE
    file's header to patch the actual address values into the program.

    Absolute Segments. Sometimes a program needs to address a
    predetermined segment of memory. In this case, the program's source
    code must declare an absolute segment so that a reference to the
    corresponding frame number can be built into the program's object
    module.

    For example, a program might need to address a video display buffer
    located at a specific physical address. The following assembler
    directive declares the name of the segment and its frame number:

    VideoBufferSeg    SEGMENT at 0B800h

    Segment Alignment. When a program is loaded, the physical address of
    each logical segment is constrained by the segment's alignment. A
    segment can be page aligned (aligned on a 256-byte boundary),
    paragraph aligned (aligned on a 16-byte paragraph boundary), word
    aligned (aligned on an even-byte boundary), or byte aligned (not
    aligned on any particular boundary). A specification of each segment's
    alignment is part of every object module's program structure
    information.

    High-level-language translators generally align segments according to
    the type of data they contain. For example, executable code segments
    are usually byte aligned; program data segments are usually word
    aligned. With an assembler, segment alignment can be specified with
    the SEGMENT directive and the assembler will build this information
    into the program's object module.

    Concatenated Segments. The linker can concatenate logical segments
    from different object modules when it builds the executable program.
    For example, several object modules may each contain part of a
    program's executable code. When the linker processes these object
    modules, it can concatenate the executable code from the different
    object modules into one range of contiguous addresses.

    The order in which the linker concatenates logical segments in the
    executable program is determined by the order in which the linker
    processes its input files and by the program structure information in
    the object modules. With a high-level-language translator, the
    translator infers which segments can be concatenated from the
    structure of the source code and builds appropriate segment
    concatenation information into the object modules it generates. With
    an assembler, the segment class type can be used to indicate which
    segments can be concatenated.

    Groups of Segments. Segments with different names may also be grouped
    together by the linker so that they can all be addressed within the
    same 64 KB frame, even though they are not concatenated. For example,
    it might be desirable to group program data segments and a stack
    segment within the same 64 KB frame so that program data items and
    data on the stack can be addressed with the same 8086 segment
    register.

    In high-level languages, it is up to the translator to incorporate
    appropriate segment grouping information into the object modules it
    generates. With an assembler, groups of segments can be declared with
    the GROUP directive.

    Fixups. Sometimes a compiler or an assembler encounters addresses
    whose values cannot be determined from the source code. The addresses
    of external symbols are an obvious example. The addresses of
    relocatable segments and of labels within those segments are another
    example.

    A fixup is a language translator's way of passing the buck about such
    addresses to the linker. Typically, a translator builds a zero value
    in the binary image at locations where it cannot store an actual
    address. Accompanying each such location is fixup information, which
    allows the linker to determine the correct address. The linker then
    completes the fixup by calculating the correct address value and
    adding it to the value in the corresponding location in the binary
    image. The only fixups the linker cannot fully resolve are those that
    refer to the segment address of a relocatable segment. Such addresses
    are not known until the program is actually loaded, so the linker, in
    turn, passes the responsibility to the MS-DOS loader by creating a
    segment relocation table in the header of the executable file.

    To process fixups properly, the linker needs three pieces of
    information: the LOCATION of the value in the object module, the
    nature of the TARGET (the address whose value is not yet known), and
    the FRAME in which the address calculations are to take place. Object
    modules contain the LOCATION, TARGET, and FRAME information the linker
    uses to calculate the appropriate address for any given fixup.

    Consider the "program" in Figure 19-2. The statement:

    start:  call    far ptr FarProc

    contains a reference to an address in the logical segment FarSeg2.
    Because the assembler does not know the address of FarSeg2, it places
    fixup information about the address into the object module. The
    LOCATION to be fixed up is 1 byte past the label start (the 4-byte
    pointer following the call opcode 9AH). The TARGET is the address
    referenced in the call instruction--that is, the label FarProc in the
    segment FarSeg2. The FRAME to which the fixup relates is designated by
    the group FarGroup and is inferred from the statement

    ASSUME  cs:FarGroup

    in the FarSeg2 segment.

    ──────────────────────────────────────────────────────────────────────

    Figure 19-2. A sample "program" containing statements from which the
    assembler derives fixup information.

    ──────────────────────────────────────────────────────────────────────

    There are several different ways for a language translator to identify
    a fixup. For example, the LOCATION might be a single byte, a 16-bit
    offset, or a 32-bit pointer, as in Figure 19-2. The TARGET might be a
    label whose offset is relative either to the base (beginning) of a
    particular segment or to the LOCATION itself. The FRAME might be a
    relocatable segment, an absolute segment, or a group of segments.

    Taken together, all the information in an object module that concerns
    the alignment and grouping of segments can be regarded as a
    specification of a program's run-time memory map. In effect, the
    object module specifies what goes where in memory when a program is
    loaded. The linker can then take the program structure information in
    the object modules and generate a file containing an executable
    program with the corresponding structure.


The Structure of an Object Module

    Although object modules contain the information that ultimately
    determines the structure of an executable program, they bear little
    structural resemblance to the resulting executable program. Each
    object module is made up of a sequence of variable-length object
    records. Different types of object records contain different types of
    program information.

    Each object record begins with a 1-byte field that identifies its
    type. This is followed by a 2-byte field containing the length (in
    bytes) of the remainder of the record. Next comes the actual
    structural or program information, represented in one or more fields
    of varied lengths. Finally, each record ends with a 1-byte checksum.

    The sequence in which object records appear in an object module is
    important. Because the records vary in length, each object module must
    be constructed linearly, from start to end. More important, however,
    is the fact that some types of object records contain references to
    preceding object records. Because the linker processes object records
    sequentially, the position of each object record within an object
    module depends primarily on the type of information each record
    contains.

Types of object records

    Microsoft LINK currently recognizes 14 types of object records, each
    of which carries a specific type of information within the object
    module. Each type of object record is assigned an identifying six-
    letter abbreviation, but these abbreviations are used only in
    documentation, not within an object module itself. As already
    mentioned, the first byte of each object record contains a value that
    indicates its type. In a hexadecimal dump of the contents of an object
    module, these identifying bytes identify the start of each object
    record.

    Table 19-1 lists the types of object records supported by LINK. The
    value of each record's identifying byte (in hexadecimal) is included,
    along with the six-letter abbreviation and a brief functional
    description. The functions of the 14 types of object records fall into
    six general categories:

    ■  Binary data (executable code and program data) is contained in the
        LEDATA and LIDATA records.

    ■  Address binding and relocation information is contained in FIXUPP
        records.

    ■  The structure of the run-time memory map is indicated by SEGDEF,
        GRPDEF, COMDEF, and TYPDEF records.

    ■  Symbol names are declared in LNAMES, EXTDEF, and PUBDEF records.

    ■  Debugging information is in the LINNUM record.

    ■  Finally, the structure of the object module itself is determined by
        the THEADR, COMENT, and MODEND records.


    Table 19-1. Types of 8086 Object Records Supported by
                Microsoft LINK.

╓┌────────────────┌──────────────────────┌───────────────────────────────────╖
    ID byte     Abbreviation           Description
    ──────────────────────────────────────────────────────────────────
    80H         THEADR                 Translator Header Record
    88H         COMENT                 Comment Record
    8AH         MODEND                 Module End Record
    8CH         EXTDEF                 External Names Definition Record
    8EH         TYPDEF                 Type Definition Record
    90H         PUBDEF                 Public Names Definition Record
    94H         LINNUM                 Line Number Record
    96H         LNAMES                 List of Names Record
    98H         SEGDEF                 Segment Definition Record
    9AH         GRPDEF                 Group Definition Record
    9CH         FIXUPP                 Fixup Record
    0A0H        LEDATA                 Logical Enumerated Data Record
    0A2H        LIDATA                 Logical Iterated Data Record
    0B0H        COMDEF                 Communal Names Definition Record


Object record order

    The sequence in which the types of object records appear in an object
    module is fairly flexible in some respects. Several record types are
    optional, and if the type of information they carry is unnecessary,
    they are omitted from an object module. In addition, most object
    record types can occur more than once in the same object module. And,
    because object records are variable in length, it is often possible to
    choose, as a matter of convenience, between combining information into
    one large record or breaking it down into several smaller records of
    the same type.

    As stated previously, an important constraint on the order in which
    object records appear is the need for some types of object records to
    refer to information contained in other records. Because the linker
    processes the records sequentially, object records containing such
    information must precede the records that refer to it. For example,
    two types of object records, SEGDEF and GRPDEF, refer to the names
    contained in an LNAMES record. Thus, an LNAMES record must appear be-
    fore any SEGDEF or GRPDEF records that refer to it so that the names
    in the LNAMES record are known to the linker by the time it processes
    the SEGDEF or GRPDEF records.

A typical object module

    Figure 19-3 contains the source code for HELLO.ASM, an assembly-
    language program that displays a short message. Figure 19-4 is a
    hexadecimal dump of HELLO.OBJ, the object module generated by
    assembling HELLO.ASM with the Microsoft Macro Assembler. Figure 19-5
    isolates the object records within the object module.

    ──────────────────────────────────────────────────────────────────────

    Figure 19-3. The source code for HELLO.ASM.

    ──────────────────────────────────────────────────────────────────────

    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
0000  80 07 00 05 48 45 4C 4C 4F 00 96 25 00 00 04 43  ....HELLO..%...C
0010  4F 44 45 04 44 41 54 41 05 53 54 41 43 4B 05 5F  ODE.DATA.STACK._
0020  44 41 54 41 06 5F 53 54 41 43 4B 05 5F 54 45 58  DATA._STACK._TEX
0030  54 8B 98 07 00 28 11 00 07 02 01 1E 98 07 00 48  T....(.........H
0040  0F 00 05 03 01 01 98 07 00 74 00 01 06 04 01 E1  .........t......
0050  A0 15 00 01 00 00 B8 00 00 8E D8 BA 00 00 B4 09  ................
0060  CD 21 B8 00 4C CD 21 D5 9C 0B 00 C8 01 04 02 02  .!..L.!.........
0070  C4 06 04 02 02 B6 A0 13 00 02 00 00 48 65 6C 6C  ............Hell
0080  6F 2C 20 77 6F 72 6C 64 0D 0A 24 A8 8A 07 00 C1  o, world..$.....
0090  00 01 01 00 00 AC                                ......

    Figure 19-4. A hexadecimal dump of HELLO.OBJ.


    0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F

THEADR
0000  80 07 00 05 48 45 4C 4C 4F 00                    ....HELLO.

LNAMES
0000                                96 25 00 00 04 43            .%...C
0010  4F 44 45 04 44 41 54 41 05 53 54 41 43 4B 05 5F  ODE.DATA.STACK._
0020  44 41 54 41 06 5F 53 54 41 43 4B 05 5F 54 45 58  DATA._STACK._TEX
0030  54 8B                                            T.

SEGDEF
0030        98 07 00 28 11 00 07 02 01 1E                ...(......

SEGDEF
0030                                      98 07 00 48              ...H
0040  0F 00 05 03 01 01                                ......

SEGDEF
0040                    98 07 00 74 00 01 06 04 01 E1        ...t......

LEDATA
0050  A0 15 00 01 00 00 B8 00 00 8E D8 BA 00 00 B4 09  ................
0060  CD 21 B8 00 4C CD 21 D5                          .!..L.!.

FIXUPP
0060                          9C 0B 00 C8 01 04 02 02          ........
0070  C4 06 04 02 02 B6                                ......

LEDATA
0070                    A0 13 00 02 00 00 48 65 6C 6C        ......Hell
0080  6F 2C 20 77 6F 72 6C 64 0D 0A 24 A8              o, world..$.

MODEND
0080                                      8A 07 00 C1              ....
0090  00 01 01 00 00 AC                                ......

    Figure 19-5. The object records in HELLO.OBJ.


    As shown most clearly in Figure 19-5, each of the object records
    begins with the single byte value identifying the record's type. The
    second and third bytes of each record contain a single 16-bit value,
    stored with its low-order byte first, that represents the length (in
    bytes) of the remainder of the object record.

    The first record, THEADR, identifies the object module and the last
    record, MODEND, terminates the object module. The second record,
    LNAMES, contains a list of segment names and segment class names that
    LINK will use to lay out the run-time memory map. The three succeeding
    SEGDEF records describe the three corresponding segments defined in
    the source code.

    The order in which the object records appear reflects both the
    structure of the source code and the record order constraints already
    mentioned. The LNAMES record appears before the three SEGDEF records
    because each SEGDEF record contains a reference to a name in the
    LNAMES record.

    The binary data representing each of the two segments in the source
    code is contained in the two LEDATA records. The first LEDATA record
    represents the _TEXT segment; the second specifies the data in the
    _DATA segment. The FIXUPP record following the first LEDATA record
    contains information about the address references in the _TEXT
    segment. Again, the order in which the records appear is important:
    the FIXUPP record refers to the LEDATA record preceding it.

References between object records

    Object records can refer to information in other records either
    indirectly, by means of implicit references, or directly, by means of
    indexed references to names or other records.

    Implicit References. Some types of object records implicitly reference
    another record in the same object module. The most important example
    of such implicit referencing is in the FIXUPP record, which always
    contains fixup information for the preceding LEDATA or LIDATA record
    in the object module. Whenever an LEDATA or LIDATA record contains a
    value that needs to be fixed up, the next record in the object module
    is always a FIXUPP record containing the actual fixup information.

    Indexed References to Names. An object record that refers to a
    symbolic name, such as the name of a segment or an external routine,
    uses an index into a list of names contained in a previous object
    record. (The LNAMES record in Figure 19-5 is an example.) The first
    name in such a list has the index number 1, the second name has index
    number 2, the third has index number 3, and so on. Altogether, a list
    of as many as 32,767 (7FFFH) names can be incorporated into an object
    module--generally adequate for even the most verbose programmer. (LINK
    does, however, impose its own version-specific limits.)

    Indexed References to Object Records. An object record can also refer
    to a previous object record by using the same type of index. In this
    case, the index number refers to one of a list of object records of a
    particular type. For example, a FIXUPP record might refer to a segment
    by referencing one of several preceding SEGDEF records in the object
    module. In that case, a value of 1 would indicate the first SEGDEF
    record in the object module, a value of 2 would indicate the second,
    and so on.

    The index-number field in an object record can be either 1 or 2 bytes
    long. If the number is in the range 0-7FH, the high-order bit (bit 7)
    is 0 and the low-order 7 bits contain the index number, so the field
    is only 1 byte long:


    bit     7      6      5      4      3      2      1      0
        ┌──────┬────────────────────────────────────────────────┐
        │      │                                                │
        │  0   │                  index number                  │
        └──────┴────────────────────────────────────────────────┘


    If the index number is in the range 80-7FFFH, the field is 2 bytes
    long. The high-order bit of the first byte in the field is set to 1,
    and the high-order byte of the index number (which must be in the
    range 0-7FH) fits in the remaining 7 bits. The low-order byte of the
    index number is specified in the second byte of the field:

    bit     7      6      5      4      3      2      1      0     7     6
        ┌──────┬────────────────────────────────────────────────┬────────────────────────────────────────────────────┐
        │      │                                                │                                                    │
        │  1   │        high-order byte of index number         │             low-order byte of index number         │
        └──────┴────────────────────────────────────────────────┴────────────────────────────────────────────────────┘
                                    first byte

    The same format is used whether an index refers to a list of names or
    to a previous object record.


Microsoft 8086 Object Record Formats

    Just as the design of the Intel 8086 microprocessor reflects the
    design of its 8-bit predecessors, 8086 object record formats are
    reminiscent of the 8-bit software tradition. In 8-bit systems, disk
    space and RAM were often at a premium. To minimize the space consumed
    by object records, information is packed into bit fields within bytes
    and variable-length fields are frequently used.

    Microsoft LINK recognizes a major subset of Intel's original 8086
    object module specification (Intel Technical Specification 121748-
    001). Intel also proposed a six-letter name for each type of object
    record and symbolic names for fields. These names are documented in
    the following descriptions, which appear in the order shown earlier in
    Table 19-1.

    The Intel record types that are not recognized by LINK provide
    information about an executable program that MS-DOS obtains in other
    ways. (For example, information about run-time overlays is supplied in
    LINK's command line rather than being encoded in object records.)
    Because they are ignored by LINK, they are not included here.

    All 8086 object records conform to the following format:


    ┌──────┬──────┬──────┬───///──┬──────┐
    │record│   record    │  body  │ chk  │
    │ type │   length    │        │ sum  │
    └──────┴──────┴──────┴───///──┴──────┘


    The record type field is a 1-byte field containing the hexadecimal
    number that identifies the type of object record (see Table 19-1).

    The record length is a 2-byte field that gives the length of the
    remainder of the object record in bytes (excluding the bytes in the
    record type and record length fields). The record length is stored
    with the low-order byte first.

    The body field of the record varies in size and content, depending on
    the record type.

    The checksum is a 1-byte field that contains the negative sum (modulo
    256) of all other bytes in the record. In other words, the checksum
    byte is calculated so that the low-order byte of the sum of all the
    bytes in the record, including the checksum byte, equals zero.

    Note: As shown in the preceding example, the boxes used to depict the
    fields vary in size. The square boxes used for record type and chksum
    indicate a single byte, the rectangular box used for record length
    indicates 2 bytes, and the diagonal lines used for body indicate a
    variable-length field.


80H THEADR Translator Header Record

    The THEADR record contains the name of the object module. This name
    identifies an object module within an object library or in messages
    produced by the linker.

Record format


    ┌──────┬──────┬──────┬───///──┬──────┐
    │      │      │      │T-module│ chk  │
    │ 80H  │   length    │  name  │ sum  │
    └──────┴──────┴──────┴───///──┴──────┘


T-module name
    The T-module name field is a variable-length field that contains the
    name of the object module. The first byte of the field contains the
    number of subsequent bytes that contain the name itself. The name can
    be uppercase or lowercase and can be any string of characters.

    The T-module name is used by LIB and LINK within error messages.
    Language translators frequently derive the T-module name from the name
    of the file that contains a program's source code. Assembly-language
    programmers can specify the T-module name explicitly with the
    assembler NAME directive.

Location in object module

    As its name implies, the THEADR record must be the first record in
    every object module generated by a language translator.

Example

    The following THEADR record was generated by the Microsoft C Compiler:

                0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  80 09 00 07 68 65 6C 6C 6F 2E 63 CB              ....hello.c.

    ■  Byte 00H contains 80H, indicating a THEADR record.

    ■  Bytes 01-02H contain 0009H, the length of the remainder of the
        record.

    ■  Bytes 03-0AH contain the T-module name. Byte 03H contains 07H, the
        length of the name, and bytes 04H through 0AH contain the name
        itself (hello.c). (In object modules generated by the Microsoft C
        Compiler, the THEADR record indicates the filename that contained
        the C source code for the module.)


    ■  Byte 0BH contains the checksum, 0CBH.


88H COMENT Comment Record

    The COMENT record contains a character string that may represent a
    plain text comment, a symbol meaningful to a program such as LIB or
    LINK, or even binary-encoded identification data. An object module can
    contain any number of COMENT records.

Record format


    ┌──────┬──────┬──────┬──────┬──────┬─────────///────────┬──────┐
    │      │      │      │      │      │                    │ chk  │
    │ 88H  │   length    │attrib│     │      comment       │ sum  │
    └──────┴──────┴──────┴──────┴──┼───┴─────────///────────┴──────┘
                                    └─ comment
                                    class


Attrib
    Attrib is a 1-byte field in which only the first 2 bits are
    meaningful:


    bit     7      6      5      4      3      2      1      0
        ┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐
        │  no  │  no  │      │      │      │      │      │      │
        │purge │ list │  0   │  0   │  0   │  0   │  0   │  0   │
        └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘


    ■  If bit 7 (no purge) is set to 1, utility programs that manipulate
        object modules should not delete the comment record from the object
        module. Bit 7 can thus protect an important comment, such as a
        copyright message, from deletion.

    ■  If bit 6 (no list) is set to 1, utility programs that can list the
        contents of object modules are directed not to list the comment.
        Bit 6 can thus hide a comment.

    ■  Bits 5 through 0 are unused and should be set to 0.

    Microsoft LIB ignores the attrib field.

Comment class
    Comment class is a 1-byte field whose value provides information about
    the type of comment. The original Intel specification provided for the
    following possible comment class values:

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Value       Use
    ─────────────────────────────────────────────────────────────────────
    00H         Language-translator comment (the name of the translator
                that generated the object module).

    01H         Copyright comment.

    02-9BH      Reserved for Intel proprietary software.

    Microsoft language translators can generate several other classes of
    COMENT record that communicate specific information about the object
    module to LINK:

╓┌────────────────┌──────────────────────────────────────────────────────────╖
    Value       Use
    ─────────────────────────────────────────────────────────────────────
    81H         Obsolete; replaced by comment class 9FH.

    9CH         MS-DOS version number. Some language translators create a
                COMENT record with a 2-byte binary value in the comment
                field indicating the MS-DOS version under which the
                module was created. This record is ignored by LINK.

    9DH         Memory model. The comment field contains a string that
                indicates the memory model used by the language
                translator. The string contains one of the lowercase
                letters s, c, m, l, and h to designate small, compact,
                medium, large, and huge memory models. Microsoft language
                translators generate COMENT records with this comment
                class only for compatibility with the XENIX version of
                LINK. The MS-DOS version of LINK ignores these COMENT
                records.

    9EH         Sets Microsoft LINK's DOSSEG switch.

    9FH         Default library search name. LINK interprets the contents
                of the comment field as the name of a library to be
                searched in order to resolve external references within
                the object module. The default library search can be
                overridden with LINK's NODEFAULTLIBRARYSEARCH switch.

    0A1H        Indicates that Microsoft extensions to the Intel object
                record specification are used in the object module. For
                example, when COMDEF records are used within an object
                module, a COMENT record with comment class 0A1H must
                appear in the object module at some point before the
                first COMDEF record. LINK ignores the comment string in
                COMENT records with this comment class.

    0C0H-0FFH   Reserved for user-defined comment classes.


Comment
    The comment field is a variable-length string of bytes that represent
    the comment. The length of the string is inferred from the length of
    the object record.

Location in object module

    A COMENT record can appear almost anywhere in an object module. Only
    two restrictions apply:

    ■  A COMENT record cannot be placed between a FIXUPP record and the
        LEDATA or LIDATA record to which it refers.

    ■  A COMENT record cannot be the first or last record in an object
        module. (The first record must always be a THEADR record and the
        last must always be MODEND.)

Examples

    The following three examples are typical COMENT records taken from an
    object module generated by the Microsoft C Compiler.

    This first example is a language-translator comment:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  88 07 00 00 00 4D 53 20 43 6E                    .....MS Cn

    ■  Byte 00H contains 88H, indicating that this is a COMENT record.

    ■  Bytes 01-02H contain 0007H, the length of the remainder of the
        record.

    ■  Byte 03H (the attrib field) contains 00H. Bit 7 (no purge) is set
        to 0, indicating that this COMENT record may be purged from the
        object module by a utility program that manipulates object modules.
        Bit 6 (no list) is set to 0, indicating that this comment need not
        be excluded from any listing of the module's contents. The
        remaining bits are all 0.

    ■  Byte 04H (the comment class field) contains 00H, indicating that
        this COMENT record contains the name of the language translator
        that generated the object module.

    ■  Bytes 05H through 08H contain the name of the language translator,
        MS C.

    ■  Byte 09H contains the checksum, 6EH.

    The second example contains the name of an object library to be
    searched by default when LINK processes the object module containing
    this COMENT record:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  88 09 00 00 9F 53 4C 49 42 46 50 10              .....SLIBFP.

    ■  Byte 04H (the comment class field) contains 9FH, indicating that
        this record contains the name of a library for LINK to use to
        resolve external references.

    ■  Bytes 05-0AH contain the library name, SLIBFP. In this example, the
        name refers to the Microsoft C Compiler's floating-point function
        library, SLIBFP.LIB.

    The last example indicates that the object module contains Microsoft-
    defined extensions to the Intel object module specification:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  88 06 00 00 A1 01 43 56 37                       .....CV7

    ■  Byte 04H indicates the comment class, 0A1H.

    ■  Bytes 05-07H, which contain the comment string, are ignored by
        LINK.


8AH MODEND Module End Record

    The MODEND record denotes the end of an object module. It also
    indicates whether the object module contains the main routine in a
    program, and it can, optionally, contain a reference to a program's
    entry point.

Record format


    ┌──────┬──────┬──────┬──────┬─────────///────────┬──────┐
    │      │             │module│                    │ chk  │
    │ 8AH  │   length    │ type │   start address    │ sum  │
    └──────┴──────┴──────┴──────┴─────────///────────┴──────┘


Module type
    The module type field is an 8-bit (1-byte) field:


    bit     7      6      5      4      3      2      1      0
        ┌──────┬──────┬──────┬──────┬──────┬──────┬──────┬──────┐
        │      │      │      │      │      │      │      │      │
        │main  │start │  0   │  0   │  0   │  0   │  0   │  1   │
        └──────┴──────┴──────┴──────┴──────┴──────┴──────┴──────┘


    ■  Bit 7 (main) is set to 1 if the module is a main program module.

    ■  Bit 6 (start) is set to 1 if the MODEND record contains an entry
        point (start address).

    ■  Bit 0 is set to 1 if the start address field contains a relocatable
        address reference that LINK must fix up. If bit 6 is set to 1, bit
        0 must also be set to 1. (The Intel specification allows bit 0 to
        be set to 0, to indicate that start address is an absolute physical
        address, but this capability is not supported by LINK.)

Start address
    The start address field appears in the MODEND record only when bit 6
    is set to 1:


    ┌──────┬─────────///────────┬─────────///────────┬─────────///────────┐
    │ end  │                    │                    │       target       │
    │ dat  │    frame datum     │    target datum    │    displacement    │
    └──────┴────────///─────────┴─────────///────────┴─────────///────────┘


    The format and interpretation of the start address field corresponds
    to the fixup field of the FIXUPP record. The end dat field corresponds
    to the fix dat field in the FIXUPP record. Bit 2 of the end dat field,
    which corresponds to the P bit in a fix dat field, must be zero.

Location in object module

    A MODEND record can appear only as the last record in an object
    module.

Example

    Consider the MODEND record of the HELLO.ASM example:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  8A 07 00 C1 00 01 01 00 00 AC                    ..........

    ■  Byte 00H contains 8AH, indicating a MODEND record.

    ■  Bytes 01-02H contain 0007H, the length of the remainder of the
        record.

    ■  Byte 03H contains 0C1H (11000001B). Bit 7 is set to 1, indicating
        that this module is the main module of the program. Bit 6 is set to
        1, indicating that a start address field is present. Bit 0 is set
        to 1, indicating that the address referenced in the start address
        field must be fixed up by LINK.

    ■  Byte 04H (end dat in the start address field) contains 00H. As in a
        FIXUPP record, bit 7 indicates that the frame for this fixup is
        specified explicitly, and bits 6 through 4 indicate that a SEGDEF
        index specifies the frame. Bit 3 indicates that the target
        reference is also specified explicitly, and bits 2 through 0
        indicate that a SEGDEF index also specifies the target. See also
        9CH FIXUPP Fixup Record, below.

    ■  Byte 05H (frame datum in the start address field) contains 01H.
        This is a reference to the first SEGDEF record in the module, which
        in this example corresponds to the _TEXT segment. This reference
        tells LINK that the start address lies in the _TEXT segment of the
        module.

    ■  Byte 06H (target datum in the start address field) contains 01H.
        This too is a reference to the first SEGDEF record in the object
        module, which corresponds to the _TEXT segment. LINK uses the
        following target displacement field to determine where in the _TEXT
        segment the address lies.

    ■  Bytes 07-08H (target displacement in the start address field)
        contain 0000H. This is the offset (in bytes) of the start address.

    ■  Byte 09H contains the checksum, 0ACH.


8CH EXTDEF External Names Definition Record

    The EXTDEF record contains a list of symbolic external references--
    that is, references to symbols defined in other object modules. The
    linker resolves external references by matching the symbols declared
    in EXTDEF records with symbols declared in PUBDEF records.

Record format


    ┌──────┬──────┬──────┬──────────────///────────────┬──────┐
    │      │      │      │                             │ chk  │
    │ 8CH  │   length    │   external reference list   │ sum  │
    └──────┴──────┴──────┴──────────────///────────────┴──────┘
                        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

                                    can be
                                    repeated


External reference list
    The external reference list is a variable-length field containing a
    list of names and name types, each formatted as follows:


    ┌──────┬─────────///────────┬──────┐
    │ name │                    │type  │
    │length│        name        │index │
    └──────┴─────────///────────┴──────┘


    ■  The name length is a 1-byte field containing the length of the name
        field that follows it. (LINK restricts name length to a value
        between 01H and 7FH.)

    ■  The type index is a 1-byte reference to the TYPDEF record in the
        object module that describes the type of symbol the name
        represents. A type index value of zero indicates that no TYPDEF
        record is associated with the symbol. A nonzero value indicates
        which TYPDEF record is associated with the external name. Microsoft
        LINK recognizes TYPDEF records only for the purpose of declaring
        communal variables. See 8EH TYPDEF Type Definition Record, below.

    LINK imposes a limit of 1023 external names.

Location in object module

    Any EXTDEF records in an object module must appear before the FIXUPP
    records that reference them. Also, if an EXTDEF record contains a
    nonzero type index, the indexed TYPDEF record must precede the EXTDEF
    record.

Example

    Consider this EXTDEF record generated by the Microsoft C Compiler:

        0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000 8C 25 00 0A 5F 5F 61 63 72 74 75 73 65 64 00 05  .%..__acrtused..
    0010 5F 6D 61 69 6E 00 05 5F 70 75 74 73 00 08 5F 5F  _main.._puts..__
    0020 63 68 6B 73 74 6B 00 A5                          chkstk..

    ■  Byte 00H contains 8CH, indicating that this is an EXTDEF record.

    ■  Bytes 01-02H contain 0025H, the length of the remainder of the
        record.

    ■  Bytes 03-26H contain a list of external references. The first
        reference starts in byte 03H, which contains 0AH, the length of the
        name acrtused. The name itself follows in bytes 04-0DH. Byte 0EH
        contains 00H, which indicates that the symbol's type is not defined
        by any TYPDEF record in this object module. Bytes 0F-26H contain
        similar references to the external symbols _main, _puts, and
        chkstk.

    ■  Byte 27H contains the checksum, 0A5H.


8EH TYPDEF Type Definition Record

    The TYPDEF record contains details about the type of data represented
    by a name declared in a PUBDEF or an EXTDEF record. This information
    may be used by the linker to validate references to names, or it may
    be used by a debugger to display data according to type.

    Starting with Microsoft LINK version 3.50, the COMDEF record should be
    used for declaration of communal variables. For compatibility,
    however, later versions of LINK recognize TYPDEF records as well as
    COMDEF records.

Record format


    ┌──────┬──────┬──────┬──────┬─────────///────────┬──────┐
    │      │      │      │      │     eight-leaf     │ chk  │
    │ 8EH  │   length    │ name │     descriptor     │ sum  │
    └──────┴──────┴──────┴──────┴─────────///────────┴──────┘
                                ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

                                        can be
                                        repeated


    Although the original Intel specification allowed for many different
    type specifications, such as scalar, pointer, and mixed data
    structure, LINK uses TYPDEF records to declare only communal
    variables. Communal variables represent globally shared memory
    areas--for example, FORTRAN common blocks or uninitialized public
    variables in C.

    The size of a communal variable is declared explicitly in the TYPDEF
    record. If a communal variable has different sizes in different object
    modules, LINK uses the largest declared size when it generates an
    executable module.

Name
    The name field of a TYPDEF record is a 1-byte field that is always
    null; that is, it contains a single zero byte.

Eight-leaf descriptor
    The eight-leaf descriptor field, in the original Intel specification,
    was a variable-length field that contained as many as eight "leaves"
    that could be used to describe mixed data structures.

    Microsoft uses a stripped-down version of the eight-leaf descriptor,
    because the field's only function is to describe communal variables:


    ┌──────┬─────────///────────┐
    │      │                    │
    │  0   │  leaf descriptor   │
    └──────┴─────────///────────┘
            ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

                    can be
                repeated


    ■  The first field in the eight-leaf descriptor is a 1-byte field that
        contains a zero byte.

    ■  The leaf descriptor field is a variable-length field that is itself
        divided into four fields ("leaves") that describe the size and type
        of a variable. The two possible variable types are NEAR and FAR.

        If the field describes a NEAR variable (one that can be referenced
        as an offset within a default data segment), the format is


    ┌──────┬──────┬────────///────────┐
    │      │      │                   │
    │ 62H  │     │  length in bits   │
    └──────┴──┼───┴────────///────────┘
            └───── variable
                    type


        - The 1-byte field containing 62H signifies a NEAR variable.

        - The variable type field is a 1-byte field that specifies the
        variable type:

        77H    Array
        79H    Structure
        7BH    Scalar

        This field is ignored by LINK.

        - The length in bits field is a variable-length field that
        indicates the size of the communal variable. Its format depends
        on the size it represents. If the size is less than 128 (80H)
        bits, length in bits is a 1-byte field containing the actual size
        of the field:


    ┌──────┐
    │      │
    │ size │
    └──────┘


        If the size is 128 bits or greater, it cannot be represented in a
        single byte value, so the length in bits field is formatted with
        an extra initial byte that indicates whether the size is
        represented as a 2-, 3-, or 4-byte value:


    ┌──────┬──────┬──────┐
    │      │             │
    │ 81H  │ 2-byte size │
    └──────┴──────┴──────┘


    ┌──────┬──────┬──────┬──────┐
    │      │                    │
    │ 84H  │    3-byte size     │
    └──────┴──────┴──────┴──────┘


    ┌──────┬──────┬──────┬──────┬──────┐
    │      │                           │
    │ 88H  │        4-byte size        │
    └──────┴──────┴──────┴──────┴──────┘


        If the leaf descriptor field describes a FAR variable (one that
        must be referenced with an explicit segment and offset), the
        format is


    ┌──────┬──────┬────────///─────────┬─────────///────────┐
    │      │      │     number of      │    element type    │
    │ 61H  │     │      elements      │       index        │
    └──────┴──┼───┴────────///─────────┴─────────///────────┘
            └───── variable
                    type


        - The 1-byte field containing 61H signifies a FAR variable.

        - The 1-byte variable type for a FAR communal variable is
        restricted to 77H (array). (As with the NEAR variable type field,
        LINK ignores this field.)

        - The number of elements is a variable-length field that contains
        the number of elements in the array. It has the same format as
        the length in bits field in the leaf descriptor for a NEAR
        variable.

        - The element type index is an index field that references a
        previous TYPDEF record. A value of 1 indicates the first TYPDEF
        record in the object module, a value of 2 indicates the second
        TYPDEF record, and so on. The TYPDEF record referenced must
        describe a NEAR variable. This way, the data type and size of the
        elements in the array can be determined.

Location in object module

    Any TYPDEF records in an object module must precede the EXTDEF or
    PUBDEF records that reference them.

Examples

    The following three examples of TYPDEF records were generated by the
    Microsoft C Compiler version 3.0. (Later versions use COMDEF records.)

    The first sample TYPDEF record corresponds to the public declaration

    int    foo;             /* 16-bit integer */

    The TYPEDEF record is

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  8E 06 00 00 00 62 7B 10 7F                       .....b{..

    ■  Byte 00H contains 8EH, indicating that this is a TYPDEF record.

    ■  Bytes 01-02H contain 0006H, the length of the remainder of the
        record.

    ■  Byte 03H (the name field) contains 00H, a null name.

    ■  Bytes 04-07H represent the eight-leaf descriptor field. The first
        byte of this field (byte 04H) contains 00H. The remaining bytes
        (bytes 05-07H) represent the leaf descriptor field:

        - Byte 05H contains 62H, indicating this TYPDEF record describes a
        NEAR variable.

        - Byte 06H (the variable type field) contains 7BH, which describes
        this variable as a scalar.

        - Byte 07H (the length in bits field) contains 10H, the size of the
        variable in bits.

    ■  Byte 08H contains the checksum, 7FH.

    The next example demonstrates how the variable size contained in the
    length in bits field of the leaf descriptor is formatted:

    char    foo2[32768];            /* 32 KB array */

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  8E 09 00 00 00 62 7B 84 00 00 04 04              .....b{.....

    ■  The length in bits field (bytes 07-0AH) starts with a byte
        containing 84H, which indicates that the actual size of the
        variable is represented as a 3-byte value (the following 3 bytes).
        Bytes 08-0AH contain the value 040000H, the size of the 32 KB array
        in bits.

    This third C statement, because it declares a FAR variable, causes two
    TYPDEF records to be generated:

    char    far     foo3[10][2][20];        /* 400-element FAR array*/

    The two TYPDEF records are

        0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000 8E 06 00 00 00 62 7B 08 87 8E 09 00 00 00 61 77  .....b{.......aw
    0010 81 90 01 01 7E                                   ....|

    ■  Bytes 00-08H contain the first TYPDEF record, which defines the
        data type of the elements of the array (NEAR, scalar, 8 bits in
        size).

    ■  Bytes 09-14H contain the second TYPDEF record. The leaf
        descriptor field of this record declares that the variable is
        FAR (byte 0EH contains 61H) and an array (byte 0FH, the variable
        type, contains 77H).

        - Because this TYPDEF record describes a FAR variable, bytes 10-12H
        represent a number of elements field. The first byte of the field
        is 81H, indicating a 2-byte value, so the next 2 bytes (bytes 11-
        12H) contain the number of elements in the array, 0190H (400D).

    ■  Byte 13H (the element type index) contains 01H, which is a
        reference to the first TYPDEF record in the object module--in this
        example, the one in bytes 00-08H.


90H PUBDEF Public Names Definition Record

    The PUBDEF record contains a list of public names. When object modules
    are linked, the linker uses these names to resolve external references
    in other object modules.

Record format


    ┌──────┬──────┬──────┬─────///─────┬─────///─────┬─────///─────┬─────///─────┬──────┐
    │      │      │      │             │             │             │             │ chk  │
    │ 90H  │  length     │ public base │ public name │public offset│ type index  │ sum  │
    └──────┴──────┴──────┴─────///─────┴─────///─────┴─────///─────┴─────///─────┴──────┘
                                        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

                                                        can be
                                                        repeated


Public base
    Each name in the PUBDEF record refers to a location (a 16-bit offset)
    in a particular segment or group. The public base, a variable-length
    field that specifies the segment or group, is formatted as follows:


    ┌────────///─────────┬─────────///────────┬──────┬──────┐
    │                    │                    │    frame    │
    │    group index     │   segment index    │   number    │
    └────────///─────────┴─────────///────────┴──────┴──────┘


    ■  Group index is an index field that references a previous GRPDEF
        record in the object module. If the group index value is 0, no
        group is associated with this PUBDEF record.

    ■  Segment index is also an index field. It associates a particular
        segment with this PUBDEF record by referencing a previous SEGDEF
        record. A value of 1 indicates the first SEGDEF record in the
        object module, a value of 2 indicates the second, and so on. If the
        segment index value is 0, the group index must also be 0--in this
        case, the frame number appears in the public base field.

    ■  The 2-byte frame number appears in the public base field only when
        the group index and segment index are both 0. In other words, the
        frame number specifies the start of an absolute segment. If
        present, the value in the frame number field indicates the number
        of the frame containing the public name.

Public name
    Public name is a variable-length field containing a public name. The
    first byte specifies the length of the name; the remainder is the name
    itself. (The Intel specification allows names of 1 to 255 bytes.
    Microsoft LINK restricts the maximum length of a public name to 127
    bytes.)

Public offset
    Public offset is a 2-byte field containing the offset of the location
    referred to by the public name. This offset is assumed to lie within
    the segment, group, or frame specified in the public base field.

Type index
    Type index is an index field that references a previous TYPDEF record
    in the object module. A value of 1 indicates the first TYPDEF record
    in the module, a value of 2 indicates the second, and so on. The type
    index value can be 0 if no data type is associated with the public
    name.

    The public name, public offset, and type index fields can be repeated
    within a single PUBDEF record. Thus, one PUBDEF record can declare a
    list of public names.

Location in object module

    Any PUBDEF records in an object module must appear after the GRPDEF
    and SEGDEF records to which they refer. Because PUBDEF records are not
    themselves referenced by any other type of object record, they are
    generally placed near the end of an object module.

Examples

    The following two examples show PUBDEF records created by the
    Microsoft Macro Assembler.

    The first example is the record for the statement

            PUBLIC     GAMMA

    The PUBDEF record is
            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  90 0C 00 00 01 05 47 41 4D 4D 41 02 00 00 F9     ......GAMMA....

    ■  Byte 00H contains 90H, indicating a PUBDEF record.

    ■  Bytes 01-02H contain 000CH, the length of the remainder of the
        record.

    ■  Bytes 03-04H represent the public base field. Byte 03H (the group
        index) contains 0, indicating that no group is associated with the
        name in this PUBDEF record. Byte 04H (the segment index) contains
        1, a reference to the first SEGDEF record in the object module.
        This is the segment to which the name in this PUBDEF record refers.

    ■  Bytes 05-0AH represent the public name field. Byte 05H contains 05H
        (the length of the name), and bytes 06-0AH contain the name itself,
        GAMMA.
    ■  Bytes 0B-0CH contain 0002H, the public offset. The name GAMMA thus
        refers to the location that is offset 2 bytes from the beginning of
        the segment referenced by the public base.

    ■  Byte 0DH is the type index. The value of the type index is 0,
        indicating that no data type is associated with the name GAMMA.

    ■  Byte 0EH contains the checksum, 0F9H.

    The next example is the PUBDEF record for the following absolute
    symbol declaration:

            PUBLIC    ALPHA
    ALPHA   EQU       1234h

    The PUBDEF record is
            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  90 0E 00 00 00 00 00 05 41 4C 50 48 41 34 12 00  ......ALPHA4....
    0010  B1                                               .

    ■  Bytes 03-06H (the public base field) contain a group index of 0
        (byte 03H) and a segment index of 0 (byte 04H). Since both the
        group index and segment index are 0, a frame number also appears in
        the public base field. In this instance, the frame number (bytes
        05-06H) also happens to be 0.

    ■  Bytes 07-0CH (the public name field) contain the name ALPHA,
        preceded by its length.

    ■  Bytes 0D-0EH (the public offset field) contain 1234H. This is the
        value associated with the symbol ALPHA in the assembler EQU
        directive. If ALPHA is declared in another object module with the
        declaration

            EXTRN     ALPHA:ABS

    any references to ALPHA in that object module are fixed up as absolute
    references to offset 1234H in frame 0. In other words, ALPHA would
    have the value 1234H.

    ■  Byte 0FH (the type index) contains 0.


94H LINNUM Line Number Record

    The LINNUM record relates line numbers in source code to addresses in
    object code.

Record format


┌──────┬──────┬──────┬─────────///────────┬──────┬──────┬──────┬──────┬──────┐
│      │      │      │    line number     │    line     │ line number │ chk  │
│ 94H  │   length    │        base        │   number    │   offset    │ sum  │
└──────┴──────┴──────┴─────────///────────┴──────┴──────┴──────┴──────┴──────┘
                                            ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

                                                        can be
                                                    repeated


Line number base
    The line number base describes the segment to which the line number
    refers. Although the complete Intel specification allows the line
    number base to refer to a group or to an absolute segment as well as
    to a relocatable segment, Microsoft restricts references in this field
    to relocatable segments. The format of the line number base field is


    ┌──────┬────────///─────────┐
    │group │                    │
    │index │   segment index    │
    └──────┴────────///─────────┘


    ■  The group index field always contains a single zero byte.

    ■  The segment index is an index field that references a previous
        SEGDEF record. A value of 1 indicates the first SEGDEF record in
        the object module, a value of 2 indicates the second, and so on.

Line number
    Line number is a 2-byte field containing a line number between 0 and
    32,767 (0-7FFFH).

Line number offset
    The line number offset is a 2-byte field that specifies the offset of
    the executable code (in the segment specified in the line number base
    field) to which the line number in the line number field refers.

    The line number and line number offset fields can be repeated, so a
    single LINNUM record can specify multiple line numbers in the same
    segment.

Location in object module

    Any LINNUM records in an object module must appear after the SEGDEF
    records to which they refer. Because LINNUM records are not themselves
    referenced by any other type of object record, they are generally
    placed near the end of an object module.

Example

    The following LINNUM record was generated by the Microsoft C Compiler:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  94 0F 00 00 01 02 00 00 00 03 00 08 00 04 00 0F ................
    0010  00 3C                                           ..

    ■  Byte 00H contains 94H, indicating that this is a LINNUM record.

    ■  Bytes 01-02H contain 000FH, the length of the remainder of the
        record.

    ■  Bytes 03-04H represent the line number base field. Byte 03H (the
        group index field) contains 00H, as it must. Byte 04H (the segment
        index field) contains 01H, indicating that the line numbers in this
        LINNUM record refer to code in the segment defined in the first
        SEGDEF record in this object module.

    ■  Bytes 05-06H (a line number field) contain 0002H, and bytes 07-08H
        (a line number offset field) contain 0000H. Together, they indicate
        that source-code line number 0002 corresponds to offset 0000H in
        the segment indicated in the line number base field.

        Similarly, the two pairs of line number and line number offset
        fields in bytes 09-10H specify that line number 0003 corresponds to
        offset 0008H and that line number 0004 corresponds to offset 000FH.

    ■  Byte 11H contains the checksum, 3CH.


96H LNAMES List of Names Record

    The LNAMES record is a list of names that can be referenced by
    subsequent SEGDEF and GRPDEF records in the object module.

Record format


    ┌──────┬──────┬──────┬─────────///────────┬──────┐
    │      │      │      │                    │ chk  │
    │ 96H  │   length    │     name list      │ sum  │
    └──────┴──────┴──────┴─────────///────────┴──────┘
                        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

                                can be
                                repeated


Name list
    Name list is a variable-length field that contains the list of names.
    Each name is preceded by 1 byte that defines its length, which can be
    a value between 0 and 255 (0-0FFH).

    The names in the list are indexed implicitly in the order they appear:
    The first name in the list has an index of 1, the second name has an
    index of 2, and so forth. References to the names contained in name
    list by subsequent object records, such as SEGDEF, are accomplished by
    using this index number. LINK imposes a limit of 255 logical names per
    object module.

Location in object module

    Any LNAMES records in an object module must appear before the GRPDEF
    or SEGDEF records that refer to them. Because it does not refer to any
    other type of object records, an LNAMES record usually appears near
    the start of an object module.

Example

    The following LNAMES record contains the segment and class names
    specified in all three of the assembler statements:

    _TEXT    SEGMENT byte public 'CODE'
    _DATA    SEGMENT word public 'DATA'
    _STACK   SEGMENT para public 'STACK'

    The LNAMES record is

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  96 25 00 00 04 43 4F 44 45 04 44 41 54 41 05 53 .%...CODE.DATA.S
    0010  54 41 43 4B 05 5F 44 41 54 41 06 5F 53 54 41 43 TACK._DATA._STAC
    0020  4B 05 5F 54 45 58 54 8B                         K._TEXT.

    ■  Byte 00H contains 96H, indicating that this is an LNAMES record.

    ■  Bytes 01-02H contain 0025H, the length of the remainder of the
        record.

    ■  Byte 03H contains 00H, a zero-length name.

    ■  Byte 04H contains 04H, the length of the class name CODE, which is
        found in bytes 05-08H. Bytes 09-26H contain the class names DATA
        and STACK and the segment names _DATA, _STACK, and _TEXT, each
        preceded by 1 byte giving its length.

    ■  Byte 27H contains the checksum, 8BH.


98H SEGDEF Segment Definition Record

    The SEGDEF record describes a logical segment in an object module. It
    defines the segment's name, length, and alignment, and the way the
    segment can be combined with other logical segments. LINK imposes a
    limit of 255 SEGDEF records per object module.

    Object records that follow a SEGDEF record can refer to it to identify
    a particular segment.

Record format


    ┌──────┬──────┬──────┬─────────///────────┬──────┬──────┬─────────///────────┬─────────///────────┬─────────///────────┬──────┐
    │      │      │      │                    │   segment   │    segment name    │     class name     │    overlay name    │ chk  │
    │ 98H  │   length    │ segment attributes │   length    │       index        │       index        │       index        │ sum  │
    └──────┴──────┴──────┴─────────///────────┴──────┴──────┴────────///─────────┴────────///─────────┴─────────///────────┴──────┘


Segment attributes
    Segment attributes is a variable-length field:


    ┌──────┬──────┬──────┬──────┐
    │ ACBP │    frame    │      │
    │ byte │   number    │offset│
    └──────┴──────┴──────┴──────┘

The ACBP byte
    The contents and size of the segment attributes field depend on the
    first byte of the field, the ACBP byte:


    bit     7      6      5      4      3      2      1      0
        ┌────────────────────┬────────────────────┬──────┬──────┐
        │                    │                    │      │      │
        │         A          │         C          │  B   │  P   │
        └────────────────────┴────────────────────┴──────┴──────┘

    The bit fields in the ACBP byte describe the following characteristics
    of the segment:

    A   Alignment in the run-time memory map
    C   Combination with other segments
    B   Big (a segment of exactly 64 KB)
    P   Page-resident (not used in MS-DOS)

    The A field. Bits 7-5 of the ACBP byte, the A field, describe
    the logical segment's alignment:

    A = 0 (000B)    Absolute (located at a specified frame address)
    A = 1 (001B)    Relocatable, byte aligned
    A = 2 (010B)    Relocatable, word aligned
    A = 3 (011B)    Relocatable, paragraph aligned
    A = 4 (100B)    Relocatable, page aligned

    The original Intel specification includes two additional segment-
    alignment values not supported in MS-DOS.

    The following examples of Microsoft assembler SEGMENT directives show
    the resulting values for the A field in the corresponding SEGDEF
    object record:

    aseg    SEGMENT at 400h                 ; A = 0
    bseg    SEGMENT byte public 'CODE'      ; A = 1
    cseg    SEGMENT para stack 'STACK'      ; A = 3

    The C field. Bits 4-2 of the ACBP byte, the C field, describe how the
    linker can combine the segment with other segments. Under MS-DOS,
    segments with the same name and class can be combined in two ways.
    They can be concatenated to form one logical segment, or they can be
    overlapped. In the latter case, they have either the same starting
    address or the same end address and they describe a common area of
    memory.

    The value in the C field corresponds to one of these two methods of
    combining segments. Meaningful values, however, also depend on whether
    the segment is absolute (A = 0) or relocatable (A = 1, 2, 3, or 4). If
    A = 0, then C must also be 0, because absolute segments cannot be
    combined. Values for the C field are

    C = 0 (000B)    Cannot be combined; used for segments whose combine
                    type is not explicitly specified (private segments).
    C = 1 (001B)    Not used by Microsoft.
    C = 2 (010B)    Can be concatenated with another segment of the same
                    name; used for segments with the public combine type.
    C = 3 (011B)    Undefined.
    C = 4 (100B)    As defined by Microsoft, same as C = 2.
    C = 5 (101B)    Can be concatenated with another segment with the same
                    name; used for segments with the stack combine type.
    C = 6 (110B)    Can be overlapped with another segment with the same
                    name; used for segments with the common combine type.
    C = 7 (111B)    As defined by Microsoft, same as C = 2.

    The following examples of assembler SEGMENT directives show the
    resulting values for the C field in the corresponding SEGDEF object
    record:

    aseg    SEGMENT at 400H               ; C = 0
    bseg    SEGMENT public 'DATA'         ; C = 2
    cseg    SEGMENT stack 'STACK'         ; C = 5
    dseg    SEGMENT common 'COMMON'       ; C = 6

    See PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING TOOLS: The
    Microsoft Object Linker.

    The B and P fields. Bit 1 of the ACBP byte, the B field, is set to 1
    (and the segment length field is set to 0) only if the segment is
    exactly 64 KB long.

    Bit 0 of the ACBP byte, the P field, is unused in MS-DOS. Its value
    should always be 0.

    Frame number and offset
    The frame number and offset fields of the segment attributes field are
    present only if the segment is an absolute segment (A = 0 in the ACBP
    byte). Taken together, the frame number and offset indicate the
    starting address of the segment.

    ■  Frame number is a 2-byte field that contains the frame number of
        the start of the segment.

    ■  Offset is a 1-byte field that contains an offset between 00H and
        0FH within the specified frame. LINK ignores the offset field.

Segment length
    Segment length is a 2-byte field that specifies the length of the
    segment in bytes. The length can be from 00H to FFFFH. If a segment is
    exactly 64 KB (10000H) in size, segment length should be 0 and the B
    field in the ACBP byte should be 1.

Segment name index, class name index, and overlay name index
    Each of the segment name index, class name index, and overlay name
    index fields contains an index into the list of names defined in
    previous LNAMES records in the object module. An index value of 1
    indicates the first name in the LNAMES record, a value of 2 the
    second, and so on.

    ■  The segment name index identifies the segment with a unique name.
        The name may have been assigned by the programmer, or it may have
        been generated by a compiler.

    ■  The class name index identifies the segment with a class name (such
        as CODE, FAR_DATA, and STACK). The linker places segments with the
        same class name into a contiguous area of memory in the run-time
        memory map.

    ■  The overlay name index identifies the segment with a run-time
        overlay. Starting with version 2.40, however, LINK ignores the
        overlay name index. In versions 2.40 and later, command-line
        parameters to LINK, rather than information contained in object
        modules, determine the creation of run-time overlays.

Location in object module

    SEGDEF records must follow the LNAMES record to which they refer. In
    addition, SEGDEF records must precede any PUBDEF, LINNUM, GRPDEF,
    FIXUPP, LEDATA, or LIDATA records that refer to them.

Examples

    In this first example, the segment is byte aligned:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  98 07 00 28 11 00 07 02 01 1E                    ...(......

    ■  Byte 00H contains 98H, indicating that this is a SEGDEF record.

    ■  Bytes 01-02H contain 0007H, the length of the remainder of the
        record.

    ■  Byte 03H contains 28H (00101000B), the ACBP byte. Bits 7-5 (the A
        field) contain 1 (001B), indicating that this segment is
        relocatable and byte aligned. Bits 4-2 (the C field) contain 2
        (010B), which represents a public combine type. (When this object
        module is linked, this segment will be concatenated with all other
        segments with the same name.) Bit 1 (the B field) is 0, indicating
        that this segment is smaller than 64 KB. Bit 0 (the P field) is
        ignored and should be zero, as it is here.

    ■  Bytes 04-05H contain 0011H, the size of the segment in bytes.

    ■  Bytes 06-08H index the list of names defined in the module's LNAMES
        record. Byte 06H (the segment name index) contains 07H, so the name
        of this segment is the seventh name in the LNAMES record. Byte 07H
        (the class name index) contains 02H, so the segment's class name is
        the second name in the LNAMES record. Byte 08H (the overlay name
        index) contains 1, a reference to the first name in the LNAMES
        record. (This name is usually null, as MS-DOS ignores it anyway.)

    ■  Byte 09H contains the checksum, 1EH.

    The second SEGDEF record declares a word-aligned segment. It differs
    only slightly from the first.

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  98 07 00 48 0F 00 05 03 01 01                   ...H......

    ■  Bits 7-5 (the A field) of byte 03H (the ACBP byte) contain 2
        (010B), indicating that this segment is relocatable and word
        aligned.

    ■  Bytes 04-05H contain the size of the segment, 000FH.

    ■  Byte 06H (the segment name index) contains 05H, which refers to the
        fifth name in the previous LNAMES record.

    ■  Byte 07H (the class name index) contains 03H, a reference to the
        third name in the LNAMES record.


9AH GRPDEF Group Definition Record


    The GRPDEF record defines a group of segments, all of which lie within
    the same 64 KB frame in the run-time memory map. LINK imposes a limit
    of 21 GRPDEF records per object module.

Record format


    ┌──────┬──────┬──────┬────────///─────────┬─────────///────────┬──────┐
    │      │      │      │     group name     │  group component   │ chk  │
    │ 9AH  │   length    │       index        │     descriptor     │ sum  │
    └──────┴──────┴──────┴────────///─────────┴─────────///────────┴──────┘
                                            ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

                                                    can be
                                                    repeated


Group name index
    Group name index is an index field whose value refers to a name in the
    name list field of a previous LNAMES record.

Group component descriptor
    The group component descriptor consists of two fields:


    ┌──────┬─────────///────────┐
    │      │                    │
    │type  │   segment index    │
    └──────┴─────────///────────┘


    ■  Type is a 1-byte field whose value is always 0FFH, indicating that
        the following field contains a segment index value. The original
        Intel specification defines four other types of group component
        descriptor with the values 0FEH, 0FDH, 0FBH, and 0FAH. LINK ignores
        these other type values, however, and assumes that the group
        component descriptor contains a segment index value.

    ■  The segment index field contains an index number that refers to a
        previous SEGDEF record. A value of 1 indicates the first SEGDEF
        record in the object module, a value of 2 indicates the second, and
        so on.

    The group component descriptor field is usually repeated within the
    GRPDEF record, so all segments constituting the group can be included
    in one GRPDEF record.

Location in object module

    GRPDEF records must follow the LNAMES and SEGDEF records to which they
    refer. They must also precede any PUBDEF, LINNUM, FIXUPP, LEDATA, or
    LIDATA records that refer to them.

Example

    The following example of a GRPDEF record corresponds to the assembler
    directive:

    tgroup  GROUP seg1,seg2,seg3

    The GRPDEF record is

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9A 08 00 06 FF 01 FF 02 FF 03 55                 ..........U

    ■  Byte 00H contains 9AH, indicating that this is a GRPDEF record.

    ■  Bytes 01-02H contain 0008H, the length of the remainder of the
        record.

    ■  Byte 03H contains 06H, the group name index. In this instance, the
        index number refers to the sixth name in the previous LNAMES record
        in the object module. That name is the name of the group of
        segments defined in the remainder of the record.

    ■  Bytes 04-05H contain the first of three group component descriptor
        fields. Byte 04H contains the required 0FFH, indicating that the
        subsequent field is a segment index. Byte 05H contains 01H, a
        segment index that refers to the first SEGDEF record in the object
        module. This SEGDEF record declared the first of three segments in
        the group.

    ■  Bytes 06-07H represent the second group component descriptor, this
        one referring to the second SEGDEF record in the object module.

    ■  Similarly, bytes 08-09H are a group component descriptor field that
        references the third SEGDEF record.

    ■  Byte 0AH contains the checksum, 55H.


9CH FIXUPP Fixup Record

    The FIXUPP record contains information that allows the linker to
    resolve (fix up) addresses whose values cannot be determined by the
    language translator. FIXUPP records describe the LOCATION of each
    address value to be fixed up, the TARGET address to which the fixup
    refers, and the FRAME relative to which the address computation is
    performed.

Record format


    ┌──────┬──────┬──────┬────────///─────────┬─────────///────────┬──────┐
    │      │      │      │                    │                    │ chk  │
    │ 9CH  │  length     │       thread       │       fixup        │ sum  │
    └──────┴──────┴──────┴────────///─────────┴─────────///────────┴──────┘
                        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

                                can be               can be
                                repeated             repeated


Thread and fixup fields
    A FIXUPP record can contain zero or more thread fields and zero or
    more fixup fields. Each fixup field describes the method to be used by
    the linker to compute the TARGET address to be placed at a particular
    location in the executable image, relative to a particular FRAME. The
    information that determines the LOCATION, TARGET, and FRAME can be
    specified explicitly in the fixup field. It can also be specified
    within the fixup field by a reference to a previous thread field.

    A thread field describes only the method to be used by the linker to
    refer to a particular TARGET or FRAME. Because the same thread field
    can be referenced in several subsequent fixup fields, a FIXUPP record
    that uses thread fields may be smaller than one in which thread fields
    are not used.

    Thread and fixup fields are distinguished from one another by the
    high-order bit of the first byte in the field. If the high-order bit
    is 0, the field is a thread field. If the high-order bit is 1, the
    field is a fixup field.

    The thread field
    A thread field contains information that can be referenced in
    subsequent thread or fixup fields in the same or subsequent FIXUPP
    records. It has the following format:


    ┌──────┬─────────///────────┐
    │thread│                    │
    │ data │       index        │
    └──────┴─────────///────────┘


    The thread data field is a single byte comprising five subfields:


    bit     7      6      5      4      3      2      1      0
        ┌──────┬──────┬──────┬────────────────────┬─────────────┐
        │      │      │      │                    │   thread    │
        │  0   │  D   │  0   │       method       │   number    │
        └──────┴──────┴──────┴────────────────────┴─────────────┘


    ■  Bit 7 of the thread data byte is 0, indicating the start of a
        thread field.

    ■  The D field (bit 6) indicates whether the thread field specifies a
        FRAME or a TARGET. The D bit is set to 1 to indicate a FRAME or to
        0 to indicate a TARGET.

    ■  Bit 5 of the thread data byte is not used. It should always be set
        to 0.

    ■  Bits 4 through 2 represent the method field. If D = 1, the method
        field contains 0, 1, 2, 4, or 5. Each of these numbers corresponds
        to one method of specifying a FRAME (see Table 19-2). If D = 0, the
        method field contains 0, 1, 2, 4, 5, or 6, each of which
        corresponds to one of the methods of specifying a TARGET (see Table
        19-3).

        In the case of a TARGET address, only bits 3 and 2 of the method
        field are used. When D = 0, the high-order bit of the value in the
        method field is derived from the P bit in the fix dat field of any
        subsequent fixup field that refers to this thread field. Thus, if D
        = 0, bit 4 of the method field is also 0, and the only meaningful
        values for the method field are 0, 1, and 2.

    ■  The thread number field (bits 1 and 0) contains a number between 0
        and 3. This number is used in subsequent fixup or thread fields to
        refer to this particular thread field.

        The thread number is implicitly associated with the D field by the
        linker, so as many as eight different thread fields (four FRAMEs
        and four TARGETs) can be referenced at any time. A thread number
        can be reused in an object module and, if it is, always refers to
        the thread field in which it last appeared.


    Table 19-2. FRAME Fixup Methods.

╓┌───────────┌───────────────────────────────────────────────────────────────╖
    Method Description
    ──────────────────────────────────────────────────────────────────
    0      The FRAME is specified by a segment index.

    1      The FRAME is specified by a group index.

    2      The FRAME is indicated by an external index. LINK determines
            the FRAME from the external name's corresponding PUBDEF record
            in another object module, which specifies either a logical
            segment or a group.

    3      The FRAME is identified by an explicit frame number. (Not
            supported by LINK.)

    4      The FRAME is determined by the segment in which the LOCATION is
            defined. In this case, the largest possible frame number is
            used.

    5      The FRAME is determined by the TARGET's segment, group, or
            external index.


    Table 19-3. TARGET Fixup Methods.

╓┌─────────────┌─────────────────────────────────────────────────────────────╖
    Method   Description
    ──────────────────────────────────────────────────────────────────
    0        The TARGET is specified by a segment index and a
            displacement. The displacement is given in the target
            displacement field of the FIXUPP record.

    1        The TARGET is specified by a group index and a target
            displacement.

    2        The TARGET is specified by an external index and a target
            displacement. LINK adds the displacement to the address it
            determines from the external name's corresponding PUBDEF
            record in another object module.

    3        The TARGET is identified by an explicit frame number. (Not
            supported by LINK.)

    4        The TARGET is specified by a segment index only.

    5        The TARGET is specified by a group index only.

    6        The TARGET is specified by an external index. The TARGET is
            the address associated with the external name.

    7        The TARGET is identified by an explicit frame number. (Not
            supported by LINK.)


    The index field either contains an index value that refers to a
    previous SEGDEF, GRPDEF, or EXTDEF record, or it contains an explicit
    frame number. The interpretation of the index value depends on the
    value of the method field of the thread data field:

    method =  0 Segment index (reference to a previous SEGDEF record)
    method =  1 Group index (reference to a previous GRPDEF record)
    method =  2 External index (reference to a previous EXTDEF record)
    method =  3 Frame number (not supported by LINK; ignored)

    The fixup field
    The fixup field provides the information needed by the linker to
    resolve a reference to a relocatable or external address. The fixup
    field has the following format:


    ┌──────┬──────┬──────┬────────///─────────┬─────────///────────┬──────┬──────┐
    │      │      │ fix  │                    │                    │   target    │
    │   locat     │ dat  │    frame datum     │    target datum    │displacement │
    └──────┴──────┴──────┴────────///─────────┴─────────///────────┴──────┴──────┘


    The 2-byte locat field has an unusual format. Contrary to
    the usual byte order in Intel data structures, the most significant
    bits of the locat field are found in the low-order, rather
    than the high-order, byte:


                        low-order byte                     │
bit     15     14     13     12     11     10     9      8   │  7      6
    ┌──────┬──────┬──────┬────────────────────┬─────────────┼───────────────────────────────────────────────────────┐
    │      │      │      │                    │                                                                     │
    │  1   │  M   │  S   │        loc         │                                  data record offset                 │
    └──────┴──────┴──────┴────────────────────┴─────────────┴───────────────────────────────────────────────────────┘


    ■  Bit 15 (the high-order bit of the locat field) contains 1,
        indicating that this is a fixup field.

    ■  Bit 14 (the M bit) is 1 if the fixup is segment relative and 0 if
        the fixup is self-relative.

    ■  Bit 13 (the S bit) is currently unused and should always be set to
        0.

    ■  Bits 12 through 10 represent the loc field. This field contains a
        number between 0 and 5 that indicates the type of LOCATION to be
        fixed up:

        loc = 0 Low-order byte
        loc = 1 Offset
        loc = 2 Segment
        loc = 3 Pointer (segment:offset)
        loc = 4 High-order byte (not recognized by LINK)
        loc = 5 Loader-resolved offset (treated as loc = 1 by the linker)

    ■  Bits 9 through 0 (the data record offset) indicate the position of
        the LOCATION to be fixed up in the LEDATA or LIDATA record
        immediately preceding the FIXUPP record. This offset indicates
        either a byte in the data field of an LEDATA record or a data byte
        in the content field of an iterated data block in an LIDATA record.

    The fix dat field is a single byte comprising five fields:


    bit     7      6      5      4      3      2      1      0
        ┌──────┬────────────────────┬──────┬──────┬─────────────┐
        │      │                    │      │      │             │
        │  F   │       frame        │  T   │  P   │   targt     │
        └──────┴────────────────────┴──────┴──────┴─────────────┘


    ■  Bit 7 (the F bit) is set to 1 if the FRAME for this fixup is
        specified by a reference to a previous thread field. The F bit is 0
        if the FRAME method is explicitly defined in this fixup field.

    ■  The interpretation of the frame field in bits 6 through 4 depends
        on the value of the F bit. If F = 1, the frame field contains a
        number between 0 and 3 that indicates the thread field containing
        the FRAME method. If F = 0, the frame field contains 0, 1, 2, 4, or
        5, corresponding to one of the methods of specifying a FRAME listed
        in Table 19-2.

    ■  Bit 3 (the T bit) is set to 1 if the TARGET for the fixup is
        specified by a reference to a previous thread field. If the T bit
        is 0, the TARGET is explicitly defined in this fixup field.

    ■  Bit 2 (the P bit) and bits 1 and 0 (the targt field) can be
        considered a 3-bit field analogous to the frame field.

    ■  If the T bit indicates that the TARGET is specified by a previous
        thread reference (T = 1), the targt field contains a number between
        0 and 3 that refers to a previous thread field containing the
        TARGET method. In this case, the P bit, combined with the 2 low-
        order bits of the method field in the thread field, determines the
        TARGET method. If the T bit is 0, indicating that the target is
        explicitly defined, the P and targt fields together contain 0, 1,
        2, 4, 5, or 6. This number corresponds to one of the TARGET fixup
        methods listed in Table 19-3. (In this case, the P bit can be
        regarded as the high-order bit of the method number.)

    Frame datum is an index field that refers to a previous SEGDEF,
    GRPDEF, or EXTDEF record, depending on the FRAME method.

    Similarly, the target datum field contains a segment index, a group
    index, or an external index, depending on the TARGET method.

    The target displacement field, a 2-byte field, is present only if the
    P bit in the fixdat field is set to 0, in which case the target
    displacement field contains the 16-bit offset used in methods 0, 1,
    and 2 of specifying a TARGET.

Location in object module

    FIXUPP records must appear after the SEGDEF, GRPDEF, or EXTDEF records
    to which they refer. In addition, if a FIXUPP record contains any
    fixup fields, it must immediately follow the LEDATA or LIDATA record
    to which the fixups refer.

Examples

    Although crucial to the proper linking of object modules, FIXUPP
    records are terse: Almost every bit is meaningful. For these reasons,
    the following three examples of FIXUPP records are particularly
    detailed.

    A good way to understand how a FIXUPP record is put together is to
    compare it to the corresponding source code. The Microsoft Macro
    Assembler is helpful in this regard, because it marks in its source
    listing address references it cannot resolve. The "program" in Figure
    19-6 is designed to show how some of the most frequently encountered
    fixups are encoded in FIXUPP records.

    ──────────────────────────────────────────────────────────────────────

    Figure 19-6. A sample "program" showing how some common fixups are
    encoded in FIXUPP records.


    ──────────────────────────────────────────────────────────────────────


    The assembler generates one LEDATA record for this program:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0010  A0 1A 00 01 00 00 E9 00 00 EB 00 EA 00 00 00 00 ................
    0020  EA 00 00 00 00 BB 00 00 B8 00 00 C3 67          ............g

    Bytes 06-2BH (the data field) of this LEDATA record contain 8086
    opcodes for each of the instruction mnemonics in the source code. The
    gaps (zero values) in the data field correspond to address values that
    the assembler cannot resolve. The linker will fix up the address
    values in the gaps by computing the correct values and adding them to
    the zero values in the gaps. The FIXUPP record that tells the linker
    how to do this immediately follows the LEDATA record in the object
    module:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 21 00 84 01 06 01 02 80 04 06 01 02 CC 06 04 .!..............
    0010  02 02 CC 0B 06 01 01 C4 10 00 01 01 15 00 C8 13 ................
    0020  04 01 01 A3                                     ....

    ■  Byte 00H contains 9CH, indicating this is a FIXUPP record.

    ■  Bytes 01-02H contain 0021H, the length of the remainder of the
        record.

    ■  Bytes 03-07H represent the first of the six fixup fields in this
        record:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 21 00 84 01 06 01 02 80 04 06 01 02 CC 06 04 .!..............
    0010  02 02 CC 0B 06 01 01 C4 10 00 01 01 15 00 C8 13 ................
    0020  04 01 01 A3                                     ....

    The information in this fixup field will allow the linkery to resolve
    the address reference in the statement

    jmp     NearLabel

        - Bytes 03-04H (the locat field) contain 8401H
        (1000010000000001B). (Recall that this field does not conform to
        the usual Intel byte order.) Bit 15 is 1, signifying that this is
        a fixup field, not a thread field. Bit 14 (the M bit) is 0, so
        this fixup is self-relative. Bit 13 is unused and should be set
        to 0, as it is here.Bits 12-10 (the loc field) contain 1 (001B),
        so the LOCATION to be fixed up is a 16-bit offset. Bits 9-0 (the
        data record offset) contain 1 (0000000001B), which informs the
        linker that the LOCATION to be fixed up is at offset 1 in the
        data field of the LEDATA record immediately preceding this FIXUPP
        record--in other words, the 2 bytes immediately following the
        first opcode 0E9H.

        - Byte 05H (the fix dat field) contains 06H (00000110B). Bit 7
        (the F bit) is 0, meaning the FRAME for this fixup is explicitly
        specified in this fixup field. Bits 6-4 (the frame field) contain
        0 (000B), indicating that FRAME method 0 specifies the FRAME. Bit
        3 (the T bit) is 0, so the TARGET for this fixup is also
        explicitly specified. Bits 2-0 (the P bit) and the targt field
        contain 6 (110B), so TARGET method 6 specifies the TARGET.

        - Byte 06H is a frame datum field, because the FRAME is explicitly
        specified (the F bit of the fix dat field = 0). And, because
        method 0 is specified, the frame datum is an index field that
        refers to a previous SEGDEF record. In this example, the frame
        datum field contains 1, which indicates the first SEGDEF record
        in the object module: the _TEXT segment.

        - Similarly, byte 07H is a target datum, because the TARGET is also
        explicitly specified (the T bit of the fix dat field = 0). The
        fix dat field also indicates that TARGET method 6 is used, so the
        target datum is an index field that refers to the external
        reference list in a previous EXTDEF record. The value of this
        index is 2, so the TARGET is the second external reference
        declared in the EXTDEF record: NearLabel in this object module.

    ■  Bytes 08-0CH represent the second fixup field:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 21 00 84 01 06 01 02 80 04 06 01 02 CC 06 04 .!..............
    0010  02 02 CC 0B 06 01 01 C4 10 00 01 01 15 00 C8 13 ................
    0020  04 01 01 A3                                     ....

    This fixup field corresponds to the statement

    jmp     short NearLabel

    The only difference between this statement and the first is that the
    jump uses an 8-bit, rather than a 16-bit, offset. Thus, the loc field
    (bits 12-10 of byte 08H) contains 0 (000B) to indicate that the
    LOCATION to be fixed up is a low-order byte.

    ■  Bytes 0D-11H represent the third fixup field in this FIXUPP record:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 21 00 84 01 06 01 02 80 04 06 01 02 CC 06 04 .!..............
    0010 02 02 CC 0B 06 01 01 C4 10 00 01 01 15 00 C8 13  ................
    0020  04 01 01 A3                                     ....

    This fixup field corresponds to the statement

    jmp     far ptr FarProc

        In this case, both the TARGET's frame (the segment FAR_TEXT) and
        offset (the label FarProc) are known to the assembler. Both the
        segment address and the label offset are relocatable, however, so
        in the FIXUPP record the assembler passes the responsibility for
        resolving the addresses to the linker.

        - Bytes 0D-0EH (the locat field) indicate that the field is a fixup
        field (bit 15 = 1) and that the fixup is segment relative (bit
        14--the M bit = 1). The loc field (bits 12-10) contains 3 (011B),
        so the LOCATION being fixed up is a 32-bit (FAR) pointer (segment
        and offset). The data record offset (bits 9-0) is 6
        (0000000110B); the LOCATION is the 4 bytes following the first
        far jump opcode (EAH) in the preceding LEDATA record.

        - In byte 0FH (the fix dat field), the F bit and the frame field
        are 0, indicating that method 0 (a segment index) is used to
        specify the FRAME. The T bit is 0 (meaning the target is
        explicitly defined in the fixup field); therefore, the P bit and
        targt fields together indicate method 4 (a segment index) to
        specify the TARGET.

        - Because the FRAME is specified with a segment index, byte 10H
        (the frame datum field) is a reference to the second SEGDEF
        record in the object module, which in this example declared the
        FAR_TEXT segment. Similarly, byte 11H (the target datum field)
        references the FAR_TEXT segment. In this case, the FRAME is the
        same as the TARGET segment; had FAR_TEXT been one of a group of
        segments, the FRAME could have referred to the group instead.

    ■  The fourth assembler statement is different from the third because
        it references a segment not known to the assembler:

        jmp     FarLabel

        Bytes 12-16H contain the corresponding fixup field:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 21 00 84 01 06 01 02 80 04 06 01 02 CC 06 04 .!..............
    0010  02 02 CC 0B 06 01 01 C4 10 00 01 01 15 00 C8 13 ................
        0020  04 01 01 A3                                     ....

        The significant difference between this and the preceding fixup
        field is that the P bit and targt field of the fix dat byte (byte
        14H) specify TARGET method 6. In this fixup field, the target datum
        (byte 16H) refers to the first EXTDEF record in the object module,
        which declares FarLabel as an external reference.

    ■  The fifth fixup field (bytes 17-1DH) is

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 21 00 84 01 06 01 02 80 04 06 01 02 CC 06 04 .!..............
    0010  02 02 CC 0B 06 01 01 C4 10 00 01 01 15 00 C8 13 ................
        0020  04 01 01 A3                                     ....

        This fixup field contains information that enables the linker to
        calculate the value of the relocatable offset LocalLabel:

        mov     bx,offset LocalLabel

        - Bytes 17-18H (the locat field) contain C410H (1100010000010000B).
        Bit 15 is 1, denoting a fixup field. The M bit (bit 14) is 1,
        indicating that this fixup is segment relative. The loc field
        (bits 12-10) contains 1 (001B), so the LOCATION is a 16-bit
        offset. The data record offset (bits 9-0) is 10H (0000010000B), a
        reference to the 2 bytes in the LEDATA record following the
        opcode 0BBH.

        - Byte 19H (the fix dat byte) contains 00H. The F bit, frame field,
        T bit, P bit, and targt field are all 0, so FRAME method 0 and
        TARGET method 0 are explicitly specified in this fixup field.

        - Because FRAME method 0 is used, byte 1AH (the frame datum field)
        is an index field. It contains 01H, a reference to the first
        SEGDEF record in the object module, which declares the segment
        _TEXT.

        Similarly, byte 1BH (the target datum field) references the _TEXT
        segment.

        - Because TARGET method 0 is specified, an offset, in addition to a
        segment, is required to define the TARGET. This offset appears in
        the target displacement field in bytes 1C-1DH. The value of this
        offset is 0015H, corresponding to the offset of the TARGET
        (LocalLabel) in its segment (_TEXT).

    ■  The sixth and final fixup field in this FIXUPP record (bytes 1E
        -22H) is

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 21 00 84 01 06 01 02 80 04 06 01 02 CC 06 04 .!..............
    0010  02 02 CC 0B 06 01 01 C4 10 00 01 01 15 00 C8 13 ................
    0020  04 01 01 A3                                     ....

        This corresponds to the segment of the relocatable address
        LocalLabel:

        mov     ax,seg LocalLabel

        - Bytes 1E-1FH (the locat field) contain C813H (1100100000010011B).
        Bit 15 is 1, so this is a fixup field. The M bit (bit 14) is 1,
        so the fixup is segment relative. The loc field (bits 12-10)
        contains 2 (010B), so the LOCATION is a 16-bit segment value. The
        data record offset (bits 9-0) indicates the 2 bytes in the LEDATA
        record following the opcode 0B8H.

        - Byte 20H (the fix dat byte) contains 04H, so FRAME method 0 and
        TARGET method 4 are explicitly specified in this fixup field.

        - Byte 21H (the frame datum field) contains 01H. Because FRAME
        method 0 is specified, the frame datum is an index value that
        refers to the first SEGDEF record in the object module
        (corresponding to the _TEXT segment).

        - Byte 22H (the target datum field) contains 01H. Because TARGET
        method 4 is specified, the target datum also references the _TEXT
        segment.

    ■  Finally, byte 23H contains this FIXUPP record's checksum, 0A3H.

    The next two FIXUPP records show how thread fields are used. The first
    of the two contains six thread fields that can be referenced by both
    thread and fixup fields in subsequent FIXUPP records in the same
    object module:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 0D 00 00 03 01 02 02 01 03 04 40 01 45 01 C0 ...........@....

    Bytes 03-04H, 05-06H, 07-08H, 09-0AH, 0B-0CH, and 0D-0EH represent the
    six thread fields in this FIXUPP record. The high-order bit of the
    first byte of each of these fields is 0, indicating that they are,
    indeed, thread fields and not fixup fields.

    ■  Byte 03H, which contains 00H, is the thread data byte of the first
        thread field. Bit 7 of this byte is 0, indicating this is a thread
        field. Bit 6 (the D bit) is 0, so this field specifies a TARGET.
        Bit 5 is 0, as it must always be. Bits 4 through 2 (the method
        field) contain 0 (000B), which specifies TARGET method 0. Finally,
        bits 1 and 0 contain 0 (00B), the thread number that identifies
        this thread field.

        Byte 04H represents a segment index field, because method 0 of
        specifying a TARGET references a segment. The value of the index,
        3, is a reference to the third SEGDEF record defined in the object
        module.

    ■  Bytes 05-06H, 07-08H, and 09-0AH contain similar thread fields. In
        each, the method field specifies TARGET method 0. The three thread
        fields also have thread numbers of 1, 2, and 3. Because TARGET
        method 0 is specified for each thread field, bytes 06H, 08H, and
        0AH represent segment index fields, which reference the second,
        first, and fourth SEGDEF records, respectively.

    ■  Byte 0BH (the thread data byte of the fifth thread field in this
        FIXUPP record) contains 40H (01000000B). The D bit (bit 6) is 1, so
        this thread field specifies a FRAME. The method field (bits 4
        through 2) contains 0 (000B), which specifies FRAME method 0. Byte
        0CH (which contains 01H) is therefore interpreted as a segment
        index reference to the first SEGDEF record in the object module.

    ■  Byte 0DH is the thread data byte of the sixth thread field. It
        contains 45H (01000101B). Bit 6 is 1, which indicates that this
        thread specifies a FRAME. The method field (bits 4 through 2)
        contains 1 (001B), which specifies FRAME method 1. Byte 0EH (which
        contains 01H) is therefore interpreted as a group index to the
        first preceding GRPDEF record.

        The thread number fields of the fifth and sixth thread fields
        contain 0 and 1, respectively, but these thread numbers do not
        conflict with the ones used in the first and second thread fields,
        because the latter represent TARGET references, not FRAME
        references.

    The next FIXUPP example appears after the preceding record, in the
    same object module. This FIXUPP record contains a fixup field in bytes
    03-05H that refers to a thread in the previous FIXUPP record:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 04 00 C4 09 9D F6                             .......

    ■  Bytes 03-04H represent the 16-bit locat field, which contains C409H
        (1100010000001001B). Bit 15 of the locat field is 1, indicating a
        fixup field. The M bit (bit 14) is 1, so this fixup is relative to
        a particular segment, which is specified later in the fixup field.
        Bit 13 is 0, as it should be. Bits 12-10 (the loc field) contain 1
        (001B), so the LOCATION to be fixed up is a 16-bit offset. Bits 9-0
        (the data record offset field) contain 9 (0000001001B), so the
        LOCATION to be fixed up is represented at an offset of 9 bytes into
        the data field of the preceding LEDATA or LIDATA record.

    ■  Byte 05H (the fix dat byte) contains 9DH (10011101B). The F bit
        (bit 7) is 1, so this fixup field references a thread field that,
        in turn, defines the method of specifying the FRAME for the fixup.
        Bits 6-4 (the frame field) contain 1 (001B), the number of the
        thread that contains the FRAME method. This thread contains a
        method number of 1, which references the first GRPDEF record in the
        object module, thus specifying the FRAME.

        The T bit (bit 3 in the fix dat byte) is 1, so the TARGET method is
        also defined in a preceding thread field. The targt field (bits 1
        and 0 in the fix dat byte) contains 1 (01B), so the TARGET thread
        field whose thread number is 1 specifies the TARGET. The P bit (bit
        3 in the fix dat byte) contains 1, which is combined with the low
        -order bits of the method field in the thread field that describes
        the target to obtain TARGET method number 4 (100B). The TARGET
        thread references the second SEGDEF record to specify the TARGET.

    The last FIXUPP example illustrates that the linker performs a fixup
    by adding the calculated address value to the value in the LOCATION
    being fixed up. This function of the linker can be exploited to use
    fixups to modify opcodes or program data, as well as to resolve
    address references.

    Consider how the following assembler instruction might be fixed up:

    lea  bx,alpha+10h   ; alpha is an external symbol

    Typically, this instruction is translated into an LEDATA record with
    zero in the LOCATION (bytes 08-09H) to be fixed up:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  A0 08 00 01 00 00 8D 1E 00 00 AC                 ...........

    The corresponding FIXUPP record contains a target displacement of 10H
    bytes (bytes 08-09H):

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 08 00 C4 02 02 01 01 10 00 82                 ...........

    This FIXUPP record specifies TARGET method 2, which is indicated by
    the targt field (bits 2-0) of the fixdat field (byte 05H). In this
    case, the linker adds the target displacement to the address it has
    determined for the TARGET (alpha) and then completes the fixup by
    adding this calculated address value to the zero value in the
    LOCATION.

    The same result can be achieved by storing the displacement (10H)
    directly in the LOCATION in the LEDATA record:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  A0 08 00 01 00 00 8D 1E 10 00 9C                 ...........

    Then, the target displacement can be omitted from the FIXUPP record:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  9C 06 00 C4 02 06 01 01 90                       .........

    This FIXUPP record specifies TARGET method 6, which does not use a
    target displacement. The linker performs this fixup by adding the
    address of alpha to the value in the LOCATION, so the result is
    identical to the preceding one.

    The difference between the two techniques is that in the latter the
    linker does not perform error checking when it adds the calculated
    fixup value to the value in the LOCATION. If this second technique is
    used, the linker will not flag arithmetic overflow or underflow errors
    when it adds the displacement to the TARGET address. The first
    technique, then, traps all errors; the second can be used when
    overflow or underflow is irrelevant and an error message would be
    undesirable.


0A0H LEDATA Logical Enumerated Data Record

    The LEDATA record contains contiguous binary data--executable code or
    program data--that is eventually copied into the program's executable
    binary image.

    The binary data in an LEDATA record can be modified by the linker if
    the record is followed by a FIXUPP record.

Record format


    ┌──────┬──────┬──────┬─────────///────────┬──────┬──────┬──────────///────────┬──────┐
    │      │      │      │                    │ enumerated  │                     │ chk  │
    │ A0H  │   length    │   segment index    │ data offset │         data        │ sum  │
    └──────┴──────┴──────┴─────────///────────┴──────┴──────┴──────────///────────┴──────┘
                                                            ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
                                                                    can be
                                                                    repeated


Segment index
    The segment index is a variable-length index field. The index number
    in this field refers to a previous SEGDEF record in the object module.
    A value of 1 indicates the first SEGDEF record, a value of 2 the
    second, and so on. That SEGDEF record, in turn, indicates the segment
    into which the data in this LEDATA record is to be placed.

Enumerated data offset
    The enumerated data offset is a 2-byte offset into the segment
    referenced by the segment index, relative to the base of the segment.
    Taken together, the segment index and the enumerated data offset
    fields indicate the location where the enumerated data will be placed
    in the run-time memory map.

Data
    The data field contains the actual data, which can be either
    executable 8086 instructions or program data. The maximum size of the
    data field is 1024 bytes.

Location in object module

    Any LEDATA records in an object module must be preceded by the SEGDEF
    records to which they refer. Also, if an LEDATA record requires a
    fixup, a FIXUPP record must immediately follow the LEDATA record.

Example

    The following LEDATA record contains a simple text string:

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  A0 13 00 02 00 00 48 65 6C 6C 6F 2C 20 77 6F 72 ......Hello, wor
    0010  6C 64 0D 0A 24 A8                               ld..$.

    ■  Byte 00H contains 0A0H, which identifies this as an LEDATA record.

    ■  Bytes 01-02H contain 0013H, the length of the remainder of the
        record.

    ■  Byte 03H (the segment index field) contains 02H, a reference to the
        second SEGDEF record in the object module.

    ■  Bytes 04-05H (the enumerated data offset field) contain 0000H. This
        is the offset, from the base of the segment indicated by the
        segment index field, at which the data in the data field will be
        placed when the program is linked. Of course, this offset is
        subject to relocation by the linker because the segment declared in
        the specified SEGDEF record may be relocatable and may be combined
        with other segments declared in other object modules.

    ■  Bytes 06-14H (the data field) contain the actual data.

    ■  Byte 15H contains the checksum, 0A8H.


0A2H LIDATA Logical Iterated Data Record

    Like the LEDATA record, the LIDATA record contains binary data--
    executable code or program data. The data in an LIDATA record,
    however, is specified as a repeating pattern (iterated), rather than
    by explicit enumeration.

    The data in an LIDATA record may be modified by the linker if the
    LIDATA record is followed by a FIXUPP record.

Record format


    ┌──────┬──────┬──────┬─────────///────────┬──────┬──────┬─────────///────────┬──────┐
    │      │      │      │                    │  iterated   │                    │ chk  │
    │ A2H  │   length    │   segment index    │ data offset │iterated data block │ sum  │
    └──────┴──────┴──────┴─────────///────────┴──────┴──────┴─────────///────────┴──────┘
                                                            ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
                                                                    can be
                                                                    repeated


Segment index
    The segment index is a variable-length index field. The index number
    in this field refers to a previous SEGDEF record in the object module.
    A value of 1 indicates the first SEGDEF record, 2 indicates the
    second, and so on. That SEGDEF record, in turn, indicates the segment
    into which the data in this LIDATA record is to be placed when the
    program is executed.

Iterated data offset
    The iterated data offset is a 2-byte offset into the segment
    referenced by the segment index, relative to the base of the segment.
    Taken together, the segment index and the iterated data offset fields
    indicate the location where the iterated data will be placed in the
    run-time memory map.

Iterated data block
    The iterated data block is a variable-length field containing the
    actual data--executable code and program data. Iterated data blocks
    can be nested, so one iterated data block can contain one or more
    other iterated data blocks. Microsoft LINK restricts the maximum size
    of an iterated data block to 512 bytes.

    The format of the iterated data block is


    ┌──────┬──────┬──────┬──────┬────────///─────────┐
    │   repeat    │    block    │                    │
    │    count    │    count    │      content       │
    └──────┴──────┴──────┴──────┴────────///─────────┘


    ■  Repeat count is a 2-byte field indicating the number of times the
        content field is to be repeated.

    ■  Block count is a 2-byte field indicating the number of iterated
        data blocks in the content field. If the block count is 0, the
        content field contains data only.

    ■  Content is a variable-length field that can contain either nested
        iterated data blocks (if the block count is nonzero) or data (if
        the block count is 0). If the content field contains data, the
        field contains a 1-byte count of the number of data bytes in the
        field, followed by the actual data.

Location in object module

    Any LIDATA records in an object module must be preceded by the SEGDEF
    records to which they refer. Also, if an LIDATA record requires a
    fixup, a FIXUPP record must immediately follow the LIDATA record.

Example

    This sample LIDATA record corresponds to the following assembler
    statement, which declares a 10-element array containing the strings
    ALPHA and BETA:

        db     10 dup('ALPHA','BETA')

    The LIDATA record is

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  A2 1B 00 01 00 00 0A 00 02 00 01 00 00 00 05 41 ...............A
    0010  4C 50 48 41 01 00 00 00 04 42 45 54 41 A9       LPHA.....BETA.

    ■  Byte 00H contains 0A2H, identifying this as an LIDATA record.

    ■  Bytes 01-02H contain 1BH, the length of the remainder of the
        record.

    ■  Byte 03H (the segment index) contains 01H, a reference to the first
        SEGDEF record in this object module, indicating that the data
        declared in this LIDATA record is to be placed into the segment
        described by the first SEGDEF record.

    ■  Bytes 04-05H (the iterated data offset) contain 0000H, so the data
        in this LIDATA record is to be located at offset 0000H in the
        segment designated by the segment.

    ■  Bytes 06-1CH represent an iterated data block:

        - Bytes 06-07H contain the repeat count, 000AH, which indicates
        that the content field of this iterated data block is to be
        repeated 10 times.

        - Bytes 08-09H (the block count for this iterated data block)
        contain 0002H, which indicates that the content field of this
        iterated data block (bytes 0A-1CH) contains two nested iterated
        data block fields (bytes 0A-13H and bytes 14-1CH).

        - Bytes 0A-0BH contain 0001H, the repeat count for the first nested
        iterated data block. Bytes 0C-0DH contain 0000H, indicating that
        the content field of this nested iterated data block contains
        data, rather than more nested iterated data blocks. The content
        field (bytes 0E-13H) contains the data: Byte 0EH contains 05H,
        the number of subsequent data bytes, and bytes 0F-13H contain the
        actual data (the string ALPHA).

        - Bytes 14-1CH represent the second nested iterated data block,
        which has a format similar to that of the block in bytes 0A-13H.
        This second nested iterated data block represents the 4-byte
        string BETA.

    ■  Byte 1DH is the checksum, 0A9H.


0B0H COMDEF Communal Names Definition Record

    The COMDEF record is a Microsoft extension to the basic set of 8086
    object record types defined by Intel that declares a list of one or
    more communal variables. The COMDEF record is recognized by versions
    3.50 and later of LINK. Microsoft encourages the use of the COMDEF
    record for declaration of communal variables.

Record format

    ┌──────┬──────┬──────┬─────────///────────┬──────┬──────┬─────────///────────┬──────┐
    │      │      │      │      communal      │type  │      │      communal      │ chk  │
    │ B0H  │   length    │        name        │index │     │       length       │ sum  │
    └──────┴──────┴──────┴─────────///────────┴──────┴──┼───┴─────────///────────┴──────┘
                        ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
                                                        └───── data
                                            can be            segment
                                            repeated           type


Communal name
    The communal name field is a variable-length field that contains the
    name of a communal variable. The first byte of this field indicates
    the length of the name contained in the remainder of the field.

Type index
    The type index field is an index field that references a previous
    TYPDEF record in the object module. A value of 1 indicates the first
    TYPDEF record in the module, a value of 2 indicates the second, and so
    on. The type index value can be 0 if no data type is associated with
    the public name.

Data segment type
    The data segment type field is a single byte that indicates whether
    the communal variable is FAR or NEAR. There are only two possible
    values for data segment type:

    61H      FAR variable
    62H      NEAR variable

Communal length
    The communal length is a variable-length field that indicates the
    amount of memory to be allocated for the communal variable. The
    contents of this field depend on the value in the data segment type
    field. If the data segment type is NEAR (62H), the communal length
    field contains the size (in bytes) of the communal variable:


    ┌─────────///────────┐
    │                    │
    │   variable size    │
    └────────///─────────┘


    If the data segment type is FAR (61H), the communal length field is
    formatted as follows:


    ┌─────────///────────┬─────────///────────┐
    │     number of      │                    │
    │      elements      │    element size    │
    └────────///─────────┴────────///─────────┘


    A FAR communal variable is viewed as an array of elements of a
    specified size. Thus, the number of elements field is a variable
    -length field representing the number of elements in the array, and
    the element size field is a variable-length field that indicates the
    size (in bytes) of each element. The amount of memory required for a
    FAR communal variable is thus the product of the number of elements
    and the element size.

    The format of the variable size, number of elements, and element size
    fields depends upon the magnitude of the values they contain:

    ■  If the value is less than 128 (80H), the field is formatted as a
        1-byte field containing the actual value:


    ┌──────┐
    │      │
    │value │
    └──────┘


    ■  If the value is 128 (80H) or greater, the field is formatted with
        an extra initial byte that indicates whether the value is
        represented in the subsequent 2, 3, or 4 bytes:


    ┌──────┬──────┬──────┐
    │      │             │
    │ 81H  │2-byte value │
    └──────┴──────┴──────┘


    ┌──────┬──────┬──────┬──────┐
    │      │                    │
    │ 84H  │    3-byte value    │
    └──────┴──────┴──────┴──────┘


    ┌──────┬──────┬──────┬──────┬──────┐
    │      │                           │
    │ 88H  │       4-byte value        │
    └──────┴──────┴──────┴──────┴──────┘


    Groups of communal name, type index, data segment type, and communal
    length fields can be repeated so that more than one communal variable
    can be declared in the same COMDEF record.

Location in object module

    Any object module that contains COMDEF records must also contain one
    COMENT record with the comment class 0A1H, indicating that Microsoft
    extensions to the Intel object record specification are included in
    the object module. This COMENT record must appear before any COMDEF
    records in the object module.

Example

    The following COMDEF record was generated by the Microsoft C Compiler
    version 4.0 for these public variable declarations:

    int     foo;                     /* 2-byte integer */
    char    foo2[32768];             /* 32768-byte array */
    char    far foo3[10][2][20];     /* 400-byte array */

    The COMDEF record is

            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
    0000  B0 20 00 04 5F 66 6F 6F 00 62 02 05 5F 66 6F 6F . .._foo.b.._foo
    0010  32 00 62 81 00 80 05 5F 66 6F 6F 33 00 61 81 90 2.b...._foo3.a..
    0020  01 01 99                                        ...

    ■  Byte 00H contains 0B0H, indicating that this is a COMDEF record.

    ■  Bytes 01-02H contain 0020H, the length of the remainder of the
        record.

    ■  Bytes 03-0AH, 0B-15H, and 16-21H represent three declarations for
        the communal variables foo, foo2, and foo3. The C compiler prepends
        an underscore to each of the names declared in the source code, so
        the symbols represented in this COMDEF record are _foo, _foo2, and
        _foo3.

        - Byte 03H contains 04H, the length of the first communal name in
        this record. Bytes 04-07H contain the name itself (_foo). Byte
        08H (the type index field) contains 00H, as required. Byte 09H
        (the data segment type field) contains 62H, indicating this is a
        NEAR variable. Byte 0AH (the communal length field) contains 02H,
        the size of the variable in bytes.

        - Byte 0BH contains 05H, the length of the second communal name.
        Bytes 0C-10H contain the name, _foo2. Byte 11H is the type index
        field, which again contains 00H as required. Byte 12H (the data
        segment type field) contains 62H, indicating that _foo2 is a NEAR
        variable.

        Bytes 13-15H (the communal length field) contain the size in bytes
        of the variable. The first byte of the communal length field (byte
        13H) is 81H, indicating that the size is represented in the
        subsequent 2 bytes of data--bytes 14-15H, which contain the value
        8000H.

        - Bytes 16-1BH represent the communal name field for _foo3, the
        third communal variable declared in this record. Byte 1CH (the
        type index field) again contains 00H as required. Byte 1DH (the
        data segment type field) contains 61H, indicating this is a FAR
        variable. This means the communal length field is formatted as a
        number of elements field (bytes 1E-20H, which contain the value
        0190H) and an element size field (byte 21H, which contains 01H).
        The total size of this communal variable is thus 190H times 1, or
        400 bytes.

    ■  Byte 22H contains the checksum, 99H.

                                                        Richard Wilton



Article 20: The Microsoft Object Linker


    MS-DOS object modules can be processed in two ways: They can be
    grouped together in object libraries, or they can be linked into
    executable files. All Microsoft language translators are distributed
    with two utility programs that process object modules: The Microsoft
    Library Manager (LIB) creates and modifies object libraries; the
    Microsoft Object Linker (LINK) processes the individual object records
    within object modules to create executable files.

    The following discussion focuses on LINK because of its crucial role
    in creating an executable file. Before delving into the complexities
    of LINK, however, it is worthwhile reviewing how object modules are
    managed.


Object Files, Object Libraries, and LIB

    Compilers and assemblers translate source-code modules into object
    modules (Figure 20-1). See PROGRAMMING IN THE MS-DOS ENVIRONMENT:
    PROGRAMMING TOOLS: Object Modules. An object module consists of a
    sequence of object records that describe the form and content of part
    of an executable program. An MS-DOS object module always starts with a
    THEADR record; subsequent object records in the module follow the
    sequence discussed in the Object Modules article.

    Object modules can be stored in either of two types of MS-DOS files:
    object files and object libraries. By convention, object files have
    the filename extension .OBJ and object libraries have the extension
    .LIB. Although both object files and object libraries contain one or
    more object modules, the files and the libraries have different
    internal organization. Furthermore, LINK processes object files and
    libraries differently.


    ┌──────────────────┐
    │ Source code      │
    └────────┬─────────┘
            │ Language translator or assembler
            │
    ┌─────────────────┐                       ┌──────────────────┐
    │  Object module   │──  Object module  ──│  Object library  │
    │   (.OBJ file)    │    librarian (LIB)    │    (.LIB file)   │
    └────────┬─────────┘                       └─────────┬────────┘
            └─────────────────────┬─────────────────────┘
                                    │  Linker (LINK)
                                    │
                        ┌─────────────────┐
                        │    Executable    │
                        │   binary image   │
                        │   (.EXE file)    │
                        └────────┬─────────┘
                                    │  MS-DOS loader
                                    
                            (Program runs)

    Figure 20-1. Object modules, object libraries, LIB, and LINK.


    The structures of object files and libraries are compared in Figure
    20-2. An object file is a simple concatenation of object modules in
    any arbitrary order. (Microsoft discourages the use of object files
    that contain more than one object module; Microsoft language
    translators never generate more than one object module in an object
    file.) In contrast, a library contains a hashed dictionary of all the
    public symbols declared in each of the object modules, in addition to
    the object modules themselves. Each symbol in the dictionary is as-
    sociated with a reference to the object module in which the symbol
    was declared.

    LINK processes object files differently than it does libraries. When
    LINK builds an executable file, it incorporates all the object modules
    in all the object files it processes. In contrast, when LINK processes
    libraries, it uses the hashed symbol dictionary in each library to
    extract object modules selectively--it uses an object module from a
    library only when the object module contains a symbol that is
    referenced within some other object module. This distinction between
    object files and libraries is important in understanding what LINK
    does.


    (a) ┌──────────────────┐
        │                  │
        │  Object module   │
        │                  │
        ├──────────────────┤
        │                  │
        │  Object module   │
        ├──────────────────┤
        │                  │
        │  Object module   │
        │                  │
        └──────────────────┘
    (b) ┌──────────────────┐
        │  Library header  │
        ├──────────────────┤
        │                  │
        │  Object module   │
        │                  │
        ├──────────────────┤
        │                  │
        │  Object module   │
        ├──────────────────┤
        │                  │
        │  Object module   │
        │                  │
        ├──────────────────┤
        │                  │
        │                  │
        │Symbol dictionary │
        │                  │
        │                  │
        └──────────────────┘

    Figure 20-2. Structures of an object file and an object library. (a)
    An object file contains one or more object modules. (Microsoft
    discourages using more than one object module per object file.) (b) An
    object library contains one or more object modules plus a hashed
    symbol dictionary indicating the object modules in which each public
    symbol is defined.


What LINK Does

    The function of LINK is to translate object modules into an executable
    program. LINK's input consists of one or more object files (.OBJ
    files) and, optionally, one or more libraries (.LIB files). LINK's
    output is an executable file (.EXE file) containing binary data that
    can be loaded directly from the file into memory and executed. LINK
    can also generate a symbolic address map listing (.MAP file)--a text
    file that describes the organization of the .EXE file and the
    correspondence of symbols declared in the object modules to addresses
    in the executable file.

Building an executable file

    LINK builds two types of information into a .EXE file. First, it
    extracts executable code and data from the LEDATA and LIDATA records
    in object modules, arranges them in a specified order according to its
    rules for segment combination and relocation, and copies the result
    into the .EXE file. Second, LINK builds a header for the .EXE file.
    The header describes the size of the executable program and also
    contains a table of load-time segment relocations and initial values
    for certain CPU registers. See Pass 2, below.

Relocation and linking

    In building an executable image from object modules, LINK performs two
    essential tasks: relocation and linking. As it combines and rearranges
    the executable code and data it extracts from the object modules it
    processes, LINK frequently adjusts, or relocates, address references
    to account for the rearrangements (Figure 20-3). LINK links object
    modules by resolving address references among them. It does this by
    matching the symbols declared in EXTDEF and PUBDEF object records
    (Figure 20-4). LINK uses FIXUPP records to determine exactly how to
    compute both address relocations and linked address references.


Object Module Order

    LINK processes input files from three sources: object files and
    libraries specified explicitly by the user (in the command line, in
    response to LINK's prompts, or in a response file) and object
    libraries named in object module COMENT records.


                                                    ┌─────────────────────┐
                                                    │                     │
                                                    │                     │
                                                    │                     │
    ┌─────────────────────┐                         │    Code segment     │
    │                     │                         │     (B4H bytes)     │
    │    Code segment     │                         │                     │
    │     (64H bytes)     │                         │                     │
    │                     │ ┌─────────────────────┐ │Label1 at offset 10H │
    │Label1 at offset 10H │ │    Code segment     │ │Label2 at offset 74H │
    │                     │ │     (50H bytes)     │ │                     │
    │                     │ │Label2 at offset 10H │ │                     │
    └─────────────────────┘ └─────────────────────┘ └─────────────────────┘
            Module1                 Module2          Combined code segment

    Figure 20-3. A simple relocation. Both object modules contain code
    that LINK combines into one logical segment. In this example, LINK
    appends the 50H bytes of code in Module2 to the 64H bytes of code in
    Module1. LINK relocates all references to addresses in the code
    segment so that they apply to the combined segment.


                                                    ┌─────────────────────┐
                                                    │ Code segment.       │
                                                    │             .       │
                                                    │             .       │
    ┌─────────────────────┐ ┌─────────────────────┐ │             .       │
    │                     │ │                     │ │        jmp Label2   │
    │ Code segment        │ │ Code segment        │ │             .       │
    │    EXTDEF Label2    │ │    PUBDEF Label2    │ │             .       │
    │                     │ │                     │ │             .       │
    │    jmp Label2       │ │    Label2:  .       │ │ Label2:             │
    │         .           │ │             .       │ │             .       │
    │         .           │ │             .       │ │             .       │
    │         .           │ │                     │ │             .       │
    └─────────────────────┘ └─────────────────────┘ └─────────────────────┘
            Module1                 Module2          Combined code segment

    Figure 20-4. Resolving an external reference. LINK resolves the
    external reference in Module1 (declared in an EXTDEF record) with
    the address of Label2 in Module2 (declared in a PUBDEF record).


    LINK always uses all the object modules in the object files it
    processes. In contrast, it extracts individual object modules from
    libraries--only those object modules needed to resolve references to
    public symbols are used. This difference is implicit in the order in
    which LINK reads its input files:

    1. Object files specified in the command line or in response to the
        Object Modules prompt

    2. Libraries specified in the command line or in response to the
        Libraries prompt

    3. Libraries specified in COMENT records

    The order in which LINK processes object modules influences the
    resulting executable file in three ways. First, the order in which
    segments appear in LINK's input files is reflected in the segment
    structure of the executable file. Second, the order in which LINK
    resolves external references to public symbols depends on the order
    in which it finds the public symbols in its input files. Finally, LINK
    derives the default name of the executable file from the name of the
    first input object file.

Segment order in the executable file

    In general, LINK builds named segments into the executable file in the
    order in which it first encounters the SEGDEF records that declare the
    segments. (The /DOSSEG switch also affects segment order. See Using
    the /DOSSEG Switch, below.) This means that the order in which
    segments appear in the executable file can be controlled by linking
    object modules in a specific order. In assembly-language programs, it
    is best to declare all the segments used in the program in the first
    object module to be linked so that the segment order in the executable
    file is under complete control.

Order in which references are resolved

    LINK resolves external references in the order in which it encounters
    the corresponding public declarations. This fact is important because
    it determines the order in which LINK extracts object modules from
    libraries. When a public symbol required to resolve an external
    reference is declared more than once among the object modules in the
    input libraries, LINK uses the first object module that contains the
    public symbol. This means that the actual executable code or data
    associated with a particular external reference can be varied by
    changing the order in which LINK processes its input libraries.

    For example, imagine that a C programmer has written two versions of
    a function named myfunc() that is called by the program MYPROG.C. One
    version of myfunc() is for debugging; its object module is found in
    MYFUNC.OBJ. The other is a production version whose object module
    resides in MYLIB.LIB. Under normal circumstances, the programmer links
    the production version of myfunc() by using MYLIB.LIB (Figure 20-5).
    To use the debugging version of myfunc(), the programmer explicitly
    includes its object module (MYFUNC.OBJ) when LINK is executed. This
    causes LINK to build the debugging version of myfunc() into the
    executable file because it encounters the debugging version in
    MYFUNC.OBJ before it finds the other version in MYLIB.LIB.

    To exploit the order in which LINK resolves external references, it
    is important to know LINK's library search strategy: Each individual
    library is searched repeatedly (from first library to last, in the
    sequence in which they are input to LINK) until no further external
    references can be resolved.


┌───────────────────┐      ┌────────────────────┐
│    main()         │      │                    │
│    {              │      │                    │
│      x=myfunc(y); ├─────│EXTDEF for myfunc() ├─┐  ┌────────────────────┐
│    }              │      │                    │ │  │                    │
└───────────────────┘      └────────────────────┘ │  │                    │
    MYPROG.C                    MYPROG.OBJ       │  │  Executable code   │
┌───────────────────┐      ┌────────────────────┐ ├─│ contains myfunc()  │
│    myfunc(a)      │      │                    │ │  │derived from either │
│    int a;         │      │                    │ │  │   MYFUNC.OBJ or    │
│    {              ├─────│PUBDEF for myfunc() ├─┤  │     MYLIB.OBJ      │
│          .        │      │                    │ │  │                    │
│          .        │      └────────────────────┘ │  │                    │
│          .        │           MYFUNC.OBJ        │  └────────────────────┘
│     }             │      ┌────────────────────┐ │
└───────────────────┘      │            .       │ │
    MYFUNC.C             │            .       │ │
                        │            .       │ │
                        │PUBDEF for myfunc() │ │
                        │            .       ├─┘
                        │            .       │
                        │            .       │
                        │                    │
                        └────────────────────┘
                                MYLIB.LIB

    Figure 20-5. Ordered object module processing by LINK. (a) With the
    command LINK MYPROG,,,MYLIB, the production version of myfunc() in
    MYLIB.LIB is used. (b) With the command LINK
    MYPROG+&lt;QL&gt;MYFUNC,,,MYLIB, the debugging version of myfunc() in
    MYFUNC.OBJ is used.


┌──────────────┐ ┌──────────────┐ ┌──────────────┐ ┌──────────────┐
│   ModuleA    │ │   ModuleC    │ │  ModuleMAIN  │ │              │ Start
│    Call C    │ │    Call B    │ │    Call A    │ │  ModuleMAIN  │ of
├──────────────┤ └──────────────┘ └──────────────┘ ├──────────────┤ pro-
│              │                                   │              │ gram
│   ModuleB    │                                   │  ModuleA     │
└──────────────┘                                   ├──────────────┤
    LIB1.LIB         LIB2.LIB        MYPROG.OBJ    │              │
                                                    │  ModuleC     │
                                                    ├──────────────┤
                                                    │              │
                                                    │  ModuleB     │
                                                    └──────────────┘
                                                        MYPROG.EXE

    Figure 20-6. Library search order. Modules are incorporated into the
    executable file as LINK extracts them from the libraries to resolve
    external references.


    The example in Figure 20-6 demonstrates this search strategy. Library
    LIB1.LIB contains object modules A and B, library LIB2.LIB contains
    object module C, and the object file MYPROG.OBJ contains the object
    module MAIN; modules MAIN, A, and C each contain an external reference
    to a symbol declared in another module. When this program is linked
    with

    LINK MYPROG,,,LIB1+LIB2  &lt;ENTER&gt;

    LINK starts by incorporating the object module MAIN into the
    executable program. It then searches the input libraries until it
    resolves all the external references:

    1. Process MYPROG.OBJ, find unresolved external reference to A.

    2. Search LIB1.LIB, extract A, find unresolved external reference
        to C.

    3. Search LIB1.LIB again; reference to C remains unresolved.

    4. Search LIB2.LIB, extract C, find unresolved external reference
        to B.

    5. Search LIB2.LIB again; reference to B remains unresolved.

    6. Search LIB1.LIB again, extract B.

    7. No more unresolved external references, so end library search.

    The order in which the modules appear in the executable file thus
    reflects the order in which LINK resolves the external references;
    this, in turn, depends on which modules were contained in the
    libraries and on the order in which the libraries are input to LINK.

Name of the executable file

    If no filename is specified in the command line or in response to the
    Run File prompt, LINK derives the name of the executable file from the
    name of the first object file it processes. For example, if the object
    files PROG1.OBJ and PROG2.OBJ are linked with the command

    LINK PROG1+PROG2;  &lt;ENTER&gt;

    the resulting executable file, PROG1.EXE, takes its name from the
    first object file processed by LINK.


Segment Order and Segment Combinations

    LINK builds segments into the executable file by applying the
    following sequence of rules:

    1. Segments appear in the executable file in the order in which their
        SEGDEF declarations first appear in the input object modules.

    2. Segments in different object modules are combined if they have the
        same name and class and a public, memory, stack, or common combine
        type. All address references within the combined segments are
        relocated relative to the start of the combined segment.

        - Segments with the same name and either the public or the memory
        combine type are combined in the order in which they are
        processed by LINK. The size of the resulting segment equals the
        total size of the combined segments.

        - Segments with the same name and the stack combine type are
        overlapped so that the data in each of the overlapped segments
        ends at the same address. The size of the resulting segment
        equals the total size of the combined segments. The resulting
        segment is always paragraph aligned.

        - Segments with the same name and the common combine type are
        overlapped so that the data in each of the overlapped segments
        starts at the same address. The size of the resulting segment
        equals the size of the largest of the overlapped segments.

    3. Segments with the same class name are concatenated.

    4. If the /DOSSEG switch is used, the segments are rearranged in
        conjunction with DGROUP. See Using the /DOSSEG Switch below.

    These rules allow the programmer to control the organization of
    segments in the executable file by ordering SEGMENT declarations in an
    assembly-language source module, which produces the same order of
    SEGDEF records in the corresponding object module, and by placing this
    object module first in the order in which LINK processes its input
    files.

    A typical MS-DOS program is constructed by declaring all executable
    code and data segments with the public combine type, thus enabling the
    programmer to compile the program's source code from separate source-
    code modules into separate object modules. When these object modules
    are linked, LINK combines the segments from the object modules
    according to the above rules to create logically unified code and data
    segments in the executable file.

Segment classes

    LINK concatenates segments with the same class name after it combines
    segments with the same segment name and class. For example, Figure
    20-7 shows the following compiling and linking:

    MASM MYPROG1;  &lt;ENTER&gt;
    MASM MYPROG2;  &lt;ENTER&gt;
    LINK MYPROG1+MYPROG2;  &lt;ENTER&gt;


┌──────────────────────────────┐ ┌────────────┐  ┌─────────┐
│                              │ │   SEGDEF   │  │         │▓         ▒
│ _TEXT SEGMENT public 'CODE'  │ │  for TEXT  │  │         │▓         ▒
│                              │ │            │  │         │▓_TEXT   ▒
├──────────────────────────────┤ │   SEGDEF   │  │         │▓ segment ▒
│FAR_TEXT SEGMENT public 'CODE'├│for FAR_TEXT├┐ │         │▓         ▒
├──────────────────────────────┤ │            ││ │         │▓         ▒─┐
│                              │ │   SEGDEF   ││ ├─────────┤          ▒  │
│ _DATA SEGMENT public 'CODE'  │ │ for _DATA  ││ │         │▓         ▒  │
│                              │ │            │├│         │▓FAR_TEXT▒  │
└──────────────────────────────┘ └────────────┘│ │         │▓ segment ▒  │
        MYPROG1.ASM             MYPROG1.OBJ  │ │         │▓         ▒  │
┌──────────────────────────────┐ ┌────────────┐│ ├─────────┤             │
│ _TEXT SEGMENT public 'CODE'  │ │            ││ │         │▓_DATA      │
│                              │ │   SEGDEF   ││ │         │▓ segment    │
│                              │ │  for _TEXT ││ └─────────┘             │
├──────────────────────────────┼│            ││ MYPROG1.EXE             │
│FAR_TEXT SEGMENT public 'CODE'│ │   SEGDEF   ├┘                         │
│                              │ │for FAR_TEXT│                          │
│                              │ │            │                          │
└──────────────────────────────┘ └────────────┘             'CODE' ──────┘
        MYPROG2.ASM             MYPROG2.OBJ               class

    Figure 20-7. Segment order and concatenation by LINK. The start of
    each file, corresponding to the lowest address, is at the top.


    After MYPROG1.ASM and MYPROG2.ASM have been compiled, LINK builds the
    _TEXT and FAR_TEXT segments by combining segments with the same name
    from the different object modules. Then, _TEXT and FAR_TEXT are
    concatenated because they have the same class name ('CODE'). _TEXT
    appears before FAR_TEXT in the executable file because LINK encounters
    the SEGDEF record for _TEXT before it finds the SEGDEF record for
    FAR_TEXT.

Segment alignment

    LINK aligns the starting address of each segment it processes
    according to the alignment specified in each SEGDEF record. It adjusts
    the alignment of each segment it encounters regardless of how that
    segment is combined with other segments of the same name or class.
    (The one exception is stack segments, which always start on a
    paragraph boundary.)


    ┌────────────────────┐ ┌────────────────────┐ ┌────────────────────┐
    │ _DATA SEGMENT byte │ │ _DATA SEGMENT word │ │ _DATA SEGMENT para │
    │ public (35H bytes) │ │ public (35H bytes) │ │ public (35H bytes) │
    └────────────────────┘ └────────────────────┘ └────────────────────┘
            Module1                Module2                Module3



00H ┌────────────────────┐
    │                    │▓ 35H bytes  (byte aligned)
    │      Module1       │▓
35H └────────────────────┘
    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
36H ┌────────────────────┐
    │                    │▓ 35H bytes  (word aligned)
    │      Module2       │▓
6BH └────────────────────┘
    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
    ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
70H ┌────────────────────┐
    │                    │▓ 35H bytes  (paragraph aligned)
    │      Module3       │▓
    └────────────────────┘
    Resulting _DATA segment
        in .EXE file

    Figure 20-8. Alignment of combined segments. LINK enforces segment
    alignment by padding combined segments with uninitialized data bytes.

    Segment alignment is particularly important when public segments with
    the same name and class are combined from different object modules.
    Note what happens in Figure 20-8, where the three concatenated _DATA
    segments have different alignments. To enforce the word alignment and
    paragraph alignment of the _DATA segments in Module2 and Module3, LINK
    inserts one or more bytes of padding between the segments.

Segment groups

    A segment group establishes a logical segment address to which all
    offsets in a group of segments can refer. That is, all addresses in
    all segments in the group can be expressed as offsets relative to the
    segment value associated with the group (Figure 20-9). Declaring
    segments in a group does not affect their positions in the executable
    file; the segments in a group may or may not be contiguous and can
    appear in any order as long as all address references to the group
    fall within 64 KB of each other.


DataGroup      GROUP     DataSeg1,DataSeg2
CodeSeg        SEGMENT   byte public 'CODE'
            ASSUME    cs:CodeSeg

            mov       ax,offset DataSeg2:TestData
            mov       ax,offset DataGroup:TestData

CodeSeg        ENDS

DataSeg1       SEGMENT   para public 'DATA'
            DB        100h dup(?)
DataSeg1       ENDS

DataSeg2       SEGMENT   para public 'DATA'
TestData       DB        ?
DataSeg2       ENDS
            END

    Figure 20-9. Example of group addressing. The first MOV loads the
    value 00H into AX (the offset of TestData relative to DataSeg2); the
    second MOV loads the value 100H into AX (the offset of TestData
    relative to the group DataGroup).


    LINK reserves one group name, DGROUP, for use by Microsoft language
    translators. DGROUP is used to group compiler-generated data segments
    and a default stack segment. See DGROUP, below.


LINK Internals

    Many programmers use LINK as a "black box" program that transforms
    object modules into executable files. Nevertheless, it is helpful to
    observe how LINK processes object records to accomplish this task.

    LINK is a two-pass linker; that is, it reads all its input object
    modules twice. On Pass 1, LINK builds an address map of the segments
    and symbols in the object modules. On Pass 2, it extracts the
    executable code and program data from the object modules and builds a
    memory image--an exact replica--of the executable file.

    The reason LINK builds an image of the executable file in memory,
    instead of simply copying code and data from object modules into the
    executable file, is that it organizes the executable file by segments
    and not by the order in which it processes object modules. The most
    efficient way to concatenate, combine, and relocate the code and data
    is to build a map of the executable file in memory during Pass 1 and
    then fill in the map with code and data during Pass 2.

    In versions 3.52 and later, whenever the /I (/INFORMATION) switch is
    specified in the command line, LINK displays status messages at the
    start of each pass and as it processes each object module. If the /M
    (/MAP) switch is used in addition to the /I switch, LINK also displays
    the total length of each segment declared in the object modules. This
    information is helpful in determining how the structure of an
    executable file corresponds to the contents of the object modules
    processed by LINK.

Pass 1

    During Pass 1, LINK processes the LNAMES, SEGDEF, GRPDEF, COMDEF,
    EXTDEF, and PUBDEF records in each input object module and uses the
    information in these object records to construct a symbol table and an
    address map of segments and segment groups.

Symbol table

    As each object module is processed, LINK uses the symbol table to
    resolve external references (declared in EXTDEF and COMDEF records) to
    public symbols. If LINK processes all the object files without
    resolving all the external references in the symbol table, it searches
    the input libraries for public symbols that match the unresolved
    external references. LINK continues to search each library until all
    the external references in the symbol table are resolved.

Segments and groups

    LINK processes each SEGDEF record according to the segment name, class
    name, and attributes specified in the record. LINK constructs a table
    of named segments and updates it as it concatenates or combines
    segments. This allows LINK to associate each public symbol in the
    symbol table with an offset into the segment in which the symbol is
    declared.

    LINK also generates default segments into which it places communal
    variables declared in COMDEF records. Near communal variables are
    placed in one paragraph-aligned public segment named c_common, with
    class name BSS (block storage space) and group DGROUP. Far communal
    variables are placed in a paragraph-aligned segment named FAR_BSS,
    with class name FAR_BSS. The combine type of each far communal
    variable's FAR_BSS segment is private (that is, not public, memory,
    common, or stack). As many FAR_BSS segments as necessary are
    generated.

    After all the object files have been read and all the external
    references in the symbol table have been resolved, LINK has a complete
    map of the addresses of all segments and symbols in the program. If a
    .MAP file has been requested, LINK creates the file and writes the
    address map to it. Then LINK initiates Pass 2.

Pass 2

    In Pass 2, LINK extracts executable code and program data from the
    LEDATA and LIDATA records in the object modules. It builds the code
    and data into a memory image of the executable file. During Pass 2,
    LINK also carries out all the address relocations and fixups related
    to segment relocation, segment grouping, and resolution of external
    references, as well as any other address fixups specified explicitly
    in object module FIXUPP records.

    If it determines during Pass 2 that not enough RAM is available to
    contain the entire image, LINK creates a temporary file in the current
    directory on the default disk drive. (LINK versions 3.60 and later use
    the environment variable TMP to find the directory for the temporary
    scratch file.) LINK then uses this file in addition to all the
    available RAM to construct the image of the executable file. (In
    versions of MS-DOS earlier than 3.0, the temporary file is named
    VM.TMP; in versions 3.0 and later, LINK uses Interrupt 21H Function
    5AH to create the file.)

    LINK reads each of the input object modules in the same order as it
    did in Pass 1. This time it copies the information from each object
    module's LEDATA and LIDATA records into the memory image of each
    segment in the proper sequence. This is when LINK expands the iterated
    data in each LIDATA record it processes.

    LINK processes each LEDATA and LIDATA record along with the
    corresponding FIXUPP record, if one exists. LINK processes the FIXUPP
    record, performs the address calculations required for relocation,
    segment grouping, and resolving external references, and then stores
    binary data from the LEDATA or LIDATA record, including the results of
    the address calculations, in the proper segment in the memory image.
    The only exception to this process occurs when a FIXUPP record refers
    to a segment address. In this case, LINK adds the address of the fixup
    to a table of segment fixups; this table is used later to generate the
    segment relocation table in the .EXE header.

    When all the data has been extracted from the object modules and all
    the fixups have been carried out, the memory image is complete. LINK
    now has all the information it needs to build the .EXE header (Table
    20-1). At this point, therefore, LINK creates the executable file and
    writes the header and all segments into it.


    Table 20-1. How LINK Builds a .EXE File Header.

╓┌──────────────┌─────────────────────────────────────┌──────────────────────╖
    Offset    Contents                               Comments
    ──────────────────────────────────────────────────────────────────
    00H       'MZ'                                   .EXE file signature

    02H       Length of executable image MOD 512  ▒
                                                ▒  Total size of all
    04H       Length of executable image in 512-  ▒ segments plus
            byte pages, including               ▒  .EXE file header
            last partial page (if any)          ▒

    06H       Number of run-time segment             Number of
            relocations                            segment fixups

    08H       Size of the .EXE header in 16-         Size of segment
            byte paragraphs                        relocation table

    0AH       MINALLOC: Minimum amount of            Size of uninitialized
            RAM to be allocated above              data and/or stack
            end ofthe loaded program (in           segments at end of
            16-byte paragraphs)                    program (0 if /HI
                                                    switch is used)

    0CH       MAXALLOC: Maximum amount of            0 if /HI switch is
            RAM to be allocated above end          used; value specified
            of the loaded program (in 16-byte      with /CP switch;
            paragraphs)                            FFFFH if /CP and /HI
                                                    switches are not
                                                    used

    0EH       Stack segment (initial value for SS    Address of
            program register); prelocated by       stack segment
            MS-DOS when program is loaded          relative to start of
                                                    executable image

    10H       Stack pointer (initial value for       Size of stack segment
            register SP)                           in bytes

    12H       Checksum                               One's complement of
                                                    sum of all words in
                                                    file, excluding
                                                    checksum itself

    14H       Entry point offset (initial value   ▒
            for register IP)                    ▒  MODEND object
                                                ▒  record that
    16H       Entry point segment (initial value  ▒ specifies program
            for register CS); relocated by      ▒  start address
            MS-DOS when program is loaded       ▒

    18H       Offset of start of segment
            relocation table relative to
            start of .EXE header

    1AH       Overlay number                         0 for resident
                                                    segments; &gt;0 for
                                                    overlay segments
    1CH       Reserved


Using LINK to Organize Memory

    By using LINK to rearrange and combine segments, a programmer can
    generate an executable file in which segment order and addressing
    serve specific purposes. As the following examples demonstrate,
    careful use of LINK leads to more efficient use of memory and simpler,
    more efficient programs.

Segment order for a TSR

    In a terminate-and-stay-resident (TSR) program, LINK must be used
    carefully to generate segments in the executable file in the proper
    order. A typical TSR program consists of a resident portion, in which
    the TSR application is implemented, and a transient portion, which
    executes only once to initialize the resident portion. See PROGRAMMING
    IN THE MS-DOS ENVIRONMENT: CUSTOMIZING MS-DOS: Terminate-and-Stay-
    Resident Utilities.

    Because the transient portion of the TSR program is executed only
    once, the memory it occupies should be freed after the resident
    portion has been initialized. To allow the MS-DOS Terminate and Stay
    Resident function (Interrupt 21H Function 31H) to free this memory
    when it leaves the resident portion of the TSR program in memory, the
    TSR program must have its resident portion at lower addresses than its
    transient portion.


    ──────────────────────────────────────────────────────────────────────

    Figure 20-10. Segment order for a terminate-and-stay-resident program.

    ──────────────────────────────────────────────────────────────────────

    In Figure 20-10, the segments containing the resident code and data
    are declared before the segments that represent the transient portion
    of the program. Because LINK preserves this segment order, the
    executable program has the desired structure, with resident code and
    data at lower addresses than transient code and data. Moreover, the
    number of paragraphs in the resident portion of the program, which
    must be computed before Interrupt 21H Function 31H is called, is easy
    to derive from the segment structure: This value is the difference
    between the segment address of the program segment prefix, which
    immediately precedes the first segment in the resident portion, and
    the address of the first segment in the transient portion of the
    program.

Groups for unified segment addressing

    In some programs it is desirable to maintain executable code and data
    in separate logical segments but to address both code and data with
    the same segment register. For example, in a hardware interrupt
    handler, using the CS register to address program data is generally
    simpler than using DS or ES.

    In the routine in Figure 20-11, code and data are maintained in
    separate segments for program clarity, yet both can be addressed using
    the CS register because both code and data segments are included in
    the same group. (The SNAP.ASM listing in the Terminate-and-Stay-
    Resident Utilities article is another example of this use of a group
    to unify segment addressing.)


ISRgroup       GROUP     CodeSeg,DataSeg
CodeSeg        SEGMENT   byte public 'CODE'
            ASSUME    cs:ISRgroup
            mov       ax,offset ISRgroup:CodeLabel
CodeLabel:     mov       bx,ISRgroup:DataLabel
CodeSeg        ENDS

DataSeg        SEGMENT   para public 'DATA'
DataLabel      DW        ?
DataSeg        ENDS
            END

    Figure 20-11. Code and data included in the same group. In this
    example, addresses within both CodeSeg and DataSeg are referenced
    relative to the CS register by grouping the segments (using the
    assembler GROUP directive) and addressing the group through CS (using
    the assembler ASSUME directive).


Uninitialized data segments

    A segment that contains only uninitialized data can be processed by
    LINK in two ways, depending on the position of the segment in the
    program. If the segment is not at the end of the program, LINK
    generates a block of bytes initialized to zero to represent the
    segment in the executable file. If the segment appears at the end of
    the program, however, LINK does not generate a block of zeroed bytes.
    Instead, it increases the minimum run-time memory allocation by
    increasing MINALLOC (specified at offset 0AH in the .EXE header) by
    the amount of memory required for the segment.

    Therefore, if it is necessary to reserve a large amount of
    uninitialized memory in a segment, the size of the .EXE file can be
    decreased by building the segment at the end of a program (Figure
    20-12). This is why, for example, Microsoft high-level-language
    translators always build BSS and STACK segments at the end of compiled
    programs. (The loader does not fill these segments with zeros; a
    program must still initialize them with appropriate values.)


(a)           CodeSeg     SEGMENT     byte public 'CODE'
                        ASSUME      cs:CodeSeg,ds:DataSeg
                        ret
            CodeSeg     ENDS

            DataSeg     SEGMENT     word public 'DATA'
            BigBuffer   DB          10000 dup(?)
            DataSeg     ENDS
                        END

(b)           DataSeg     SEGMENT     word public 'DATA'
            BigBuffer   DB          10000 dup(?)
            DataSeg     ENDS

            CodeSeg     SEGMENT     byte public 'CODE'
                        ASSUME      cs:CodeSeg,ds:DataSeg
                        ret
            CodeSeg     ENDS
                        END

    Figure 20-12. LINK processing of uninitialized data segments. (a) When
    DataSeg, which contains only uninitialized data, is placed at the end
    of this program, the size of the .EXE file is only 513 bytes. (b) When
    DataSeg is not placed at the end of the program, the size of the .EXE
    file is 10513 bytes.


Overlays

    If a program contains two or more subroutines that are mutually
    independent--that is, subroutines that do not transfer control to each
    other--LINK can be instructed to build each subroutine into a
    separately loaded portion of the executable file. (This instruction is
    indicated in the command line when LINK is executed by enclosing each
    overlay subroutine or group of subroutines in parentheses.) Each of
    the subroutines can then be overlaid as it is needed in the same area
    of memory (Figure 20-13). The amount of memory required to run a
    program that uses overlays is, therefore, less than the amount
    required to run the same program without overlays.

    A program that uses overlays must include the Microsoft run-time
    overlay manager. The overlay manager is responsible for copying
    overlay code from the executable file into memory whenever the program
    attempts to transfer control to code in an overlay. A program that
    uses overlays runs slower than a program that does not use them,
    because it takes longer to extract overlays separately from the .EXE
    file than it does to read the entire .EXE file into memory at once.


    (a)
    ┌───────────┐
    E│           │
    ├───────────┤
    D│ Call E()  │              (b)
    ├───────────┤             ┌───────────┐  ┌───────────┐  ┌───────────┐
    C│           │            ▒│           │ C│           │ E│           │
    ├───────────┤   Overlay ▒│           │  ├───────────┤  ├───────────┤
    B│ Call C()  │      area  ▒│           │ B│ Call C()  │ D│ Call E()  │
    ├───────────┤             ├───────────┤  └───────────┘  └───────────┘
    A│ Call B()  │            A│ Call B()  │
    │ Call D()  │             │ Call D()  │
    └───────────┘             └───────────┘
    LINK A+B+C+D+E;                             LINK A+(B+C)+(D+E);

    Figure 20-13. Memory use in a program linked (a) without overlays and
    (b) with overlays. In (b), either modules (B+C) or modules (D+E) can
    be loaded into the overlay area at run time.


    The default object libraries that accompany Microsoft high-level-
    language compilers contain object modules that support the Microsoft
    run-time overlay manager. The following description of LINK's
    relationship to the run-time overlay manager applies to versions 3.00
    through 3.60 of LINK; implementation details may vary in future
    versions.

Overlay format in a .EXE file

    An executable file that contains overlays has a .EXE header preceding
    each overlay (Figure 20-14). The overlays are numbered in sequence,
    starting at 0; the overlay number is stored in the word at offset 1AH
    in each overlay's .EXE header. When the contents of the .EXE file are
    loaded into memory for execution, only the resident, nonoverlaid part
    of the program is copied into memory. The overlays must be read into
    memory from the .EXE file by the run-time overlay manager.


    Start of file ┌───────────────────┐
                │    .EXE header    │  Overlay number 0
                ├───────────────────┤
                │                   │
                │                   │
                │                   │
                │                   │
                │         A         │
                │ Overlay segments  │
                │                   │
                │                   │
                ├───────────────────┤
                │    .EXE header    │  Overlay number 1
                ├───────────────────┤
                │                   │
                │         B         │
                │         C         │
                ├───────────────────┤
                │    .EXE header    │  Overlay number 2
                ├───────────────────┤
                │                   │
                │         D         │
                │         E         │
    End of file └───────────────────┘

    Figure 20-14. .EXE file structure produced by LINK A + (B+C) + (D+E).


Segments for overlays
    When LINK produces an executable file that contains overlays, it adds
    three segments to those defined in the object modules: OVERLAY_AREA,
    OVERLAY_END, and OVERLAY_DATA. LINK assigns the segment class name
    'CODE' to OVERLAY_AREA and OVERLAY_END and includes OVERLAY_DATA in
    the default group DGROUP.

    OVERLAY_AREA is a reserved segment into which the run-time overlay
    manager is expected to load each overlay as it is needed. Therefore,
    LINK sets the size of OVERLAY_AREA to fit the largest overlay in the
    program. The OVERLAY_END segment is declared immediately after
    OVERLAY_AREA, so a program can determine the size of the OVERLAY_AREA
    segment by subtracting its segment address from that of OVERLAY_END.
    The OVERLAY_DATA segment is initialized by LINK with information about
    the executable file, the number of overlays, and other data useful to
    the run-time overlay manager.

    LINK requires the executable code used in overlays to be contained in
    segments whose class names end in CODE and whose segment names differ
    from those of the segments used in the resident (nonoverlaid) portion
    of the program. In assembly language, this is accomplished by using
    the SEGMENT directive; in high-level languages, the technique of
    ensuring unique segment names depends on the compiler. In Microsoft C,
    for example, the /A switch in the command line selects the memory
    model and thus the segment naming defaults used by the compiler; in
    medium, large, and huge memory models, the compiler generates a unique
    segment name for each C function in the source code. In Microsoft
    FORTRAN, on the other hand, the compiler always generates a uniquely
    named segment for each SUBROUTINE and FUNCTION in the source code, so
    no special programming is required.

    LINK substitutes all far CALL instructions from root to overlay or
    from overlay to overlay with a software interrupt followed by an
    overlay number and an offset into the overlay segment (Figure 20-15).
    The interrupt number can be specified with LINK's /OVERLAYINTERRUPT
    switch; if the switch is omitted, LINK uses Interrupt 3FH by default.
    By replacing calls to overlay code with a software interrupt, LINK
    provides a mechanism for the run-time overlay manager to take control,
    load a specified overlay into memory, and transfer control to a
    specified offset within the overlay.


(a)           EXTRN     OverlayEntryPoint:far
            call      OverlayEntryPoint   ; far CALL

(b)           int       IntNo               ; interrupt number
                                            ;  specified with
                                            ;  /OVERLAYINTERRUPT
                                            ;  switch (default 3FH)
            DB        OverlayNumber       ; overlay number
            DW        OverlayEntry        ; offset of overlay entry point
                                            ;  (the address to which the
                                            ;  overlay manager transfers
                                            ;  control)

    Figure 20-15. Executable code modification by LINK for accessing
    overlays. (a) Code as written. (b) Code as modified by LINK.


Run-time processing of overlays
    The resident (nonoverlaid) portion of a program that uses overlays
    initializes the overlay interrupt vector specified by LINK with the
    address of the run-time overlay manager. (The OVERLAY_DATA segment
    contains the interrupt number.) The overlay manager then takes control
    wherever LINK has substituted a software interrupt for a far call in
    the executable code.

    Each time the overlay manager executes, its first task is to determine
    which overlay is being called. It does this by using the return
    address left on the stack by the INT instruction that invoked the
    overlay manager; this address points to the overlay number stored in
    the byte after the interrupt instruction that just executed. The
    overlay manager then determines whether the destination overlay is
    already resident and loads it only if necessary. Next, the overlay
    manager opens the .EXE file, using the filename in the OVERLAY_DATA
    segment. It locates the start of the specified overlay in the file by
    examining the length (offset 02H and offset 04H) and overlay number
    (offset 1AH) in each overlay's .EXE header.

    The overlay manager can then read the overlay from the .EXE file into
    the OVERLAY_AREA segment. It uses the overlay's segment relocation
    table to fix up any segment references in the overlay. The overlay
    manager transfers control to the overlay with a far call to the
    OVERLAY_AREA segment, using the offset stored by LINK 1 byte after the
    interrupt instruction (see Figure 20-15).

Interrupt 21H Function 4BH
    LINK's protocol for implementing overlays is not recognized by
    Interrupt 21H Function 4BH (Load and Execute Program). This MS-DOS
    function, when called with AL = 03H, loads an overlay from a .EXE file
    into a specified location in memory. See SYSTEM CALLS: INTERRUPT 21H:
    Function 4BH. However, Function 4BH does not use an overlay number, so
    it cannot find overlays in a .EXE file formatted by LINK with multiple
    .EXE headers.

DGROUP

    LINK always includes DGROUP in its internal table of segment groups.
    In object modules generated by Microsoft high-level-language
    translators, DGROUP contains both the default data segment and the
    stack segment. LINK's /DOSSEG and /DSALLOCATE switches both affect the
    way LINK treats DGROUP. Changing the way LINK manages DGROUP
    ultimately affects segment order and addressing in the executable
    file.

Using the /DOSSEG switch
    The /DOSSEG switch causes LINK to arrange segments in the default
    order used by Microsoft high-level-language translators:

    1. All segments with a class name ending in CODE. These segments
        contain executable code.

    2. All other segments outside DGROUP. These segments typically contain
        far data items.

    3. DGROUP segments. These are a program's near data and stack
        segments. The order in which segments appear in DGROUP is

        - Any segments of class BEGDATA. (This class name is reserved for
        Microsoft use.)

        - Any segments not of class BEGDATA, BSS, or STACK.

        - Segments of class BSS.

        - Segments of class STACK.

    This segment order is necessary if programs compiled by Microsoft
    translators are to run properly. The /DOSSEG switch can be used
    whenever an object module produced by an assembler is linked ahead of
    object modules generated by a Microsoft compiler, to ensure that
    segments in the executable file are ordered as in the preceding list
    regardless of the order of segments in the assembled object module.

    When the /DOSSEG switch is in effect, LINK always places DGROUP at the
    end of the executable program, with all uninitalized data segments at
    the end of the group. As discussed above, this placement helps to
    minimize the size of the executable file. The /DOSSEG switch also
    causes LINK to restructure the executable program to support certain
    conventions used by Microsoft language translators:

    ■  Compiler-generated segments with the class name BEGDATA are placed
        at the beginning of DGROUP.

    ■  The public symbols _edata and _end are generated to point to the
        beginning of the BSS and STACK segments.

    ■  Sixteen bytes of zero are inserted in front of the _TEXT segment.

    Microsoft compilers that rely on /DOSSEG conventions generate a
    special COMENT object record that sets the /DOSSEG switch when the
    record is processed by LINK.

Using the /HIGH and /DSALLOCATE switches
    When a program has been linked without using LINK's /HIGH switch, MS-
    DOS loads program code and data segments from the .EXE file at the
    lowest address in the first available block of RAM large enough to
    contain the program (Figure 20-16). The value in the .EXE header at
    offset 0CH specifies the maximum amount of extra RAM MS-DOS must
    allocate to the program above what is loaded from the .EXE file. Above
    that, all unused RAM is managed by MS-DOS. With this memory allocation
    strategy, a program can use Interrupt 21H Functions 48H (Allocate
    Memory Block) and  4AH (Resize Memory Block) to increase or decrease
    the amount of RAM allocated to it.

    When a program is linked with LINK's /HIGH switch, LINK zeros the
    words it stores in the .EXE header at offset 0AH and 0CH. Setting the
    words at 0AH and 0CH to zero indicates that the program is to be
    loaded into RAM at the highest address possible (Figure 20-16). With
    this memory layout, however, a program can no longer change its memory
    allocation dynamically because all available RAM is allocated to the
    program when it is loaded and the uninitialized RAM between the
    program segment prefix and the program itself cannot be freed.


┌─ FFFFFH                                              FFFFFH ─┐
└┌─────────────────────┐              ┌─────────────────────┐┘
│                     │              │                     │
│  System ROM, etc.   │              │  System ROM, etc.   │
│                     │              │                     │
├─────────────────────┤              ├─────────────────────┤
│                     │              │                     │▒
│                     │              │                     │▒Program code
│                     │              │                     │▒ and data
│      (Unused)       │              ├─────────────────────┤  segments
│                     │              │                     │  copied from
│                     │              │                     │  .EXE file
│                     │              │                     │
├─────────────────────┤              │                     │
│    Uninitialized    │▒Specified   │    Uninitialized    │
│     program RAM     │▒ in .EXE     │     program RAM     │
├─────────────────────┤  header      │                     │
│                     │▒             │                     │
│                     │▒Program code│                     │
│                     │▒ and data    │                     │
├─────────────────────┤  segments    ├─────────────────────┤
│  Environment, PSP   │  copied from │  Environment, PSP   │
├─────────────────────┤  .EXE file   ├─────────────────────┤
│                     │              │                     │
│                     │              │                     │
│  Resident portion   │              │  Resident portion   │
│     of MS-DOS       │              │     of MS-DOS       │
│                     │              │                     │
┌└─────────────────────┘              └─────────────────────┘─┐
└─ 00000H                                              00000H ──┘
                    (a)              (b)

    Figure 20-16. Effect of the /HIGH switch on run-time memory use. (a)
    The program is linked without the /HIGH switch. (b) The program is
    linked with the /HIGH switch.


    The only reason to load a program with this type of memory allocation
    is to allow a program data structure to be dynamically extended toward
    lower memory addresses. For example, both stacks and heaps can be
    implemented in this way. If a program's stack segment is the first
    segment in its memory map, the stack can grow downward without
    colliding with other program data.

    To facilitate addressing in such a segment, LINK provides the
    /DSALLOCATE switch. When a program is linked using this switch, all
    addresses within DGROUP are relocated in such a way that the last byte
    in the group has offset FFFFH. For example, if the program in Figure
    20-17 is linked without the /DSALLOCATE and /HIGH switches, the value
    of offset DGROUP:DataItem would be 00H; if these switches are used,
    the linker adjusts the segment value of DGROUP downward so that the
    offset of DataItem within DGROUP becomes FFF0H.

    Early versions of Microsoft Pascal (before version 3.30) and Microsoft
    FORTRAN (before version 3.30) generated object code that had to be
    linked with the /DSALLOCATE switch. For this reason, LINK sets the
    /DSALLOCATE switch by default if it processes an object module
    containing a COMENT record generated by one of these compilers. (Such
    a COMENT record contains the string MS PASCAL or FORTRAN 77. See
    PROGRAMMING IN THE MS-DOS ENVIRONMENT: PROGRAMMING TOOLS: Object
    Modules.) Apart from this special requirement of certain language
    translators, however, the use of /DSALLOCATE and /HIGH should probably
    be avoided because of the limitations they place on run-time memory
    allocation.


DGROUP          GROUP     _DATA
_DATA           SEGMENT   word public 'DATA'
DataItem        DB        10h dup (?)
_DATA           ENDS

_TEXT           SEGMENT   byte public 'CODE'
                ASSUME    cs:_TEXT,ds:DGROUP
                mov       bx,offset DGROUP:DataItem
_TEXT           ENDS
                END

    Figure 20-17. The value of offset DGROUP:DataItem in this program is
    FFF0H if the program is linked with the /DSALLOCATE switch or 00H if
    the program is linked without using the switch.


Summary

    LINK's characteristic support for segment ordering, for run-time
    memory management, and for dynamic overlays has an impact in many
    different situations. Programmers who write their own language
    translators must bear in mind the special conventions followed by LINK
    in support of Microsoft language translators. Application programmers
    must be familiar with LINK's capabilities when they use assembly
    language or link assembly-language programs with object modules
    generated by Microsoft compilers. LINK is a powerful program
    development tool and understanding its special capabilities can lead
    to more efficient programs.

                                                Richard Wilton
</code></pre>

<p>Return to <a href="../index.html">The MS-DOS Encyclopedia</a>: <a href="../index.html#contents">Contents</a></p>



      </section>
      <footer>
<div class="pcjs-explorer">
  <h2 id="pcjs-explorer">PCjs Explorer</h2>
  <ul id="pcjs-explorer-menu" class="menu">
    <li><a href="#" onclick="pcjsExplorerExpandAll(this, event, true)">Expand All</a></li>
    <li><a href="#" onclick="pcjsExplorerExpandAll(this, event, false)">Collapse All</a></li>
    <li><a href="#" onclick="pcjsExplorerSurprise()">Surprise Me</a></li>
  </ul>
          <ul class="pcjs-explorer-top">
            <li id="pcjs-hardware" class="pcjs-explorer-fixed">Hardware
              <ul><li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">All PCs
                  <ul>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">AT&T
                      <ul>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">AT&T 6300
                          <ul>
                            <li id="machines-pcx86-att-6300-cga" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/att/6300/cga/index.html">Color Graphics</a></li>
                            
<li id="machines-pcx86-att-6300" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/att/6300/index.html">Documentation</a></li>

                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">CDP
                      <ul>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">CDP MPC 1600
                          <ul>
                            <li id="machines-pcx86-cdp-mpc1600-cga" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/cdp/mpc1600/cga/index.html">Color Graphics</a></li>
                            
<li id="machines-pcx86-cdp-mpc1600" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/cdp/mpc1600/index.html">Documentation</a></li>

                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">COMPAQ
                      <ul>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Portable
                          <ul>
                            <li id="machines-pcx86-compaq-portable-vdu" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/compaq/portable/vdu/index.html">Monochrome Graphics</a></li>
                            
<li id="machines-pcx86-compaq-portable" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/compaq/portable/index.html">Documentation</a></li>

                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">DeskPro 286
                          <ul>
                            
<li id="machines-pcx86-compaq-deskpro286" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/compaq/deskpro286/index.html">Documentation</a></li>

                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">DeskPro 386
                          <ul>
                            
<li id="machines-pcx86-compaq-deskpro386" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/compaq/deskpro386/index.html">Documentation</a></li>

                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">LTE/286
                          <ul>
                            
<li id="machines-pcx86-compaq-lte286" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/compaq/lte286/index.html">Documentation</a></li>

                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM
                      <ul>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PCJr (Model 4860)
                          <ul>
                            
<li id="machines-pcx86-ibm-4860" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/4860/index.html">Documentation</a></li>

                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PC (Model 5150)
                          <ul>
                            <li id="machines-pcx86-ibm-5150-cga" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5150/cga/index.html">Color Graphics</a></li>
                            <li id="machines-pcx86-ibm-5150-mda" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5150/mda/index.html">Monochrome Display</a></li>
                            <li id="machines-pcx86-ibm-5150-dual" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5150/dual/index.html">Dual Displays</a></li>
                            <li id="machines-pcx86-ibm-5150-vga" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5150/vga/index.html">VGA Display</a></li>
                            
<li id="machines-pcx86-ibm-5150" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5150/index.html">Documentation</a></li>

                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PC XT (Model 5160)
                          <ul>
                            <li id="machines-pcx86-ibm-5160-cga" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5160/cga/index.html">Color Graphics</a></li>
                            <li id="machines-pcx86-ibm-5160-ega" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5160/ega/index.html">Enhanced Graphics</a></li>
                            <li id="machines-pcx86-ibm-5160-mda" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5160/mda/index.html">Monochrome Display</a></li>
                            
<li id="machines-pcx86-ibm-5160" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5160/index.html">Documentation</a></li>

                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PC AT (Model 5170)
                          <ul>
                            <li id="machines-pcx86-ibm-5170-cga" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5170/cga/index.html">Color Graphics</a></li>
                            <li id="machines-pcx86-ibm-5170-vga-cdrom" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5170/vga/cdrom/index.html">VGA Display with CD-ROM</a></li>
                            
<li id="machines-pcx86-ibm-5170" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/5170/index.html">Documentation</a></li>

                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PC Hard Drives
                          <ul>
                            
<li id="machines-pcx86-ibm-hdc" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/hdc/index.html">Documentation</a></li>

                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PC Video Adapters
                          <ul>
                            
<li id="machines-pcx86-ibm-video" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/ibm/video/index.html">Documentation</a></li>

                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Zenith
                      <ul>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Zenith Z-150
                          <ul>
                            <li id="machines-pcx86-zenith-z150-cga" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/zenith/z150/cga/index.html">Color Graphics</a></li>
                            
<li id="machines-pcx86-zenith-z150" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx86/zenith/z150/index.html">Documentation</a></li>

                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li><li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Arcade
                  <ul>
                            <li id="machines-arcade-invaders" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/arcade/invaders/index.html">Space Invaders</a></li>
                  </ul>
                </li><li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">DEC
                  <ul>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PDP-10
                      <ul>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">KA10
                          <ul>
                            <li id="machines-dec-pdp10-ka10-test" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp10/ka10/test/index.html">PDP-10 KA10 Test</a></li>
                            
<li id="machines-dec-pdp10-ka10" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp10/ka10/index.html">Documentation</a></li>

                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">KL10
                          <ul>
                            
<li id="machines-dec-pdp10-kl10" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp10/kl10/index.html">Documentation</a></li>

                          </ul>
                        </li>
                        
<li id="machines-dec-pdp10" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp10/index.html">Documentation</a></li>

                      </ul>
                    </li>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PDP-11
                      <ul>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PDP-11/20
                          <ul>
                            <li id="machines-dec-pdp11-1120-basic" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1120/basic/index.html">PDP-11/20 with BASIC</a></li>
                            <li id="machines-dec-pdp11-1120-bootstrap" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1120/bootstrap/index.html">PDP-11/20 with Bootstrap Loader</a></li>
                            <li id="machines-dec-pdp11-1120-monitor" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1120/monitor/index.html">PDP-11/20 with Boot Monitor</a></li>
                            <li id="machines-dec-pdp11-1120-panel" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1120/panel/index.html">PDP-11/20 with Front Panel</a></li>
                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PDP-11/45
                          <ul>
                            <li id="machines-dec-pdp11-1145-panel" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1145/panel/index.html">PDP-11/45 with 256Kb</a></li>
                            <li id="machines-dec-pdp11-1145-vt100" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1145/vt100/index.html">PDP-11/45 with VT100</a></li>
                          </ul>
                        </li>
                        <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PDP-11/70
                          <ul>
                            <li id="machines-dec-pdp11-1170-4mb" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1170/4mb/index.html">PDP-11/70 with 4Mb</a></li>
                            <li id="machines-dec-pdp11-1170-array" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1170/array/index.html">PDP-11/70 "Server Array"</a></li>
                            <li id="machines-dec-pdp11-1170-monitor" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1170/monitor/index.html">PDP-11/70 with Boot Monitor</a></li>
                            <li id="machines-dec-pdp11-1170-panel" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1170/panel/index.html">PDP-11/70 with Front Panel</a></li>
                            <li id="machines-dec-pdp11-1170-panel-debugger-cpuexer" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1170/panel/debugger/cpuexer/index.html">PDP-11/70 with CPU Exerciser</a></li>
                            <li id="machines-dec-pdp11-1170-panel-debugger-rsts" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1170/panel/debugger/rsts/index.html">PDP-11/70 with RSTS/E</a></li>
                            <li id="machines-dec-pdp11-1170-panel-debugger-rt11" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1170/panel/debugger/rt11/index.html">PDP-11/70 with RT-11</a></li>
                            <li id="machines-dec-pdp11-1170-panel-debugger-xxdp" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1170/panel/debugger/xxdp/index.html">PDP-11/70 with XXDP+</a></li>
                            <li id="machines-dec-pdp11-1170-vt100" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1170/vt100/index.html">PDP-11/70 with VT100</a></li>
                            <li id="machines-dec-pdp11-1170" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/1170/index.html">Documentation</a></li>
                          </ul>
                        </li>
                        
<li id="machines-dec-pdp11" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/index.html">Documentation</a></li>

                      </ul>
                    </li>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">ROMs
                      <ul>
                            <li id="machines-dec-roms-m9312" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/pdp11/rom/M9312/index.html">DEC PDP-11 ROMs</a></li>
                            <li id="machines-dec-roms-vt100" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/vt100/rom/index.html">DEC VT100 ROMs</a></li>
                            <li id="machines-dec-roms-assorted" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/roms/assorted/index.html">Other DEC ROMs</a></li>
                      </ul>
                    </li>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">VT100
                      <ul>
                            <li id="machines-dec-vt100" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/vt100/index.html">VT100 Terminal</a></li>
                            <li id="machines-dec-vt100-dual" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/vt100/dual/index.html">Dual VT100 Terminals</a></li>
                            <li id="machines-dec-vt100-5170" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/dec/vt100/5170/index.html">VT100 connected to IBM PC AT</a></li>
                      </ul>
                    </li>
                  </ul>
                </li><li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Intel
                  <ul>
                            <li id="machines-pcx80-exerciser" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/pcx80/exerciser/index.html">8080 Exerciser</a></li>
                  </ul>
                </li><li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">LEDs
                  <ul>
                            <li id="machines-led-life-color" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/led/life/color/index.html">Game of Life</a></li>
                            <li id="machines-led-lite-brite" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/led/lite-brite/index.html">Lite-Brite</a></li>
                            <li id="machines-led-scroller" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/led/scroller/index.html">Text Scroller</a></li>
                  </ul>
                </li><li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">OSI
                  <ul>
                            <li id="machines-osi-c1p" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/osi/c1p/index.html">Challenger 1P</a></li>
                            <li id="machines-osi-c1p-array" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/osi/c1p/array/index.html">Challenger 1P "Array"</a></li>
                            <li id="machines-osi-c1p-debugger" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/osi/c1p/debugger/index.html">Challenger 1P with Debugger</a></li>
                  </ul>
                </li><li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">TI
                  <ul>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">TI-42 Calculator
                      <ul>
                            <li id="machines-ti-ti42" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/ti/ti42/index.html">TI-42</a></li>
                            <li id="machines-ti-ti42-diags" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/ti/ti42/diags/index.html">TI-42 with Diagnostics</a></li>
                      </ul>
                    </li>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">TI-55 Calculator
                      <ul>
                            <li id="machines-ti-ti55" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/ti/ti55/index.html">TI-55</a></li>
                            <li id="machines-ti-ti55-diags" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/ti/ti55/diags/index.html">TI-55 with Diagnostics</a></li>
                      </ul>
                    </li>
                    <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">TI-57 Calculator
                      <ul>
                            <li id="machines-ti-ti57" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/ti/ti57/index.html">TI-57</a></li>
                            <li id="machines-ti-ti57-rev0" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/ti/ti57/rev0/index.html">TI-57 with Diagnostics</a></li>
                            <li id="machines-ti-ti57-rev1" class="pcjs-explorer-item" onclick="pcjsExplorerClick(this, event)"><a href="../../../../../../machines/ti/ti57/rev1/index.html">TI-57 with Revised ROM</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>


          <ul class="pcjs-explorer-top">
            <li id="pcjs-software" class="pcjs-explorer-fixed">Software
              <ul>
                <li class="pcjs-explorer-family pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">DEC
                  <ul>
                    <li id="software-pdp10" class="pcjs-explorer-platform pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PDP-10
                      <ul>
                        <li id="software-pdp10-diag" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Diagnostics
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">KA10
                              <ul>
                                        <li id="software-dec-pdp10-diag-ka10-dakaa" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAA-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakaa/index.html">DAKAA</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakab" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAB-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (2)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakab/index.html">DAKAB</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakac" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAC-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (3)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakac/index.html">DAKAC</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakad" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAD-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakad/index.html">DAKAD</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakae" class="pcjs-explorer-version pcjs-explorer-item" title="AH-6859C-DD: DAKAEC0 PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (5)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakae/index.html">DAKAE</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakaf" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAF-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (6)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakaf/index.html">DAKAF</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakag" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAG-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (7)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakag/index.html">DAKAG</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakah" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAH-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (8)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakah/index.html">DAKAH</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakai" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAI-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (9)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakai/index.html">DAKAI</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakaj" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAJ-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (10)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakaj/index.html">DAKAJ</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakak" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAK-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (11)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakak/index.html">DAKAK</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakal" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAL-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (12)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakal/index.html">DAKAL</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakam" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKAM-B-D: PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (13)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakam/index.html">DAKAM</a>
                                        </li>
                                        <li id="software-dec-pdp10-diag-ka10-dakba" class="pcjs-explorer-version pcjs-explorer-item" title="MAINDEC-10-DAKBA-B-D: PDP-10 KA10 BASIC INSTRUCTION RELIABILITY TEST (1)">
                                          <a href="../../../../../../software/dec/pdp10/diag/ka10/dakba/index.html">DAKBA</a>
                                        </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pdp10-lang" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Languages
                          <ul>
                                        <li id="software-dec-pdp10-lang-macro10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/dec/pdp10/lang/macro10/index.html">MACRO-10</a>
                                        </li>
                          </ul>
                        </li>
                        <li id="software-pdp10-test" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Tests
                          <ul>
                                        <li id="software-dec-pdp10-test-macro10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/dec/pdp10/test/macro10/index.html">PDP-10 Mini-Assembler Tests</a>
                                        </li>
                                        <li id="software-dec-pdp10-test-opcodes" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/dec/pdp10/test/opcodes/index.html">PDP-10 Opcode Tests</a>
                                        </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li id="software-pdp11" class="pcjs-explorer-platform pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PDP-11
                      <ul>
                        <li id="software-pdp11-disks" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Disks
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">RK03
                              <ul>
                                        <li id="software-dec-pdp11-disks-rk03-rt11v4" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/dec/pdp11/disks/rk03/rt11v4/index.html">RT-11 4.0</a>
                                        </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pdp11-tapes" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Tapes
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">BASIC
                              <ul>
                                        <li id="software-dec-pdp11-tapes-basic" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/dec/pdp11/tapes/basic/index.html">BASIC (Single User)</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Diagnostics
                              <ul>
                                        <li id="software-dec-pdp11-tapes-diag-d0aa" class="pcjs-explorer-version pcjs-explorer-item" title="D0AA: TEST 1 - BRANCH">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0aa">D0AA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0ba" class="pcjs-explorer-version pcjs-explorer-item" title="D0BA: TEST 2 - CON BRANCH">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0ba">D0BA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0ca" class="pcjs-explorer-version pcjs-explorer-item" title="D0CA: TEST 3 - UNARY">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0ca">D0CA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0da" class="pcjs-explorer-version pcjs-explorer-item" title="D0DA: TEST 4 - UNARY + BINARY">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0da">D0DA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0ea" class="pcjs-explorer-version pcjs-explorer-item" title="D0EA: TEST 5 - ROTATE SHIFT">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0ea">D0EA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0fa" class="pcjs-explorer-version pcjs-explorer-item" title="D0FA: TEST 6 - COMPARE">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0fa">D0FA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0ga" class="pcjs-explorer-version pcjs-explorer-item" title="D0GA: TEST 7 - COMPARE NOT">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0ga">D0GA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0ha" class="pcjs-explorer-version pcjs-explorer-item" title="D0HA: TEST 8 - MOVE">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0ha">D0HA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0ia" class="pcjs-explorer-version pcjs-explorer-item" title="D0IA: TEST 9 - BIS, BIC + BIT">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0ia">D0IA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0ja" class="pcjs-explorer-version pcjs-explorer-item" title="D0JA: TEST 10 - ADD">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0ja">D0JA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0ka" class="pcjs-explorer-version pcjs-explorer-item" title="D0KA: TEST 11 - SUBTRACT">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0ka">D0KA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0la" class="pcjs-explorer-version pcjs-explorer-item" title="D0LA: TEST 12 - JUMP">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0la">D0LA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0ma" class="pcjs-explorer-version pcjs-explorer-item" title="D0MA: TEST 13 - JSR, RTS, RTI">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0ma">D0MA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0na" class="pcjs-explorer-version pcjs-explorer-item" title="D0NA: TEST 14A - TRAP TEST">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0na">D0NA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0nb" class="pcjs-explorer-version pcjs-explorer-item" title="D0NB: TEST 14B - TRAP TEST">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0nb">D0NB</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0nc" class="pcjs-explorer-version pcjs-explorer-item" title="D0NC: TEST 14C - TRAP TEST">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0nc">D0NC</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-d0oa" class="pcjs-explorer-version pcjs-explorer-item" title="D0OA: TEST 15 - CPU EXERCISER">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#d0oa">D0OA</a>
                                        </li>
                                        <li id="software-dec-pdp11-tapes-diag-deqkc" class="pcjs-explorer-version pcjs-explorer-item" title="DEQKC: 11/70 INSTRUCTION EXERCISER">
                                          <a href="../../../../../../software/dec/pdp11/tapes/diag/index.html#deqkc">DEQKC</a>
                                        </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                </li>
                    <li id="software-pcx86" class="pcjs-explorer-platform pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM PC
                      <ul>
                        <li id="software-pcx86-app" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Applications
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">BASIC
                                  <ul>
                                        <li id="software-pcx86-app-ibm-basic-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/ibm/basic/1.00/index.html">Programs from PC DOS 1.00</a>
                                        </li>
                                        <li id="software-pcx86-app-ibm-basic-1.00-donkey" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/ibm/basic/1.00/donkey/index.html">DONKEY.BAS from PC DOS 1.00</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Multiplan
                                  <ul>
                                        <li id="software-pcx86-app-ibm-multiplan-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/ibm/multiplan/1.00/index.html">IBM Multiplan 1.00</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Lotus
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">1-2-3
                                  <ul>
                                        <li id="software-pcx86-app-lotus-123-1a" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/lotus/123/1a/index.html">1-2-3 1A</a>
                                        </li>
                                        <li id="software-pcx86-app-lotus-123-1aa" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/lotus/123/1aa/index.html">1-2-3 1A*</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microsoft
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microsoft Chart
                                  <ul>
                                        <li id="software-pcx86-app-microsoft-chart-2.02" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/microsoft/chart/2.02/index.html">Microsoft Chart 2.02</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microsoft Multiplan
                                  <ul>
                                        <li id="software-pcx86-app-microsoft-multiplan-1.06" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/microsoft/multiplan/1.06/index.html">Microsoft Multiplan 1.06</a>
                                        </li>
                                        <li id="software-pcx86-app-microsoft-multiplan-2.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/microsoft/multiplan/2.00/index.html">Microsoft Multiplan 2.00</a>
                                        </li>
                                        <li id="software-pcx86-app-microsoft-multiplan-2.01" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/microsoft/multiplan/2.01/index.html">Microsoft Multiplan 2.01</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microsoft Word
                                  <ul>
                                        <li id="software-pcx86-app-microsoft-word-1.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/microsoft/word/1.10/index.html">Microsoft Word 1.10</a>
                                        </li>
                                        <li id="software-pcx86-app-microsoft-word-1.15" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/microsoft/word/1.15/index.html">Microsoft Word 1.15</a>
                                        </li>
                                        <li id="software-pcx86-app-microsoft-word-3.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/microsoft/word/3.00/index.html">Microsoft Word 3.00</a>
                                        </li>
                                        <li id="software-pcx86-app-microsoft-word-3.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/microsoft/word/3.10/index.html">Microsoft Word 3.10</a>
                                        </li>
                                        <li id="software-pcx86-app-microsoft-word-5.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/microsoft/word/5.00/index.html">Microsoft Word 5.00</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Word for Windows
                                  <ul>
                                        <li id="software-pcx86-app-microsoft-winword-2.0c" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/microsoft/winword/2.0c/index.html">Word for Windows 2.0c</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Other
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">dBASE II
                                  <ul>
                                        <li id="software-pcx86-app-other-dbase2-2.4" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/dbase2/2.4/index.html">dBASE II 2.4</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">dBASE III
                                  <ul>
                                        <li id="software-pcx86-app-other-dbase3-1.0" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/dbase3/1.0/index.html">dBASE III 1.0</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">SuperCalc
                                  <ul>
                                        <li id="software-pcx86-app-other-sc1-1.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/sc1/1.10/index.html">SuperCalc 1.10</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">SuperCalc2
                                  <ul>
                                        <li id="software-pcx86-app-other-sc2-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/sc2/1.00/index.html">SuperCalc2 1.00</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">SuperCalc3
                                  <ul>
                                        <li id="software-pcx86-app-other-sc3-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/sc3/1.00/index.html">SuperCalc3 1.00</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">ThinkTank
                                  <ul>
                                        <li id="software-pcx86-app-other-thinktank-1987" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/thinktank/1987/index.html">ThinkTank (1987)</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">VisiCalc
                                  <ul>
                                        <li id="software-pcx86-app-other-visicalc-1981" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/visicalc/1981/index.html">VisiCalc (1981)</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">WordStar
                                  <ul>
                                        <li id="software-pcx86-app-other-wordstar" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/wordstar/index.html">Overview</a>
                                        </li>
                                        <li id="software-pcx86-app-other-wordstar-3.20" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/wordstar/3.20/index.html">WordStar 3.20</a>
                                        </li>
                                        <li id="software-pcx86-app-other-wordstar-3.24" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/wordstar/3.24/index.html">WordStar 3.24</a>
                                        </li>
                                        <li id="software-pcx86-app-other-wordstar-3.30" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/wordstar/3.30/index.html">WordStar 3.30</a>
                                        </li>
                                        <li id="software-pcx86-app-other-wordstar-4.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/wordstar/4.00/index.html">WordStar 4.00</a>
                                        </li>
                                        <li id="software-pcx86-app-other-wordstar-pcjr" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/app/other/wordstar/pcjr/index.html">WordStar for PCjr</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pcx86-demo" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Demos
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Exploring the IBM PC
                                  <ul>
                                        <li id="software-pcx86-demo-ibm-exploring-1.00-CGA" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/demo/ibm/exploring/1.00-CGA/index.html">Exploring the IBM PC (CGA)</a>
                                        </li>
                                        <li id="software-pcx86-demo-ibm-exploring-1.00-MDA" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/demo/ibm/exploring/1.00-MDA/index.html">Exploring the IBM PC (MDA)</a>
                                        </li>
                                        <li id="software-pcx86-demo-ibm-exploring-1.00-AT" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/demo/ibm/exploring/1.00-AT/index.html">Exploring the IBM PC AT 1.00</a>
                                        </li>
                                        <li id="software-pcx86-demo-ibm-exploring-2.00-AT" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/demo/ibm/exploring/2.00-AT/index.html">Exploring the IBM PC AT 2.00</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM EGA Demos and Utilities
                                  <ul>
                                        <li id="software-pcx86-demo-ibm-ega" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/demo/ibm/ega/index.html">Fantasy Land</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pcx86-dev" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Devices
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Mouse
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microsoft Mouse
                                  <ul>
                                        <li id="software-pcx86-dev-mouse-microsoft-2.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/dev/mouse/microsoft/2.00/index.html">MS Mouse 2.00</a>
                                        </li>
                                        <li id="software-pcx86-dev-mouse-microsoft-2.50" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/dev/mouse/microsoft/2.50/index.html">MS Mouse 2.50</a>
                                        </li>
                                        <li id="software-pcx86-dev-mouse-microsoft-4.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/dev/mouse/microsoft/4.00/index.html">MS Mouse 4.00</a>
                                        </li>
                                        <li id="software-pcx86-dev-mouse-microsoft-5.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/dev/mouse/microsoft/5.00/index.html">MS Mouse 5.00</a>
                                        </li>
                                        <li id="software-pcx86-dev-mouse-microsoft-6.xx" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/dev/mouse/microsoft/6.xx/index.html">MS Mouse 6.xx</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">ROM
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM PC ROMs
                                  <ul>
                                        <li id="software-pcx86-dev-rom-ibm-5150" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/dev/rom/ibm/5150/index.html">IBM PC BIOS Sources</a>
                                        </li>
                                        <li id="software-pcx86-dev-rom-ibm-5160" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/dev/rom/ibm/5160/index.html">IBM PC XT BIOS Sources</a>
                                        </li>
                                        <li id="software-pcx86-dev-rom-ibm-5170" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/dev/rom/ibm/5170/index.html">IBM PC AT BIOS Sources</a>
                                        </li>
                                        <li id="software-pcx86-dev-rom-ibm-ega" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/dev/rom/ibm/ega/index.html">IBM EGA BIOS Sources</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pcx86-diag" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Diagnostics
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">COMPAQ
                              <ul>
                                        <li id="software-pcx86-diag-compaq-5.02" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/compaq/5.02/index.html">COMPAQ Diagnostics 5.02</a>
                                        </li>
                                        <li id="software-pcx86-diag-compaq-5.08" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/compaq/5.08/index.html">COMPAQ Diagnostics 5.08</a>
                                        </li>
                                        <li id="software-pcx86-diag-compaq-6.12" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/compaq/6.12/index.html">COMPAQ Diagnostics 6.12</a>
                                        </li>
                                        <li id="software-pcx86-diag-compaq-1986" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/compaq/1986/index.html">COMPAQ DeskPro 386 (1986)</a>
                                        </li>
                                        <li id="software-pcx86-diag-compaq-1987" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/compaq/1987/index.html">COMPAQ User Programs (1987)</a>
                                        </li>
                                        <li id="software-pcx86-diag-compaq-1989" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/compaq/1989/index.html">COMPAQ User Programs (1989)</a>
                                        </li>
                                        <li id="software-pcx86-diag-compaq-1990" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/compaq/1990/index.html">COMPAQ SystemPro</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM Diagnostics
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM PC
                                  <ul>
                                        <li id="software-pcx86-diag-ibm-5150-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5150/1.00/index.html">IBM PC Diagnostics 1.00</a>
                                        </li>
                                        <li id="software-pcx86-diag-ibm-5150-1.02" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5150/1.02/index.html">IBM PC Diagnostics 1.02</a>
                                        </li>
                                        <li id="software-pcx86-diag-ibm-5150-1.02A" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5150/1.02A/index.html">IBM PC Diagnostics 1.02 (Adv)</a>
                                        </li>
                                        <li id="software-pcx86-diag-ibm-5150-2.02" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5150/2.02/index.html">IBM PC Diagnostics 2.02</a>
                                        </li>
                                        <li id="software-pcx86-diag-ibm-5150-2.05" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5150/2.05/index.html">IBM PC Diagnostics 2.05</a>
                                        </li>
                                        <li id="software-pcx86-diag-ibm-5150-2.05A" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5150/2.05A/index.html">IBM PC Diagnostics 2.05 (Adv)</a>
                                        </li>
                                        <li id="software-pcx86-diag-ibm-5150-2.07" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5150/2.07/index.html">IBM PC Diagnostics 2.07</a>
                                        </li>
                                        <li id="software-pcx86-diag-ibm-5150-2.20A" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5150/2.20A/index.html">IBM PC Diagnostics 2.20 (Adv)</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM PC AT
                                  <ul>
                                        <li id="software-pcx86-diag-ibm-5170-1.01A" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5170/1.01A/index.html">IBM PC AT Diagnostics 1.01 (Adv)</a>
                                        </li>
                                        <li id="software-pcx86-diag-ibm-5170-1.02" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5170/1.02/index.html">IBM PC AT Diagnostics 1.02</a>
                                        </li>
                                        <li id="software-pcx86-diag-ibm-5170-2.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5170/2.00/index.html">IBM PC AT Diagnostics 2.00</a>
                                        </li>
                                        <li id="software-pcx86-diag-ibm-5170-2.07A" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/diag/ibm/5170/2.07A/index.html">IBM PC AT Diagnostics 2.07 (Adv)</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pcx86-game" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Games
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM
                              <ul>
                                        <li id="software-pcx86-game-ibm-101mazes" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/ibm/101mazes/index.html">101 Monochrome Mazes (1983)</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Id Software
                              <ul>
                                        <li id="software-pcx86-game-id-commander_keen" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/id/commander_keen/index.html">Commander Keen (1991)</a>
                                        </li>
                                        <li id="software-pcx86-game-id-wolf3d" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/id/wolf3d/index.html">Wolfenstein 3D (1993)</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Infocom
                              <ul>
                                        <li id="software-pcx86-game-infocom-hhiker" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/infocom/hhiker/index.html">The Hitchhiker's Guide to the Galaxy</a>
                                        </li>
                                        <li id="software-pcx86-game-infocom-phobos" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/infocom/phobos/index.html">Leather Goddesses of Phobos</a>
                                        </li>
                                        <li id="software-pcx86-game-infocom-planetfall" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/infocom/planetfall/index.html">Planetfall</a>
                                        </li>
                                        <li id="software-pcx86-game-infocom-zork1" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/infocom/zork1/index.html">Zork I: The Great Underground Empire</a>
                                        </li>
                                        <li id="software-pcx86-game-infocom-zork2" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/infocom/zork2/index.html">Zork II: The Wizard of Frobozz </a>
                                        </li>
                                        <li id="software-pcx86-game-infocom-zork3" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/infocom/zork3/index.html">Zork III: The Dungeon Master</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microsoft
                              <ul>
                                        <li id="software-pcx86-game-microsoft-adventure" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/microsoft/adventure/index.html">Microsoft Adventure</a>
                                        </li>
                                        <li id="software-pcx86-game-microsoft-flightsim-1984" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/microsoft/flightsim/1984/index.html">Flight Simulator (1984)</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Other
                              <ul>
                                        <li id="software-pcx86-game-other-1983-adventmath" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1983/adventmath/index.html">Adventures in Math (1983)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1985-castle_adventure" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1985/castle_adventure/index.html">Castle Adventure (1985)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1992-dune2" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1992/dune2/index.html">Dune II (1992)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1982-esuite" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1982/esuite/index.html">Executive Suite (1982)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-2019-invaders" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../machines/pcx86/ibm/5150/vga/indexa0a7.html?software=/pcx86/game/other/2019/invaders/&amp;autoMount=%7BA:%7Bname:%22Invaders%20Boot%20Sector%20(2019)%22,path:%22/gamedisks/pcx86/game/other/2019/invaders/INVADERS-BOOT.json%22%7D%7D">Invaders Boot Sector (2019)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1985-kings_quest1" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1985/kings_quest1/index.html">King's Quest (1985)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1987-kings_quest1" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1987/kings_quest1/index.html">King's Quest (1987)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1991-lemmings" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1991/lemmings/index.html">Lemmings (1991)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1992-moria" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1992/moria/index.html">Moria (1992)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1990-oregon_trail" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1990/oregon_trail/index.html">The Oregon Trail (1990)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1985-rogue" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1985/rogue/index.html">Rogue (1985)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1988-trump_castle" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1988/trump_castle/index.html">Trump Castle (1988)</a>
                                        </li>
                                        <li id="software-pcx86-game-other-1984-wizardry1" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/game/other/1984/wizardry1/index.html">Wizardry I (1984)</a>
                                        </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pcx86-lang" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Languages
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Borland
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Turbo Pascal
                                  <ul>
                                        <li id="software-pcx86-lang-borland-pascal-2.00b" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/borland/pascal/2.00b/index.html">Borland Turbo Pascal 2.00B</a>
                                        </li>
                                        <li id="software-pcx86-lang-borland-pascal-3.00b" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/borland/pascal/3.00b/index.html">Borland Turbo Pascal 3.00B</a>
                                        </li>
                                        <li id="software-pcx86-lang-borland-pascal-3.01a" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/borland/pascal/3.01a/index.html">Borland Turbo Pascal 3.01A</a>
                                        </li>
                                        <li id="software-pcx86-lang-borland-pascal-3.02a" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/borland/pascal/3.02a/index.html">Borland Turbo Pascal 3.02A</a>
                                        </li>
                                        <li id="software-pcx86-lang-borland-pascal-4.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/borland/pascal/4.00/index.html">Borland Turbo Pascal 4.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-borland-pascal-5.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/borland/pascal/5.00/index.html">Borland Turbo Pascal 5.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-borland-pascal-5.50" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/borland/pascal/5.50/index.html">Borland Turbo Pascal 5.50</a>
                                        </li>
                                        <li id="software-pcx86-lang-borland-pascal-6.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/borland/pascal/6.00/index.html">Borland Turbo Pascal 6.00</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Digital Research
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Pascal/MT+
                                  <ul>
                                        <li id="software-pcx86-lang-dresearch-pascal-3.11" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/dresearch/pascal/3.11/index.html">Pascal/MT+ 3.11</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">APL
                                  <ul>
                                        <li id="software-pcx86-lang-ibm-apl-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/ibm/apl/1.00/index.html">IBM APL 1.00</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">BASIC
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">BASIC Compiler
                                      <ul>
                                        <li id="software-pcx86-lang-ibm-basic-compiler-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/ibm/basic/compiler/1.00/index.html">IBM BASIC Compiler 1.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-ibm-basic-compiler-2.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/ibm/basic/compiler/2.00/index.html">IBM BASIC Compiler 2.00</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">COBOL
                                  <ul>
                                        <li id="software-pcx86-lang-ibm-cobol-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/ibm/cobol/1.00/index.html">IBM COBOL 1.00</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Macro Assembler
                                  <ul>
                                        <li id="software-pcx86-lang-ibm-masm-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/ibm/masm/1.00/index.html">IBM Macro Assembler 1.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-ibm-masm-2.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/ibm/masm/2.00/index.html">IBM Macro Assembler 2.00</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Pascal
                                  <ul>
                                        <li id="software-pcx86-lang-ibm-pascal-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/ibm/pascal/1.00/index.html">IBM Pascal Compiler 1.00</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Logitech
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Modula-2/86
                                  <ul>
                                        <li id="software-pcx86-lang-logitech-modula2-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/logitech/modula2/1.00/index.html">Modula-2/86 1.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-logitech-modula2-1.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/logitech/modula2/1.10/index.html">Modula-2/86 1.10</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microsoft
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">BASIC
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">BASIC Compiler
                                      <ul>
                                        <li id="software-pcx86-lang-microsoft-basic-compiler-5.36" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/basic/compiler/5.36/index.html">MS BASIC Compiler 5.36</a>
                                        </li>
                                      </ul>
                                    </li>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">QBasic
                                      <ul>
                                        <li id="software-pcx86-lang-microsoft-basic-qbasic-1.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/basic/qbasic/1.10/index.html">MS QBasic 1.10</a>
                                        </li>
                                      </ul>
                                    </li>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">QuickBASIC
                                      <ul>
                                        <li id="software-pcx86-lang-microsoft-basic-quickbasic-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/basic/quickbasic/1.00/index.html">MS QuickBASIC 1.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-basic-quickbasic-2.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/basic/quickbasic/2.00/index.html">MS QuickBASIC 2.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-basic-quickbasic-2.01" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/basic/quickbasic/2.01/index.html">MS QuickBASIC 2.01</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-basic-quickbasic-3.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/basic/quickbasic/3.00/index.html">MS QuickBASIC 3.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-basic-quickbasic-4.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/basic/quickbasic/4.00/index.html">MS QuickBASIC 4.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-basic-quickbasic-4.50" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/basic/quickbasic/4.50/index.html">MS QuickBASIC 4.50</a>
                                        </li>
                                      </ul>
                                    </li>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Visual Basic
                                      <ul>
                                        <li id="software-pcx86-lang-microsoft-basic-vb-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/basic/vb/1.00/index.html">MS Visual Basic 1.00</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">C Compiler
                                  <ul>
                                        <li id="software-pcx86-lang-microsoft-c-1.03" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/c/1.03/index.html">Microsoft C Compiler 1.03</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-c-1.04" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/c/1.04/index.html">Microsoft C Compiler 1.04</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-c-2.03" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/c/2.03/index.html">Microsoft C Compiler 2.03</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-c-3.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/c/3.00/index.html">Microsoft C Compiler 3.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-c-4.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/c/4.00/index.html">Microsoft C Compiler 4.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-c-5.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/c/5.00/index.html">Microsoft C Compiler 5.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-c-5.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/c/5.10/index.html">Microsoft C Compiler 5.10</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-c-5.10-os2" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/c/5.10-os2/index.html">Microsoft C Compiler for OS/2 5.10</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">COBOL
                                  <ul>
                                        <li id="software-pcx86-lang-microsoft-cobol-1.12" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/cobol/1.12/index.html">MS COBOL 1.12</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Macro Assembler
                                  <ul>
                                        <li id="software-pcx86-lang-microsoft-masm-1.00-1981" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/1.00-1981/index.html">Macro Assembler 1.00-1981</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/1.00/index.html">Macro Assembler 1.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-1.06" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/1.06/index.html">Macro Assembler 1.06</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-1.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/1.10/index.html">Macro Assembler 1.10</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-1.12" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/1.12/index.html">Macro Assembler 1.12</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-1.25" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/1.25/index.html">Macro Assembler 1.25</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-2.04" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/2.04/index.html">Macro Assembler 2.04</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-3.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/3.00/index.html">Macro Assembler 3.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-3.01" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/3.01/index.html">Macro Assembler 3.01</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-4.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/4.00/index.html">Macro Assembler 4.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-5.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/5.00/index.html">Macro Assembler 5.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-5.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/5.10/index.html">Macro Assembler 5.10</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-5.10x" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/5.10x/index.html">Macro Assembler 5.10 (Feb 1988)</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-6.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/6.00/index.html">Macro Assembler 6.00</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-masm-6.11" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/masm/6.11/index.html">Macro Assembler 6.11</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Pascal
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">MS Pascal
                                      <ul>
                                        <li id="software-pcx86-lang-microsoft-pascal-compiler-3.31" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/pascal/compiler/3.31/index.html">MS Pascal 3.31</a>
                                        </li>
                                        <li id="software-pcx86-lang-microsoft-pascal-compiler-4.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/pascal/compiler/4.00/index.html">MS Pascal 4.00</a>
                                        </li>
                                      </ul>
                                    </li>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">MS QuickPascal
                                      <ul>
                                        <li id="software-pcx86-lang-microsoft-pascal-quickpascal-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/microsoft/pascal/quickpascal/1.00/index.html">MS QuickPascal 1.00</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Other
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">RatBas
                                  <ul>
                                        <li id="software-pcx86-lang-other-ratbas-1982" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/lang/other/ratbas/1982/index.html">RatBas (1982)</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pcx86-sdk" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">SDKs
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">OS/2 SDKs
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microsoft
                                  <ul>
                                        <li id="software-pcx86-sdk-os2-microsoft-1.02" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sdk/os2/microsoft/1.02/index.html">MS OS/2 SDK 1.02</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Windows SDKs
                              <ul>
                                        <li id="software-pcx86-sdk-windows-1.01" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sdk/windows/1.01/index.html">Windows SDK 1.01</a>
                                        </li>
                                        <li id="software-pcx86-sdk-windows-1.03" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sdk/windows/1.03/index.html">Windows SDK 1.03 </a>
                                        </li>
                                        <li id="software-pcx86-sdk-windows-1.04" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sdk/windows/1.04/index.html">Windows SDK 1.04</a>
                                        </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pcx86-sw" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Shareware
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Books
                              <ul>
                                        <li id="software-pcx86-sw-books-dos_internals" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/books/dos_internals/index.html">DOS Internals (1994)</a>
                                        </li>
                                        <li id="software-pcx86-sw-books-graphics_for_the_ibm_pc" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/books/graphics_for_the_ibm_pc/index.html">Graphics for the IBM PC</a>
                                        </li>
                                        <li id="software-pcx86-sw-books-inside_the_ibm_pc" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/books/inside_the_ibm_pc/index.html">Inside the IBM PC</a>
                                        </li>
                                        <li id="software-pcx86-sw-books-unauthorized_windows_95" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/books/unauthorized_windows_95/index.html">Unauthorized Windows 95</a>
                                        </li>
                                        <li id="software-pcx86-sw-books-undocumented_dos" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/books/undocumented_dos/index.html">Undocumented DOS</a>
                                        </li>
                                        <li id="software-pcx86-sw-books-undocumented_pc" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/books/undocumented_pc/index.html">The Undocumented PC</a>
                                        </li>
                                        <li id="software-pcx86-sw-books-undocumented_windows" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/books/undocumented_windows/index.html">Undocumented Windows</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Magazines
                              <ul>
                                        <li id="software-pcx86-sw-magazines-pcdm" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/magazines/pcdm/index.html">PC Disk Magazine</a>
                                        </li>
                                        <li id="software-pcx86-sw-magazines-pcm" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/magazines/pcm/index.html">PC Magazine Diskettes</a>
                                        </li>
                                        <li id="software-pcx86-sw-magazines-pctj" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/magazines/pctj/index.html">PC Tech Journal Diskettes</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Miscellaneous
                              <ul>
                                        <li id="software-pcx86-sw-misc-pcsig08" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/misc/pcsig08/index.html">PC-SIG Library 8th Edition</a>
                                        </li>
                                        <li id="software-pcx86-sw-misc-scbc" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/misc/scbc/index.html">Small Computer Book Club</a>
                                        </li>
                                        <li id="software-pcx86-sw-misc-unprot" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sw/misc/unprot/index.html">Unprotect Assortment</a>
                                        </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pcx86-sys" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Systems
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">CP/M-86
                              <ul>
                                        <li id="software-pcx86-sys-cpm-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/cpm/1.00/index.html">CP/M-86 1.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-cpm-1.1b" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/cpm/1.1b/index.html">CP/M-86 1.1B</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">DOS
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">COMPAQ
                                  <ul>
                                        <li id="software-pcx86-sys-dos-compaq-1.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/compaq/1.10/index.html">COMPAQ MS-DOS 1.10</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-compaq-1.11" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/compaq/1.11/index.html">COMPAQ MS-DOS 1.11</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-compaq-1.12" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/compaq/1.12/index.html">COMPAQ MS-DOS 1.12</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-compaq-2.11" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/compaq/2.11/index.html">COMPAQ MS-DOS 2.11</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-compaq-2.12" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/compaq/2.12/index.html">COMPAQ MS-DOS 2.12</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-compaq-3.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/compaq/3.00/index.html">COMPAQ MS-DOS 3.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-compaq-3.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/compaq/3.10/index.html">COMPAQ MS-DOS 3.10</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-compaq-3.31" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/compaq/3.31/index.html">COMPAQ MS-DOS 3.31</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Digital Research
                                  <ul>
                                        <li id="software-pcx86-sys-dos-dresearch-3.31" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/dresearch/3.31/index.html">DR DOS 3.31</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-dresearch-3.32" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/dresearch/3.32/index.html">DR DOS 3.32</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-dresearch-3.33" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/dresearch/3.33/index.html">DR DOS 3.33</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-dresearch-3.34" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/dresearch/3.34/index.html">DR DOS 3.34</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-dresearch-3.40" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/dresearch/3.40/index.html">DR DOS 3.40</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-dresearch-3.41" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/dresearch/3.41/index.html">DR DOS 3.41</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-dresearch-5.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/dresearch/5.00/index.html">DR DOS 5.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-dresearch-6.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/dresearch/6.00/index.html">DR DOS 6.00</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM
                                  <ul>
                                        <li id="software-pcx86-sys-dos-ibm-0.90" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/0.90/index.html">PC DOS 0.90</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/1.00/index.html">PC DOS 1.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-1.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/1.10/index.html">PC DOS 1.10</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-2.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/2.00/index.html">PC DOS 2.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-2.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/2.10/index.html">PC DOS 2.10</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-3.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/3.00/index.html">PC DOS 3.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-3.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/3.10/index.html">PC DOS 3.10</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-3.20" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/3.20/index.html">PC DOS 3.20</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-3.30" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/3.30/index.html">PC DOS 3.30</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-4.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/4.00/index.html">PC DOS 4.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-4.01" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/4.01/index.html">PC DOS 4.01</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-5.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/5.00/index.html">PC DOS 5.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-5.02" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/5.02/index.html">PC DOS 5.02</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-6.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/6.10/index.html">PC DOS 6.10</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-6.30" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/6.30/index.html">PC DOS 6.30</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-ibm-7.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/ibm/7.00/index.html">PC DOS 7.00</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">MS-DOS
                                  <ul>
                                        <li id="software-pcx86-sys-dos-microsoft-2.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/2.00/index.html">MS-DOS 2.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-3.20" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/3.20/index.html">MS-DOS 3.20</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-3.21" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/3.21/index.html">MS-DOS 3.21</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-3.30" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/3.30/index.html">MS-DOS 3.30</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-3.31" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/3.31/index.html">MS-DOS 3.31</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-4.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/4.00/index.html">MS-DOS 4.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-4.01" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/4.01/index.html">MS-DOS 4.01</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-4.0M" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/4.0M/index.html">MS-DOS 4.0M</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-5.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/5.00/index.html">MS-DOS 5.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-6.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/6.00/index.html">MS-DOS 6.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-6.20" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/6.20/index.html">MS-DOS 6.20</a>
                                        </li>
                                        <li id="software-pcx86-sys-dos-microsoft-6.22" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/dos/microsoft/6.22/index.html">MS-DOS 6.22</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">DOS Extensions
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">TopView
                                      <ul>
                                        <li id="software-pcx86-sys-ext-ibm-topview-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/ibm/topview/1.00/index.html">TopView 1.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-ext-ibm-topview-1.01" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/ibm/topview/1.01/index.html">TopView 1.01</a>
                                        </li>
                                        <li id="software-pcx86-sys-ext-ibm-topview-1.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/ibm/topview/1.10/index.html">TopView 1.10</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microsoft
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">MS-DOS Manager
                                      <ul>
                                        <li id="software-pcx86-sys-ext-microsoft-dosmgr-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/microsoft/dosmgr/1.00/index.html">MS-DOS Manager 1.00</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Quarterdeck
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">DESQview
                                      <ul>
                                        <li id="software-pcx86-sys-ext-quarterdeck-desqview-1.02" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/quarterdeck/desqview/1.02/index.html">DESQview 1.02</a>
                                        </li>
                                      </ul>
                                    </li>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">QEMM-386
                                      <ul>
                                        <li id="software-pcx86-sys-ext-quarterdeck-qemm386-4.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/quarterdeck/qemm386/4.10/index.html">QEMM-386 4.10</a>
                                        </li>
                                        <li id="software-pcx86-sys-ext-quarterdeck-qemm386-4.23" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/quarterdeck/qemm386/4.23/index.html">QEMM-386 4.23</a>
                                        </li>
                                        <li id="software-pcx86-sys-ext-quarterdeck-qemm386-5.13" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/quarterdeck/qemm386/5.13/index.html">QEMM-386 5.13</a>
                                        </li>
                                        <li id="software-pcx86-sys-ext-quarterdeck-qemm386-6.02" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/quarterdeck/qemm386/6.02/index.html">QEMM-386 6.02</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">SoftLogic
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Software Carousel
                                      <ul>
                                        <li id="software-pcx86-sys-ext-softlogic-carousel-2.0.3" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/softlogic/carousel/2.0.3/index.html">Software Carousel 2.0.3</a>
                                        </li>
                                      </ul>
                                    </li>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">DoubleDOS
                                      <ul>
                                        <li id="software-pcx86-sys-ext-softlogic-doubledos-2.1f" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/softlogic/doubledos/2.1f/index.html">DoubleDOS 2.1F</a>
                                        </li>
                                        <li id="software-pcx86-sys-ext-softlogic-doubledos-2.1v" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/softlogic/doubledos/2.1v/index.html">DoubleDOS 2.1V</a>
                                        </li>
                                      </ul>
                                    </li>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Disk Optimizer
                                      <ul>
                                        <li id="software-pcx86-sys-ext-softlogic-optimizer-2.0.3" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/softlogic/optimizer/2.0.3/index.html">Disk Optimizer 2.0.3</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Other
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Omniview 386
                                      <ul>
                                        <li id="software-pcx86-sys-ext-other-omniview-4.30" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/ext/other/omniview/4.30/index.html">Omniview 386 4.30</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">OS/2
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM OS/2
                                  <ul>
                                        <li id="software-pcx86-sys-os2-ibm-1.0" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/os2/ibm/1.0/index.html">IBM OS/2 1.0</a>
                                        </li>
                                        <li id="software-pcx86-sys-os2-ibm-1.1" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/os2/ibm/1.1/index.html">IBM OS/2 1.1</a>
                                        </li>
                                        <li id="software-pcx86-sys-os2-ibm-1.2" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/os2/ibm/1.2/index.html">IBM OS/2 1.2</a>
                                        </li>
                                        <li id="software-pcx86-sys-os2-ibm-1.3" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/os2/ibm/1.3/index.html">IBM OS/2 1.3</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">MS OS/2
                                  <ul>
                                        <li id="software-pcx86-sys-os2-microsoft-1.0" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/os2/microsoft/1.0/index.html">MS OS/2 1.0</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">OS/2 Prototype Disks
                                  <ul>
                                        <li id="software-pcx86-sys-os2-misc-86295" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/os2/misc/86295/index.html">OS/2 CP-DOS (v7.68)</a>
                                        </li>
                                        <li id="software-pcx86-sys-os2-misc-87007" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/os2/misc/87007/index.html">OS/2 SIZZLE (v7.68.18)</a>
                                        </li>
                                        <li id="software-pcx86-sys-os2-misc-87058" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/os2/misc/87058/index.html">OS/2 FOOTBALL (v7.68.17)</a>
                                        </li>
                                        <li id="software-pcx86-sys-os2-misc-87357" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/os2/misc/87357/index.html">OS/2 FOOTBALL (v4.41.00)</a>
                                        </li>
                                        <li id="software-pcx86-sys-os2-misc-88286" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/os2/misc/88286/index.html">OS/2 1.0 Debugger (1988)</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">UNIX
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PC/IX
                                      <ul>
                                        <li id="software-pcx86-sys-unix-ibm-pcix-1.0" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/ibm/pcix/1.0/index.html">PC/IX 1.0</a>
                                        </li>
                                      </ul>
                                    </li>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">XENIX
                                      <ul>
                                        <li id="software-pcx86-sys-unix-ibm-xenix-1.0" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/ibm/xenix/1.0/index.html">XENIX 1.0</a>
                                        </li>
                                        <li id="software-pcx86-sys-unix-ibm-xenix-2.0" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/ibm/xenix/2.0/index.html">XENIX 2.0</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microport
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">AT&T UNIX System V-AT
                                      <ul>
                                        <li id="software-pcx86-sys-unix-microport-system-v-2.3" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/microport/system-v/2.3/index.html">AT&T UNIX System V-AT 2.3</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">MINIX
                                  <ul>
                                        <li id="software-pcx86-sys-unix-minix-1.1" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/minix/1.1/index.html">MINIX 1.1</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">QNX
                                  <ul>
                                        <li id="software-pcx86-sys-unix-qnx-1.1" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/qnx/1.1/index.html">QNX 1.1</a>
                                        </li>
                                        <li id="software-pcx86-sys-unix-qnx-1.2" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/qnx/1.2/index.html">QNX 1.2</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">SCO
                                  <ul>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Xenix 8086
                                      <ul>
                                        <li id="software-pcx86-sys-unix-sco-xenix-086-2.1.3" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/sco/xenix/086/2.1.3/index.html">Xenix 8086 2.1.3</a>
                                        </li>
                                      </ul>
                                    </li>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Xenix 286
                                      <ul>
                                        <li id="software-pcx86-sys-unix-sco-xenix-286-2.1.3" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/sco/xenix/286/2.1.3/index.html">Xenix 286 2.1.3</a>
                                        </li>
                                        <li id="software-pcx86-sys-unix-sco-xenix-286-2.2.1e" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/sco/xenix/286/2.2.1e/index.html">Xenix 286 2.2.1e</a>
                                        </li>
                                        <li id="software-pcx86-sys-unix-sco-xenix-286-2.2.3b" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/sco/xenix/286/2.2.3b/index.html">Xenix 286 2.2.3b</a>
                                        </li>
                                        <li id="software-pcx86-sys-unix-sco-xenix-286-2.3.2d" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/sco/xenix/286/2.3.2d/index.html">Xenix 286 2.3.2d</a>
                                        </li>
                                      </ul>
                                    </li>
                                    <li class="pcjs-explorer-product pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Xenix 386
                                      <ul>
                                        <li id="software-pcx86-sys-unix-sco-xenix-386-2.2.3b" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/sco/xenix/386/2.2.3b/index.html">Xenix 386 2.2.3b</a>
                                        </li>
                                        <li id="software-pcx86-sys-unix-sco-xenix-386-2.3.2f" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/sco/xenix/386/2.3.2f/index.html">Xenix 386 2.3.2f</a>
                                        </li>
                                        <li id="software-pcx86-sys-unix-sco-xenix-386-2.3.4h" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/unix/sco/xenix/386/2.3.4h/index.html">Xenix 386 2.3.4h</a>
                                        </li>
                                      </ul>
                                    </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Windows
                              <ul>
                                        <li id="software-pcx86-sys-windows-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/1.00/index.html">Microsoft Windows 1.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-1.01" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/1.01/index.html">Microsoft Windows 1.01</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-1.02" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/1.02/index.html">Microsoft Windows 1.02</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-1.03" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/1.03/index.html">Microsoft Windows 1.03</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-1.03a" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/1.03a/index.html">Microsoft Windows 1.03a</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-1.03b" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/1.03b/index.html">Microsoft Windows 1.03b</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-1.04" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/1.04/index.html">Microsoft Windows 1.04</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-2.03" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/2.03/index.html">Microsoft Windows 2.03</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-2.0x" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/2.0x/index.html">Microsoft Windows/386 2.0x</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-2.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/2.10/index.html">Microsoft Windows/386 2.10</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-2.11" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/2.11/index.html">Microsoft Windows 2.11</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-3.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/3.00/index.html">Microsoft Windows 3.00</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-3.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/3.10/index.html">Microsoft Windows 3.10</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-3.11" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/3.11/index.html">Windows for Workgroups 3.11</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-win95-4.00.499" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/win95/4.00.499/index.html">Windows 95 (Build 499)</a>
                                        </li>
                                        <li id="software-pcx86-sys-windows-win95-4.00.950" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/sys/windows/win95/4.00.950/index.html">Windows 95 (RTM) 4.00.950</a>
                                        </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-pcx86-test" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Tests
                          <ul>
                                        <li id="software-pcx86-test-cpu" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/test/cpu/index.html">PCx86 CPU Tests</a>
                                        </li>
                                        <li id="software-pcx86-test-testmon" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/test/testmon/index.html">PCx86 TestMonitor</a>
                                        </li>
                                        <li id="software-pcx86-test-vga-blackbook" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/test/vga/blackbook/index.html">VGA "Black Book" Tests</a>
                                        </li>
                          </ul>
                        </li>
                        <li id="software-pcx86-util" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Utilities
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Borland
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Sidekick
                                  <ul>
                                        <li id="software-pcx86-util-borland-sidekick-1.11c" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/borland/sidekick/1.11c/index.html">Sidekick 1.11C</a>
                                        </li>
                                        <li id="software-pcx86-util-borland-sidekick-1.56" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/borland/sidekick/1.56/index.html">Sidekick 1.56</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">SideKick Plus
                                  <ul>
                                        <li id="software-pcx86-util-borland-skplus-1.00a" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/borland/skplus/1.00a/index.html">SideKick Plus 1.00A</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">IBM Professional Debug
                                  <ul>
                                        <li id="software-pcx86-util-ibm-prodebug-1.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/ibm/prodebug/1.00/index.html">IBM Professional Debug 1.00</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Microsoft
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Unfiled
                                  <ul>
                                        <li id="software-pcx86-util-microsoft-unfiled" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/microsoft/unfiled/index.html">MS Unfiled Utilities</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Norton Utilities
                              <ul>
                                        <li id="software-pcx86-util-norton-2.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/norton/2.00/index.html">Norton Utilities 2.00</a>
                                        </li>
                                        <li id="software-pcx86-util-norton-2.01" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/norton/2.01/index.html">Norton Utilities 2.01</a>
                                        </li>
                                        <li id="software-pcx86-util-norton-3.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/norton/3.00/index.html">Norton Utilities 3.00</a>
                                        </li>
                                        <li id="software-pcx86-util-norton-3.10" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/norton/3.10/index.html">Norton Utilities 3.10</a>
                                        </li>
                                        <li id="software-pcx86-util-norton-4.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/norton/4.00/index.html">Norton Utilities 4.00</a>
                                        </li>
                                        <li id="software-pcx86-util-norton-4.00-advanced" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/norton/4.00/advanced/index.html">Norton Utilities 4.00 (Adv)</a>
                                        </li>
                                        <li id="software-pcx86-util-norton-4.50-advanced" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/norton/4.50/advanced/index.html">Norton Utilities 4.50 (Adv)</a>
                                        </li>
                                        <li id="software-pcx86-util-norton-5.00" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/norton/5.00/index.html">Norton Utilities 5.00</a>
                                        </li>
                                        <li id="software-pcx86-util-norton-6.01" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/norton/6.01/index.html">Norton Utilities 6.01</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Other
                              <ul>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Enhanced DEBUG
                                  <ul>
                                        <li id="software-pcx86-util-other-enhdebug-1.32b" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/other/enhdebug/1.32b/index.html">Enhanced DEBUG 1.32b</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">FlickerFree
                                  <ul>
                                        <li id="software-pcx86-util-other-flickerfree-1.0" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/other/flickerfree/1.0/index.html">FlickerFree 1.0</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">OBJASM
                                  <ul>
                                        <li id="software-pcx86-util-other-objasm-2.0" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/other/objasm/2.0/index.html">OBJASM 2.0</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PC Tools
                                  <ul>
                                        <li id="software-pcx86-util-other-pctools-1.03" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/other/pctools/1.03/index.html">PC Tools 1.03</a>
                                        </li>
                                        <li id="software-pcx86-util-other-pctools-4.30" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/other/pctools/4.30/index.html">PC Tools 4.30</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PFM (Paul's File Manager)
                                  <ul>
                                        <li id="software-pcx86-util-other-pfm-3.14" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/other/pfm/3.14/index.html">PFM 3.14</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Spacemaker
                                  <ul>
                                        <li id="software-pcx86-util-other-spacemaker-1.06" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/other/spacemaker/1.06/index.html">Spacemaker 1.06</a>
                                        </li>
                                  </ul>
                                </li>
                                <li class="pcjs-explorer-vendor pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">UNP
                                  <ul>
                                        <li id="software-pcx86-util-other-unp-4.11" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/pcx86/util/other/unp/4.11/index.html">UNP 4.11</a>
                                        </li>
                                  </ul>
                                </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li id="software-c1p" class="pcjs-explorer-platform pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">OSI C1P
                      <ul>
                        <li id="software-c1p-basic" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">BASIC Programs
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">OSI
                              <ul>
                                        <li id="software-osi-c1p-basic-osi-math" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/osi/math/indexcabf.html?autoStart=true&amp;autoMount=%7Bname:%22BASIC%20MATH%22,path:%22/software/osi/c1p/basic/osi/math/MATH.BAS%22%7D">BASIC MATH</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-osi-checking" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/osi/checking/index3ca5.html?autoStart=true&amp;autoMount=%7Bname:%22CHECKING%22,path:%22/software/osi/c1p/basic/osi/checking/CHECKING.BAS%22%7D">CHECKING</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-osi-counter" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/osi/counter/index25fd.html?autoStart=true&amp;autoMount=%7Bname:%22COUNTER%22,path:%22/software/osi/c1p/basic/osi/counter/COUNTER.BAS%22%7D">COUNTER</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-osi-poker" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/osi/poker/index50f4.html?autoStart=true&amp;autoMount=%7Bname:%22POKER%22,path:%22/software/osi/c1p/basic/osi/poker/POKER.BAS%22%7D">POKER</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-osi-presidents" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/osi/presidents/index1833.html?autoStart=true&amp;autoMount=%7Bname:%22PRESIDENTS%22,path:%22/software/osi/c1p/basic/osi/presidents/PRESIDENTS.BAS%22%7D">PRESIDENTS</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-osi-starwars" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/osi/starwars/index8118.html?autoStart=true&amp;autoMount=%7Bname:%22STAR%20WARS%22,path:%22/software/osi/c1p/basic/osi/starwars/STARWARS.BAS%22%7D">STAR WARS</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-osi-trigtutor" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/osi/trigtutor/index1f92.html?autoStart=true&amp;autoMount=%7Bname:%22TRIG%20TUTOR%22,path:%22/software/osi/c1p/basic/osi/trigtutor/TRIGTUTOR.BAS%22%7D">TRIG TUTOR</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Other
                              <ul>
                                        <li id="software-osi-c1p-basic-other-osiweb-seawolfe" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/other/osiweb/seawolfe/indexe7eb.html?autoStart=true&amp;autoMount=%7Bname:%22SEAWOLFE%22,path:%22/software/osi/c1p/basic/other/osiweb/seawolfe/SEAWOLFE.BAS%22%7D">SEAWOLFE</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-other-osiweb-spacewar" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/other/osiweb/spacewar/index67b4.html?autoStart=true&amp;autoMount=%7Bname:%22SPACEWAR%22,path:%22/software/osi/c1p/basic/other/osiweb/spacewar/SPACEWAR.BAS%22%7D">SPACEWAR</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-other-osiweb-startrek" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/other/osiweb/startrek/indexc666.html?autoStart=true&amp;autoMount=%7Bname:%22STAR%20TREK%22,path:%22/software/osi/c1p/basic/other/osiweb/startrek/STARTREK.BAS%22%7D">STAR TREK</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-other-osiweb-tankfortwo" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/other/osiweb/tankfortwo/indexd45c.html?autoStart=true&amp;autoMount=%7Bname:%22TANK%20FOR%20TWO%22,path:%22/software/osi/c1p/basic/other/osiweb/tankfortwo/TANKFORTWO.BAS%22%7D">TANK FOR TWO</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PCjs
                              <ul>
                                        <li id="software-osi-c1p-basic-jeffpar-checkers" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/jeffpar/checkers/index0d40.html?autoStart=true&amp;autoMount=%7Bname:%22CHECKERS%22,path:%22/software/osi/c1p/basic/jeffpar/checkers/CHECKERS.BAS%22%7D">CHECKERS</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-jeffpar-hangwoman" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/jeffpar/hangwoman/indexe6d7.html?autoStart=true&amp;autoMount=%7Bname:%22HANGWOMAN%22,path:%22/software/osi/c1p/basic/jeffpar/hangwoman/HANGWOMAN.BAS%22%7D">HANGWOMAN</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-jeffpar-life" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/jeffpar/life/index8c9f.html?autoStart=true&amp;autoMount=%7Bname:%22LIFE%22,path:%22/software/osi/c1p/basic/jeffpar/life/LIFE.BAS%22%7D">LIFE</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-jeffpar-othello" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/jeffpar/othello/index71c7.html?autoStart=true&amp;autoMount=%7Bname:%22OTHELLO%22,path:%22/software/osi/c1p/basic/jeffpar/othello/OTHELLO.BAS%22%7D">OTHELLO</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-jeffpar-soforecast" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/jeffpar/soforecast/index2725.html?autoStart=true&amp;autoMount=%7Bname:%22SOFORECAST%22,path:%22/software/osi/c1p/basic/jeffpar/soforecast/SOFORECAST.BAS%22%7D">SOFORECAST</a>
                                        </li>
                                        <li id="software-osi-c1p-basic-jeffpar-tubelist" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/basic/jeffpar/tubelist/indexfe90.html?autoStart=true&amp;autoMount=%7Bname:%22TUBELIST%22,path:%22/software/osi/c1p/basic/jeffpar/tubelist/TUBELIST.BAS%22%7D">TUBELIST</a>
                                        </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                        <li id="software-c1p-6502" class="pcjs-explorer-category pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">6502 Programs
                          <ul>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PCjs
                              <ul>
                                        <li id="software-osi-c1p-6502-jeffpar-assembler" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/6502/jeffpar/assembler/index9cfb.html?autoStart=true&amp;autoMount=%7Bname:%226502%20Assembler%20(8K)%22,path:%22/software/osi/c1p/6502/jeffpar/assembler/ASSEMBLER-8K.json%22%7D">6502 Assembler (8K)</a>
                                        </li>
                                        <li id="software-osi-c1p-6502-jeffpar-basicext" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/6502/jeffpar/basicext/indexc791.html?autoStart=true&amp;autoMount=%7Bname:%22BASIC%20Extensions%22,path:%22/software/osi/c1p/6502/jeffpar/basicext/BASICEXT.json%22%7D">BASIC Extensions</a>
                                        </li>
                                        <li id="software-osi-c1p-6502-jeffpar-life" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/6502/jeffpar/life/indexc29e.html?autoStart=true&amp;autoMount=%7Bname:%22LIFE%22,path:%22/software/osi/c1p/6502/jeffpar/life/LIFE.json%22%7D">LIFE</a>
                                        </li>
                              </ul>
                            </li>
                            <li class="pcjs-explorer-subcategory pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Processor Tests
                              <ul>
                                        <li id="software-osi-c1p-6502-tests-bcd" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/6502/tests/bcd/index.html">BCD Tests</a>
                                        </li>
                                        <li id="software-osi-c1p-6502-tests-vflag" class="pcjs-explorer-version pcjs-explorer-item">
                                          <a href="../../../../../../software/osi/c1p/6502/tests/vflag/index.html">Overflow Tests</a>
                                        </li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                <li class="pcjs-explorer-family pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PCjs Archives
                  <ul>
                    <li id="software-pcjs" class="pcjs-explorer-version pcjs-explorer-item">
                      <a href="../../../../../../software/pcjs/index.html">Software Archive</a>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>

<ul class="pcjs-explorer-top">
  <li id="pcjs-documents" class="pcjs-explorer-fixed">Documents
    <ul>
      <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Books
        <ul>
                  <li id="documents-books-programming" class="pcjs-explorer-item"><a href="../../../../programming/index.html">Programming</a></li>
                  <li id="documents-books-mspl13" class="pcjs-explorer-item"><a href="../../../index.html">Microsoft Programmer's Library</a></li>
        </ul>
      </li>
      <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Datasheets
        <ul>
                  <li id="documents-datasheets-intel" class="pcjs-explorer-item"><a href="../../../../../datasheets/intel/index.html">Intel</a></li>
                  <li id="documents-datasheets-motorola" class="pcjs-explorer-item"><a href="../../../../../datasheets/motorola/index.html">Motorola</a></li>
                  <li id="documents-datasheets-ns" class="pcjs-explorer-item"><a href="../../../../../datasheets/ns/index.html">National Semiconductor</a></li>
        </ul>
      </li>
      <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Magazines
        <ul>
                  <li id="documents-magazines-byte" class="pcjs-explorer-item"><a href="../../../../../magazines/byte/index.html">BYTE</a></li>
                  <li id="documents-magazines-dgn" class="pcjs-explorer-item"><a href="../../../../../magazines/dgn/index.html">DosGetNews()</a></li>
                  <li id="documents-magazines-mln" class="pcjs-explorer-item"><a href="../../../../../magazines/mln/index.html">Microsoft Languages</a></li>
                  <li id="documents-magazines-msj" class="pcjs-explorer-item"><a href="../../../../../magazines/msj/index.html">Microsoft Systems Journal</a></li>
                  <li id="documents-magazines-pcdm" class="pcjs-explorer-item"><a href="../../../../../magazines/pcdm/index.html">PC Disk Magazine</a></li>
                  <li id="documents-magazines-pctj" class="pcjs-explorer-item"><a href="../../../../../magazines/pctj/index.html">PC Tech Journal</a></li>
        </ul>
      </li>
      <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Manuals
        <ul>
                  <li id="documents-manuals-dec" class="pcjs-explorer-item"><a href="../../../../../manuals/dec/index.html">DEC</a></li>
                  <li id="documents-manuals-ibm" class="pcjs-explorer-item"><a href="../../../../../manuals/ibm/index.html">IBM</a></li>
                  <li id="documents-manuals-intel" class="pcjs-explorer-item"><a href="../../../../../manuals/intel/index.html">Intel</a></li>
                  <li id="documents-manuals-microsoft" class="pcjs-explorer-item"><a href="../../../../../manuals/microsoft/index.html">Microsoft</a></li>
                  <li id="documents-manuals-motorola" class="pcjs-explorer-item"><a href="../../../../../manuals/motorola/index.html">Motorola</a></li>
        </ul>
      </li>
      <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Papers
        <ul>
          <li id="documents-papers-research" class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Research
            <ul>
                  <li id="documents-papers-research-ecp" class="pcjs-explorer-item" title="Institute for Advanced Study’s Electronic Computer Project (1946-1954)"><a href="../../../../../papers/research/ecp/index.html">Electronic Computer Project</a></li>
                  <li id="documents-papers-research-estelita" class="pcjs-explorer-item" title="Step-father, entrepreneur, visionary (1941-1988)"><a href="../../../../../papers/research/estelita/index.html">Tom Estelita</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">Photos
        <ul>
                  <li id="documents-photos-lite-brite" class="pcjs-explorer-item"><a href="../../../../../photos/lite-brite/index.html">Lite-Brite</a></li>
        </ul>
      </li>
      <li class="pcjs-explorer-closed" onclick="pcjsExplorerClick(this, event)">PCjs Archives
        <ul>
                  <li id="library" class="pcjs-explorer-item"><a href="../../../../../index.html">Library</a></li>
                  <li id="documents-pcjs" class="pcjs-explorer-item"><a href="../../../../../pcjs/index.html">Document Archive</a></li>
                  <li id="documents-pcjs-programming" class="pcjs-explorer-item"><a href="../../../../../pcjs/programming/index.html">Programming Notes</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

</div>
        <script>
          function pcjsGetURLVars() {
            var vars = {}, parts = window.location.search.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
              vars[key] = value;
            });
            return vars;
          }
          function pcjsOnClick(element, event) {
            element.href += window.location.search;
          }
          function pcjsExplorerClick(element, event) {
            if (event) event.stopPropagation();
            if (element.classList.contains("pcjs-explorer-open")) {
              element.classList.add("pcjs-explorer-closed");
              element.classList.remove("pcjs-explorer-open");
            } else if (element.classList.contains("pcjs-explorer-closed")) {
              element.classList.add("pcjs-explorer-open");
              element.classList.remove("pcjs-explorer-closed");
            }
          }
          function pcjsExplorerExpand(path, altpath, prefix) {
            var expansions = 0;
            if (!path && altpath) {
              path = altpath.replace(/^\/[^/]*\/([^/]*)\/.*$/, "/$1/");
            }
            if (path) {
              var element;
              if (prefix) path = prefix + path;
              var id = path.substr(1).replace(/\//g, '-').replace(/-$/, '');
              if (id == "documents") id = "library";
              do {
                element = document.getElementById(id);
                if (element) break;
                var idNew = id.replace(/-[^-]+$/, '');
                if (idNew == id) break;
                id = idNew;
              } while (true);
              if (element) {
                do {
                  if (element.classList.contains("pcjs-explorer-item")) {
                    element.classList.add("pcjs-explorer-selected");
                  } else if (element.classList.contains("pcjs-explorer-closed")) {
                    element.classList.add("pcjs-explorer-open");
                    element.classList.remove("pcjs-explorer-closed");
                  }
                  element = element.parentElement;
                  expansions++;
                } while (element);
              }
            }
            return expansions;
          }
          function pcjsExplorerExpandAll(element, event, fExpand) {
            if (event) event.preventDefault();
            var elements = document.querySelectorAll(fExpand? ".pcjs-explorer-closed" : ".pcjs-explorer-open");
            elements.forEach((element) => {pcjsExplorerClick(element);});
          }
          function pcjsExplorerSurprise() {
            var elements = document.querySelectorAll(".pcjs-explorer-item");
            var element = elements && elements[Math.random() * elements.length | 0];
            if (element && element.children) window.location.href = element.children[0].href;
          }
          function pcjsExplorerView(element, event) {
            event.preventDefault();
            var target = document.getElementById("pcjs-explorer-menu");
            if (target) {
              var yOffset = -48;
              var y = target.getBoundingClientRect().top + window.pageYOffset + yOffset;
              window.scrollTo({top: y, behavior: 'smooth'});
            }
          }
          function pcjsExplorerInit() {
            let path = window.location.pathname;
            pcjsExplorerExpand(path + window.location.hash.substr(1));
            pcjsExplorerExpand(pcjsGetURLVars()['software'], path, "/software");
            if (path.indexOf("/machines") < 0) {
              if (path == '/' || path.indexOf("/pcx86") >= 0) pcjsExplorerExpand("/machines/pcx86/ibm/5150");
            }
          }
          pcjsExplorerInit();
        </script>
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','../../../../../../../www.google-analytics.com/analytics.js','ga');
          ga('create', 'UA-49658648-1', 'auto');
          ga('send', 'pageview');
        </script>


        <p><a href="#pcjs-machines">pcjs.org</a> © 2012-2022 <a rel="me" href="https://mastodon.sdf.org/@jeffpar">Jeff Parsons</a><br/>
        <a href="https://github.com/jeffpar/pcjs">PCjs</a> is released under an <a href="../../../../../../LICENSE.txt">MIT License</a></p>
      </footer>
    </div>


  </body>

<!-- Mirrored from www.pcjs.org/documents/books/mspl13/msdos/encyclopedia/section2/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 30 Nov 2022 13:05:44 GMT -->
</html>
